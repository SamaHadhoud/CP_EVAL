 Okay, we are to implement the solution described in the editorial.
 Steps:
 1. Read input: n, m, and the m edges.
 2. We represent the graph with an adjacency matrix (or a 2D boolean array) and maintain a degree array.
 3. We note that initially, we have m edges. The total edges needed to form a complete graph is n*(n-1)/2.
    So, the number of edges we need to add is: total_edges_to_add = n*(n-1)/2 - m.

 4. We are going to binary search on k in the range [0, 2*(n-1)] (because the maximum degree a node can have is n-1, so the maximum sum is 2*(n-1)).

 5. For a candidate k, we simulate the process:
    - We start with the current graph and the current degrees.
    - We maintain a max-heap (or priority_queue) for the non-edges. Since priority_queue in C++ is a max-heap by default, we can use a priority_queue that stores tuples (current_degree_sum, u, v). But note: we want the highest degree sum first. However, we must update non-edges when degrees change. But note: we cannot update existing entries in the heap. Instead, we will use a lazy heap: we may have outdated entries, so we skip them.

    Steps for check(k):
        a. Copy the graph and the degree array (because we are going to simulate adding edges).
        b. Create a priority_queue that stores (degree_sum, u, v) for every non-edge (u, v) initially. We store the degree_sum as the current degree of u plus degree of v. And we want the maximum degree_sum first, so we use a max-heap (which in C++ is the default for priority_queue with the largest at top).

        However, note: we cannot store all non-edges initially and then update all adjacent ones? Actually, we can do:

        We'll have a priority_queue that stores a tuple: (current_degree_sum, u, v). We push all non-edges.

        Then:
          while the priority_queue is not empty and the top's degree_sum >= k:
            pop the top (let it be (s, u, v)).
            Check if the edge (u, v) is already added? (we have a graph matrix that we update). If already added, skip.
            Also, check if the current degree_sum for (u, v) is still s? Because the degrees might have changed. Actually, we can skip this by updating the heap lazily: we do:
                if the current degree[u] + degree[v] < s -> then we know this entry is outdated? Actually, it might be that the degree increased? But we only update by increasing when we add edges? Actually, we are adding edges, so the degrees can only increase. Therefore, if at the time we have an entry (s, u, v) and now the degree[u]+degree[v] is greater than s, then we might have a more recent entry. However, note: when we update, we push a new entry with the updated sum. So when we pop an entry that has s < current degree[u]+degree[v], then we skip? Actually, we don't need to because we are always pushing the updated value. But wait: we push the updated value when we update the degrees of u and v? Actually, we update the degrees of u and v when we add an edge. Then we update the non-edges incident to u and to v? 

        However, the problem: we are storing (s, u, v). When we add an edge (u, v), we then update the degrees of u and v. Then for every neighbor x (which is not connected to u) we push a new entry with the updated degree_sum = (degree[u] (updated) + degree[x]). Similarly for v.

        But note: we might have multiple entries for the same non-edge. So when we pop an edge (u, v) and we see that the graph already has that edge (because we added it in a later step) then we skip. Also, if the current degree[u] + degree[v] is not equal to the stored s? Actually, because we are pushing new values when updating, we can skip the entry if the stored s is less than the current degree[u]+degree[v]? Actually, no: because the stored s is the degree sum at the time of pushing. But if the degrees have increased, then we have a more recent entry that is larger. So we can skip if the stored s is not equal to the current degree[u]+degree[v]? Actually, that is one way. But note: the stored s might be outdated and less than the current degree sum? Then we don't want to skip? Actually, we want to add the edge only if the current degree sum is at least k. So if the stored s is less than k, we break. But if it's >=k, but the current degree sum is even higher, then we don't need to skip? Actually, we don't: because the stored s is the value at the time we pushed. However, the condition for adding the edge is at the time of evaluation: we require current_degree[u] + current_degree[v] >= k. But the stored s might be outdated and the current degree sum might be higher? Then the condition still holds. However, we have a problem: if we have an outdated entry that is (s, u, v) and now the current degree sum is s' (>= s) and s>=k, then the condition is satisfied. But we have a more recent entry for (u, v) with s'? Then we might process the same edge twice? We don't want that.

        How to avoid duplication? We can mark the edge (u, v) as added and then skip any future entry for (u, v). So we set g[u][v] = true as soon as we add it.

        Proposed lazy deletion:
            When popping an entry (s, u, v):
                if g[u][v] is already true -> skip.
                else if the current degree[u] + degree[v] < k -> then we break? Actually, we cannot break because there might be other edges? But note: we are processing the maximum first. If the maximum is below k, then we break. However, we stored s which might be outdated? So we need to check the current degree sum.

            Actually, we should check: if the current degree[u] + degree[v] >= k, then we add the edge. But if the stored s is less than the current? That can happen? Actually, no: because the stored s is the value at the time of pushing, and degrees only increase. So the current degree[u]+degree[v] is at least s. Therefore, if s >= k, then the current is >= k? Actually, not necessarily: because when we push an entry for (u, v) with s0, then we update the degrees of u and v (say because of another edge) and then we push a new entry with s1 = s0 + (some increment). But then we update again and push s2, etc. However, if we have an old entry with s0 and the current degree sum is actually s2 (which is >= s0) then if s0>=k, then the current is also >=k? So we can add the edge? But we are going to have multiple entries for the same edge? And we don't want to add the same edge multiple times.

        Therefore, we can do:
            while (!pq.empty()):
                pop the top (which is the largest s, but note: we are storing as a max-heap) -> we store (s, u, v) and use the largest s first.
                Check if the edge (u, v) is already present -> if yes, skip.
                Else, if the current degree[u] + degree[v] >= k -> then we add the edge.
                Else, break because the rest in the heap are <= s (but note: the heap is a max-heap, so if the top is < k, then we break) -> actually, we break the while loop? But wait: the heap might have multiple entries for the same edge? Actually, we break the inner while? Actually, we break the entire process? Because the maximum remaining edge is below k? Then we stop.

        However, the problem: we might have an entry that is outdated: the stored s is less than the current degree sum? Then we cannot break? But note: we are storing the max-heap by the stored s. The current degree sum might be higher? Then we should not break? How do we know the current degree sum?

        Therefore, we do:
          We get the top element (s0, u, v). 
          If the edge (u, v) is already added -> pop and continue.
          Else, if the current degree[u] + degree[v] >= k -> then we add the edge (u, v) and then update the degrees and push the updated non-edges for u and v.
          Else, we break: because the top element is below k? Actually, we break the entire while loop? But note: the heap might have other edges that are not updated? However, the stored s0 is the maximum in the heap. But if the current degree[u]+degree[v] is higher than s0? Then we should not break? Actually, we don't know the current degree sum until we check. Therefore, we break only when the current degree[u]+degree[v] < k? And then we break the entire process? Because if the current maximum (which we have just checked and found that its current value is < k) then every other edge must be < k? Not necessarily: because the stored s0 might be outdated for other edges? Actually, we are storing the stored s0, and we are popping the one with the largest s0. But if that edge has a current degree sum < k, then all the other stored s0 are <= s0, and hence their current degree sums (which are at least as large as the stored s0? no, wait: the stored s0 for an edge (u, v) is the degree sum at the time of pushing. The current degree sum is at least the stored s0? Actually, yes: because degrees only increase. Therefore, if the stored s0 for the top is < k, then break. But wait: we just saw that the stored s0 might be < k, but the current degree sum might be >=k? Actually, that's impossible: because the stored s0 is the degree sum at the time of pushing, and then the degrees only increased? Then the current degree sum is >= stored s0. So if the stored s0 is >=k, then the current is >=k? But if the stored s0 is < k, then the current might be >=k? Actually, yes: because degrees increased. 

        So we cannot break on stored s0? We must check the current degree sum.

        Revised algorithm for check(k):
          Initialize:
            g: adjacency matrix (current graph) -> we'll update as we add edges.
            deg: array of degrees -> updated as we add edges.
            pq: priority_queue (max-heap) of pairs: (degree_sum, u, v) for non-edges? Actually, we want the max first? Then we can store (degree_sum, u, v) and the priority_queue will be:
                priority_queue<tuple<int, int, int>> -> but we want the largest degree_sum first? Then we store the degree_sum as positive and then the tuple will compare by the first element? Actually, in C++ the priority_queue is a max-heap by default.

          But note: we might have multiple entries for the same edge? So we need to avoid adding the same edge twice.

          Steps:
            Push all non-edges (u, v) with the initial degree[u] + degree[v] and also u and v.

          Then:
            while (!pq.empty()):
                auto [s, u, v] = pq.top(); pq.pop();
                // If the edge is already added, skip.
                if (g[u][v]) continue;

                // Check if the current degree[u] + degree[v] >= k?
                if (deg[u] + deg[v] < k) {
                    // We break because the top is the largest? Actually, but note: the stored s might be outdated? 
                    // However, the stored s was the value at the time of pushing. The current value is deg[u]+deg[v] which is >= s? Then if deg[u]+deg[v] < k, then s <= deg[u]+deg[v] < k -> so every other entry in the heap has stored s <= current stored top (which we just popped) and hence < k? But wait: we popped the top, which is the maximum stored s. Then if the current value of the top edge is < k, then the stored s for all others are <= this stored s and hence the current value for those edges (which is >= stored s) might be < k? Actually, no: the current value might be higher? But we don't know until we check. However, we cannot break the entire while loop? 

                    // Actually, we break the inner while? But then we break the entire process? Because we cannot add any more edges? 
                    // However, we have to break the while loop? Because we cannot add this edge, and we cannot add any edge that has stored s <= this stored s? But note: we might have pushed an entry with a larger stored s later? Actually, we push when updating, so we might have entries that are larger than the current top? But we are popping the top.

                    // Actually, we break because the top edge (the one with the highest stored s) has a current degree sum < k, then no edge can be added? Because all other edges have stored s <= this one, and their current degree sum is at least the stored s (so we don't know if they are >=k?) but actually, we don't know: maybe an edge has a stored s that is lower than this top, but its current degree sum might be >=k? 

                    // Example: we have two edges: 
                    //   edge1: stored s1 = 10, but current degree sum = 9 (which is < k=10) -> we skip edge1.
                    //   edge2: stored s2 = 9, but due to updates, its current degree sum is 11? Then we should process edge2.

                    // How did edge2 get updated? Because we updated the degrees of its endpoints when adding another edge? But we haven't added any edge in this iteration? Actually, we are popping the top and then we break? 

                    // Therefore, we cannot break the entire while loop? We just skip this edge and continue? 

                    // But note: the stored s for edge2 is 9, which is less than 10? Then it is not at the top? We just popped the top? Then we need to continue popping? 

                    // So we don't break. We just skip this edge and continue.

                    // Actually, we skip this edge and continue to the next in the heap.

                    // But we break the inner while? Actually, we don't break the entire while loop? We just skip this edge and pop the next.

                }
                else {
                    // Then we add the edge (u, v)
                    g[u][v] = true;
                    g[v][u] = true;
                    deg[u]++;
                    deg[v]++;
                    // Then we update: for every other node x, if u is not connected to x, then we push (deg[u]+deg[x], u, x) into the heap? But note: we already have an entry for (u, x) that might be outdated? Then we push a new one. Similarly for (v, x). And also we update the non-edges incident to u and v.

                    // But note: we don't need to push (u, x) if it's already in the heap? We just push a new entry and the old one will be skipped because we mark the edge as added only when we add it? Actually, we skip by checking g[u][x]? So we push only if the edge (u, x) is not present.

                    for (int x = 1; x <= n; x++) {
                        if (x != u && !g[u][x] && x != v) { // note: we avoid self-loop and the edge (u,v) we just added? Actually, we skip x==v? but we already have (u,v) added. So we don't push (u,v) again? Also, skip x==u? 
                            pq.push({deg[u] + deg[x], u, x});
                        }
                        if (x != v && !g[v][x] && x != u) {
                            pq.push({deg[v] + deg[x], v, x});
                        }
                    }
                }

          Then, after the while loop, we check if we have added all the required edges? How? We can count the number of edges we added? And compare with target_edges_to_add.

        However, note: we are updating the graph as we add edges. At the end, we can check: for all pairs (i, j) with i<j, if g[i][j] is true? But that is O(n^2). Alternatively, we can count as we add.

        But note: we are pushing the same non-edge multiple times? So we might add the same non-edge twice? We avoid by checking g[u][v] at the beginning.

        However, the above simulation might be inefficient: we push the same non-edge multiple times? But the total number of edges we add is at most n(n-1)/2 - m, and each time we update, we push O(n) new entries. So worst-case, we push O(n * (n^2)) = O(n^3) entries. And n<=500, then 500^3 = 125e6, which is acceptable? Actually, worst-case we have about 125e6 operations? But each operation is a heap push (log(size)), and the heap size can be O(n^3) -> worst-case log(125e6) is about 27? Then total operations 125e6 * 27 = 3.375e9, which might be borderline in C++ in 1 second? Actually, we have multiple test cases? No, one test case. But the problem says: time limit 1.0s? And worst-case 3e9 operations? That might be too slow.

        Alternatively, we note that the editorial in Python says O(N^3 log^2 N) and we are doing O(N^3 log N) per check? And then multiplied by logN (for binary search). So total O(N^3 log^2 N) which is about 500^3 * (log2(500) ~ 9, and then squared -> 125e6 * 81 = 10.125e9 -> too slow.

        We need to optimize.

        Alternate approach from known solutions for "graph closure" problems: use a static algorithm? There is an algorithm by HÃ¥kan for the closure problem? But we are simulating the closure.

        However, note: the problem constraints: n<=500 -> n^3 is 125e6, and then multiplied by log n (for the heap operations) and then by log n (binary search) -> 125e6 * 9 * 9 = 10.125e9? That is 10 seconds? We need to optimize the inner loop.

        Actually, we can try to use a more efficient structure? Or we can note:

        We don't need to push every non-edge incident to u and v? Actually, we do? Because when we add an edge (u, v), then the degrees of u and v increase by one. Then any non-edge (u, x) or (v, x) now has a degree sum that increases by one? So we need to update the heap.

        But we cannot avoid.

        Alternatively, we can use a different approach: we maintain an array for each node of the current degree, and then for non-edges we don't store in the heap? Actually, we need the max.

        Known idea: use a set for the non-edges? Or use a matrix of current degree sums? Then we can scan for the maximum? That would be O(n^2) per edge added -> total O(n^4) which is worse.

        We stick to the heap with lazy deletion? And hope that the worst-case is not hit? But worst-case we are pushing O(n) per edge added, and we add O(n^2) edges? Then total pushes O(n^3). Then the heap operations are O(n^3 log(n^3)) = O(n^3 * 3 log n) = O(3 * n^3 log n). Then multiplied by binary search (log n) -> O(3 * n^3 log^2 n). For n=500: 3 * 125e6 * (log2(500))^2 -> 3 * 125e6 * (9)^2 = 3 * 125e6 * 81 = 30.375e9 -> too slow.

        We need a better method.

        Known efficient algorithm: the Erdos-Gallai type? Or using the idea from the "Dense Graph" problem? 

        Alternate known solution for the same problem: 
          The highest k is the minimum of (deg[i] + deg[j]) over all non-edges (i, j) in the closure? Actually, the answer is the minimum value of (deg[i] + deg[j]) in the final complete graph? But note: the problem asks for the maximum k such that there exists an order that completes the graph.

        There is a known result: 
          Let G' be the closure of G with parameter k. Then k is at most the minimum over all non-edges (u, v) in the original graph of (deg_G'(u) + deg_G'(v)), but we don't know G' without k.

        Alternatively, we know that the closure is unique? Actually, no: the closure depends on the order? But there is a maximum closure: the closure obtained by repeatedly adding any edge that has degree sum >=k? Then the closure is unique? Actually, the closure is unique for a fixed k? 

        Then we can compute the closure for candidate k without the heap? How? 

        We can use a two-pointer method? Or use a queue: 

          Initialize: 
            deg = current degrees
            g = current graph

          Then we maintain a queue of edges that we can add: initially all non-edges (u, v) with deg[u]+deg[v] >= k? Then we add that edge? Then update the degrees? Then check adjacent non-edges? 

          But then we use a queue (BFS) for edges? But we have to update when degrees change? 

          Steps:
            Let Q be a queue.
            For every non-edge (u, v): 
                if deg[u]+deg[v] >= k, then push (u, v) into Q.

            Then while Q is not empty:
                pop an edge (u, v) from the front.
                if the edge is already added, skip.
                else, add the edge: 
                    deg[u]++, deg[v]++
                    then for every neighbor w of u: if the edge (v, w) is not present and now deg[v] + deg[w] >= k, then push (v, w) into the queue? 
                    similarly for every neighbor w of v: if the edge (u, w) is not present and now deg[u] + deg[w] >= k, then push (u, w)? 

            But note: we might push the same edge multiple times? So we mark as added when we add.

          However, this might not be efficient? And the order of processing matters? Actually, we don't care about the order? We are not using a priority. We are just adding whenever the condition holds? 

          But the condition might hold only after updating? 

          This BFS method: 
            We start with non-edges that initially satisfy the condition.
            Then we add them arbitrarily? Then update the degrees and then check their neighbors? 

          But note: when we update the degree of u, then every non-edge incident to u might become eligible? So we have to check all non-edges incident to u? 

          How? We can iterate for all w that are not adjacent to u? That is O(n). Then we check if deg[u] + deg[w] >= k? And if so, then we push (u, w) into the queue.

          Similarly for v.

          The total number of edges we add is target_edges_to_add. And each edge is processed at most once? Then the total operations is O(n * target_edges_to_add) = O(n^3). 

          Then we can do:

            Use a matrix g and an array deg.
            Use a queue (or stack) and a visited matrix for edges? Or we can use a set for non-edges? Actually, we don't need to store the non-edges? We can simply update when we add an edge.

          Steps:

            Create a 2D array added (or g) to mark which edges are present.

            Initialize a queue Q.

            For u from 1 to n:
                for v from u+1 to n:
                    if not g[u][v] and deg[u]+deg[v]>=k:
                         push (u, v) and mark as to be added? Actually, we push and then we will mark when we add.

            But note: we might push the same edge multiple times? So we also maintain a 2D boolean array inQueue? Or we can avoid by marking the edge as added as soon as we push? But we haven't added it. Alternatively, we can use a set for edges that are in the queue? 

          Alternatively, we can avoid duplicates by having a flag for each non-edge: we push an edge only once? 

          Proposed:

            Let's maintain a 2D array `added` for edges (both existing and added during simulation). Initially, added[u][v] = true for the given edges.

            We also maintain a queue Q and a 2D array `in_queue`? Or we can avoid by checking when popping? 

            We do:

                for u in range(1, n+1):
                    for v in range(u+1, n+1):
                         if not added[u][v] and deg[u]+deg[v]>=k:
                             Q.push((u, v))
                             in_queue[u][v] = true;   [optional]

            Then while Q not empty:
                pop (u, v) from Q.
                if added[u][v]: continue.
                else:
                    added[u][v] = true;
                    deg[u]++; deg[v]++;
                    // Then for every node w: 
                    //   for u: check non-edges (u, w) for w in [1, n] (w != u and not added[u][w])
                    //        if deg[u]+deg[w] >= k and we haven't pushed (u, w) before? -> then push (u, w) and mark in_queue? 
                    //   similarly for v.

            However, we don't mark in_queue? Then we might push the same edge multiple times? 

            Since n is 500, the total non-edges is O(n^2) = 125000. So we can use a 2D boolean array `in_queue` of size n x n? Actually, we can use a 2D array `handled`? Actually, we don't need: we can push the same edge multiple times? Then we check at the beginning of the while loop: if added, skip.

            But worst-case, we might push an edge O(n) times? Then total queue size O(n^3) which is 125e6? That is acceptable? 

          Complexity: 
            Each edge is pushed at most O(n) times? Why? Because when we update the degree of u, we push every non-edge (u, w). Then when we update the degree of u again, we push again? 

            Actually, we can avoid by not pushing if the edge is already added? We check: if added[u][w] then skip.

          But note: we are pushing only when the condition holds? And we are updating the degrees? Then it might become eligible again? Actually, no: because we are increasing the degrees. So if the condition holds at one point, and then we update and then the condition holds again? Actually, it always holds? But we only push when we see it becomes eligible? And we are not storing whether we have pushed it before? Then we might push it multiple times.

          How to avoid? We can use a flag that marks when the condition becomes satisfied? Actually, we can push an edge only once: because once it becomes eligible, we push it, and then we add it eventually? But what if we push it and then the condition becomes even more satisfied? We don't need to push again? Actually, we only need to process it once.

          Therefore, we can maintain a 2D boolean array `eligible`? Or we can use the fact that we mark added? And then we push only if the edge is not added and the condition holds? And we don't care if we push it multiple times? Then we skip at the time of popping.

          Algorithm:

            queue Q;
            bool added[n+1][n+1] = {false};   // initially, set the existing edges to true, and others false.
            int deg[n+1] = initial degrees.

            // Initialize: for every non-edge (u, v) (i.e., !added[u][v]), if deg[u]+deg[v]>=k, then push (u, v) into Q.

            for (int i=1; i<=n; i++) {
                for (int j=i+1; j<=n; j++) {
                    if (!added[i][j] && deg[i]+deg[j]>=k) {
                        Q.push({i, j});
                    }
                }
            }

            while (!Q.empty()) {
                auto [u, v] = Q.front(); Q.pop();
                if (added[u][v]) continue;
                if (deg[u]+deg[v] < k) continue;   // because it might become below k? Actually, degrees only increase? So if it was >=k when pushed, then now it is still >=k? Actually, no: wait, we are updating degrees for u and v? But note: when we update u and v by adding edges, the degrees of u and v increase. So if the condition held at the time of pushing, then after we add other edges, the degrees of u and v might have increased? Then the condition still holds? 

                Actually, the condition holds? Then we can skip the check? But what if we push an edge (u, v) and then we update the degrees of u and v by adding other edges? Then the condition deg[u]+deg[v] becomes even larger? 

                So we don't need to check again? Actually, we do: because when we pop, we are going to add the edge? But the condition must hold? 

                However, it is possible that the edge (u, v) was pushed because at time t0: deg[u]+deg[v]>=k. Then we update the degrees of u and v (by adding other edges) so that deg[u] and deg[v] become larger? Then the condition still holds? 

                Therefore, we can skip the condition check? 

                But note: we might have an edge that was pushed multiple times? And the first time we pop it, we add it. The next time we skip because added[u][v] becomes true.

                So we can do:

                    if (added[u][v]) continue;
                    added[u][v] = true;
                    deg[u]++; deg[v]++;

                    // Then we update: for every node w (w != u and not added[u][w]), then if deg[u] + deg[w] >= k, then push (u, w) into Q?
                    // But note: we are updating the degree of u, so we need to check all non-edges incident to u? 

                    for (int w=1; w<=n; w++) {
                        if (w == u) continue;
                        if (!added[u][w]) {
                            if (deg[u] + deg[w] >= k) {
                                Q.push({u, w});
                            }
                        }
                        if (w == v) continue;
                        if (!added[v][w]) {
                            if (deg[v] + deg[w] >= k) {
                                Q.push({v, w});
                            }
                        }
                    }

                But note: we are updating both u and v? Then we check incident to u and to v.

            Then after the while loop, we check if the graph is complete: count the number of added edges? Actually, we can count the edges we added? Or we can check: for every pair (i, j) (i<j), added[i][j] is true.

            How to count? We start with m edges, then we add edges in the simulation. We can count the number of edges we added: initially, we had m, then we add one per successful while loop iteration? Then we compare to total_edges_to_add.

          However, we are not counting? We can maintain a counter: 
            added_count = m;
            then each time we add an edge, added_count++.
            then at the end, if added_count == n*(n-1)/2, then candidate k works.

          But note: we might add an edge that was already in the queue multiple times? But we skip if added[u][v] is true? So each edge is added once.

          Complexity: 
            Each edge is added once. For each edge added, we do O(n) work: scanning neighbors of u and v -> O(n). Total O(n * (n^2)) = O(n^3). Then the initialization: O(n^2). Then total per candidate k: O(n^3). Then binary search: O(log n) iterations -> total O(n^3 * log n). For n=500: 125e6 * log2(500) ~ 125e6 * 9 = 1.125e9 -> which is acceptable in C++? Probably in 1 second? Maybe borderline, but we note that the constant factors are low? And worst-case might be sparse? 

          But worst-case: complete graph? Then we don't do anything? Or worst-case: a graph that requires adding many edges? 

          Actually, worst-case is when we start with no edges? Then we have to add n(n-1)/2 edges, and each edge takes O(n) time -> O(n^3) per candidate k. Then total O(n^3 * log n) = 125e6 * 9 = 1.125e9 operations? In C++, each operation is a few instructions? Then 1e9 operations might run in 1-2 seconds? 

          Let's hope.

        We'll implement the BFS method for check(k).

        Steps for check(k):
          - Copy the graph and the degrees? Because we are going to simulate.
          - Create a 2D array `added` (size (n+1) x (n+1)): initially set to the existing graph.
          - Create a queue (queue of pairs).
          - added_count = m
          - Precompute: for all non-edges (u, v) that are not added, if deg[u]+deg[v]>=k, then push (u, v) into the queue? But note: we don't want to push duplicates? We skip by checking when popping? We'll push even if we push the same edge multiple times? Then we avoid by marking added[u][v] at the time of popping? Actually, we push an edge only once? No, we push it when we see it for the first time and then after we add it we mark it so we won't push again? But we might push it again from a different update? 

          Actually, we push an edge (u, v) if it is not added and the condition holds? And we don't care if it is already in the queue? Then we push it every time we update u or v? 

          But that leads to multiple pushes? How many? The degree of u increases at most (n-1 - initial_degree[u]). Similarly for v? So the edge (u, v) will be pushed at most O(n) times? Then the total queue size is O(n^3). Then the while loop would be O(n^3). And each iteration we do O(n) work? Then total O(n^4) per candidate k? That is 500^4 = 62.5e9? Then multiplied by log n -> 62.5e9 * 9 = 562.5e9 -> too slow.

        Therefore, we need to avoid pushing the same edge repeatedly.

        How to avoid? We can mark that we are going to push an edge only once? We push it the first time it becomes eligible? Then we never push it again? 

        But then, what if the condition becomes satisfied later? Actually, the condition becomes satisfied earlier? And we push it? Then when we update the degrees, it becomes even more satisfied? But we don't need to push it again? Because we are going to add it eventually? 

        Actually, once we push an edge, it will eventually be processed? But when we process it, we add it? Then we mark it as added? Then we skip in the future.

        But what if we push an edge, but when we pop it, the condition fails? Actually, we have a check: 
            if (added[u][v]) continue;
            if (deg[u] + deg[v] < k) continue;   // then skip

        But note: the condition might become true again? Actually, no: because we are updating the degrees? The condition might become true again after we update the degrees of u and v by other edges? But we have already pushed it once? And we skipped it? Then we never push it again? 

        So we must push it only when it becomes eligible? And then if it becomes ineligible? We don't push it again? But then it might be that the edge becomes eligible again? 

        Actually, the degrees only increase? So if at one point deg[u]+deg[v] >= k, then after that, it is always >=k? Then we don't need to push it again? Because if we have already pushed it, then it will be processed eventually? 

        But our queue might not be processed in order? It is a BFS? Then we process edges that become eligible earlier first? But we don't care about the order? 

        Therefore, we can push an edge only once: the first time it becomes eligible? 

        How to do? We maintain an array `in_queue`? Or we can set a flag? 

        We do:

          We maintain a 2D array `pushed` or simply use the fact that we are going to push it only once? 

          Alternatively, we can do:

            We push an edge (u, v) if:
                !added[u][v] and deg[u]+deg[v]>=k and we haven't pushed it before? 

          But then, how do we know if we have pushed it before? We maintain a 2D boolean array `pushed`? But then we need to reset for each candidate k? 

          We can do:

            We create a 2D array `pushed` of size (n+1) * (n+1) and initialize to false.

            Then when we see a non-edge (u, v) that is not added and deg[u]+deg[v]>=k and not pushed[u][v], then we push it and mark pushed[u][v]=true.

          Then in the while loop, when we add the edge, we update the degrees and then for neighbors w of u and v, we check non-edges (u, w) and (v, w): if they are not added and not pushed, and now deg[u]+deg[w]>=k, then we push (u, w) and mark pushed[u][w]=true? 

          But note: the condition for (u, w) might already be satisfied? Then we push it? 

          This way, each edge is pushed at most once.

          Then the total number of edges in the queue is at most n(n-1)/2 - m. And for each edge, we do O(n) work? Then total O(n^3) per candidate k.

          Then binary search: O(log n) * O(n^3) = 125e6 * 9 = 1.125e9, which is acceptable in C++? 

        Let's code accordingly.

        Steps for check(k):
          - Create a 2D vector `added` of size (n+1) by (n+1) and initialize with the given graph.
          - Copy the initial degree array to `deg`.
          - Create a 2D vector `pushed` of size (n+1) by (n+1), initialize to false.
          - Create a queue.
          - int added_count = m;   // we will count how many edges we have in total (including the initial ones and the ones we add)
          - total_edges = n*(n-1)/2

          // Pre-initialize the queue: for every non-edge (u, v) (i.e., !added[u][v]) that satisfies deg[u]+deg[v]>=k and mark pushed[u][v]=true, then push.
          for (int u=1; u<=n; u++) {
             for (int v=u+1; v<=n; v++) {
                 if (!added[u][v] && deg[u]+deg[v]>=k) {
                     pushed[u][v] = true;
                     queue.push({u, v});
                 }
             }
          }

          while (!queue.empty()) {
              auto [u, v] = queue.front(); queue.pop();
              // It might be that the edge is already added? But we pushed only once? Actually, we pushed when not added? Then we haven't added it? But it might have been added by a duplicate push? We don't have duplicate push? 
              if (added[u][v]) 
                  continue;

              // Check the condition again? Actually, the condition might have been updated? But we pushed it only when the condition held? And then the degrees of u and v might have increased? So it holds? 
              // But what if the condition fails? Actually, the condition holds? Because degrees only increase? 
              // So we don't check? 

              // Add the edge (u, v)
              added[u][v] = true;
              added[v][u] = true;
              deg[u]++;
              deg[v]++;
              added_count++;

              // Now, update: for every node w (w from 1 to n, w != u and w != v) we check the non-edge (u, w) and (v, w)
              for (int w=1; w<=n; w++) {
                  if (w == u || w == v) continue;
                  // For (u, w): 
                  if (!added[u][w] && !pushed[u][w]) {
                      if (deg[u] + deg[w] >= k) {
                          pushed[u][w] = true;
                          queue.push({u, w});
                      }
                  }
                  if (!added[v][w] && !pushed[v][w]) {
                      if (deg[v] + deg[w] >= k) {
                          pushed[v][w] = true;
                          queue.push({v, w});
                      }
                  }
              }
          }

          return (added_count == total_edges);

        But note: the condition for (u, w) is checked after we updated deg[u]? So it is the current value.

        However, we don't update the degree of w? Then we are safe.

        But what if the edge (u, w) is not pushed yet and the condition holds? Then we push it.

        Also note: we don't push the same edge twice because of the `pushed` array.

        Then we run the binary search.

        Special note: when k=0, then every non-edge satisfies the condition? Then we should be able to add all edges? 

        Also, when k is too large, we might not add any edge? Then the graph remains incomplete.

        We want the maximum k such that the closure becomes complete.

        Let's test with the sample: "4 3\n1 2\n2 3\n3 4" -> k=3.

        We'll simulate check(3) and check(4).

        For check(3):
          Initial graph: 
            edges: (1,2), (2,3), (3,4)
            deg: [1,2,2,1]

          Non-edges: (1,3), (1,4), (2,4)

          Condition for non-edges:
            (1,3): 1+2=3 -> push.
            (1,4): 1+1=2 -> skip.
            (2,4): 2+1=3 -> push.

          Queue: [ (1,3), (2,4) ]? Or in any order? 

          Then we pop the front: 
            Option: if we pop (1,3) first:
                Add (1,3): then deg[1]=2, deg[3]=3.
                Then update:
                  For w: 
                    for u=1: check non-edges: (1,4) -> now deg[1]+deg[4] = 2+1=3 -> condition holds? Then push (1,4) -> and mark pushed[1][4]=true.
                    for v=3: check non-edges: (3,?) -> but (3,1) already added? (3,2) exists? (3,4) exists? So nothing? 
                Then added_count becomes 4.

            Then pop (2,4): 
                Add (2,4): then deg[2]=3, deg[4]=2.
                Then update:
                  for u=2: check non-edges: (2,1) exists? (2,3) exists? (2,4) we just added? Then nothing.
                  for v=4: check non-edges: (4,1) -> not added? But we pushed (1,4) above? Actually, we pushed (1,4) and we haven't processed it? 
                Then we push (4,1) again? No, because we have pushed[1][4] = true? Then we skip.

            Then we pop (1,4): 
                Add (1,4): then deg[1]=3, deg[4]=3.
                Then update: 
                  for u=1: check non-edges: none? (1,2) exists, (1,3) exists, (1,4) added -> nothing.
                  for v=4: check non-edges: (4,2) exists? (4,3) exists? nothing.
                added_count becomes 5? Then we have 5 edges? The complete graph has 6 edges? 

          We started with 3, then added 2 -> 5? Missing (2,3) is already there? Actually, the complete graph has 6 edges? 

          What's the total? 
            Initial: 3 edges.
            Then we add (1,3) -> 4
            Then we add (2,4) -> 5
            Then we add (1,4) -> 6? 

          Then added_count becomes 6? 

          How? We start at 3, then we add (1,3): added_count=4, then (2,4): added_count=5, then (1,4): added_count=6.

          Then we return true.

        But what if we pop (2,4) first?
          Pop (2,4): 
            Add (2,4): deg[2]=3, deg[4]=2 -> becomes 3 and 2? Then update:
                for u=2: check non-edges: (2,1) exists? (2,3) exists? (2,4) added -> nothing? 
                for v=4: check non-edges: (4,1) -> deg[4]+deg[1]=2+1=3 -> condition holds? Then push (4,1) -> and mark pushed[4][1]=true? 
            added_count=4.

          Then pop (1,3): 
            Add (1,3): deg[1]=2, deg[3]=3 -> then update:
                for u=1: check (1,4): now deg[1]=2, deg[4]=2 -> 4? >=3 -> but we already pushed (1,4)? Actually, we pushed (4,1) but we store as (1,4) in the queue? How do we store? We store with u<v? 

          We must store in a canonical form? For example, always store with u<v? Then we don't push (4,1) but push (1,4) with u=min, v=max.

          How do we handle? 

          We can store the edge (min(u,v), max(u,v))? Then when we get an edge (u, v), we store (min(u,v), max(u,v)).

          Then in the update, when we consider (u, w), we store (min(u,w), max(u,w))? 

          Similarly for (v, w).

          Then we avoid duplicates.

          Actually, we are storing in `pushed` and `added` by (u, v) with u<v? Then we only consider u<v.

          How we store the graph? We store as undirected: if we add (u, v), we set added[u][v]=true and added[v][u]=true? 

          Then we can do:

            When iterating for w: 
                for (u, w): we consider the canonical edge: let u1 = min(u,w), w1 = max(u,w). Then we check added[u1][w1] and pushed[u1][w1]? 

          Alternatively, we can store the graph as symmetric? Then we don't need to store twice? 

          We'll assume that when we set added[u][v] = true, we also set added[v][u]=true? 

          Similarly, pushed: we can use a 2D array indexed by min and max? But we don't have to: we can store for (min, max) only? 

          Actually, we can maintain:

            added[u][v] for u<v? But then we have to index by u<v? 

          Or we can just store for all pairs? Since n is 500, we can have a 2D array of size 501x501.

          We'll do:

            for (int u=1; u<=n; u++) {
                for (int v=1; v<=n; v++) {
                    // we store added[u][v] for u!=v? and for u==v, skip.
                }
            }

          But we are storing both (u,v) and (v,u)? Actually, we set:

            added[u][v] = added[v][u] = true;

          Similarly, for the `pushed` array: we set pushed[u][v] and pushed[v][u]? Actually, we only consider u<v? Then we can store only the canonical representation? 

          We decide: we store the edge in the queue as (min(u,v), max(u,v)). And we maintain:

            added[i][j] for i and j: symmetric? But we are using a 2D array of booleans that is symmetric? 

          Then when we update:

            for w from 1 to n:
                if w != u and w != v:
                    // for the edge (u, w): we consider the canonical representation: let a = min(u, w), b = max(u, w)
                    // similarly for (v, w): a = min(v, w), b = max(v, w)

          Then we check added[a][b] and pushed[a][b]? 

          We'll do:

            int a1 = min(u, w);
            int b1 = max(u, w);
            if (!added[a1][b1] && !pushed[a1][b1] && deg[u] + deg[w] >= k) {
                pushed[a1][b1] = true;
                queue.push({a1, b1});
            }

          Similarly for v.

        Alternatively, we can avoid the canonical representation in the queue? And then in the `pushed` and `added` arrays, we use symmetric? But then we have to store two entries? 

        Actually, we can do without canonical representation: 

          We store the edge as (u, v) without ordering? Then we set added[u][v]=true and added[v][u]=true? And we set pushed[u][v]=true and pushed[v][u]=true? 

          But then we push (u, v) and (v, u) as the same edge? 

          We avoid by storing the edge in the queue in canonical form? 

        We choose: we store in the queue as (min, max). And then the arrays `added` and `pushed` we maintain for all pairs? Actually, we don't need: we can use the canonical representation for the arrays? 

        Let's create:

          vector<vector<bool>> added(n+1, vector<bool>(n+1, false));
          vector<vector<bool>> pushed(n+1, vector<bool>(n+1, false));

        And we only use the upper triangle? For i<j? 

          When we have an edge (u, v), we set u0 = min(u,v), v0 = max(u,v). Then we work with (u0, v0).

        Then in the initialization of the graph: for the given edge (a, b) we set a0 = min(a,b), b0 = max(a,b), then set added[a0][b0]=true.

        Similarly, for the degree update: we don't need the canonical for the graph? Actually, the graph is symmetric? 

        How about in the update loop? 
          for w from 1 to n:
             if w==u || w==v: skip?
             then consider the edge (u, w): we set a = min(u,w), b = max(u,w). Then check if added[a][b] is false? and pushed[a][b] is false? 

        Then we push (a, b) and set pushed[a][b]=true.

        Similarly for (v, w).

        Then we avoid duplicates.

        We'll implement accordingly.

        Steps:

          Precompute: 
            total_edges = n*(n-1)/2
            If m == total_edges, then we output 0 and return.

          Binary search: low=0, high=2*(n-1)

          For each candidate k in the binary search:

            // Copy the graph to a local `added` (a 2D vector for n+1 x n+1, initially false)
            // and copy the initial degrees to a local `deg` array.

            // Initialize:
            vector<vector<bool>> added(n+1, vector<bool>(n+1, false));
            vector<int> deg_local = deg;   // copy the initial degrees.

            // Set the existing edges: 
            //   We are going to set for each given edge (a,b): set added[min(a,b)][max(a,b)] = true.

            // But we already have the graph? Actually, we stored the graph in a global way? We don't: we have the initial graph in a matrix? Actually, we read the edges? Then we can set:

            for each edge (a,b) in the input:
                int u = min(a, b);
                int v = max(a, b);
                added[u][v] = true;
            // Note: we don't set the symmetric? Actually, we only use the upper triangle? So we only set for u<v.

            // Initialize a 2D vector `pushed` (size n+1 x n+1, false) for the upper triangle.

            queue< pair<int,int> > Q;

            int added_count = m;

            // Pre-push the non-edges that satisfy the condition: for u=1 to n, for v=u+1 to n: 
            for (int u=1; u<=n; u++) {
                for (int v=u+1; v<=n; v++) {
                    if (!added[u][v]) {
                        if (deg_local[u] + deg_local[v] >= k) {
                            pushed[u][v] = true;
                            Q.push({u, v});
                        }
                    }
                }
            }

            while (!Q.empty()) {
                auto edge = Q.front(); Q.pop();
                int u = edge.first, v = edge.second;
                if (added[u][v]) 
                    continue;
                // Check: if the condition still holds? Actually, we know that the condition holds? Because we pushed it only when it held and then the degrees only increased? 
                // But to be safe, we can check? The condition is: deg_local[u] + deg_local[v] >= k? 
                // Actually, it must hold? But if k is negative? Actually, k>=0. 
                // So we add the edge.
                added[u][v] = true;
                added_count++;
                deg_local[u]++;
                deg_local[v]++;

                // update for u: consider all w from 1 to n, w != u and w != v? Actually, we consider every w that is not u? 
                for (int w=1; w<=n; w++) {
                    if (w == u || w == v) 
                        continue;
                    // For the edge (u, w): we consider the canonical representation: a = min(u, w), b = max(u, w)
                    int a = min(u, w);
                    int b = max(u, w);
                    if (!added[a][b] && !pushed[a][b]) {
                        if (deg_local[u] + deg_local[w] >= k) {
                            pushed[a][b] = true;
                            Q.push({a, b});
                        }
                    }
                }
                for (int w=1; w<=n; w++) {
                    if (w == u || w == v) 
                        continue;
                    int a = min(v, w);
                    int b = max(v, w);
                    if (!added[a][b] && !pushed[a][b]) {
                        if (deg_local[v] + deg_local[w] >= k) {
                            pushed[a][b] = true;
                            Q.push({a, b});
                        }
                    }
                }
            }

            return (added_count == total_edges);

        Then we run the binary search.

        But note: the update for u: we consider every w? That is O(n). Similarly for v: O(n). Then per edge we do O(n). Then total O(n^3) per candidate k.

        We'll run this for O(log n) candidates? Then worst-case O(n^3 log n) which is about 125e6 * 9 = 1.125e9? 

        We hope that the worst-case is not too bad.

        Let's test with sample input #1: n=4, m=3, edges: (1,2), (2,3), (3,4) -> k=3.

        We'll run check(3): 
          added_count starts at 3.

          Pre-push: 
            (1,3): 1+2=3 -> push
            (1,4): 1+1=2 -> skip
            (2,4): 2+1=3 -> push

          Queue: [ (1,3), (2,4) ]

          Pop (1,3):
            added[1][3] = true; added_count=4.
            deg_local: [1->2, 2->2, 3->3, 4->1] -> actually: 
                deg_local[1] becomes 2, deg_local[3] becomes 3.
            Then update for u=1: w from 1 to 4: skip w=1, w=3 -> consider w=2 and w=4.
                w=2: edge (1,2) -> added? yes (initial) -> skip.
                w=4: edge (1,4): a = min(1,4)=1, b=4. 
                    not added? true -> not pushed? true -> then condition: deg_local[1]+deg_local[4]=2+1=3 -> condition holds? Then push (1,4) and mark pushed[1][4]=true.
            Then update for v=3: w from 1 to 4: skip w=1, w=3 -> w=2 and w=4.
                w=2: edge (2,3): added? yes -> skip.
                w=4: edge (3,4): added? yes -> skip.

          Then pop (2,4):
            added[2][4]=true; added_count=5.
            deg_local[2] becomes 3, deg_local[4] becomes 2.
            Then update for u=2: w from 1 to 4: skip w=2, w=4 -> w=1 and w=3.
                w=1: edge (1,2): added -> skip.
                w=3: edge (2,3): added -> skip.
            Then update for v=4: w from 1 to 4: skip w=2, w=4 -> w=1 and w=3.
                w=1: edge (1,4): already pushed? pushed[1][4] is true -> skip.
                w=3: edge (3,4): added -> skip.

          Then pop (1,4): 
            added[1][4]=true; added_count=6.
            deg_local[1] becomes 3, deg_local[4] becomes 3.
            Then update for u=1: w=2,3,4 -> skip w=1 and w=4? 
                w=2: edge(1,2): added -> skip.
                w=3: edge(1,3): added -> skip.
                w=4: skip? 
            Then update for v=4: w=1,2,3: all edges added.

          Then we return true.

        Then check(4): 
          Pre-push:
            (1,3): 1+2=3 <4 -> skip.
            (1,4): 1+1=2 <4 -> skip.
            (2,4): 2+1=3 <4 -> skip.
          Then the queue is empty? Then added_count=3 != 6 -> returns false.

        Then the binary search: 
            low=0, high=2*(n-1)=6? 
            mid = (0+6)/2 = 3 -> check(3) returns true -> ans=3, then low=4, then mid=5, check(5) -> false, then mid=4 -> check(4) false, then high=3 -> done.

        Output: 3.

        Sample Input #2: "5 0" -> then k=0? 
          total_edges = 10, m=0 -> added_count=0.
          Pre-push: all non-edges? But condition: 0+0=0>=0? -> true. Then we push all 10 edges? 
          But we push one edge at a time? 

          Actually, we push all non-edges? Then we process them? 

          How? The queue has 10 edges? Then we process one, and then update? 

          But note: we are storing the canonical form? 

          Actually, we are pushing all non-edges? Then we process one edge: 
            pop an edge (u, v): 
                added[u][v]=true, added_count=1.
                update: for u: for every w (w != u and w != v) we consider the edge (u, w) -> but we haven't pushed them? Actually, we pushed them all initially? So we skip because pushed[min(u,w)][max(u,w)] is true? 

          Then we process the next edge? 

          Actually, we don't push any new edge? Because we pushed all initially? 

          Then we process 10 edges? 

          Then added_count=10 -> true.

          Then we try k=1: 
            condition: 0+0>=1? -> false. Then we don't push any edge? Then added_count=0 -> false.

          Then the binary search: 
            low=0, high=8 -> mid=4: check(4) fails, mid=2: check(2) fails, mid=1: fails, then ans=0.

          Output:0.

        Sample Input #3: "5 2\n1 2\n3 4"
          n=5, m=2, total_edges=10, so we need to add 8 edges.

          Initial graph: 
            edges: (1,2) and (3,4)
            deg: [1,1,1,1,0]? Actually, nodes: 
                1: connected to 2 -> deg=1
                2: connected to 1 -> deg=1
                3: connected to 4 -> deg=1
                4: connected to 3 -> deg=1
                5: deg=0

          We'll run check(k) for k=0,1,2,3,4,5,6,7,8? 

          We know the answer is 2.

          Let's check k=2:
            Pre-push: non-edges: 
                Condition: deg[u]+deg[v]>=2?
                For (1,3): 1+1=2 -> push
                (1,4): 1+1=2 -> push
                (1,5): 1+0=1 -> skip
                (2,3): 1+1=2 -> push
                (2,4): 1+1=2 -> push
                (2,5): 1+0=1 -> skip
                (3,5): 1+0=1 -> skip
                (4,5): 1+0=1 -> skip
                (3,4) is already present? skip.
                (1,2) present -> skip.

            Then we push: (1,3), (1,4), (2,3), (2,4)

            Then we process:

              We pop one, say (1,3): 
                add (1,3): then deg[1]=2, deg[3]=2.
                Then update: 
                    for u=1: w from 1 to 5: skip w=1, w=3 -> w=2,4,5.
                      w=2: edge (1,2): present? yes -> skip.
                      w=4: edge (1,4): pushed? yes -> skip.
                      w=5: edge (1,5): canonical (1,5): not added and not pushed? then condition: deg[1]+deg[5]=2+0=2 -> condition holds? Then push (1,5) and mark pushed[1][5]=true.
                for v=3: w from 1 to 5: skip w=1, w=3 -> w=2,4,5.
                      w=2: edge (2,3): pushed? yes -> skip.
                      w=4: edge (3,4): present? yes -> skip.
                      w=5: edge (3,5): condition: 2+0=2 -> push (3,5) and mark.

              Then pop next: (1,4): 
                add (1,4): deg[1]=3, deg[4]=2.
                update for u=1: w=2,3,4,5 -> 
                    w=2: present -> skip.
                    w=3: already added? (1,3) added -> skip.
                    w=4: skip? (we just added (1,4)) -> skip.
                    w=5: already pushed? yes -> skip.
                for v=4: w=1,2,3,5 -> 
                    w=1: skip.
                    w=2: edge (2,4): pushed? yes -> skip.
                    w=3: present -> skip.
                    w=5: edge (4,5): condition: deg[4]=2, deg[5]=0 -> 2 -> condition holds? Then push (4,5) and mark.

              Then pop (2,3): 
                add (2,3): deg[2]=2, deg[3]=3.
                update for u=2: w=1,3,4,5 -> 
                    w=1: present -> skip.
                    w=3: skip -> already added? skip.
                    w=4: edge (2,4): pushed? yes -> skip.
                    w=5: edge (2,5): condition: 2+0=2 -> push (2,5) and mark.
                for v=3: w=1,2,4,5 -> 
                    w=1: added? skip.
                    w=2: skip -> we just added? skip.
                    w=4: present? skip.
                    w=5: already pushed? (3,5) pushed -> skip.

              Then pop (2,4): 
                add (2,4): deg[2]=3, deg[4]=3.
                update: 
                  for u=2: w=1,3,4,5 -> 
                      w=1: skip.
                      w=3: skip.
                      w=4: skip.
                      w=5: already pushed? (2,5) pushed -> skip.
                  for v=4: w=1,2,3,5 -> 
                      w=1: skip.
                      w=2: skip.
                      w=3: skip.
                      w=5: pushed? (4,5) pushed -> skip.

              Then pop (1,5): 
                add (1,5): deg[1]=4, deg[5]=1.
                update:
                  for u=1: w=2,3,4,5 -> skip? because all edges from 1 are added? 
                  for v=5: w=1,2,3,4 -> 
                      w=1: skip.
                      w=2: edge (2,5): pushed? yes -> skip? but we haven't added it? Actually, we pushed (2,5) and it's in the queue? Then we skip? 
                      Actually, we have pushed (2,5) and we haven't processed it? Then we will process it later.

              Then pop (3,5): 
                add (3,5): deg[3]=4, deg[5]=2.
                update: 
                  for u=3: w=1,2,4,5 -> skip? (all edges from 3 are added? 3-1,3-2,3-4,3-5)
                  for v=5: w=1,2,3,4 -> 
                      w=1: skip.
                      w=2: edge (2,5): pushed -> skip? but not added? Then we push again? No, we skip because pushed is true.

              Then pop (4,5): 
                add (4,5): deg[4]=4, deg[5]=3.
                update: 
                  for u=4: w=1,2,3,5 -> skip.
                  for v=5: w=1,2,3,4 -> skip.

              Then pop (2,5): 
                add (2,5): deg[2]=4, deg[5]=4.
                update: skip.

              Then added_count = 2 (initial) + 8 = 10 -> true.

          Then check(3) would fail? Because initially, we have (1,5): 1+0=1 <3 -> skip, and (3,5): 1+0=1<3, etc. So we only push (1,3), (1,4), (2,3), (2,4). Then we add those 4, then we check the others? They are not pushed? Then we don't add the other 4? 

          Therefore, check(3) returns false.

          Then the binary search: 
            low=0, high=8 -> mid=4: false, mid=2: true -> then ans=2, then we check k=3: false, so the highest is 2.

        So we output 2.

        Therefore, we code accordingly.

        Note: We must be cautious about the performance: worst-case n=500, then total_edges = 125000. Then the queue initially has 125000 - m. Then each edge we do 2*(n-2) ~ 1000 operations? Then total operations 125000 * 1000 = 125e6? Then per candidate k: 125e6? Then binary search: log(500) ~ 9 -> 1125e6? That is 1.1e9, which might run in 1-2 seconds in C++? 

        But worst-case: we have to add 125000 edges? Then the inner loop per edge is O(n) -> 500 * 125000 = 62.5e6? Then total per candidate k: 62.5e6? Then binary search: 9 * 62.5e6 = 562.5e6? That is acceptable.

        Actually, I see: the queue has at most 125000 edges. Then we do for each edge popped: two loops over w (each of size n) -> 2 * n = 1000. Then total 125000 * 1000 = 125e6 per candidate k. Then 9 * 125e6 = 1125e6 = 1.125e9 -> which is acceptable in C++ if we optimize the inner loop? 

        We'll code accordingly.

        Let me write the code accordingly.

        Note: We must avoid using vector<bool> for large 2D arrays? Because vector<bool> is bitset? Then we can use vector<vector<int>> or vector<vector<char>> for `added` and `pushed`? 

        Since n=500, then the size of the 2D array is 501*501 = 251001, which is acceptable.

        We'll use vector<vector<char>> for `added` and `pushed` to avoid the performance issue of vector<bool>.

        Steps:

          Precompute total_edges = n*(n-1)/2.

          If m == total_edges, then output 0 and exit.

          Then binary search:

            low = 0, high = 2*(n-1)

            ans = 0

            while (low <= high):
                mid = (low+high)/2
                if check(mid) is true:
                    ans = mid
                    low = mid+1
                else:
                    high = mid-1

            print ans

          In check(k):

            We create:
              vector<vector<char>> added(n+1, vector<char>(n+1, 0));
              vector<vector<char>> pushed(n+1, vector<char>(n+1, 0));
              vector<int> deg_local = deg_initial;   // we have an initial deg array of size n+1

            // Initialize added: for each edge in the input, set added[min(a,b)][max(a,b)] = 1.

            int added_count = m;

            queue< pair<int,int> > Q;

            // Pre-push: for u from 1 to n, for v from u+1 to n: 
            for (int u=1; u<=n; u++) {
                for (int v=u+1; v<=n; v++) {
                    if (added[u][v]) 
                        continue;
                    if (deg_local[u] + deg_local[v] >= k) {
                        pushed[u][v] = 1;
                        Q.push({u, v});
                    }
                }
            }

            while (!Q.empty()) {
                int u = Q.front().first;
                int v = Q.front().second;
                Q.pop();

                if (added[u][v]) 
                    continue;

                added[u][v] = 1;
                added_count++;
                deg_local[u]++;
                deg_local[v]++;

                for (int w=1; w<=n; w++) {
                    if (w == u || w == v) 
                        continue;
                    // For (u, w)
                    int a = min(u, w);
                    int b = max(u, w);
                    if (!added[a][b] && !pushed[a][b]) {
                        if (deg_local[u] + deg_local[w] >= k) {
                            pushed[a][b] = 1;
                            Q.push({a, b});
                        }
                    }
                    // For (v, w)
                    int c = min(v, w);
                    int d = max(v, w);
                    if (!added[c][d] && !pushed[c][d]) {
                        if (deg_local[v] + deg_local[w] >= k) {
                            pushed[c][d] = 1;
                            Q.push({c, d});
                        }
                    }
                }
            }

            return (added_count == total_edges);

        Note: We are updating both (u, w) and (v, w) in the same loop? Actually, we are doing two separate checks? But we can break the loop into two: one for u and one for v? 

        Actually, the above inner loop does two checks per w? 

        Alternatively, we can do:

          for (int w=1; w<=n; w++) {
              if (w == u || w == v) continue;
              // for (u, w)
              int a = min(u, w);
              int b = max(u, w);
              ... 
          }
          for (int w=1; w<=n; w++) {
              if (w == u || w == v) continue;
              // for (v, w)
              int c = min(v, w);
              int d = max(v, w);
              ...
          }

        But the above does the same? 

        Actually, the current code does both in one loop? Then we do two checks per w? That is acceptable? 

        However, we might do redundant work: for w, we compute a,b and then c,d? 

        We'll do as above.

        Let me test with the sample input #1: k=3, and the edge (1,3) popped: then we update for w=2 and w=4? Then we do:

          w=2: 
            a = min(1,2)=1, b=2 -> already added? skip.
            c = min(3,2)=2, d=3 -> already added? skip.
          w=4:
            a = min(1,4)=1, b=4 -> not added, not pushed -> condition: deg[1]=2, deg[4]=1 -> 3>=3 -> true -> push (1,4) and mark pushed[1][4]=true.
            c = min(3,4)=3, d=4 -> already added? skip.

        So it works.

        We'll code accordingly.

        Note: The initial degree array: we need to compute from the input? 

        How we compute the initial deg array?
          We start with deg[i]=0 for all i.
          For each edge (a,b): 
              deg[a]++
              deg[b]++

        Then we store in a global vector.

        Finally, we output the answer.

        Let me write the entire C++ code accordingly.

        Important: We must not forget to set the initial added for the input edges.

        We'll do:

          vector<int> deg(n+1, 0);
          for each edge: 
              int a = min(u, v) from input? Actually, the input gives a and b? 
              deg[a]++; deg[b]++;

          Then in check(k): 
              vector<vector<char>> added(n+1, vector<char>(n+1, 0));
              for each edge in input:
                  int u = min(a,b), v = max(a,b);
                  added[u][v] = 1;

        And then we proceed.

        Let's code accordingly.

        We hope it passes.

        Note: The worst-case might be a complete graph? Then we skip the while loop? Then it is fast.

        We'll run the sample tests.

        We assume the input is given as described.

        Code accordingly.