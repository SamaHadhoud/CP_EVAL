We are given a graph with up to 100,000 vertices and edges. We wish to find the maximum number of disjoint boomerangs. A boomerang is a tuple <u, v, w> such that (u,v) and (v,w) are edges and u != w. The boomerangs are disjoint in that no edge is used in more than one boomerang.

Note that each boomerang uses two edges. Therefore, the maximum possible number of boomerangs is floor(M/2). However, it may not always be possible to achieve that because of the structure of the graph. But surprisingly, we can always achieve floor(M/2) boomerangs? Actually, let's think: we are allowed to use each edge only once. However, a boomerang requires two edges that share a common vertex. The problem is to cover as many edges as possible with boomerangs (each boomerang covering two edges) and such that the boomerangs are edge-disjoint.

But note: the problem does not require covering every edge? We just want as many disjoint boomerangs as possible. However, if we can form k boomerangs, we cover 2k edges. The maximum k is then at most floor(M/2). But is it always possible to form floor(M/2) boomerangs? Not exactly: because we require that the two edges in a boomerang share a common vertex. For example, if the graph is a triangle: 3 edges and we can form one boomerang (using two edges). Then we have one edge left which cannot form a boomerang? Actually, in the triangle we can form only one boomerang? But the sample input #3 has a triangle and outputs one boomerang.

But sample input #2: a complete graph on 4 vertices (6 edges) -> outputs 3 boomerangs (so 3 boomerangs = 6 edges). So that uses all edges.

However, consider a graph that is a set of disjoint edges (no vertex has degree more than 1). Then we cannot form any boomerang. So the maximum number of boomerangs is 0.

So the problem is: we want to cover as many edges as possible with edge-disjoint boomerangs (each boomerang being two edges incident to a common vertex). This is similar to an edge packing problem with a local structure constraint.

How to solve?

We note that each boomerang is centered at a vertex (the middle vertex v in <u,v,w>). And each boomerang uses two edges incident to v. Therefore, if we let d(v) be the degree of vertex v, then the number of boomerangs that can be centered at v is at most floor(d(v)/2). But note: the same edge cannot be used twice. Therefore, we are looking for a way to assign edges to boomerangs such that each boomerang is assigned to a center and uses two edges incident to that center.

But note: an edge is incident to two vertices. How do we assign the edges? We can view the problem as: we wish to partition the edge set into as many boomerangs as possible. Each boomerang is a path of length 2 (two edges) and we output the three vertices (u, v, w) meaning the two edges are (u,v) and (v,w).

We can also think: if we can cover the entire graph with disjoint paths of length 2, then we get k = M/2 boomerangs. But that is not always possible (like the matching example). So we need an algorithm that maximizes the number of such paths.

This problem is known in graph theory: edge-disjoint paths of length two (which are just two edges sharing a common vertex). Alternatively, we can see it as: we are going to assign to each boomerang a center and two edges incident to that center. The constraints are that each edge can only be assigned once.

We can model this as a matching problem on the edges? But note: two edges incident to the same vertex can form a boomerang. However, an edge might be incident to two centers (the two endpoints). How do we assign edges to centers? And each edge can only be used once.

Alternatively, we can use an Euler tour? Or greedy?

But note: M and N can be up to 100,000. We need an efficient algorithm.

Idea: we can use a greedy algorithm that iterates over the vertices and for each vertex, we try to form as many boomerangs as possible from the edges that remain incident to it.

However, if we do a naive greedy: we process vertices one by one. For a vertex v, we look at the current edges incident to v that are not used. Then we try to pair two edges incident to v to form a boomerang. But note: if we take two edges (v, a) and (v, b), then we form a boomerang <a, v, b>. Then we remove these two edges.

But the problem: what order to process the vertices? The choice at one vertex affects the degrees of adjacent vertices.

We can use a DFS/BFS and use a stack? But note: we are allowed to output any valid solution with the maximum number.

Alternatively, we can use a strategy that always works: we can use an approach similar to finding an edge-disjoint path cover for paths of length two.

But note: we are only forming paths of length two. Each boomerang is a path of two edges. The entire set of boomerangs forms a graph where each connected component might be a star (with center v and two leaves) or more complex? Actually, the boomerangs might not be connected to each other.

We can also note: the problem is equivalent to decomposing the graph into as many paths of length two as possible. The maximum number of such paths is at most floor(M/2). And we want to achieve the maximum.

But is it always possible to achieve floor(M/2)? Actually, no: as in the disjoint edges example. But we want the maximum.

We can use a greedy algorithm that uses a queue (or a stack) of vertices that have at least one unused edge. However, we want to avoid having an edge that becomes isolated (so that we cannot form a boomerang with it). How?

Alternatively, we can use the following known approach:

1. For each vertex, we maintain the current degree (in terms of unused edges) and the list of adjacent edges that are still available.

2. We maintain a queue of vertices that have at least two available edges (so they can form a boomerang).

3. While there is a vertex v with at least two available edges, we do:
   - Take two available edges incident to v: say (v, a) and (v, b). 
   - Form the boomerang <a, v, b> (or <b, v, a>? the problem does not care about order? but note the output: the middle vertex is v, and the two others are a and b. The problem does not specify an order for the two endpoints, but the sample outputs have the middle in the center. However, the problem says: output three integers: u v w meaning the boomerang <u, v, w> which implies (u,v) and (v,w) are edges. So we must output the middle vertex as the second one.

   However, note: the two edges are (v,a) and (v,b). We can output either (a, v, b) or (b, v, a). Both are valid.

   - Then we remove the edges (v,a) and (v,b). This decreases the available degree of v by 2, and also decreases the available degree of a and b by 1.

   - If after removing these edges, the available degree of a becomes 1 (or 0) then we don't do anything? But note: if a now has available edges, we might check if a has at least two available edges? Actually, we should update a and b: after removing the edge (v,a), the degree of a drops. Similarly for b.

   - Then we check: if the available degree of a becomes at least 2, we push a into the queue (if it isn't already). Similarly for b.

But what about v? After we remove two edges, if v still has at least two available edges, we leave it in the queue? Actually, we remove two edges so we should update v. If after removal, v has at least two edges, then we keep it in the queue. Otherwise, we remove it.

However, what if we get stuck? That is, there are edges left but no vertex has two available edges? Then we have a set of edges that form a matching (each vertex has degree at most 1). Then we cannot form any more boomerangs.

But is this greedy optimal? Why?

Let k be the number of boomerangs we form. Then we use 2k edges. The remaining edges form a graph where every vertex has degree at most 1. Therefore, we cannot form any more boomerangs. So we have used the maximum possible? 

Yes: because if we have any boomerang, it requires two edges incident to a common vertex. But after we remove the boomerangs, the remaining graph has no vertex with degree 2 or more. So we cannot form any more. Thus, we have the maximum.

But note: the greedy might not form as many boomerangs as possible? Because the order of processing matters? 

Actually, the greedy is known as the "edge-disjoint star packing" and it is optimal for this structure. Why? Because each boomerang is a star of two edges at a vertex. The entire graph is decomposed into stars (each star being one or more boomerangs? but note: each boomerang is a star of two edges). Actually, we are forming disjoint two-edge stars.

We can also view: the greedy algorithm is similar to the one for matching? and it is optimal because the set of edges we have at the end is a matching and we cannot form any more.

But we must be cautious: what if at a vertex v we have an odd number of edges? Then we leave one edge. That edge might be used at the other endpoint? But the greedy does not use it at v because we process v only when we have at least two edges. Then we rely on the other endpoint to pick it? However, the other endpoint might not get enough edges.

But the greedy algorithm:

We maintain:
   deg[v] = current degree of vertex v (the number of available edges incident to v).
   adj[v] = the list of neighbors connected to v by an available edge.

We also need to quickly remove edges? Actually, we can use linked lists? Or we can mark edges as used.

However, we don't need to store the entire graph? We can use an array for deg, and we can use a data structure for each adjacency list that we can remove edges? But removal from a linked list is O(1) if we have pointers? But in practice we can use a vector and mark edges as used? But then we have to skip used edges.

Alternatively, we can use a queue for each vertex? Actually, we can maintain for each vertex v a container (like a stack or a queue) of the current available neighbors.

But note: when we remove an edge (v, a), we must remove a from the adjacency list of v and v from the adjacency list of a.

We can do:

   while the queue (which holds vertices with deg[v]>=2) is not empty:
        pop a vertex v.
        if deg[v] < 2: skip (because it might have been updated by previous operations).
        Then, we take two distinct neighbors from adj[v]: say a and b.

        Then we remove the edges (v,a) and (v,b):
            remove a from adj[v] and remove v from adj[a].
            remove b from adj[v] and remove v from adj[b].
            deg[v] -= 2
            deg[a] -= 1
            deg[b] -= 1

        Then we output the boomerang: (a, v, b) [or (b, v, a)? but the problem does not care about the order of a and b? Actually, the problem does not specify an order. However, the sample output: for the first sample they output (4,1,2) and (4,3,2). But note: in (4,1,2): the middle is 1? Actually, wait: the boomerang is <4,1,2> meaning the edges (4,1) and (1,2). So the middle vertex is the second one. Therefore, we output (a, v, b) meaning the edges are (a,v) and (v,b). But note: we have the edge (v,a) and (v,b). We can output either (a,v,b) or (b,v,a). 

        However, the problem does not require a specific order. But we must be consistent? Actually, any order is acceptable.

        But note: the edges are undirected. The boomerang <a, v, b> uses the edges (a,v) and (v,b). This is valid.

        Then we push a and b into the queue if their deg becomes 2? Actually, if we subtract one from deg[a] and deg[a] becomes 2 (from 3) then now a can form a boomerang. But if it was 2 and becomes 1, then we don't push. Similarly, we push when deg[a] becomes >=2? But note: we started with a queue of vertices that have deg>=2. When we update a vertex, if its deg becomes 2 (from 3, for example) then we add it to the queue. But what if it was 1 and we subtract to 0? Then we skip.

        However, we must avoid duplicates? We can check: when we update a vertex, if its new degree is exactly 2, then we push it. But note: it might already be in the queue? We can avoid duplicates by using a flag? Or we can use a queue that allows duplicates? But then we might process a vertex that has deg<2. So we must check at the beginning of processing the vertex: if deg[v] < 2, then we skip.

        We can use a queue (or a stack) and we push a vertex only when its degree becomes 2? But note: it might have been more than 2 and we subtract one: then it becomes 2? Then we push? Actually, we might push the same vertex multiple times. But we can avoid that by using a condition: we only push when the degree becomes 2? But if it becomes 3? Then we don't push? Actually, we don't need to push when it becomes 3 because we only require at least 2. But if it is already in the queue, then we don't need to push again? 

        Alternatively, we can use a set: we maintain a set S of vertices that have deg>=2. Then we extract one from S, and then update the neighbors: if after updating a neighbor a, we check if deg[a]>=2: then we add it to S (if not already present). But if it is already present, then we don't add. And when we extract a vertex, we remove it from S? Actually, we remove it from S when we extract? Then we process it and then if after processing (and we used two edges) and if deg[v] is still >=2, then we put it back? 

        Actually, we can do:

          Let Q be a queue (or stack) that holds vertices with deg[v]>=2.

          while Q is not empty:
             take v from Q.
             if deg[v] < 2: continue.  [because it might have been reduced by other operations]

             take two neighbors a and b from adj[v] (and remove them from adj[v] and also remove the edge from adj[a] and adj[b] for v).

             deg[v] -= 2
             deg[a] -= 1
             deg[b] -= 1

             Remove the edge (v,a): we remove a from adj[v] and remove v from adj[a]. Similarly for (v,b).

             Output the boomerang: we output "a v b" (meaning the boomerang <a, v, b>)

             Then, for a: if deg[a] becomes 2 (from 3) then we push a? Actually, we push a if deg[a] >=2? But note: we started with deg[a]>=1? Actually, we subtract one: so if deg[a] was 2, then it becomes 1 -> we don't push. If it was 3, then becomes 2 -> we push. Similarly for b.

             But note: we must update the adjacency lists and the degrees.

        However, we must be cautious: the same edge might be taken twice? No, because we remove the edges.

        How to remove an edge from the adjacency list? We can use linked lists? Or we can use a vector and then mark the edge as used? But then when we pick a neighbor from adj[v], we have to skip the used ones? That would be inefficient.

        Alternatively, we can maintain for each vertex a container (like a stack) that holds the current available neighbors. And we pop when we use an edge? But then if we remove an edge (v,a), we have to remove it from both ends.

        Implementation:

          We maintain:
            deg: array of integers of size (N+1)
            g: array of sets? But sets have O(log n) per removal. Total operations: O(M) removals? Then total O(M log n) which might be acceptable? M=100000 -> 100000 * log(100000) ~ 100000*17 = 1.7e6, which is acceptable in 0.5s? But worst-case we might have 100000 vertices and each set has about 1000 neighbors? Then 100000 * log(1000) ~ 100000 * 10 = 1e6.

          Alternatively, we can use linked lists with pointers? But in C++ we can use std::set? Or std::unordered_set? But we don't need the full set operations: we only need to remove an arbitrary element? Actually, we don't care which two edges we take? So we can remove any two.

          How about: for each vertex, we maintain a vector? But then removal from a vector is O(deg). Then worst-case total O(M * deg) which is too high.

          Instead, we can use linked lists: we can use a list for each vertex and also we maintain an array of iterators for the position of each neighbor in the list? That is complex.

        Alternatively, we can use a different approach: we maintain the graph as an array of sets. The set for vertex v: set of neighbors. Then when we remove an edge (v,a):
            g[v].erase(a);
            g[a].erase(v);

        Then we can pick two arbitrary neighbors of v: 
            a = *g[v].begin();
            then we remove a from g[v]. Then we remove v from g[a]. Then we pick the next one: if g[v] is not empty then b = *g[v].begin(); then remove b from g[v] and remove v from g[b].

        But note: we might have only one edge? So we pick two arbitrarily: we remove two from the set.

        Steps for a vertex v:
            if g[v].size() < 2: skip.
            else:
                a = *g[v].begin(); 
                g[v].erase(a); 
                g[a].erase(v);

                b = *g[v].begin();
                g[v].erase(b);
                g[b].erase(v);

                Then we form the boomerang (a, v, b) [or (b, v, a)? we choose (a, v, b)].

                Then we push a and b into the queue if their set size becomes 2? Actually, after removal, if the size of g[a] becomes 2, then we push a. Similarly for b.

        We also update deg? Actually, we don't need the deg array? We only use the set sizes.

        But we must update the queue: we use a queue (or stack) of vertices that have set size>=2. When we remove edges, the set sizes decrease. We start by pushing all vertices that have set size>=2.

        Algorithm:

          Let Q be a queue (or stack) of vertices that currently have at least two edges (i.e., |g[v]|>=2).

          while Q is not empty:
             v = pop from Q.
             if |g[v]| < 2: continue.

             a = pop one neighbor from g[v] (and remove v from g[a])
             b = pop one neighbor from g[v] (and remove v from g[b])

             Then output the boomerang: (a, v, b)   [meaning edges (a,v) and (v,b)]

             Then, if after removal, |g[a]| >= 2, then push a to Q? But note: we might have pushed a already? We can push it again? But then we might process a multiple times. But that's okay because we check at the beginning: if |g[a]|>=2.

             Similarly for b.

          Then we continue until no vertex has at least two edges.

        Why is this efficient? Each edge is removed at most once. And each removal is O(log n) for sets. Total O(M log n).

        How many times is a vertex pushed? The number of times a vertex is pushed is at most O(deg(v))? Because each time we remove one edge from it, and we push it only when we remove an edge and the degree becomes 2? Actually, we push when the degree becomes 2 from 3? But if the degree is 3, then we push it only once? Actually, we might push the same vertex multiple times: when we remove an edge incident to it, if the degree becomes 2, then we push. But if the vertex is already in the queue, then we have duplicates. But we can avoid duplicates by using a flag? Or we can use a separate "inQueue" array? 

        Alternatively, we can avoid duplicates: we maintain a boolean array "inQ" that tells if the vertex is already in the queue. Then we only push a vertex if it is not in the queue and its |g[v]|>=2.

        Steps:

          Initialize:
            Build the graph: g as an array of sets (or unordered_sets) for each vertex.
            deg = [0]*(n+1)   # we don't need deg separately, we can use the set size.
            Q = deque()
            inQ = [False]*(n+1)

            For v from 1 to n:
                if |g[v]| >= 2:
                    push v to Q
                    inQ[v] = True

          while Q is not empty:
             v = pop from Q; inQ[v] = False
             if |g[v]| < 2: continue

             # We are going to remove two edges from v
             a = pop an element from g[v]: we can do a = g[v].begin() and then erase that element, and then remove v from g[a].
             Similarly for b.

             Then output: (a, v, b)

             # Now update a: 
                 remove v from g[a]   [we already did that? when we popped a from g[v], we also have to remove v from g[a]. So we do that explicitly? Actually, we did:
                    g[v].erase(a)   [but that only removes a from g[v]]
                    we also need: g[a].erase(v)

             Similarly for b: we remove v from g[b].

             Now, for vertex a: if |g[a]|>=2 and not inQ[a], then push a to Q and set inQ[a]=True.
             Similarly for b.

             For v: if |g[v]|>=2 and not inQ[v], then push v to Q and set inQ[v]=True.

        But note: we just removed two edges from v, so |g[v]| might be still >=2? Then we should push v again? But we just popped v? And we set inQ[v]=False. Then we check: if |g[v]|>=2 and not inQ[v] -> then we push. So yes.

        However, we must be cautious: we are removing two edges from v. So we do:

             g[v].erase(a); 
             g[a].erase(v);
             g[v].erase(b);
             g[b].erase(v);

        Then we output the boomerang.

        Then we check for a: if |g[a]|>=2 and not inQ[a] -> push a and mark inQ[a]=True.

        Similarly for b and v.

        This algorithm should run in O(M log n) time.

        Why is it optimal? Because we use every opportunity to form a boomerang. When we get stuck, no vertex has two edges so we cannot form any more boomerangs.

        But let's test with the triangle:

          Input: 
            3 3
            1 2
            1 3
            2 3

          Build:
            g[1] = {2,3}
            g[2] = {1,3}
            g[3] = {1,2}

          Initialize: 
            All vertices have |g[v]| = 2 -> so we push all to Q. (order? say we push 1, then 2, then 3? but the queue has [1,2,3])

          Step1: pop v=1. 
            a = 2 -> remove 2 from g[1] -> now g[1] = {3}; and remove 1 from g[2] -> now g[2] = {3}.
            Then we need to pop another: but now g[1] has only one element? So we cannot form? 

          What went wrong? We popped one element and then the set size becomes one? Then we cannot form a boomerang at v=1.

          But we can form a boomerang at another vertex? For example, at vertex 2: we have g[2] = {1,3} -> we can form one boomerang: say with 1 and 3? then output (1,2,3). Then the edges are (1,2) and (2,3). Then the edge (1,3) remains? but then we cannot form a boomerang with (1,3) because they form a single edge and no common vertex? Actually, the edge (1,3) is incident to 1 and 3. Then at 1: we have one edge (to 3) -> not enough. Similarly at 3: we have one edge (to 1). So we form one boomerang.

          How to avoid the problem at vertex 1? 

          The issue: when we remove the first edge (v,a) from g[v], we also remove v from g[a]. Then the set g[v] becomes of size 1 and we cannot take the second edge? 

          We must remove the two edges simultaneously? But in the set we can take two arbitrary edges? Then we can take two without removing one by one? Actually, we can take two distinct neighbors arbitrarily without removing them until we have both? 

          How about:

            We do:
              a = *g[v].begin();
              b = *next(g[v].begin());   # the second element? but what if the set has only two? then next is the last.

            Then we remove both at the same time:

              g[v].erase(a);
              g[v].erase(b);
              g[a].erase(v);
              g[b].erase(v);

          Then we output (a, v, b).

          This way, we remove both edges at once. Then we don't get stuck in the middle.

          So the corrected step:

            v = pop from Q, and if |g[v]| < 2: skip.

            Then pick two distinct neighbors a and b from g[v] (any two). 

            Then remove both from g[v] and remove v from g[a] and g[b].

          Then update the queue for a, b, and v.

        Now in the triangle:

          We start with v=1: 
            g[1] = {2,3} -> we pick a=2, b=3 (arbitrarily).
            Then remove: 
                g[1] becomes empty.
                g[2] becomes {3} -> remove 1: so becomes {3}? Actually, we remove the edge (1,2) from both ends: so from g[2] we remove 1 -> then g[2]={3}. Similarly, g[3] becomes {2} (by removing 1).

            Then we output (2,1,3) [if we pick a=2 and b=3].

            Then we check: 
                For a=2: |g[2]| = 1 -> not push.
                For b=3: |g[3]| = 1 -> not push.
                For v=1: |g[1]|=0 -> not push.

            Then we have one boomerang. Then the queue becomes: we started with [1,2,3] and we popped 1. Then we check 2 and 3: we don't push them. Then we pop 2: but |g[2]|=1 -> skip. Then pop 3: skip.

            Then we stop: one boomerang, which is correct.

        But what if we start with a different vertex? 

          Suppose we start with vertex 2? 
            g[2] = {1,3}
            remove 1 and 3 from g[2] -> g[2] becomes empty.
            Then remove 2 from g[1] -> g[1] becomes {3}? Actually, we remove the edge (2,1) from g[1] so g[1] = {3}. Similarly, remove 2 from g[3] -> g[3] becomes {1}.
            Output: (1,2,3)

            Then we check: 
                a=1: |g[1]|=1 -> skip.
                b=3: |g[3]|=1 -> skip.
                v=2: skip.

            Then we process the next in the queue? say vertex 1: |g[1]|=1 -> skip. Then vertex 3: skip.

          Same result.

        Now test with the complete graph on 4 vertices (K4):

          Edges: 
            1: [2,3,4]
            2: [1,3,4]
            3: [1,2,4]
            4: [1,2,3]

          We start: all vertices have degree 3 -> push all.

          Process order? Let's do 1 first:
             take two from 1: say 2 and 3 -> remove edges (1,2) and (1,3) from both ends? 
                 Then g[1] becomes {4}
                 g[2] becomes {3,4}   (removed 1)
                 g[3] becomes {2,4}   (removed 1)
                 g[4] remains {1,2,3}? Actually, we haven't touched 4 yet.

             Output: (2,1,3)

             Then we update: 
                 For a=2: |g[2]|=2 -> push 2 (if not in queue? we have to mark: initially we had 2 in the queue? and we haven't popped 2 yet? Actually, we have a queue that initially has all? and we are processing one by one. 

             How do we maintain the queue? 

                We have a queue Q: initially [1,2,3,4] (in some order). We popped 1. Then we mark inQ[1]=False. Then we push 2? but 2 is already in the queue? Then we don't push? Actually, we have a boolean "inQ". Initially, we set inQ[1..4]=True? Then we pop 1 -> set inQ[1]=False. Then we update 2: |g[2]|=2 and inQ[2] is True? (because we haven't popped it) so we don't push again. Similarly for 3: we don't push.

             Then we push 1? no because |g[1]|=1.

          Then we pop the next: say vertex 2:
             g[2] = {3,4} -> take two: say 3 and 4.
                 Remove: 
                    g[2] becomes empty.
                    g[3]: remove 2 -> then g[3] becomes {4} (because we already removed 1 from g[3] earlier? and now remove 2 -> then g[3] = {4})
                    g[4]: remove 2 -> then g[4] = {1,3}
                 Output: (3,2,4)

             Then update: 
                 a=3: |g[3]|=1 -> skip
                 b=4: |g[4]|=2 -> but inQ[4] is True? (we haven't popped 4) -> so we don't push.

          Then we pop 3: 
             |g[3]|=1 -> skip.

          Then pop 4: 
             |g[4]|=2: we take two: say 1 and 3.
                 Remove: 
                    g[4] becomes empty.
                    g[1]: remove 4 -> then g[1] becomes empty.
                    g[3]: remove 4 -> then g[3] becomes empty.
                 Output: (1,4,3)

          Then we have 3 boomerangs? That uses all edges? 

          The boomerangs: 
            (2,1,3): edges (2,1) and (1,3)
            (3,2,4): edges (3,2) and (2,4) -> but wait: the edge (2,3) was already removed? Actually, no: the edge (2,3) was used? 

          How were the edges used?

            Boomerang1: (2,1,3): uses (1,2) and (1,3)
            Boomerang2: (3,2,4): uses (2,3) and (2,4) -> but (2,3) is an edge? But in the graph we have (2,3) as an edge. But note: when we processed vertex1, we removed the edge (1,2) and (1,3). Then when we processed vertex2, we removed (2,3) and (2,4). Then when processing vertex4, we removed (4,1) and (4,3). 

          But the edge (3,4) remains? Actually, we removed (4,3) in the last boomerang? So that's the same edge. 

          Actually, the edges are:

            Edge1: (1,2) -> used in boomerang1
            Edge2: (1,3) -> used in boomerang1
            Edge3: (1,4) -> used in boomerang3: (1,4,3) -> but that uses (1,4) and (4,3)
            Edge4: (2,3) -> used in boomerang2
            Edge5: (2,4) -> used in boomerang2
            Edge6: (3,4) -> used in boomerang3: (1,4,3) uses (4,3) which is the same as (3,4).

          So all edges are covered. 

          However, the sample output for K4 is:

             3
             1 2 3
             1 3 4
             1 4 2

          This is a different set: 
             (1,2,3): uses (1,2) and (2,3) -> but wait, the boomerang is <1,2,3> meaning edges (1,2) and (2,3). 
             (1,3,4): edges (1,3) and (3,4)
             (1,4,2): edges (1,4) and (4,2) -> but (4,2) is (2,4)

          So that uses:
            (1,2), (2,3), (1,3), (3,4), (1,4), (2,4) -> that is all edges? Actually, no: (2,3) is used twice? 

          Let me check: 
            First boomerang: edges (1,2) and (2,3) -> so edge (2,3) is used.
            Second boomerang: edges (1,3) and (3,4) -> then edge (1,3) and (3,4).
            Third boomerang: edges (1,4) and (4,2) -> (1,4) and (2,4).

          Then the edges used are: (1,2), (2,3), (1,3), (3,4), (1,4), (2,4). That is all six.

          So our algorithm produced a different set of boomerangs? But that is acceptable.

        But note: the problem does not require a specific set, only that the number is maximum.

        However, in the sample output for the first sample:

          Input: 
            5 7
            1 2
            1 4
            2 3
            2 4
            2 5
            3 4
            3 5

          They output:
            3
            4 1 2
            4 3 2
            2 5 3

          How would our algorithm work?

          Let me simulate:

          Build graph:

            g[1]: [2,4]
            g[2]: [1,3,4,5]
            g[3]: [2,4,5]
            g[4]: [1,2,3]
            g[5]: [2,3]

          Initialize: push all vertices (all have at least two edges? 
            g[1]:2 -> push
            g[2]:4 -> push
            g[3]:3 -> push
            g[4]:3 -> push
            g[5]:2 -> push

          Order: we can choose arbitrarily? Let's choose vertex 2 first (since it has the highest degree? but we don't require).

          Step1: pop vertex 2: 
             We take two edges: say the first two in the set: 1 and 3? 
                 Then remove: 
                   g[2]: remove 1 and 3 -> becomes {4,5}
                   g[1]: remove 2 -> becomes {4}
                   g[3]: remove 2 -> becomes {4,5}
                 Output: (1,2,3)

          Then update:
             For a=1: |g[1]|=1 -> skip
             For b=3: |g[3]|=2 -> push? but it was already in the queue? so we don't push again? 
             For v=2: |g[2]|=2 -> we push it again? But we just popped it? And we set inQ[2]=False? Then we check: if not inQ[2] -> then push and mark inQ[2]=True. But we just set inQ[2] to False? So we push 2 again.

          Then the queue now: [1,3,4,5,2] (without 2? we popped 2, then we pushed 2 at the end? so the queue becomes [1,3,4,5,2])

          Step2: pop vertex 1? -> but g[1]={4} -> skip.
          Step3: pop vertex 3: 
                 g[3] = {4,5} -> take two: 4 and 5.
                 Remove:
                    g[3]: becomes empty.
                    g[4]: remove 3 -> then g[4] = {1,2}   [because initially: {1,2,3} -> remove 3 -> {1,2}]
                    g[5]: remove 3 -> then g[5] = {2}
                 Output: (4,3,5)

          Then update:
             a=4: |g[4]|=2 -> push? and inQ[4] is True? (because we haven't popped 4 yet? so we don't push? Actually, we popped 1 and 3, but 4 is still in the queue? Then we don't push 4 again.
             b=5: |g[5]|=1 -> skip.
             v=3: skip.

          Step4: pop vertex 4: 
                 g[4] = {1,2} -> take two: 1 and 2.
                 Remove:
                    g[4]: becomes empty.
                    g[1]: remove 4 -> becomes empty.
                    g[2]: remove 4 -> becomes {5}   [because g[2] was {4,5} -> then we removed 4 -> then {5}]
                 Output: (1,4,2)

          Then update:
             a=1: skip.
             b=2: |g[2]|=1 -> skip.
             v=4: skip.

          Step5: pop vertex 5: |g[5]|=1 -> skip.
          Step6: pop vertex 2: |g[2]|=1 -> skip.

          Then we have three boomerangs: 
             (1,2,3), (4,3,5), (1,4,2)

          But the sample output is:
             (4,1,2), (4,3,2), (2,5,3)

          Our output: 
             (1,2,3): edges (1,2) and (2,3)
             (4,3,5): edges (4,3) and (3,5)  -> but wait, the sample output has (2,5,3) which uses (2,5) and (5,3) -> but (5,3) is the same as (3,5). 
             (1,4,2): edges (1,4) and (4,2) -> same as (2,4).

          But the edges used in our solution:
             (1,2), (2,3), (4,3), (3,5), (1,4), (2,4) -> that's 6 edges? but the graph has 7 edges. The edge (2,5) is not used? 

          Actually, we did not use the edge (2,5). How did the sample output use it? 
            (4,1,2): uses (4,1) [same as (1,4)] and (1,2) -> but then (1,2) is used again? 

          Actually, the sample output:

             boomerang1: (4,1,2): edges (4,1) and (1,2) -> that's (1,4) and (1,2)
             boomerang2: (4,3,2): edges (4,3) and (3,2) -> (2,3) and (3,4) -> note: (3,4) is the same as (4,3)
             boomerang3: (2,5,3): edges (2,5) and (5,3) -> (2,5) and (3,5)

          Then the edges used: 
            (1,4), (1,2), (2,3), (3,4), (2,5), (3,5) -> 6 edges? but the graph has 7 edges. The edge (2,4) is not used.

          The sample input has 7 edges: 
            1 2
            1 4
            2 3
            2 4
            2 5
            3 4
            3 5

          So the edge (2,4) is missing. And the sample output uses 6 edges? Then why the sample output says 3 boomerangs? 

          Actually, the problem says: the maximum number of disjoint boomerangs is 3. And 3 boomerangs use 6 edges. The remaining edge (2,4) is not used. 

          But our solution also used 6 edges? So both are valid. 

          However, our solution did not use the edge (2,5) but the sample output did. 

          The problem: we have an edge (2,5) that was not used? How did we miss it? 

          Let me check our simulation:

            Step1: we processed vertex2: we took edges (2,1) and (2,3). Then we removed them. Then the edge (2,5) remains? and (2,4) remains? 

            Then after step1: 
                g[2] = {4,5} -> so we pushed 2 again.

            Then we processed vertex1: skipped.
            Then vertex3: we took (3,4) and (3,5) -> then we removed (3,4) and (3,5). Then the edge (2,5) is still in g[5]? But we also have to remove (3,5) from g[5]: so g[5] becomes {2}. Then we did not use (2,5).

            Then we processed vertex4: we took (4,1) and (4,2) -> then we removed them. Then the edge (2,5) remains? 

          So we did not form a boomerang for (2,5). Why? Because at the end, vertex2 has one edge (to 5) and vertex5 has one edge (to 2). They cannot form a boomerang.

          But the sample output used the edge (2,5) in the boomerang (2,5,3). How? 

          In the sample output, the boomerang (2,5,3) uses the edges (2,5) and (5,3). But we already used (5,3) in the boomerang (4,3,5) at step3? 

          Actually, in our simulation we used (3,5) in the boomerang at step3: (4,3,5). So we cannot use it again. 

          The sample output does not use (3,5) twice? They use (3,5) only in (2,5,3)? and (4,3,2) uses (3,2) and (3,4). 

          So the edge (3,5) is only used once.

          How did our simulation use (3,5)? We used it in (4,3,5). Why did we use it? Because we processed vertex3 and took edges (3,4) and (3,5). 

          But the sample output uses (3,4) in the boomerang (4,3,2) and (3,5) in (2,5,3). 

          The issue: the order of processing. 

          The sample output does not form a boomerang at vertex3? 

          How can we get the sample output? 

          We start with vertex4? 

            Step1: pop vertex4: 
                 g[4] = {1,2,3} -> take two: say 1 and 2 -> output (1,4,2)
                 Then remove: 
                    g[4] becomes {3}
                    g[1]: remove 4 -> becomes {2} -> then |g[1]|=1 -> skip.
                    g[2]: remove 4 -> becomes {1,3,5} -> but then we update g[2]: now it's {1,3,5} -> so we push 2? (if it's not in the queue? it is in the queue, so we don't push again? but we haven't popped it yet? we have to push if we update? Actually, we don't push because it's already in the queue? 

            Then we push 4? no because |g[4]|=1.

            Then we pop vertex1: skip.
            Then pop vertex2: 
                 g[2] = {1,3,5} -> take two: say 1 and 3 -> output (1,2,3)
                 Then remove: 
                    g[2] becomes {5}
                    g[1]: remove 2 -> becomes empty -> skip.
                    g[3]: remove 2 -> becomes {4,5} -> then we push 3? but 3 is still in the queue? we haven't popped it? so we don't push.

            Then we push 2? no because |g[2]|=1.

            Then pop vertex3: 
                 g[3] = {4,5} -> take two: 4 and 5 -> output (4,3,5)
                 Then remove:
                    g[3] becomes empty.
                    g[4]: remove 3 -> becomes empty -> skip.
                    g[5]: remove 3 -> becomes {2} -> skip.

            Then we have three boomerangs: 
                 (1,4,2), (1,2,3), (4,3,5)

            But the sample output is: 
                 (4,1,2) -> which is the same as (1,4,2) if we output (1,4,2) as (4,1,2)? Actually, the problem: the boomerang <4,1,2> means edges (4,1) and (1,2). 
                 In our output (1,4,2): that means edges (1,4) and (4,2) -> that is a different set of edges: we used (1,4) and (4,2) but the sample output used (4,1) [same as (1,4)] and (1,2). 

            So we did not use (1,2) in the first boomerang? we used (4,2) in the first boomerang and (1,2) in the second? 

            But the sample output uses (1,2) in the first boomerang and (4,2) is not used? 

          Actually, the sample output does use (4,2) in the second boomerang: (4,3,2) uses (4,3) and (3,2) -> and then (2,4) is not used? 

          The sample output uses: 
            boomerang1: (4,1,2) -> edges (4,1) and (1,2)
            boomerang2: (4,3,2) -> edges (4,3) and (3,2) -> note: (3,2) is the same as (2,3)
            boomerang3: (2,5,3) -> edges (2,5) and (5,3) -> (5,3) is (3,5)

          The edges used: 
            (1,4), (1,2), (3,4), (2,3), (2,5), (3,5) -> and the edge (2,4) is not used.

          But in our simulation we used: 
            boomerang1: (1,4,2) -> edges (1,4) and (4,2) -> (1,4) and (2,4)
            boomerang2: (1,2,3) -> edges (1,2) and (2,3)
            boomerang3: (4,3,5) -> edges (4,3) and (3,5)

          Then we used: (1,4), (2,4), (1,2), (2,3), (4,3), (3,5) -> that is 6 edges: (2,5) is not used.

          So we have a different set.

          But the problem allows any valid set.

          However, we must ensure that we use the maximum number, which is 3.

        But note: the problem says the maximum number of disjoint boomerangs is 3. Our algorithm produced 3. 

        However, the sample output also has 3. 

        The problem: the sample input has 7 edges, so maximum boomerangs is floor(7/2)=3. 

        Therefore, the greedy algorithm is correct.

        Implementation:

          We use:
            n, m = input
            g = [set() for _ in range(n+1)]
            for i in range(m):
                u, v = input
                g[u].add(v)
                g[v].add(u)

          from collections import deque
          q = deque()
          inQ = [False] * (n+1)
          # Initialize: for v from 1 to n, if len(g[v])>=2: 
          for i in range(1, n+1):
              if len(g[i])>=2:
                  q.append(i)
                  inQ[i] = True

          boomerangs = []

          while q:
              v = q.popleft()
              inQ[v] = False
              if len(g[v]) < 2:
                  continue

              # Take two distinct neighbors
              # We take two: we can use:
              a = g[v].pop()   # remove a from g[v] and then we remove v from g[a]
              b = g[v].pop()   # remove b from g[v] and then remove v from g[b]

              # Remove the edges: 
              g[a].discard(v)   # discard is safe (if not present, does nothing) but it should be present.
              g[b].discard(v)

              # Form the boomerang: we output (a, v, b) meaning edges (a,v) and (v,b)
              boomerangs.append((a, v, b))

              # Now update a: 
              if len(g[a])>=2 and not inQ[a]:
                  q.append(a)
                  inQ[a] = True

              if len(g[b])>=2 and not inQ[b]:
                  q.append(b)
                  inQ[b] = True

              # Also, v might still have at least two edges? Then we push v again?
              if len(g[v])>=2 and not inQ[v]:
                  q.append(v)
                  inQ[v] = True

          Then we output:
              print(len(boomerangs))
              for (a,v,b) in boomerangs:
                  print(a, v, b)

        But note: the problem requires that the edges are given with u<v? but the boomerang does not require that? 

        However, the edges (a,v) and (v,b) are present. The output: we output (a,v,b) and the problem does not require a specific order for a and b? 

        But note: the problem's input has edges with u<v? but the output for the boomerang: the middle vertex is the center. The two endpoints can be in any order? 

        The sample outputs: 
          Sample1: 
              4 1 2   -> here 4 and 1: 4>1? but the problem does not require the endpoints to be in increasing order.

        However, the problem says: output three integers: u v w. There is no constraint on the ordering of u and w.

        Therefore, we output as (a, v, b) with a and b being the two neighbors.

        But note: we popped a and b arbitrarily? 

        We must be cautious: when we pop from a set, the order is arbitrary? In Python, set.pop() is arbitrary? But that is acceptable.

        However, the problem does not care about the order of the boomerangs or the order of the two endpoints.

        But note: the boomerang is defined as <u, v, w> meaning the edges (u,v) and (v,w). So we must have the center as the second one.

        Our output: (a, v, b) -> then the center is v, which is correct.

        This algorithm runs in O(M log n) because each edge is removed once and each removal is O(log n) in a set.

        But note: we are using sets, and the total number of removals is 2*M (each edge is removed from two sets). So total O(M log n) which is acceptable for M=100000.

        Let me test with the sample input #3: triangle.

          n=3, m=3
          Edges: 
            1: {2,3}
            2: {1,3}
            3: {1,2}

          Initialize: all have size 2 -> push 1,2,3 to q.

          Step1: pop v=1 -> 
            a = g[1].pop() -> could be 2 or 3. Suppose 2.
            b = g[1].pop() -> then 3.
            Then remove: 
                g[2]: remove 1 -> becomes {3} -> then we check: |g[2]|=1 -> skip
                g[3]: remove 1 -> becomes {2} -> skip
            Then boomerang: (2,1,3)
            Then push 1? |g[1]|=0 -> skip.

          Then we pop 2: |g[2]|=1 -> skip.
          Then pop 3: |g[3]|=1 -> skip.

          Output: 1 boomerang: (2,1,3) -> which is acceptable.

        Another run: if we pop v=1 and we get a=3, then b=2: then output (3,1,2) -> also acceptable.

        Therefore, we have a solution.

        However, note: the problem says the edges are given with u<v. But our graph is undirected: so we store both ways.

        One more sample: Sample Input #2: K4.

          We hope to get 3 boomerangs? 

          But the order of popping matters? 

          Let me simulate:

            g[1]: {2,3,4}
            g[2]: {1,3,4}
            g[3]: {1,2,4}
            g[4]: {1,2,3}

            q = [1,2,3,4] (all)

            Step1: pop v=1 -> 
                a = g[1].pop() -> say 2
                b = g[1].pop() -> say 3
                Then boomerang: (2,1,3)
                Then remove: 
                  g[1] becomes {4}
                  g[2]: remove 1 -> becomes {3,4}
                  g[3]: remove 1 -> becomes {2,4}

                Then we update: 
                  For a=2: |g[2]|=2 -> and not inQ[2]? we just popped? Actually, we set inQ[1]=False, but 2 is still in the queue? Then we don't push 2.
                  For b=3: similarly, 3 is in the queue -> skip.
                  For v=1: |g[1]|=1 -> skip.

            Step2: pop v=2 -> 
                a = g[2].pop() -> say 3
                b = g[2].pop() -> say 4
                Then boomerang: (3,2,4)
                Then remove:
                  g[2] becomes empty
                  g[3]: remove 2 -> becomes {4} -> then |g[3]|=1 -> skip
                  g[4]: remove 2 -> becomes {1,3} -> then |g[4]|=2 -> and inQ[4] is True? (it is in the queue) -> skip.

            Step3: pop v=3: |g[3]|=1 -> skip.
            Step4: pop v=4:
                a = g[4].pop() -> say 1
                b = g[4].pop() -> say 3
                Then boomerang: (1,4,3)
                Then remove:
                  g[4] becomes empty
                  g[1]: remove 4 -> becomes empty -> skip
                  g[3]: remove 4 -> becomes empty -> skip

            Then we have three boomerangs: 
                (2,1,3), (3,2,4), (1,4,3)

            This is valid.

        Therefore, we code accordingly.

        Edge Cases:

          M=0: then we output 0.

          M=1: then we cannot form any boomerang -> output 0.

          M=2: then we can form one boomerang only if the two edges share a common vertex? 
                Example: two edges (1,2) and (1,3): then we can form (2,1,3). 
                But if the two edges are (1,2) and (3,4): then we cannot.

          So we must design: 
                If the two edges share a common vertex, then the greedy will form one boomerang. Otherwise, not.

          How? 
            We build the graph: 
                g[1] = {2} -> degree=1 -> not pushed? 
                g[2] = {1} -> degree=1
                g[3] = {4} -> degree=1
                g[4] = {3} -> degree=1
            Then the queue is empty -> output 0.

          Correct.

        Therefore, we are done.

        Code (in C++ for speed? but the problem allows any language? but we are writing an editorial without code). 

        However, we write the editorial as:

          We use a greedy algorithm that repeatedly picks a vertex with at least two available edges, forms a boomerang by taking two of its edges, and then removes those edges. We maintain the graph using sets (or similar data structures) for adjacency lists to allow efficient removal. We use a queue to process vertices that have at least two available edges. The algorithm runs in O(M log N) time.

        Why is the number of boomerangs maximum? 
          Because when the algorithm stops, the remaining graph has no vertex of degree>=2, meaning that we cannot form any more boomerangs. Therefore, we have used the maximum possible.

        We then output the list of boomerangs we formed.

        Let me run the first sample as in the problem:

          Input: 
            5 7
            1 2
            1 4
            2 3
            2 4
            2 5
            3 4
            3 5

          We want to get the sample output? But we don't require that. However, we can try to simulate to get the sample output? 

          The sample output: 
            3
            4 1 2
            4 3 2
            2 5 3

          How to get the sample output?

          We need:
            (4,1,2): formed at center 1? -> so we need to form at vertex1: take edges (1,4) and (1,2).
            (4,3,2): formed at center 3? -> so we need to form at vertex3: take edges (3,4) and (3,2) -> but wait, (3,2) is the same as (2,3). 
            (2,5,3): formed at center 5? no, the center is the middle: the center for the last is 2? -> then we would take edges (2,5) and (2,3). But the edge (2,3) was already used in the second boomerang? 

          Actually, the sample output: 
            (4,1,2): center 1: edges (1,4) and (1,2)
            (4,3,2): center 3: edges (3,4) and (3,2) -> (3,2) is (2,3)
            (2,5,3): center 5? no: the output is "2 5 3", meaning center is 5? -> no, the output is "2 5 3" meaning the boomerang is <2,5,3> so the edges are (2,5) and (5,3). 

          So the centers are 1, 3, and 5.

          How do we form at center 5? 

          We start: 
            g[1] = {2,4}
            g[2] = {1,3,4,5}
            g[3] = {2,4,5}
            g[4] = {1,2,3}
            g[5] = {2,3}

          Push all.

          We want to form a boomerang at center 5 first? 
            Pop vertex5: 
                a = 2, b=3 -> output (2,5,3) -> then remove:
                    g[5] becomes empty.
                    g[2]: remove 5 -> becomes {1,3,4}
                    g[3]: remove 5 -> becomes {2,4}
            Then update: 
                a=2: |g[2]|=3 -> but it was in the queue? so we don't push.
                b=3: |g[3]|=2 -> but it was in the queue? so we don't push.
                v=5: skip.

          Then we pop vertex1: 
                a=2, b=4 -> output (2,1,4)   [but the sample output for the first boomerang is (4,1,2) -> which is the same as (2,1,4) if we output (a,v,b) as (2,1,4) but the sample output is (4,1,2). 

          How can we output (4,1,2)? 
            We output (a=4, v=1, b=2) -> but we popped 2 first? 

          How about: we change the order? Instead of popping arbitrarily, we can try to choose a specific neighbor? 

          But the problem does not require a specific output. 

          Alternatively, we can output (a, v, b) as (a, v, b) and then the sample output has (4,1,2). That would be if we pop from g[1] and we get a=4 and then b=2? 

          How? We can change the order of the set? 

          In the set for g[1]: we can store in sorted order? But the problem does not require. 

          However, if we use a set that is sorted, then we pop the smallest? 

          But in our algorithm, we used set in Python: which pops arbitrarily? In C++, std::set gives the smallest? 

          Actually, if we use a set that returns the smallest, then for vertex1: 
            g[1] = {2,4} -> if we pop the smallest: 2 then 4? then we output (2,1,4). 

          But we want (4,1,2)? Then we would have to pop 4 first? 

          How about: we pop the largest? 

          Actually, we can output the boomerang as (a, v, b) or (b, v, a)? The problem does not specify the order of the two endpoints. 

          But the sample output: 
            (4,1,2) -> meaning the edges (4,1) and (1,2). 

          In our boomerang: we have edges (a,v) and (v,b) -> so if we output (a,v,b) then the edges are (a,v) and (v,b). 

          But the sample output (4,1,2) has edges (4,1) and (1,2) -> so that matches: a=4, v=1, b=2.

          Therefore, if we pop 4 first from g[1], then a=4 and then we pop 2 -> b=2. Then we output (4,1,2).

          How to pop 4 first? We can use a set that returns the largest? Or we can use a priority queue? 

          But the problem does not require a specific order. 

          However, the sample output uses (4,1,2) and (4,3,2). 

          To get the second boomerang at center 3: 
            After removing edges (1,4), (1,2) [by the first boomerang] and (5,2), (5,3) [by the third boomerang? we did the third first]? 

          Actually, we did center5 first. Then we did center1? 

          Then we have: 
            g[3] = {2,4} -> we want to form at center3: we take 4 and then 2? then output (4,3,2). 

          So we can do: 
            For vertex3: pop 4 first? 

          How to ensure that? We can use a set that stores the neighbors in decreasing order? 

          Alternatively, we can use a set that is a min-heap or max-heap? But we want arbitrary? 

          Actually, the problem does not require the same output, so we can output any.

        Therefore, we don't worry.

        Conclusion:

          Algorithm:

            Read n, m.
            Initialize an array of sets g of size n+1.
            For each edge (u, v):
                g[u].add(v)
                g[v].add(u)

            inQ = [False]*(n+1)
            queue = deque()
            For v in 1..n:
                if size(g[v])>=2:
                    queue.append(v)
                    inQ[v] = True

            boomerangs = []
            while queue:
                v = queue.popleft()
                inQ[v] = False
                if |g[v]| < 2: continue
                a = g[v].pop()   # remove one neighbor
                b = g[v].pop()   # remove another neighbor

                # Remove the edges from the other ends:
                g[a].remove(v)
                g[b].remove(v)

                boomerangs.append( (a, v, b) )

                # Check and push a, b, and v if they have at least two edges and are not in the queue.
                for u in [a, b, v]:
                    if u==v: 
                        # we check v
                        if len(g[v])>=2 and not inQ[v]:
                            queue.append(v)
                            inQ[v]=True
                    else:
                        if len(g[u])>=2 and not inQ[u]:
                            queue.append(u)
                            inQ[u]=True

            Then output the number of boomerangs and the list.

        But note: we don't need to push v in the same loop? We can do:

            for u in {a, b}:
                if len(g[u])>=2 and not inQ[u]:
                    queue.append(u)
                    inQ[u]=True

            if len(g[v])>=2 and not inQ[v]:
                queue.append(v)
                inQ[v]=True

        This is the same.

        We'll run this.

        However, note: we removed two edges from v, so we update v at the end.

        Let me test the triangle with this:

          v=1: 
            a=2, b=3.
            Then update: 
                a=2: g[2] becomes {3} -> not push.
                b=3: g[3] becomes {2} -> not push.
                v=1: g[1] becomes {} -> not push.

        Correct.

        We are done.

        Time complexity: O(M log N) per edge removal? And each edge is removed once. Total O(M log N) which is acceptable for M=100000.

        Memory: we store the graph: O(M) and the queue: O(N). So total O(M+N) which is within 256MB.

        Therefore, we have a solution.

        Note: the problem constraints: N, M up to 100000.

        Let me write the editorial accordingly.

        Editorial:

          Problem Interpretation:
            We are given an undirected graph with N vertices and M edges. We want to find the maximum number of edge-disjoint boomerangs. A boomerang is defined as a triple (u, v, w) such that the edges (u,v) and (v,w) exist and u != w. Two boomerangs are disjoint if they do not share any edge.

          Key Insight:
            Each boomerang uses two distinct edges incident to a common vertex (the center v). Therefore, the problem reduces to packing as many edge-disjoint two-edge stars (centered at any vertex) as possible. Since each boomerang uses two edges, the maximum number of boomerangs is at most floor(M/2). Moreover, we can always achieve a packing such that the only edges left form a matching (each vertex has degree at most 1). This greedy packing is optimal.

          Algorithm:
            We use a greedy algorithm that repeatedly selects a vertex with at least two available edges, forms a boomerang by taking two of its edges, and removes these edges from the graph. We maintain the graph using sets for adjacency lists to allow efficient edge removal. We also maintain a queue of vertices that currently have at least two available edges.

          Steps in detail:
            1. Read the input and build the graph: for each vertex, store its neighbors in a set.
            2. Initialize a queue (e.g., a FIFO queue) and a boolean array "inQ" to track which vertices are in the queue. Enqueue every vertex that has at least two edges initially.
            3. While the queue is not empty:
                 a. Dequeue a vertex v.
                 b. If the current degree of v (number of available edges) is less than 2, skip.
                 c. Otherwise, remove two distinct edges incident to v: (v, a) and (v, b). 
                    - Remove a from the adjacency set of v and remove v from the adjacency set of a.
                    - Similarly, remove b from the adjacency set of v and remove v from the adjacency set of b.
                 d. Record the boomerang (a, v, b) [which uses edges (a,v) and (v,b)].
                 e. After removing these edges, the degrees of a, b, and v decrease. Check for each of these vertices (a, b, and v) if its current degree is at least 2 and it is not already in the queue. If so, enqueue it.
            4. Output the number of boomerangs and then each boomerang (a, v, b).

          Why is it optimal?
            The algorithm terminates when no vertex has two or more available edges. At this point, the remaining graph is a matching (each vertex has at most one incident edge), so no boomerang can be formed. Therefore, we have used the maximum possible number of boomerangs.

          Time Complexity:
            Each edge is removed once from two sets. The removal from a set takes O(log(degree)) time, which is O(log N) per operation. The total number of edge removals is O(M), so the overall complexity is O(M log N). The queue operations are O(1) per enqueue and dequeue, and each vertex is enqueued at most O(degree) times, but the total number of operations is O(M). Thus, the algorithm is efficient for the constraints.

          Space Complexity:
            We store the graph in adjacency sets, which uses O(M) space. The queue and other arrays use O(N) space. Therefore, the total space is O(M+N).

          Sample Runs:
            We verified the algorithm on the provided examples.

          Implementation Note:
            The order in which we pop the edges (the two neighbors) is arbitrary and does not affect the correctness. The output boomerang (a, v, b) is valid as long as the edges (a,v) and (v,b) exist and are distinct.

        This concludes the editorial.

        Let's hope it passes.

        Note: the problem has a time limit of 0.5s and memory of 256MB. The algorithm uses O(M log N) time and O(M) memory, which should be acceptable for M=100000.

        However, in C++ we can use std::set or std::unordered_set? 

          - std::set: O(log n) per removal.
          - std::unordered_set: O(1) average but worst-case O(n). But we don't need ordered, so unordered_set is better. But then how to pop two elements? We cannot pop an arbitrary element? 

          Actually, we can: in C++ unordered_set, we can use begin() to get an iterator and then erase that iterator. But the order is arbitrary.

          Alternatively, we can use a vector and mark edges? But removal would be O(deg). 

          We can use linked lists? 

          But the problem: we need to remove edges from two sets. 

          In C++, we can use:

            unordered_set<int> g[MAXN];
            Then for removal: 
                int a = *g[v].begin();
                g[v].erase(g[v].begin());
                g[a].erase(v);

          Similarly for b.

          This is O(1) average for unordered_set.

          But worst-case the graph might be a complete graph? Then the set might be large? But the average for unordered_set is O(1). 

          However, worst-case for unordered_set might be O(n) per operation? Then worst-case total O(n^2). 

          Alternatively, we can use a linked list for each vertex? 

          But in practice, unordered_set is faster for random graphs.

          Or we can use a vector and lazy deletion? 

            We can maintain for each vertex a vector of neighbors, and a degree count. Then when we remove an edge, we decrement the degree. But when we pick two neighbors, we have to skip the ones that are already removed? 

          We can do:

            For each vertex, we maintain:
                deg: the current degree (number of available edges)
                a vector (or list) of neighbors? but then we have to skip the removed ones.

          Then the removal: we mark the edge as removed? But then when we pick two neighbors, we might have to skip many removed ones.

          Alternatively, we can use a stack for each vertex: 
            When we remove an edge (v,a), we remove a from the stack? 

          Actually, we can use a stack and simply pop until we get a valid one? 

          Algorithm per vertex v:

            while (stack for v is not empty and the edge (v, stack_top) is already removed? no, we remove when we pop.

          How about:

            For each vertex, we maintain a stack (or a vector that we use as a stack) of the current available neighbors.

            Then for step for v:
                while (stack_v not empty and the top element is not connected? but we don't know) -> we cannot check without storing the state.

          Instead, we can do:

            We maintain an array "deg" for the current degree, and for each vertex, we have a vector of neighbors. But when we remove an edge, we don't remove from the vector, we just decrement the deg. Then when we pick two neighbors, we might pick an edge that is already removed.

          We need a better way.

          We can use linked lists: for each vertex, a linked list of the current available edges. And we also store for each edge an iterator to its position in the other vertex's list? That is heavy.

          Alternatively, we can use the set (or unordered_set) as described.

          Since M=100000, and the average degree is low (about 2M/N), the set operations might be acceptable.

          In C++, unordered_set has average O(1) and worst-case O(n) but in practice it is fast.

          We'll use unordered_set.

          Steps in C++:

            #include <bits/stdc++.h>
            using namespace std;
            const int N = 100010;
            unordered_set<int> g[N];
            bool inQ[N];
            vector<tuple<int,int,int>> boomerangs;

            int main() {
                int n, m;
                cin >> n >> m;
                for (int i=0; i<m; i++) {
                    int u, v;
                    cin >> u >> v;
                    g[u].insert(v);
                    g[v].insert(u);
                }
                queue<int> q;
                for (int i=1; i<=n; i++) {
                    if (g[i].size()>=2) {
                        q.push(i);
                        inQ[i] = true;
                    }
                }
                while (!q.empty()) {
                    int v = q.front(); q.pop();
                    inQ[v] = false;
                    if (g[v].size() < 2) continue;
                    // Take two distinct neighbors
                    int a = *g[v].begin();
                    g[v].erase(a);
                    g[a].erase(v);

                    int b = *g[v].begin();
                    g[v].erase(b);
                    g[b].erase(v);

                    boomerangs.push_back({a, v, b});

                    // Update a, b, and v
                    vector<int> candidates = {a, b, v};
                    for (int u : candidates) {
                        if (g[u].size() >= 2 && !inQ[u]) {
                            inQ[u] = true;
                            q.push(u);
                        }
                    }
                }
                cout << boomerangs.size() << endl;
                for (auto [a, v, b] : boomerangs) {
                    cout << a << " " << v << " " << b << endl;
                }
            }

          However, note: we update v? But we just removed two edges from v. So we check if v still has at least two edges? Then we push it.

          But note: we updated a and b: we removed one edge from each.

          This should be acceptable.

        But wait: when we remove the edge (v,a) and (v,b), we update g[a] and g[b]. Then we check a, b, and v.

        One more issue: after we remove the edge (v,a), the vertex a is updated: we remove v from g[a]. Then we do the same for b. Then we form the boomerang. Then we check.

        This is the same as the Python pseudocode.

        We hope it works.

        However, note: the sample output for the first sample had a different order? We can adjust the order by changing the output: but we output (a, v, b) with a and b being the two neighbors we popped in that order.

        We are done.

        But note: the problem says the graph has no multiple edges and the edges are given with u<v.

        We assume that.

        Let's run the provided sample inputs.

        Sample Input #3: 
          3 3
          1 2
          1 3
          2 3

          We output one of: (2,1,3) or (3,1,2). The sample output is "2 1 3", which is (2,1,3). 

          But our output: 
            We start: 
                g[1] = {2,3}; g[2]={1,3}; g[3]={1,2}
                q: [1,2,3] (all)
                We pop 1: 
                    a = 2 -> remove: g[1] becomes {3}; g[2] becomes {3} (removed 1)
                    then b = 3 -> remove: g[1] becomes {}; g[3] becomes {2} (removed 1)
                Then boomerang: (2,1,3)

          So we output: 
              1
              2 1 3

          which matches sample output #3.

        Sample Input #2: 
          4 6
          1 2
          1 3
          1 4
          2 3
          2 4
          3 4

          We output 3 boomerangs. The sample output is:
            3
            1 2 3
            1 3 4
            1 4 2

          How can we get the sample output?

          The sample output uses center 2, then center 3, then center 4? 

          Actually, the boomerangs:
            (1,2,3): center 2 -> edges (1,2) and (2,3)
            (1,3,4): center 3 -> edges (1,3) and (3,4)
            (1,4,2): center 4 -> edges (1,4) and (4,2) -> but (4,2) is (2,4), and we have an edge (2,4) but we already used (2,3) and (3,4) and (1,2) and (1,3) and (1,4) and (2,4) -> that is all.

          But wait, the edge (2,4) is used in the last boomerang? But the edge (2,4) is also incident to 2, which was used in the first boomerang? 

          Actually, the edge (2,4) is not used in the first boomerang? The first boomerang used (1,2) and (2,3). 

          So the last boomerang uses (1,4) and (4,2) -> which is (2,4).

          How do we form the boomerangs in the order of the sample output? 

          We start: 
            g[1] = {2,3,4}
            g[2] = {1,3,4}
            g[3] = {1,2,4}
            g[4] = {1,2,3}

          We can choose the order of the queue arbitrarily? 

          Step1: pop vertex1 -> 
             a = 2, b = 3 -> output (2,1,3) -> then remove:
                 g[1] = {4}
                 g[2] = {3,4} -> remove 1 -> becomes {3,4}
                 g[3] = {2,4}  -> remove 1 -> becomes {2,4}
             Then push: 
                 a=2: |g[2]|=2 -> push (if not in queue? it is in the queue? we popped 1, but 2 is still in the queue? so we don't push.
                 b=3: same.
                 v=1: |g[1]|=1 -> skip.

          Then we pop vertex2: 
                 a=3, b=4 -> output (3,2,4) -> then remove:
                     g[2] becomes {}
                     g[3]: remove 2 -> becomes {4}
                     g[4]: remove 2 -> becomes {1,3}
                 Then push:
                     a=3: |g[3]|=1 -> skip
                     b=4: |g[4]|=2 -> and not in queue? we have to check: we haven't popped 4, so inQ[4] is true? Then we don't push.

          Then we pop vertex3: skip (size=1)
          Then pop vertex4: 
                 a=1, b=3 -> output (1,4,3) -> which is the same as the sample's third boomerang? but the sample's third is (1,4,2) -> which we did not get.

          We got:
            (2,1,3)  -> (1,2,3) if we reordered the endpoints? but we output (2,1,3) meaning edges (2,1) and (1,3) -> that is not the same as the sample output's first boomerang (1,2,3) which uses edges (1,2) and (2,3).

          How to get (1,2,3) at center2? 
            We must form the boomerang at center2: 
               For center2: we take edges (1,2) and (2,3) -> then output (1,2,3).

          How? 
            We start: 
               g[2] has {1,3,4}. We pop 1 first? then we pop 3? then output (1,2,3).

          Then the output is (1,2,3). 

          Then remove:
               g[2] becomes {4}
               g[1]: remove 2 -> becomes {3,4}
               g[3]: remove 2 -> becomes {1,4}

          Then push: 
               a=1: |g[1]|=2 -> push (if not in queue? it was in the queue? so we mark that we are going to push? Actually, we popped vertex? we started by popping vertex2? Then we push 1: but we set inQ[1] to false? when we popped? no, we haven't popped 1 yet? we only popped 2. 

          How we manage the queue? 

            We have a queue: initially [1,2,3,4] (if we push in increasing order). 
            We pop 2: then we push 1? but 1 is already in the queue? and we haven't popped 1? Then we don't push.

          Then we pop 1: 
               g[1] = {3,4} -> we take two: 3 and 4 -> output (3,1,4) -> which is the sample output's second boomerang: (1,3,4) if we output as (3,1,4) but the sample output is (1,3,4) meaning center3? 

          Actually, we output (3,1,4) meaning edges (3,1) and (1,4). The sample output's second boomerang is (1,3,4) which is center3: edges (1,3) and (3,4). 

          We did not form that.

          Alternatively, we form the second boomerang at center3: 
            After the first boomerang (1,2,3): 
               g[3] = {1,4} -> so we can form at center3: take 1 and 4 -> output (1,3,4).

          Then we remove:
               g[3] becomes {}
               g[1]: remove 3 -> becomes {4}
               g[4]: remove 3 -> becomes {2}   (because we had g[4] initially {1,2,3} -> then we removed 2? no, we only removed 2 from g[2] and then from g[4]? 

          Actually, after the first boomerang: 
               g[4] = {1,2} -> because we removed nothing from g[4]? 
          Then after the second boomerang: 
               g[1]: {4} -> remove 3 -> becomes {4} (still)
               g[4]: remove 3 -> becomes {1,2} without 3? -> so {1,2}

          Then we output (1,3,4). Then the third boomerang: 
            We have edge (1,4) and (2,4) and (1,2) is not present? 
            Then we can form at center4: 
                g[4] = {1,2} -> take 1 and 2 -> output (1,4,2) -> which is the sample output's third.

          So we want the first boomerang to be formed at center2: (1,2,3) -> output (1,2,3) meaning (1,2) and (2,3). 
          Then the second at center3: (1,3,4) -> output (1,3,4) meaning (1,3) and (3,4).
          Then the third at center4: (1,4,2) -> output (1,4,2) meaning (1,4) and (4,2).

          How to do that in our queue? 

            We start: 
                q: [1,2,3,4] (in order 1,2,3,4)

            Step1: pop 1 -> skip? no, we don't want to form at center1 first. We want to form at center2.

            How? We can change the queue to a priority queue that prioritizes by the vertex index? Or we can use a stack? 

            The algorithm does not specify the order of popping. We can use any order. 

            To get the sample output, we must form the first boomerang at center2. So we want to pop vertex2 first.

            How? We can sort the queue by vertex index? Or by degree? 

            But the problem: we are free to choose any valid set.

          Therefore, we output (1,2,3), (1,3,4), (1,4,2) as in the sample? 

          Actually, we can form:

            (1,2,3): center2 -> edges (1,2) and (2,3)
            (1,3,4): center3 -> edges (1,3) and (3,4) -> but the edge (1,3) is incident to 1 and 3: but at vertex3 we have edges (3,1) and (3,4) -> valid.
            (1,4,2): center4 -> edges (1,4) and (4,2) -> but the edge (1,4) is incident to 1 and 4, and (4,2) is incident to 4 and 2.

          But wait: the edge (1,2) is used in the first boomerang? 
            Then the second boomerang: (1,3,4) uses (1,3) and (3,4) -> valid.
            Then the third: (1,4,2) requires (1,4) and (4,2). 
          The edge (1,4) is present? yes. The edge (4,2) is present? But the first boomerang did not use (4,2). 

          However, after the first boomerang, we removed (1,2) and (2,3). The edge (4,2) is still there.

          But then the third boomerang: (1,4,2) uses (1,4) and (4,2). 

          But the edge (1,4) is also incident to 1: and we have used (1,2) and (1,3) already? But we haven't: we used (1,2) in the first boomerang, but not (1,3) or (1,4) at that time. Then in the second boomerang we used (1,3). Then the edge (1,4) remains. 

          So it is valid.

          How to form in the algorithm? 

            We start: 
                g[1] = {2,3,4}
                g[2] = {1,3,4}
                g[3] = {1,2,4}
                g[4] = {1,2,3}

            We want to pop vertex2 first: so we arrange the queue to have vertex2 first? 

            We can do: in the initial queue, we push vertices in decreasing order? so that 2 is popped after 4,3? 

            Or we can use a stack? 

          Since the problem does not specify the order, we can use a queue that is a FIFO: and we push in increasing order, then we pop the smallest? 

          But we pushed: for i=1..n: so we push 1, then 2, then 3, then 4. Then the queue is [1,2,3,4]. Then we pop 1 first.

          To pop 2 first, we can push in a different order? 

          Alternatively, we can use a priority queue that prioritizes by the vertex index? 

          But the sample output uses center1 for all? 

          Actually, the sample output for sample input #2: 
                3
                1 2 3
                1 3 4
                1 4 2

          This means they are centered at 2, 3, and 4? but the output has the center as the second vertex? 

          The boomerangs: 
                <1,2,3> -> center is 2.
                <1,3,4> -> center is 3.
                <1,4,2> -> center is 4.

          So they are not centered at 1.

          How did they get the output? They must have formed the first boomerang at center2, then at center3, then at center4.

          Therefore, we can use a queue that is a FIFO, but we start by pushing the vertices in the order: 2, then 1, then 3, then 4? 

          Or we can push in decreasing order of degree? 

          But the initial degrees: 
                deg[1]=3, deg[2]=3, deg[3]=3, deg[4]=3.

          We can push in any order.

          We can change the initial loop:

            // Push vertices 2,3,4,1? 
            for (int i = n; i>=1; i--) {
                if (g[i].size()>=2) {
                    q.push(i);
                    inQ[i]=true;
                }
            }

          Then the queue: [4,3,2,1]? and we pop 4 first? 

          But we want vertex2 first.

          Or we can use a stack: then we pop in the reverse order of insertion.

          We'll do: 

            stack: push 1,2,3,4 -> then pop 4,3,2,1.

          So we want to push in the order: 1,2,3,4? then pop 4 first? 

          But we want vertex2.

          Alternatively, we can use a priority queue by vertex index? and we set to pop the smallest? then we pop 1 first.

          How about we use a queue that is a min-heap by vertex index? Then we pop the smallest? 

          But the sample output uses center2, which is vertex2? 

          How to pop vertex2? 

          We can use a queue that is a min-heap by the degree? 

          Actually, we can use a queue that prioritizes vertices by a certain criterion. But the problem doesn't require a specific solution.

          Since we are free to output any, we don't worry.

        Therefore, we can output the solution as described.

        We'll write the code in C++ for efficiency.

        Note: we must be cautious: the graph has up to 100000 vertices, so we use 0-indexed or 1-indexed? The input: vertices from 1 to N.

        We use 1-indexed.

        Code:

          #include <iostream>
          #include <vector>
          #include <queue>
          #include <unordered_set>
          #include <tuple>
          using namespace std;

          const int N = 100010;
          unordered_set<int> g[N];
          bool inQ[N];

          int main() {
              ios::sync_with_stdio(false);
              cin.tie(0);

              int n, m;
              cin >> n >> m;
              for (int i = 0; i < m; i++) {
                  int u, v;
                  cin >> u >> v;
                  g[u].insert(v);
                  g[v].insert(u);
              }

              queue<int> q;
              vector<tuple<int,int,int>> ans;

              for (int i = 1; i <= n; i++) {
                  if (g[i].size() >= 2) {
                      q.push(i);
                      inQ[i] = true;
                  }
              }

              while (!q.empty()) {
                  int v = q.front(); q.pop();
                  inQ[v] = false;

                  // It is possible that the degree has changed since we pushed
                  if (g[v].size() < 2) continue;

                  // Extract two distinct neighbors
                  int a = *g[v].begin();
                  g[v].erase(a);
                  g[a].erase(v);

                  // After removing a, if the set becomes empty? we skip the second extraction?
                  if (g[v].size() < 1) {
                      // Then we cannot form a boomerang. But we already removed one edge? 
                      // We have to put it back? 
                      // Actually, we removed one edge (v,a). Then we have to put it back? 
                      // But the algorithm: we require two. So we break.
                      // We can break and then skip.
                      // But we have already removed the edge (v,a) and then we break? then the edge is lost? 
                      // We should not break, but instead check again: we break the boomerang formation.
                      // How about: if we don't have a second neighbor, we break and skip, and the edge (v,a) remains removed? then we leave it as removed? 
                      // But that edge (v,a) is now not used? 
                      // This should not happen because we checked g[v].size()>=2 at the beginning of the loop and then we removed one, so we have at least one left.
                  }
                  int b = *g[v].begin();
                  g[v].erase(b);
                  g[b].erase(v);

                  ans.push_back({a, v, b});

                  // Update the three vertices: a, b, v
                  // For a, b, and v: if they have at least two edges and are not in the queue, push them.
                  vector<int> candidates = {a, b, v};
                  for (int u : candidates) {
                      if (g[u].size() >= 2 && !inQ[u]) {
                          inQ[u] = true;
                          q.push(u);
                      }
                  }
              }

              cout << ans.size() << "\n";
              for (auto [a, v, b] : ans) {
                  cout << a << " " << v << " " << b << "\n";
              }
          }

        But note: after removing a, we might have g[v].size() become 0? Then we cannot get b. But we checked at the beginning: g[v].size()>=2. Then after removing a, we have at least one. So we can get b.

        Therefore, we don't need the extra check.

        We run the sample input #1 to see if we get 3 boomerangs.

        We hope so.

        Given the time, we assume.

        We output the editorial as described.

        End of editorial.