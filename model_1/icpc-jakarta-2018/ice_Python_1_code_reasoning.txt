 We are going to follow the editorial approach:
 Steps:
 1. Read R, C and the grid.
 2. For each row, check if there is at least one dry land ('#'). If not, mark the row as empty.
 3. Similarly, for each column, check if there is at least one dry land. If not, mark the column as empty.
 4. We note that we need to cover every empty row and every empty column. 
    We can cover an empty row and an empty column simultaneously by converting a cell (that is currently icy) at their intersection to dry land.
 5. Build a bipartite graph:
    - Left side: indices of empty rows (we can index them arbitrarily, say from 0 to A-1, where A = number of empty rows)
    - Right side: indices of empty columns (indexed from 0 to B-1, where B = number of empty columns)
    - For an empty row i (with actual row index r) and empty column j (with actual column index c), if grid[r][c] is '.', then we can add an edge from i (left) to j (right).
 6. Find the maximum matching in this bipartite graph (using DFS or BFS). The size of the matching is the number of cells that can be converted to cover one row and one column at the same time.
 7. The answer is: (number of empty rows) + (number of empty columns) - (size of maximum matching)

 Note: It is important that we only consider the empty rows and empty columns. The problem is that if a row is not empty (i.e., it has at least one dry land) then we don't need to worry about that row? Similarly for columns.

 Why is this sufficient?
  - We require that every row has at least one dry land? Actually, the problem is: to be able to stop in every row and every column, we need at least one dry land in every row and every column. Because:
      * Without a dry land in a row, if you start in that row, you cannot stop (because you slide until you hit a dry land or border). But if there's no dry land in the row, then you slide until you hit the border? However, the problem says that when you slide, you only consider the starting and ending positions as visited. So to visit a cell in an empty row, we must convert at least one cell in that row to dry land so that we can stop and visit that cell.
      * Similarly for a column.

 However, note: the problem does not require that we stop in every row and column? Actually, we must be able to visit all cells. The key is that if a row is empty (no dry land), then we cannot stop in that row? Actually, we can stop at the border? But note: when we slide from a dry land, we can stop only at the next dry land or border. However, if we start in that row, we can slide and leave the row? But then we cannot come back to visit a cell in the middle? 

 The insight from the editorial is: we must have at least one dry land in every row and every column to be able to stop anywhere arbitrarily. 

 But note: the problem says we can change any icy land to dry land. And we want the minimum number of changes so that regardless of the starting position, we can visit every cell.

 Therefore, the necessary condition is that every row and every column must have at least one dry land. Why?
   - Consider an empty row: if there is no dry land in a row, then if we start in that row, we can only slide to the borders (and then leave the row). Then we cannot stop to visit any cell in the middle of the row? Actually, we can only visit the borders? But the middle cells in the row are icy, so if we start at a middle cell, we slide to the border? Then we haven't visited the middle? So to visit the middle, we must have a dry land in that row? Actually, we can also be coming from above or below? However, without a dry land in the row, we cannot stop in the row. Therefore, we cannot visit any cell that is not at the border? Actually, we can only visit the border cells by sliding to the border. But what about a cell in the middle? We cannot stop there. So we must convert at least one cell in that row to dry land.

 Similarly for a column.

 Hence, the condition: every row must have at least one dry land and every column must have at least one dry land.

 However, note: we can cover one row and one column by converting one cell that is at the intersection. This is why we model the problem as a bipartite graph: we want to cover all the empty rows and empty columns with as few changes as possible (each change at (r, c) covers row r and column c).

 Steps in code:

  1. Initialize two boolean arrays: rowEmpty (size R) and colEmpty (size C) to True.
  2. Traverse the grid: for each cell (i, j) that is a dry land ('#'), set rowEmpty[i] = False and colEmpty[j] = False.
  3. Then, we collect:
        emptyRows = [i for i in range(R) if rowEmpty[i]]
        emptyCols = [j for j in range(C) if colEmpty[j]]
  4. Let A = len(emptyRows), B = len(emptyCols).
  5. Build a bipartite graph: left nodes (0 to A-1) for emptyRows, right nodes (0 to B-1) for emptyCols.
        For each left node i (representing row r = emptyRows[i]):
            For each right node j (representing column c = emptyCols[j]):
                if grid[r][c] is '.' (meaning we can convert it to '#'), then add an edge from i to j.
  6. Run bipartite matching (using DFS) to compute the maximum matching.
  7. Answer = A + B - (size of matching)

 However, note: what if there are no empty rows? Then A=0, and similarly for columns. Then we output 0? That's correct.

 But consider: what if the grid has at least one dry land? Then the row and column of that dry land are not empty. Then we might have some rows and columns that are empty? Then we need to cover them.

 Example: sample input
     4 4
     ....
     .###
     ##..
     ###.

  In the sample:
      Row0: '.' only -> empty? But we have no dry land? So row0 is empty.
      Row1: has '###' -> not empty.
      Row2: has '##' -> not empty.
      Row3: has '###' -> not empty.

      Columns?
        Col0: '.' in row0, '.' in row1, '#' in row2, '#' in row3 -> so not empty? because there is at least one dry land?
        Actually, we have dry lands in row2 and row3? So col0 is not empty.
        Similarly, col1: row0: '.'; row1: '#' -> so not empty? because row1 has '#'? So col1 is not empty.
        Col2: row0: '.'; row1: '#' -> not empty? 
        Col3: row0: '.'; row1: '#' -> not empty.

      Then only row0 is empty? and no column is empty? Then answer = 1 + 0 - 0 = 1? 

  However, wait: the sample output is 1.

  But the problem says: we need to change cell (3,3). Note: in 0-indexed, row3 is the last row? But the grid:

      row0: "...."
      row1: ".###"
      row2: "##.."
      row3: "###."

  Actually, the sample explanation says: change cell (3,3) -> which in 0-indexed is (3,3) -> that's the last character in the last row? which is currently '.'.

  But according to our analysis, we only have one empty row (row0) and no empty columns? Then why change (3,3)? 

  Let me check the condition: 
      After changing (3,3) to '#', then row3 now has a dry land in column3? But row3 already had dry lands? So row3 was not empty. Column3: 
          row0: '.' -> not dry? 
          row1: '#' -> dry land -> so col3 is already not empty? 
          row2: '.' -> but we don't require that every cell is dry? We only require that each row and each column has at least one dry land.

      Actually, before the change:
          row0: no dry land -> empty.
          col0: row2 has '#' -> not empty.
          col1: row1 has '#' -> not empty.
          col2: row1 has '#' -> not empty.
          col3: row1 has '#' -> not empty.

      So why change one? Because row0 is empty? Then we need to change one cell in row0? 

      However, the problem changed a cell in row3? 

  Let me see: the problem says: change cell (3,3) -> which is the last character of the last row? 

      The grid becomes:
          row0: "...."
          row1: ".###"
          row2: "###."   -> wait, the original row2 was "##..", but they changed row2? Actually, the sample output grid is:

          ....
          .###
          ###.   -> row2: now has three '#' and one '.'? 
          ###.

      But the problem says: change cell (3,3) -> which in 1-indexed row3? In 0-indexed that is row2 (because first row is row1 in 1-indexed, so row3 is index2?).

      Actually, the sample input:

          4 4
          ....   -> row0
          .###   -> row1
          ##..   -> row2
          ###.   -> row3

      Then they change the cell at (3,3) -> meaning row=3, col=3? In 1-indexed? Then 0-indexed: row=2, col=2? 

      So change grid[2][2] from '.' to '#'? Then row2 becomes: "###." -> becomes "###" in the first three? Actually, the example output grid:

          ....
          .###
          ###.   -> so they changed row2, col2? 
          ###.

      But wait: row2 originally: "##.." -> then after changing the third character (which is at index2) from '.' to '#', we get "##.#"? Actually, no: the string is "##..", and changing the third character (index2) to '#' would yield "##.#", but the example output is "###." -> which is three '#' and then a '.'.

      Actually, the example output grid:

          ....
          .###
          ###.   -> this is row2: so the first three are '###' and the last is '.'? 
          ###.

      How do we get that? They changed row2, col2? But the original row2: "##.." -> 
          index0: '#' -> remains
          index1: '#' -> remains
          index2: '.' -> changed to '#' -> so becomes '#'
          index3: '.' -> remains

      Then row2 becomes "###."? That matches.

      Now, why did that help? 

      Before the change:
          row0: no dry land -> empty.
          row2: originally had two dry lands? so not empty? 
          row1: has three dry lands? not empty.
          row3: has three dry lands? not empty.

          Columns: 
            col0: row2 has '#' -> not empty.
            col1: row1 has '#' -> not empty.
            col2: row1 has '#'? and row2 has '#'? -> not empty? Actually row2 at col2: originally '.' -> so col2: 
                row0: '.' -> not dry
                row1: '#' -> dry -> so col2 is not empty? 
            col3: row1 has '#' -> not empty.

      Then we only have row0 as empty? so we need to put one dry land in row0? 

      However, the problem changed a cell in row2, col2. Why?

      The key: the condition is necessary but also sufficient? Actually, the problem requires that we can visit every cell. The above condition (every row and every column has at least one dry land) is necessary? But is it sufficient? 

      After the change: 
          row0: still empty? 
          but wait: we did not change row0? 

      How do we visit row0? 

      The sample provided a sequence of moves. 

      Actually, the problem changed one cell that is at the intersection of an empty row? But row0 is the only empty row? Then why change a cell in row2? 

      I see: the condition we described (every row and every column must have at least one dry land) is the necessary condition? But actually, the problem does not require that we cover only the empty rows and columns? 

      Let me reexamine the problem: 
        The problem says: regardless of the starting position, we must be able to visit all cells.

      How do we visit a cell in row0? 
        We note that without a dry land in row0, we cannot stop in row0? So we must put at least one dry land in row0? 

      Why then the answer is 1? 

      The problem changed a cell that is not in row0? 

      There is an alternative: 
        Actually, the bipartite graph model is not only about covering the empty rows and columns? 

      We must have at least one dry land in every row and every column. Therefore, the minimum changes is at least the number of empty rows plus the number of empty columns minus the number of overlaps that we can cover by one change? 

      But note: we can only convert icy cells. And if we have an empty row i and an empty column j, and the cell (i,j) is icy, then we can cover both by one change.

      However, in the sample: 
        empty row: row0 (index0)
        empty columns: none? 

      Then why change one? Because we have one empty row? Then we need one change? 

      But we can change any icy cell in row0? Then we can choose a cell in row0, say (0,0) to change to dry land? Then row0 is covered? 

      Why did the sample change (2,2) instead? 

      Actually, the sample output grid still has row0 as all icy? 

      Let me see the sample output grid:

        .... -> row0: still all icy? 
        .### -> row1
        ###. -> row2: changed one to '#' at col2? 
        ###. -> row3

      So row0 is still empty? 

      How then do we visit row0? 

      The sample provided a sequence that starts at (1,1) (which is (0,0) in 0-indexed) and then moves: 
        "SSENNWENSESSESWENWENWNE"

      They say: 
        (1,1) -> (3,1) -> (4,1) -> (4,2) -> (3,2) -> (2,2) -> (2,1) -> (2,2) -> (2,3) -> (3,3) -> (4,3) -> (4,4) -> (4,3) -> (3,3) -> (3,4) -> (2,4) -> (2,3) -> (1,3) -> (1,4)

      How do they get to (1,3) and (1,4)? 
        From (2,3) they move north to (1,3)? 
        But row1, col3 is dry? So they stop at (1,3). Then from (1,3) they can move east? to (1,4) and then stop? because (1,4) is dry? 

      But note: row0: 
        They never stop at row0? 

      The problem says: "visit all the cells". The grid has row0: four cells: (0,0), (0,1), (0,2), (0,3). 

      How do they visit (0,0)? 
        The sequence starts at (0,0) -> that's the initial position? 

      But the problem says: regardless of the starting position? 

      However, in the example they started at (0,0). 

      How about if we start at (0,0)? Then we are standing at (0,0). Then we move? But we are at an icy land? Then if we move south, we slide until we hit a dry land? 
        From (0,0) moving south: 
          row0: (0,0) -> then row1: (1,0) -> which is '.' -> then row2: (2,0) -> which is '#' -> so we stop at (2,0). 
        Then we have visited (0,0) and (2,0)? But what about (1,0)? The problem says: we only consider the starting and ending positions as visited? So (1,0) is passed through and not visited? 

      Therefore, we have not visited (1,0) and (0,0) is visited only at the start? 

      But then we are at (2,0). How do we go back to (0,0)? 

      Actually, the sequence they provided does not show going back to (0,0). They started at (0,0) and then left? and then never came back? 

      The problem states: "visiting 8 different cells" in the example? But in the sample input, there are 16 cells? 

      Actually, the sample input has 4x4=16 cells. The sequence they provided for the sample output visits: 
        (0,0) -> (2,0) -> (3,0) -> (3,1) -> (2,1) -> (1,1) -> (1,0) -> (1,1) -> (1,2) -> (2,2) -> (3,2) -> (3,3) -> (3,2) -> (2,2) -> (2,3) -> (1,3) -> (1,2) -> (0,2) -> (0,3)

      So they visited (0,0) at the start, then later (0,2) and (0,3). How did they get to (0,2)? 
        They were at (1,2) and then moved north? 
          From (1,2) moving north: 
            row1: (1,2) is dry? Then we leave? Actually, no: the problem says: if we stand at a dry land, we can move one step? But note: the movement rule: 
              "If you stand at cell (r, c) and decide to move on a particular direction, then you will move on that direction continuously until you reach a dry land or the border of the board."

          However, the problem says: we can walk or standstill on dry land. But when we move from a dry land, we start sliding? 

          Actually, the rule applies: when you are at a dry land and move, you then slide until you hit the next dry land or border? 

          So from (1,2) (which is dry) moving north: 
            we go to (0,2): which is icy? then we continue? but there is no dry land above? so we hit the border? 
            Then we stop at (0,2)? 

          Then we have visited (0,2). Similarly, from (0,2) we can move east to (0,3) and then stop at the border? 

      Therefore, the entire row0 is visited: 
        (0,0) at start, then (0,2) and (0,3) by sliding.

      But note: we did not need a dry land in row0? 

      Then why do we need to change any cell? 

      The problem says: we must be able to visit all cells regardless of the starting position. 

      Consider starting at (0,1): 
        We are at (0,1). Then we move south? 
          We slide: row0: (0,1) -> row1: (1,1) -> which is dry? so we stop at (1,1). 
        Then we have visited (0,1) and (1,1). 
        How do we visit (0,0)? 
          We are at (1,1). We move west? then we go to (1,0) which is dry? Then we stop at (1,0). 
          Then from (1,0) we move north? then we go to (0,0) and then ...? we are at (0,0) which is icy? so we slide? 
          From (0,0) moving north? we hit the border? so we stop? 
          But then we have visited (0,0). 
        Similarly, (0,2) and (0,3): we can go from (1,2) to (0,2) as above.

      So without any change, we can visit all cells? 

      Why then the sample output is 1? 

      The problem changed one cell? 

      Actually, the problem states: "We only need to change cell (3,3)". 

      And the sample input grid:

        row0: "...."
        row1: ".###"
        row2: "##.."   -> note: row2 has two dry lands at col0 and col1? 
        row3: "###."   -> three dry lands at col0, col1, col2, and then icy at col3.

      Without any change, is it possible to visit all cells? 

      Let me try to start at (0,0). Then we can move south to (2,0) (because row1, col0 is icy and row2, col0 is dry). 
      Then we can move east? 
          From (2,0) (dry) moving east: 
            (2,1): dry? then we stop? 
          Then we move east again: 
            (2,2): icy? then we slide? 
            We go east: (2,3): icy? then we slide until we hit the border? -> (2,3) is the last in the row? then we stop at (2,3) (border). 
      Then we have visited (2,3). 

      Then we can move north? 
          From (2,3) moving north: 
            (1,3): dry? (because row1: ".###" -> col3 is '#' -> dry) -> so we stop at (1,3). 
      Then we can move west? 
          From (1,3) moving west: 
            (1,2): dry -> stop? 
          Then west: (1,1): dry -> stop? 
          Then west: (1,0): icy? then we slide? 
            We go west? but we are at col0? then we stop? 
            Actually, we are at (1,0) and moving west: we go to (1,-1)? -> that's out of board? so we stop at (1,0) as the border? 

      Now we are at (1,0). How to get to (0,1)? 
          We can move north: 
            (0,0): icy -> then we slide? 
            From (0,0) we can only go north? but we are at row0? so we hit the border? 
            Actually, we are at (0,0) and we are still sliding? 
            The rule: we slide until we hit a dry land or border. Since there is no dry land in row0? we hit the border? so we stop at (0,0)? 
          Then we have not visited (0,1), (0,2), (0,3). 

      Alternatively, from (1,0) we can move east? to (1,1) again? 

      How about moving north from (1,0): 
          We go to (0,0) and then we are at the border? 
          Then we are at (0,0). Then we move east? 
            We are at icy land? so we slide? 
            We go east: (0,1), (0,2), (0,3) and then stop at (0,3) (border). 
          Then we have visited (0,0), (0,1), (0,2), (0,3)? 

      So it seems we can visit all cells without any change? 

      Why then the problem says we need to change one? 

      Actually, the problem says: "regardless of the initial starting position". 

      Consider starting at (0,3): 
          We are at (0,3). Then we move south? 
            row1: (1,3): dry land? so we stop at (1,3). 
          Then we can move west? 
            (1,2): dry -> stop.
            (1,1): dry -> stop.
            (1,0): icy -> then we move west? hit border? so we stop at (1,0). 
          Then from (1,0) we move north? 
            (0,0): icy -> then we slide? we go to (0,0) and then we hit the border? so we stop at (0,0). 
          Then we move east? 
            (0,1), (0,2), (0,3): we slide to (0,3) and stop? 
          Then we have visited (0,0), (0,1), (0,2), (0,3)? 

      So without any change, we can visit all cells? 

      But the problem states that we change one cell? 

      I suspect there is a flaw in the above simulation? 

      How about (2,2)? 
        We start at (0,3). We go to (1,3), then (1,2), (1,1), (1,0), (0,0), then (0,3). 
        How do we get to (2,2)? 
          We were at (1,1): then we went to (1,0). 
          How do we get to (2,2)? 
          From (0,0) we can move south? 
            (0,0) -> south: (1,0): icy -> then we slide? 
            But (1,0) is icy? then we slide south? 
                (2,0): dry? so we stop at (2,0). 
          Then from (2,0) we move east? 
            (2,1): dry? stop. 
          Then from (2,1) we move east? 
            (2,2): icy? then we slide? 
            (2,3): icy? then we slide to the border? stop at (2,3). 
          Then we have visited (2,0), (2,1), (2,3). 
          How to visit (2,2)? 
          We never stopped at (2,2)? 

      The problem says: we only count the starting and ending positions. So we passed through (2,2) but did not stop? 

      Therefore, we have not visited (2,2). 

      How do we visit (2,2)? 
        We must stop at (2,2). But to stop, we need to have a dry land at (2,2) or be forced to stop by the border? But (2,2) is not at the border? 
        Without a dry land at (2,2), we cannot stop there? 

      Therefore, we must change (2,2) to dry land? 

      Now, after the change, we can stop at (2,2). 

      So the condition: we must be able to stop at every cell? 
        Actually, no: the problem says we can visit a cell if we stop at it? 

      Therefore, to visit a cell that is icy and not at the border? we must convert it to dry land? 

      But wait: we can also start at that cell? 
        If we start at (2,2), then we are at (2,2) and we count it as visited? Then we leave? 
        Then we have visited (2,2). 

      However, the problem says: regardless of the starting position? 
        If we start at (0,3), we cannot stop at (2,2) without converting it? 

      How about: 
        We start at (0,3). Then we move south to (1,3). Then we move west to (1,2). Then we move south? 
          From (1,2): dry land? moving south: 
            (2,2): icy? then we slide? 
            We go south: (3,2): dry land? so we stop at (3,2). 
          Then we have passed through (2,2) but not stopped? 

      How do we stop at (2,2)? 
        We must have a dry land at (2,2)? 

      Therefore, we must change (2,2) to dry land? 

      Alternatively, we could change any other cell in the grid? But the problem says minimum one? 

      Why not change (0,0) to dry land? 
        Then we can stop at (0,0). Then from (0,0) we can move east? 
          We slide to (0,3) -> border? 
        Then we have not visited (2,2)? 

      How about change (2,2) to dry land? 
        Then from (1,2) we move south: we stop at (2,2) (because it becomes dry). 

      Therefore, we must change (2,2) to dry land? 

      Now, what about the condition that every row and every column must have at least one dry land? 
        Without the change: 
          row0: no dry land? -> empty -> then we must cover row0? 
          row2: has dry lands? at col0 and col1? -> so not empty? 
          col2: 
            row0: '.' -> not dry
            row1: '#' -> dry -> so col2 is not empty? 
          So we only have one empty row? then the bipartite graph method says we need 1 change? 

      But note: the change we did (at row2, col2) does not cover the empty row (row0)? 

      How then is row0 covered? 
        We don't require row0 to have a dry land? 
        But without a dry land in row0, we can still visit the cells in row0 by starting there? 
        However, we also require that we can stop at every cell? 
          Actually, to visit a cell in row0, we can start there? but the problem: regardless of starting position? 

        But if we start at (0,0), we are at (0,0) -> that counts as visited? Then we leave? 
        Then we have visited (0,0). 
        Similarly, if we start at (0,1), we are at (0,1) -> counts as visited? 

      However, the problem says: "you can move to either one of the four directions", meaning after starting we move? 
        But note: we are allowed to standstill? 
        Actually, the problem says: "You can walk or standstill on any dry land without any problem". 
        But on icy land? if we standstill? the problem does not say. 

      The problem says: "If you stand at cell (r, c) and decide to move on a particular direction, then you will move ...". 
        It doesn't say what happens if we standstill on icy land? 

      But the problem says: "an icy land is very slippery" only when you decide to move? 

      So we can standstill on icy land? 

      Therefore, if we start at (0,0), we are standing at (0,0) -> that counts as visited? 

      Then why do we need to change (2,2)? 
        Because we must also visit (2,2) and we cannot stop there if we are not starting there? 

      But if we start at (2,2), we are standing at (2,2) -> that counts as visited? 

      Therefore, without any change, we can visit all cells? 

      Why then the sample output is 1? 

      I think the problem intended that you can only stop at a cell if it is dry land? or if you are forced to stop (by the border) but then the starting cell counts? 

      However, the problem statement: 
          "Cells in which you only passed through are also not considered as visited, e.g., in the example above, if you move south from (3, 1), then you will pass through (4, 1) and (5, 1), and arrive at (6, 1); thus, (4, 1) and (5, 1) are not considered as visited from that particular move, only (3, 1) and (6, 1) are."

      This implies that to visit a cell, you must either start there or stop there (as the end of a slide or by being dry land?).

      Therefore, an icy cell that is not the starting cell and not the end of a slide (because we slide through) is not visited? 

      So to visit an icy cell that is not at the border? we must either start there or change it to dry land? 
        But if we start there, we count it. 
        But the problem: regardless of the starting position? 

      That means: we must be able to visit the cell even if we do not start there? 
        Therefore, for an icy cell that is not at the border, we must change it to dry land? 
        Why? because if we don't start there, we will slide through and not stop? so we won't visit it? 

      But consider an icy cell that is at the border? 
        We can stop there by sliding into the border? 

      Therefore, the only cells that are problematic are the icy cells that are not at the border? 

      Then the answer would be the number of icy cells that are not at the border? 

      But the sample: 
        The board has many icy cells that are not at the border? 
        For example, (0,0) is at the border? so no problem? 
        (0,1): not at the border? -> need to change? 
        (0,2): not at the border? -> need to change? 
        (0,3): at the border? -> not needed? 
        (1,0): at the border? (because col0) -> not needed? 
        (2,2): not at the border? -> need to change? 
        (2,3): at the border? -> not needed? 
        (3,3): at the border? -> not needed? 

      Then we would need to change (0,1), (0,2), (2,2) -> 3 changes? 

      But the sample output is 1? 

      This suggests that the above is not the solution.

  After rethinking: 

      The intended solution is the bipartite matching on empty rows and empty columns? 

      Why is that? 
        - To be able to stop in a row, we need at least one dry land in that row? 
        - To be able to stop in a column, we need at least one dry land in that column? 

      Why? 
        Because if a row has no dry land, then if you are in that row and you move left/right, you will slide to the border? but then you leave the row? and you cannot stop in the middle of the row? 
        Therefore, you cannot visit a cell in the middle of the row? 

      Similarly for a column. 

      Therefore, we must have at least one dry land in every row and every column? 

      The minimum number of changes is the minimum number of cells we change to achieve that. 

      How to compute that minimum? 
        We start with the set of rows that have no dry land (R_empty) and the set of columns that have no dry land (C_empty).
        We can cover a row in R_empty and a column in C_empty by changing the cell at (r, c) (if it is icy) to dry land? 

      Therefore, we want to cover every row in R_empty and every column in C_empty? 
        But one change covers one row and one column? 

      Then the minimum number of changes is |R_empty| + |C_empty| - (maximum matching between R_empty and C_empty, where an edge exists if grid[r][c]=='.').

      In the sample: 
        R_empty = [0] (row0)
        C_empty = []? 
        Then answer = 1 + 0 - 0 = 1? 

      But wait, the sample changed a cell that is not in R_empty? 

      However, we are allowed to change any icy cell? 
        We could change a cell in row0? then we cover row0? 
        For example, change (0,0) to dry land: then row0 is covered? and we don't cover any column? 
        Then the condition is satisfied: every row has at least one dry land? and every column? col0 now has a dry land? (it already had dry lands in row2 and row3, but now also in row0) -> so col0 is still covered? 

      Why then the sample changed (2,2)? 

      Because the problem says: "What is the minimum number of cells you need to change to ensure that your goal can be achieved?"

      In the sample, they changed (2,2) and the grid then has:
        row0: still no dry land? 

      That means row0 is still empty? 

      How then is the condition satisfied? 

      The problem must have intended that we change a cell in an empty row? 

      But the sample output grid has row0 still empty? 

      This is a contradiction? 

  After reading the sample explanation again: 
      They say: 
        "We only need to change cell (3,3)."

      And then they provide a grid: 
          ....
          .###
          ###.
          ###.

      In this grid, row0: still no dry land? 

      Then how can we visit the cells in row0? 

      They say: 
        "If you start at cell (1,1), then the movement ... will visit all the cells."

      And the starting cell (1,1) is (0,0) in 0-indexed? 

      Then they start at (0,0) -> so they visit (0,0) by starting there? 
        Then they move and leave? 

      And they also visit (0,2) and (0,3) by sliding? 

      But then they don't stop at (0,1)? 

      How do they visit (0,1)? 
        The sequence: 
          (0,0) -> (2,0) -> (3,0) -> (3,1) -> (2,1) -> (1,1) -> (1,0) -> (1,1) -> (1,2) -> (2,2) -> (3,2) -> (3,3) -> (3,2) -> (2,2) -> (2,3) -> (1,3) -> (1,2) -> (0,2) -> (0,3)

        They never list (0,1) as a stop? 

      But the problem says: "visit all the cells", meaning every cell must be either started at or stopped at? 

      In the sequence, they list (0,0) and (0,2) and (0,3). 
        (0,1) is missing? 

      However, they passed through (0,1) when sliding from (0,0) to (0,3)? 
        The problem says: passing through does not count. 

      Therefore, (0,1) is not visited? 

      So the sample output grid does not allow visiting (0,1) if we start at (0,0)? 

      How about if we start at (0,1)? 
        Then we are at (0,1) -> counts as visited? 

      But the problem: regardless of the starting position? 
        The goal is: you can visit all cells regardless of the starting position? 

      This means: for any starting cell, there exists a sequence that visits all cells? 

      In the sample output grid, if we start at (0,0), we can visit (0,0), then we move east? 
        We are on ice: slide east until we hit the border? -> then we stop at (0,3). 
        Then we have visited (0,0) and (0,3)? 
        How to visit (0,1) and (0,2)? 
          We passed through them? but that doesn't count? 

      Therefore, we must change at least one cell in row0? 

      But the sample output changed (2,2) and not any cell in row0? 

      This is very confusing. 

  I think the intended solution is the bipartite matching, and it is widely known in the literature as the "escape" problem? 

  There is a known problem: 
      We are given an grid of R rows and C columns. Some cells are blocked. We want to place minimum number of rocks (on blocked cells? or change to rocks) such that from any free cell, we can escape (by sliding in one of the four directions until we hit a rock or the border). 

  However, in our problem: 
      We want to be able to visit every cell (stop at every cell) regardless of the starting position. 

  The known solution for the escape problem is: 
      We need to cover every row and every column with a rock? and we can cover one row and one column by a rock at their intersection? 
      Then the minimum number of rocks is |R_empty| + |C_empty| - (maximum matching between R_empty and C_empty).

  In the sample input, the grid has no rock in row0? so R_empty has row0, and no empty column? then answer=1.

  And the sample output is 1.

  Therefore, we trust the bipartite matching solution.

  Steps in code:

    Let R, C = dimensions.
    grid = [input().strip() for _ in range(R)]

    rowEmpty = [True] * R   # True if the row has no dry land
    colEmpty = [True] * C   # True if the col has no dry land

    for i in range(R):
        for j in range(C):
            if grid[i][j] == '#':
                rowEmpty[i] = False
                colEmpty[j] = False

    # Now, we want to cover the empty rows and empty columns.
    # We consider the set of empty rows and empty columns.

    emptyRows = [i for i in range(R) if rowEmpty[i]]
    emptyCols = [j for j in range(C) if colEmpty[j]]

    A = len(emptyRows)
    B = len(emptyCols)

    # Build bipartite graph: left side [0, A-1] for emptyRows, right side [0, B-1] for emptyCols.
    # For i in range(A), and j in range(B):
    #   r = emptyRows[i], c = emptyCols[j]
    #   if grid[r][c] == '.', then we can put a dry land here to cover row r and column c.

    graph = [[] for _ in range(A)]

    for i in range(A):
        r = emptyRows[i]
        for j in range(B):
            c = emptyCols[j]
            if grid[r][c] == '.':
                graph[i].append(j)

    # Now, we do bipartite matching on graph (left has A nodes, right has B nodes)

    # We'll use DFS for matching.

    match = [-1] * B   # match[j] = which left node (index in [0, A-1]) is matched to right node j
    seen = [False] * B

    def dfs(u, seen, graph, match):
        for v in graph[u]:
            if not seen[v]:
                seen[v] = True
                if match[v] == -1 or dfs(match[v], seen, graph, match):
                    match[v] = u
                    return True
        return False

    matching_count = 0
    for u in range(A):
        # reset seen for each u
        seen = [False] * B
        if dfs(u, seen, graph, match):
            matching_count += 1

    ans = A + B - matching_count
    print(ans)

  However, note: the grid might be large (R, C up to 500). 
      A and B can be at most 500? 
      The graph has at most 500*500 = 250000 edges? 
      And we run DFS for each left node (at most 500 times) -> worst-case 500 * 250000 = 125e6, which in Python might be borderline in PyPy/C++ but in Python it might be too slow? 

  We need to optimize:

      The DFS function uses recursion and we have 500 left nodes. 
      The inner loop for each u: we iterate over the neighbors of u. 

      The worst-case total edges is 250000? then the total work is 250000? 
          But the DFS function does:

          for u in range(A):
              seen = [False]*B
              for each neighbor v of u: 
                  if not seen[v]: ... and then recursively.

      The worst-case total work is the sum_{u} (number of neighbors of u) * (the work per neighbor)? 
          The work per neighbor in the recursion might involve a DFS that goes deep? 

      Actually, the Hopcroft-Karp algorithm is more efficient in worst-case? but for 500 nodes, and 250000 edges, the DFS-based bipartite matching (augmenting path) is acceptable in C++? but in Python? 

      We must hope that the graphs are sparse? or worst-case we do 500 * (number of edges from u) and the DFS recursion might have a depth of the length of the path? which is at most 500? 

      Total operations: each edge might be tried at most once per outer DFS? 
          Actually, the worst-case total time is O(A*(A+B+E))? because we do a DFS from each u? 
          But we reset 'seen' for each u? 

      Alternatively, we can use a for loop for each u and then do a BFS? but the standard DFS is used.

      We note that the worst-case total work is O(A*E) = 500 * 250000 = 125e6, which in C++ is acceptable in 1s, but in Python it might be borderline? 

      However, the problem time limit is 1.0s? and 125e6 operations in Python might be 10-20 seconds? 

  We need to optimize the matching algorithm? 

      We can use a BFS-based (like Hopcroft-Karp) for bipartite matching? but that is more complex? 

      Alternatively, we can try to optimize the DFS by using iterative DFS? 

      But note: the graph is not huge? 500 nodes on the right? and 500 nodes on the left? 

      However, worst-case 125e6 edges traversals? 

      We can try to reduce the constant factors? 

      Another idea: use a different representation? 

      But let us hope that the worst-case does not happen? 

      Or we can use a better algorithm: we can use the classic DFS matching with a single seen array reset per u? 

      We'll try to write it carefully.

  Alternatively, we can use an algorithm that uses a global visited marker? 

      We can avoid resetting the entire 'seen' array for every u? 

      We do:

          match = [-1] * B
          parent = [None] * B   # we don't need parent? 

          Instead, we can use a global visited array that we reset at the beginning of the outer loop? 

      But that's what we are doing: we reset seen to [False]*B for each u.

      We can use an integer timestamp? 

          Let visited_time = [0] * B   # initialize to 0
          time = 1

          for u in range(A):
              time += 1
              if dfs(u, time, visited_time, ...): ...

          In dfs(u, time, visited_time, ...):
              for v in graph[u]:
                  if visited_time[v] != time:
                      visited_time[v] = time
                      ... 

      Then we avoid the reset by a full array.

      But the DFS recursion remains the same.

  Let us implement with the timestamp to avoid the reset of an entire list of size B for each u.

  Steps for DFS with timestamp:

      visited_time = [0] * B   # all 0 initially
      time = 1

      match = [-1] * B   # for the right nodes

      def dfs(u, time, visited_time, graph, match):
          for v in graph[u]:
              if visited_time[v] != time:
                  visited_time[v] = time
                  # then we check: if match[v] is -1 or we can reassign?
                  if match[v] == -1 or dfs(match[v], time, visited_time, graph, match):
                      match[v] = u
                      return True
          return False

      But note: the recursive call will use the same time? 
          Why? because in the same DFS call we want to mark the same time? 

      Actually, we want to mark all nodes visited in the current DFS call (for u) with the same time? 

      Then in the recursion, we use the same time? 

      Then we must not reset the time for the inner DFS? 

      This works? 

      However, the entire DFS tree for u uses the same time? 

      Then we avoid revisiting a node in the same DFS tree? 

      But the matching DFS is: we do a DFS to find an augmenting path? and we want to avoid cycles? 

      And the timestamp per u is unique? 

      This is the standard way.

  Code:

      time_counter = 1
      visited_time = [0] * B
      match = [-1] * B
      count = 0

      for u in range(A):
          # We do DFS for u
          if dfs(u, time_counter, visited_time, graph, match):
              count += 1
          time_counter += 1

      But note: we can do without increasing time_counter for each u? 
          Actually, we can do: 
              if we do:
                  time = time_counter
                  time_counter += 1
              then call dfs(u, time, ...)

          But we can also use the same time for all u? 

      Actually, we want to mark that for the current u, we have not seen any v? 
          So we set a new time for each u? 

      Therefore, we increment time_counter for each u.

  However, the worst-case work is still O(A * (number of edges in the DFS tree))? 

      But worst-case the DFS for u might traverse the entire graph? which is O(B + E_u) where E_u is the number of edges from u and the edges from the nodes we recurse? 

      The total work over all u is O(A*B + total_edges)? which is O(A*B + A*B) = O(A*B) = 250000? 

      Actually, no: the DFS for one u might traverse many edges? 

      How many times is an edge traversed? 
          For a fixed u, we traverse the edges from u, and then recursively from the nodes we call. 
          But in the worst-case, the entire graph might be traversed for one u? 

      Then the total work is O(A * (A*B))? 

      Actually, the DFS for one u might visit all the right nodes and for each right node we look at all the left nodes? 
          But our graph is from left to right? and we are going to the left node only when we match? 

      The standard DFS for bipartite matching: 
          The worst-case running time is O(|E|) for one DFS? 
          But we do it for each u? 
          Then total O(A * |E|) = O(A * (A*B)) = O(A^2 * B) = 500^3 = 125e6? 

      But note: in our graph, the total number of edges is at most A*B? which is 500*500=250000.

      Then the worst-case total work is O(A * (A*B)) = 500 * 250000 = 125000000, which is 125e6? 

      This is acceptable in C++ in 1s? but in Python? 

      We must optimize.

  We can use a BFS or DFS that uses a global visited array per phase? but the standard algorithm for bipartite matching is:

      match = [-1] * B
      for u in range(A):
          seen = [False] * B
          dfs(u, seen, ...)

      The worst-case work is O(|E|) per u? then total O(A * |E|) = 125e6.

      We must hope that the worst-case is not met? 

      But worst-case graph: a complete bipartite graph? then |E| = A*B = 250000, and then 500 * 250000 = 125e6.

      In Python, 125e6 iterations might take around 10 seconds? 

      We need a better algorithm: Hopcroft-Karp? 

      Hopcroft-Karp runs in O(sqrt(n) * |E|), which is about sqrt(500) * 250000 = 22.36 * 250000 = 5.59e6, which is acceptable.

  However, implementing Hopcroft-Karp in Python for this problem might be heavy? 

  Alternatively, we can try to optimize the DFS by iterative DFS? and hope that the worst-case doesn't happen? 

  But worst-case (complete graph) might be common? 

  We note that the grid is given and the empty rows and empty columns: the graph is built only for the empty rows and empty columns? 

      The number of empty rows and empty columns might be much smaller than 500? 

      In the worst-case, if the grid is all icy, then A=R (500), B=C (500), and then the graph has 250000 edges? 

      Then we do 500 * 250000 = 125e6 iterations? 

      We need to avoid that.

  We can use a different algorithm: BFS for matching? 

      Actually, the classic DFS algorithm can be optimized by breaking early? but worst-case remains.

  Since the constraints are 500, and 125e6 is acceptable in PyPy/C++ but in Python we have to be careful? 

  We can try to use an iterative DFS? but the depth is not large? 

  Or we can use a global 'visited' array that is reset once per matching? 

      But the standard DFS per node is the algorithm.

  Alternatively, we can use the following: 
      We use an array 'prev' to record the parent in the DFS tree? and use BFS to find an augmenting path? 

      That is the standard BFS (like Dinic) for bipartite matching? 

      Algorithm:

          matchL = [-1] * A   # for left node u, matchL[u] = the right node matched to u, or -1
          matchR = [-1] * B   # for right node v, matchR[v] = the left node matched to v, or -1

          prev = [-1] * A   # we can use for BFS? 

          total_matching = 0
          for u in range(A):
              # BFS: we are going to find an augmenting path from u
              dist = [-1] * A   # distance from u in the BFS tree? but we are building an alternating tree? 
              queue = deque()
              queue.append(u)
              dist[u] = 0
              path_found = False
              while queue and not path_found:
                  u_node = queue.popleft()
                  for v in graph[u_node]:
                      # v is a neighbor
                      next_node = matchR[v]   # the left node that is currently matched to v, or -1 if none
                      if next_node == -1:
                          # we found an augmenting path
                          # then we backtrack to update the matching
                          # but how to backtrack? we didn't store parent for the right nodes? 
                          # Actually, we store parent for left nodes? 
                          # We can store: for each right node, we record the left node from which we came? 
                          # But we are not storing that? 
                          # Alternatively, we can store an array 'parent' for the right nodes? 
                          # Actually, we store: 
                          #   parent = for each right node, the left node that led to it? 
                          # But we are doing BFS over left nodes? 

              This is getting complex.

  After checking, the standard DFS with recursion and resetting the 'visited' array for the right nodes per left node is the most common.

  We will use the iterative DFS? 

      But recursion depth might be up to 500? which is acceptable? 

  However, worst-case 125e6 iterations? 

  We must hope that the graph is sparse? 

  Alternatively, we note: in practice, the graph might not be complete? 

  But worst-case the grid is all icy? then the graph is complete? 

  We must optimize the DFS: 

      We can use a list for the DFS stack? 

      Iterative DFS for augmenting path for u:

          stack = [u]
          parent = [None] * A   # for left nodes? 
          # Actually, we are only interested in the path to update the matching? 

          But we can do:

          path = {}
          # We want to find an augmenting path: starting at u, and we traverse the graph: 
          #   from u we go to a right node v? then from v we go to the current match of v (if any) and then from that left node we go to another right node? 

          We can do:

          pre = [-1] * A   # for left nodes: the previous edge? 
          We don't need? 

          Instead, we store for each right node, the left node that we came from? 

          We do:

              from collections import deque
              q = deque()
              q.append(u)
              path = {}
              in_path = [False] * B   # for right nodes, if they are visited in this BFS?
              # But we can avoid if we break when we find a free right node? 

              while q:
                  u1 = q.popleft()
                  for v in graph[u1]:
                      if v in path: 
                          continue
                      path[v] = u1
                      if matchR[v] == -1:   # free right node
                          # augmenting path found: from u to v, and the path is stored by 'path'
                          # update the matching: 
                          while v != -1:
                              u_prev = path[v]
                              # save the next v: 
                              next_v = matchL[u_prev]   # the current match of u_prev? 
                              # set matchL[u_prev] = v
                              # set matchR[v] = u_prev
                              # then set v = next_v? 
                              # Actually, we backtrack the path? 
                              # But we don't store the entire path? 
                          break
                      else:
                          # v is matched, then we add the left node that is matched to v to the queue
                          u_next = matchR[v]
                          if u_next not in ?   # we mark left nodes visited? 
                          q.append(u_next)
                          # and record the path to u_next? 
                          # But we don't need to record the path to u_next? because we are going to record how we got to u_next? 
              This is not complete.

  We stick to DFS with recursion and use the timestamp trick to avoid resetting a big array.

  We hope that worst-case 125e6 is acceptable in Pyton? 

      In Pyton, 125e6 iterations might take 10 seconds? but the problem time limit is 1s? 

  We need to use Hopcroft-Karp? 

      Hopcroft-Karp: 
          It runs in O(sqrt(n) * |E|) 
          Steps: 
            1. Do BFS to compute distances and find multiple augmenting paths at once? 

      But we only have 500 nodes? 

  Alternatively, we can use a simple DFS and hope that the worst-case doesn't happen? 

  But worst-case (complete graph) might be in the test data? 

  After checking: R, C up to 500 -> A, B <= 500 -> 500 * 500 = 250000 edges? 
      Then the DFS for each node: in the worst-case, we do 500 * 250000 = 125e6.

  We try to run 125e6 iterations in Python? 
      In Pyton, a for loop of 125e6 iterations might run in about 5-10 seconds? 

  We must optimize the inner loop? 

      We can use PyPy? but the problem says to output in Python.

  We can try to use an adjacency list and hope that the constant factors are small? 

  Or we can try to optimize by using local variables? 

  We decide to implement the DFS matching with recursion and timestamp, and hope that the test data is not worst-case? 

  But worst-case is possible? 

  Alternatively, we note that the grid is not worst-case? 

  But the problem states: 1<=R,C<=500, and grid has R*C cells? 

  So worst-case is all '.'? then we have A=R, B=C, and the graph is complete? 

  We must find a better algorithm.

  We implement a BFS-based matching (which is essentially the same as the DFS in terms of complexity) but iterative to avoid recursion limits? 

      The worst-case time is still O(A * |E|) = 125e6.

  We write the iterative DFS for bipartite matching? 

      But the standard DFS uses recursion and the recursion stack might be 500 deep? which is acceptable? 

  We go with the DFS and hope that the worst-case runs in time? 

  But 125e6 in Python might be borderline? 

  We try to write the DFS with recursion and the timestamp trick? 

  Steps:

      matchR = [-1] * B   # for right node j, the matched left node index (in [0, A-1])
      visited_time = [0] * B   # all 0 initially
      time_counter = 1

      def dfs(u, time, visited_time, graph, matchR):
          for v in graph[u]:
              if visited_time[v] != time:
                  visited_time[v] = time
                  if matchR[v] == -1 or dfs(matchR[v], time, visited_time, graph, matchR):
                      matchR[v] = u
                      return True
          return False

      matching_count = 0
      for u in range(A):
          if dfs(u, time_counter, visited_time, graph, matchR):
              matching_count += 1
          time_counter += 1

  But note: the recursive DFS might be expensive? 

  We change to iterative DFS? 

      How to do iterative DFS for bipartite matching? 

      We can use a stack to simulate recursion? 

      We store the state: (u, index) where index is the next neighbor to try? 

      We'll maintain for each left node u, the next neighbor index.

      Algorithm for one u:

          stack = []
          # we want to find an augmenting path from u
          # For the current u, we try its neighbors in order.
          # For each right node we might have a 'visited' mark for this DFS (for u)? 
          # We use the timestamp for the right nodes? 

          Instead, we do:

          parent = {}   # for right nodes, the left node that led to it? 
          # But we want to avoid using a dictionary? 

          We can do:

              stack = []
              ptr = [0] * (A+1)   # we are going to do for u, so we need for the entire DFS tree? we need for each left node in the DFS tree the next neighbor index? 
              # But the DFS tree involves multiple left nodes? 

          Alternatively, we do:

              We maintain an array 'next_index' for the left nodes that are currently in the DFS stack? 

          We initialize: 
              next_index = [0] * (A)   # for each left node, the next neighbor index to try? but we are only doing one DFS? 
              for u, we start at next_index[u] = 0.

          But we do one u at a time? 

          We can do:

              # For the current u, we do:
              path = []   # not needed
              # We maintain: 
              #   an array 'visited_right' for the current u: but we use the timestamp? 

              # We'll use the same timestamp trick for the right nodes? 
              #   we have a global visited_time_right (for the whole graph) and a global time_counter for the current u? 

          Actually, we can use the timestamp trick without recursion? 

          For a fixed u and a fixed time T:

              stack = [u]
              # we maintain the next pointer for each left node? 
              next_ptr = [0] * A   # for the current DFS tree, the next neighbor index for left node i? 
              found = False
              # We will try to find an augmenting path.

              while stack:
                  u1 = stack[-1]
                  if next_ptr[u1] < len(graph[u1]):
                      v = graph[u1][next_ptr[u1]]
                      next_ptr[u1] += 1
                      if visited_time[v] != T:   # T is the current time for this DFS (for the current u)
                          visited_time[v] = T
                          if matchR[v] == -1:
                              # augmenting path found: update the match along the path?
                              # But we didn't store the path? 
                              # How do we update the matching? 
                              # Actually, in DFS we update recursively. Here, we don't store the entire path? 

                              # We need to store the parent of v? 

                              # Instead, we do: we break and then update? 
                              # But we are not storing the path? 

                              # We store: an array 'prev' for the right node v: the left node that we are coming from? 
                              # But we are not storing that? 

                      else:
                          # skip
                  else:
                      stack.pop()

          This is not working.

  Given the complexity, we decide to use the recursive DFS with timestamp and hope that the worst-case runs in 10 seconds? 

  But the problem time limit is 1s? 

  We must try to use Hopcroft-Karp? 

  Here is a sketch of Hopcroft-Karp:

      We build the graph: left->right.

      Steps:
        matchL = [-1] * A   # for left node i, the matched right node
        matchR = [-1] * B   # for right node j, the matched left node

        while true:
            # BFS: build layers for BFS tree (starting from all free left nodes)
            dist = [-1] * A   # distance for left nodes
            queue = deque()
            for i in range(A):
                if matchL[i] == -1:
                    dist[i] = 0
                    queue.append(i)

            while queue:
                u = queue.popleft()
                for v in graph[u]:
                    # if v is matched, then we consider the next left node
                    u2 = matchR[v]
                    if u2 != -1 and dist[u2] == -1:
                        dist[u2] = dist[u] + 1
                        queue.append(u2)

            # Then we do DFS for each free left node (in the first layer) to find an augmenting path using the layered graph?
            # But we do multiple DFS? 

            Actually, we do:

            additional_matching = 0
            for u in range(A):
                if matchL[u] == -1:
                    if dfs(u, dist, matchL, matchR, graph):
                        additional_matching += 1

            if additional_matching==0: break
            total_matching += additional_matching

        In the DFS for u (in the layered graph):
            conditions: 
                for v in graph[u]:
                    u2 = matchR[v]
                    if u2 == -1:
                        # then we found an augmenting path: match u to v, and return True
                    else:
                        if dist[u2] == dist[u]+1:   # meaning u2 is in the next layer?
                            if dfs(u2, dist, matchL, matchR, graph):
                                matchR[v] = u
                                matchL[u] = v
                                return True

            then return False

      The DFS in Hopcroft-Karp: we are not resetting a visited array? because we use the distance as a marker? 

      The total running time is O(sqrt(n) * |E|) ? 

  We implement Hopcroft-Karp.

  Steps:

      matchL = [-1] * A   # for left nodes
      matchR = [-1] * B   # for right nodes

      total_matching = 0
      while True:
          dist = [-1] * A
          queue = deque()
          for i in range(A):
              if matchL[i] == -1:
                  dist[i] = 0
                  queue.append(i)

          # BFS: 
          while queue:
              u = queue.popleft()
              for v in graph[u]:
                  # for a neighbor v
                  u2 = matchR[v]
                  if u2 != -1 and dist[u2] == -1:
                      dist[u2] = dist[u] + 1
                      queue.append(u2)

          # Now, run DFS for every left node that is free (in the first layer)
          # But we can do a multi-start DFS using a stack? 
          # We'll do a DFS for each free left node, but using the layered graph.
          # We use an array 'ptr' for each left node to remember the next neighbor to try? 
          # But we do one DFS at a time? 

          # Instead, we do a DFS for each free left node? 

          # But the algorithm: 
          #   we do a DFS for each free left node in the current layered graph? 

          # We can do iterative DFS? 

          # We'll do:
          additional = 0
          # We maintain a next pointer for each left node: 
          ptr = [0] * A   # for each left node, the next index in graph[u] to try

          # But we do for each free left node: 
          #   but we can do a single DFS with a stack? 

          stack = []
          for i in range(A):
              if dist[i] == 0:   # free and in layer0
                  stack.append(i)

          # We are going to do a DFS in the layered graph? 
          # But we can do multiple DFS? 
          # Actually, we do for each free left node: 
          for u in range(A):
              if dist[u] == 0:
                  # DFS for u
                  stack = [u]
                  while stack:
                      u1 = stack.pop()
                      while ptr[u1] < len(graph[u1]):
                          v = graph[u1][ptr[u1]]
                          ptr[u1] += 1
                          u2 = matchR[v]
                          if u2 == -1:
                              # found an augmenting path: update the matching
                              # backtrack: we don't store the path? 
                              # But we know: we want to update the matching along the path? 
                              # However, in Hopcroft-Karp we store the path by the BFS tree? 
                              # Actually, we need to update: 
                              #   we will update: 
                              #       matchR[v] = u1
                              #   then we go back: we need to update the previous matching? 
                              # But we don't store the entire path? 

                              # How to update the matching? 
                              #   We can store during the DFS the parent of each right node? 
                              #   But we are not storing it? 

                              # We do: 
                              cur = u1
                              while True:
                                  # we match cur to v
                                  # then we break the previous match of cur? 
                                  # but currently, cur is free? 
                                  # Actually, we are matching cur to v, which is free? 
                                  # then we are done? 
                              But wait: the matching update for an augmenting path is more complex? 

                          else:
                              if dist[u2] == dist[u1] + 1:
                                  # then we can push u2 and continue
                                  stack.append(u1)   # push u1 again because we may have more neighbors
                                  stack.append(u2)
                                  break

                  # but we haven't updated the matching? 

          This is not complete.

  Given the complexity, and the constraints (125e6 worst-case) we decide to use the simple DFS matching and hope that the worst-case is not in the test data? 

  Or we use the recursive DFS and hope that Pyton can handle 125e6 iterations? 

  We try on the worst-case locally: 
      A=500, B=500, and for each u, graph[u] = list(range(B))   # complete graph

      Then we do:

          for u in range(500):
              for v in range(500):  # in the worst-case, the DFS for the first u will try 500 and then match one? 
              # but the next u: might try 500 and then then one that is matched, and then try the next free? 

          The worst-case for the simple DFS matching is O(A * |E|) = 500 * 500 * 500 = 125e6.

  We time in Python: 

      for i in range(500):
          for j in range(250000):

      This is 500 * 250000 = 125e6, which in Python:

          On my machine: 
              a = 0
              for i in range(500):
                  for j in range(250000):
                      a += 1

          This takes: about 10 seconds? 

  We cannot do that.

  Therefore, we must use the Hopcroft-Karp algorithm.

  Here is a standard implementation of Hopcroft-Karp for bipartite matching.

  We will:

      matchL = [-1] * A   # for left node i, matchL[i] = the right node matched, or -1
      matchR = [-1] * B   # for right node j, matchR[j] = the left node matched, or -1

      dist = [0] * A    # for BFS (distance for left nodes)

      def bfs():
          # build layers
          nonlocal dist   # we can use a list that we update
          queue = deque()
          for i in range(A):
              if matchL[i] == -1:
                  dist[i] = 0
                  queue.append(i)
              else:
                  dist[i] = -1

          layer_end = 0   # the distance of the last layer where we found a free right node? 
          while queue:
              u = queue.popleft()
              for v in graph[u]:
                  # u is matched to someone? but here we are at a free node? 
                  u_next = matchR[v]
                  if u_next == -1:
                      layer_end = dist[u] + 1   # actually, we will not use layer_end? 
                      # we know that we have a free right node in the next layer? 
                  else:
                      if dist[u_next] == -1:
                          dist[u_next] = dist[u] + 1
                          queue.append(u_next)

          return (layer_end < inf)   # if we found any free right node? 

      Then the DFS function for a left node u (with the layered graph):

          for v in graph[u]:
              u_next = matchR[v]
              if u_next == -1 or (dist[u_next] == dist[u] + 1 and dfs(u_next)):
                  # then we can match u to v
                  matchR[v] = u
                  matchL[u] = v
                  return True

          return False

      Then the main:

          matching = 0
          while bfs():
              for u in range(A):
                  if matchL[u] == -1:
                      if dfs(u):
                          matching += 1

          Here, the DFS is a recursive function.

      The complexity: the number of phases is O(sqrt(A)), and in each phase, we do a BFS and then several DFS that in total cover the entire graph? 

      Specifically, the total work in one phase is O(|E|) for BFS and O(|E|) for the DFS in that phase? 

      So total O(sqrt(A) * |E|) = sqrt(500) * 250000 = about 22 * 250000 = 5.5e6, which is acceptable in Python.

  We implement accordingly.

  Note: the DFS in the Hopcroft-Karp does not need a separate visited array because we use the distance (and only use edges that go to the next layer).

  Let's write the DFS function carefully:

      def dfs(u):
          for v in graph[u]:
              u_next = matchR[v]
              if u_next == -1:
                  # then we can match u to v
                  matchR[v] = u
                  matchL[u] = v
                  return True
              else:
                  if dist[u_next] == dist[u] + 1:   # this is the layered graph condition
                      if dfs(u_next):   # if we can find an augmenting path from u_next
                          matchR[v] = u
                          matchL[u] = v
                          return True
          return False

      But wait: we might try the same v multiple times? 
          But we are iterating over v in graph[u]? 

      However, if we try one v and it fails, we try next? 

      This DFS is standard.

  However, the DFS might be called recursively and the depth might be the length of the augmenting path? which is at most 2*A+1? 

  But A is 500, so recursion depth 500 is acceptable.

  We then output: A + B - matching

  Let's test with the sample: 
        emptyRows = [0] (only row0)
        emptyCols = []  -> B=0, A=1.
        graph[0] = []   # because there are no empty columns? 
        Then matching = 0.
        ans = 1+0-0 = 1.

  This matches.

  Code structure:

      from collections import deque
      import sys
      sys.setrecursionlimit(10000)

      # ... (read input, compute emptyRows, emptyCols, build graph)

      A = len(emptyRows)
      B = len(emptyCols)

      # If there are no right nodes, then we can only match 0.
      matchL = [-1] * A
      matchR = [-1] * B   # note: B might be 0, then we skip the matching

      # dist: for left nodes, used in BFS
      dist = [0] * A

      graph0 = graph   # graph0 is the graph for the left nodes (size A), each graph0[u] = list of indices in [0, B-1]

      def bfs():
          nonlocal dist
          queue = deque()
          for i in range(A):
              if matchL[i] == -1:
                  dist[i] = 0
                  queue.append(i)
              else:
                  dist[i] = -1

          found = False   # whether we found at least one augmenting path in this BFS (i.e., a free right node)
          while queue:
              u = queue.popleft()
              for v in graph0[u]:
                  u_next = matchR[v]
                  if u_next == -1:
                      found = True   # we don't break, because we want to set the dist for all?
                  elif u_next != -1 and dist[u_next] == -1:   # note: if u_next is -1, we don't do this
                      dist[u_next] = dist[u] + 1
                      queue.append(u_next)

          return found

      def dfs(u):
          for v in graph0[u]:
              u_next = matchR[v]
              if u_next == -1:
                  matchR[v] = u
                  matchL[u] = v
                  return True
              if dist[u_next] == dist[u] + 1:   # it is in the next layer
                  if dfs(u_next):
                      matchR[v] = u
                      matchL[u] = v
                      return True
          return False

      matching_count = 0
      while bfs():
          for u in range(A):
              if matchL[u] == -1:
                  if dfs(u):
                      matching_count += 1

      ans = A + B - matching_count
      print(ans)

  However, note: in the BFS, we return 'found'. In the BFS, we set the dist for all left nodes that are in the alternating tree? 
      The condition for the BFS: if we found at least one free right node, then we will have an augmenting path? 
      But we return found, and then we do DFS.

  We hope this is correct.

  Let us test with a small complete graph: A=2, B=2, and graph[0]=[0,1], graph[1]=[0,1]

      Initially: 
          matchL = [-1,-1], matchR = [-1,-1]

      BFS for the first phase:
          u0: dist[0]=0, u1: dist[1]=-1 (because not free? initially free) -> wait, initially free? 
          Actually, initially all left nodes are free? 
          So we set dist[0]=0, dist[1]=0? -> no, we set for free left nodes: dist[i]=0, and then append both.

          Then we process u0 (dist=0):
             v0: u_next = matchR[0] = -1 -> found=True
             v1: u_next = -1 -> found=True
          Then we process u1 (dist=0):
             same.

          Then we return found=True.

          Then we do DFS for u0: 
             try v0: 
                 u_next = matchR[0] = -1 -> then we set matchR[0]=0, matchL[0]=0, and return True -> matching_count=1.
          Then for u1: 
             if matchL[1] is -1? yes.
             try v0: u_next = matchR[0]=0 -> then we require dist[0] (which is 0) to be dist[u1]+1? -> dist[u1] is not set? 
                 In BFS, for u1 we did set dist[1]=0? 
                 But then in the BFS, we updated dist for other nodes? 
                 However, after the BFS, we don't reset dist? 

          But wait, we do BFS once, then we do DFS for all free left nodes? 

          In the next phase: we do BFS again? 

          For the next phase:
            matchL[0]=0 -> not free, so dist[0] = -1 initially.
            matchL[1]=-1 -> free, so dist[1]=0, and we do BFS:
                queue: [1]
                u=1: 
                   v0: u_next = matchR[0] = 0 -> which is not -1, then we check dist[0] (currently -1) -> so we set dist[0]=dist[1]+1=1, and push 0.
                Then u=0 (dist=1):
                   for v in graph0[0]: [0,1]
                     v0: u_next = matchR[0]=0 -> which is not -1? and then we look at dist[0] for the next? 
                         But we are at u0, then for v0: u_next=0, and we check if dist[0] has been set? it has (to 1), and we've already pushed it? 
                   v1: u_next = matchR[1] = -1 -> then found=True.

                So BFS returns True.

            Then we do DFS for u1: 
                try v0: 
                    u_next = matchR[0]=0 -> then we check if dist[0] == dist[1]+1? -> dist[1]=0, dist[0]=1 -> yes.
                    then we do dfs(0): 
                       for v in graph0[0]: [0,1]
                         v0: u_next = matchR[0]=0 -> but then we are at node0, and we are matching v0 again? 
                             actually, we are not allowed to reuse the edge (0,0) because it is matched? 
                         But in the DFS, we are allowed to use the edge (0,0) because it is matched? 
                         How: 
                             We try to find an alternative for 0: 
                                for v in graph0[0]: 
                                  v0: matchR[0]=0 -> but then we look for the next edge: 
                                  v1: matchR[1] = -1 -> then we set matchR[1]=0, matchL[0]=1? 
                                  then we return True.

                       so in dfs(0): 
                           try v0: we try to find an alternative for node0? 
                           try v1: free, so set matchR[1]=0, matchL[0]=1, and return True.

                    then in the call for u1: we then set matchR[0]=1, and matchL[1]=0? 
                    then return True.

                Then matching_count becomes 2.

            Then the while condition: do BFS again? 
                matchL = [1,0] -> no free left node? so BFS: 
                    no free left node, so no queue, and we return found=False -> break.

            Then ans = A+B - 2 = 2+2-2 = 2.

            But the maximum matching is 2, and then we cover both empty rows and empty columns? 
            But empty rows:2, empty columns:2, then ans=2.

            Without the matching, we would have 2+2=4, then subtract 2 gives 2.

      This is correct.

  We implement accordingly.

  Note: if there are no empty rows or no empty columns, then we don't build the graph? 

  But the graph might be for A=0 or B=0? 

      If A==0, then we skip the matching -> matching_count=0, then ans = 0+B = B.
      If B==0, then ans = A+0 = A.

  This is correct.

  Let's code accordingly.

  However, note: if there are no empty rows and no empty columns, then A=0, B=0, ans=0.

  We'll do:

      import sys
      from collections import deque

      # Read input...

      # ... (then compute emptyRows, emptyCols, and build graph for the bipartite graph on emptyRows and emptyCols)

      A = len(emptyRows)
      B = len(emptyCols)

      # Build graph0: for left nodes in range(A), graph0[i] = list of j (index in emptyCols) such that grid[emptyRows[i]][emptyCols[j]] is '.'

      graph0 = [[] for _ in range(A)]
      for i in range(A):
          r = emptyRows[i]
          for j in range(B):
              c = emptyCols[j]
              if grid[r][c]=='.':
                  graph0[i].append(j)

      # Now, matching on graph0: left nodes [0, A-1] to right nodes [0, B-1]
      if A==0 or B==0:
          print(A+B)
          exit(0)

      matchL = [-1] * A
      matchR = [-1] * B
      dist = [-1] * A

      def bfs():
          nonlocal dist
          queue = deque()
          for i in range(A):
              if matchL[i] == -1:
                  dist[i] = 0
                  queue.append(i)
              else:
                  dist[i] = -1

          found = False
          while queue:
              u = queue.popleft()
              for v in graph0[u]:
                  u_next = matchR[v]
                  if u_next == -1:
                      found = True
                  elif u_next != -1 and dist[u_next] == -1:
                      dist[u_next] = dist[u] + 1
                      queue.append(u_next)

          return found

      def dfs(u):
          for v in graph0[u]:
              u_next = matchR[v]
              if u_next == -1:
                  matchR[v] = u
                  matchL[u] = v
                  return True
              if dist[u_next] == dist[u] + 1:
                  if dfs(u_next):
                      matchR[v] = u
                      matchL[u] = v
                      return True
          return False

      matching_count = 0
      while bfs():
          for u in range(A):
              if matchL[u] == -1:
                  if dfs(u):
                      matching_count += 1

      ans = A + B - matching_count
      print(ans)

  But note: the condition in the BFS: 
        if u_next == -1: then found=True (but we continue to set the dist for the entire tree? )

  This is correct.

  However, the DFS might be called many times? but the number of free nodes reduces.

  We hope this works.

  Let us test with the sample: 
        emptyRows = [0] -> A=1
        emptyCols = []   -> B=0 -> then we print A+B=1.

  But the sample has emptyCols = []? 
        In the sample: 
            row0: "...." -> no dry land? -> empty row.
            columns: 
                col0: in row1: '.' -> not dry? but in row2: '#' -> so col0 is not empty.
                similarly col1, col2, col3: not empty? 
            so emptyCols = []? 
        Then we print 1.

  This matches.

  But the sample also changed one cell? and the answer is 1.

  Therefore, we output 1.

  We hope it is correct.

  We'll run the code on the sample input.

  Sample input:
      4 4
      ....
      .###
      ##..
      ###.

  We compute:

      row0: "...." -> no '#' -> rowEmpty[0]=True.
      row1: ".###" -> has '#' -> rowEmpty[1]=False.
      row2: "##.." -> has '#' -> rowEmpty[2]=False.
      row3: "###." -> has '#' -> rowEmpty[3]=False.

      col0: 
          row0: '.' -> not dry? 
          row1: '.' -> not dry? 
          row2: '#' -> dry -> so col0 is not empty.
      col1:
          row0: '.' -> not dry
          row1: '#' -> dry -> not empty.
      col2:
          row0: '.' -> not dry
          row1: '#' -> dry -> not empty.
      col3:
          row0: '.' -> not dry
          row1: '#' -> dry -> not empty.

      Therefore, emptyRows = [0], emptyCols = [].

      Then we output 1.

  So it works.

  Now, we hope that the Hopcroft-Karp is efficient.

  We'll submit.