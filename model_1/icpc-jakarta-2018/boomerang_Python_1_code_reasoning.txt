 We are going to follow the editorial guidelines but note that the constraints are up to 100000 edges.
 However, using sets for each vertex (which are implemented as hash sets) might be acceptable in C++ but in Python we have to be cautious.

 We note:
   - Each edge is stored in two sets.
   - We will maintain an array (list) of sets for the graph: `g = [set() for _ in range(n+1)]`
   - We maintain a queue (collections.deque) for vertices that have at least 2 edges.
   - We also maintain a list `in_queue` to avoid duplicate enqueue.

 Steps:
   1. Read input: n, m and the edges.
   2. Build the graph: for each edge (u, v), add v to g[u] and u to g[v].
   3. Initialize a queue and a boolean list `in_queue` (size n+1) to mark if a vertex is in the queue.
   4. For each vertex from 1 to n, if the degree >= 2, then add it to the queue and mark in_queue as True.
   5. Process the queue until empty:
        pop a vertex v.
        If the current degree of v is less than 2, skip.
        Otherwise, remove two distinct neighbors: 
            a = pop one neighbor (we can use next(iter(g[v])))
            then remove a from g[v] and remove v from g[a].
            Similarly, b = pop one neighbor from g[v] (if any) and remove the edge (v, b) and (b, v).
        Then we record the boomerang (a, v, b) [Note: the problem output order: u, v, w meaning (a, v) and (v, b)].

        After removing these edges, we check the three vertices: v, a, b. 
        For each of these, if the degree becomes at least 2 and they are not in the queue, then add them to the queue and mark in_queue.

   6. Output the number of boomerangs and then each boomerang.

 However, note: when removing an edge, the degree of a and b decreases. We must check after updating.

 Important: We must ensure that we don't remove an edge twice and that we do not process a vertex that has been reduced to less than two edges.

 But note: what if the vertex v still has more edges? Then we will process it again when it is enqueued.

 But we only enqueue a vertex when its degree becomes >=2 and it is not already in the queue.

 However, we must note that after removing two edges, v might have more edges? Then we leave it to be processed again when we enqueue it? 
 But we are removing two edges at once, and then we enqueue v again only if after removal its degree is still >=2? Actually, we remove two edges so the degree of v is decreased by 2. So if it had 3 edges, then after removal it has 1 -> so we skip. But if it had 4, then it becomes 2 -> we enqueue.

 But we also enqueue a and b? Because they lost one edge. So if they had 3 edges and we remove one, they become 2 -> we enqueue.

 But note: we might have already removed edges from a and b in previous steps. So we have to check their current state.

 However, we must be cautious: the same vertex might be enqueued multiple times. We have the `in_queue` flag to avoid duplicates.

 Implementation:

   We'll use:
      g = [set() for _ in range(n+1)]
      in_queue = [False] * (n+1)
      q = deque()

   Steps for each vertex v from the queue:

        while q:
            v = q.popleft()
            in_queue[v] = False

            if len(g[v]) < 2:
                continue

            # Take two distinct neighbors: we remove them from the graph
            a = g[v].pop()
            # Now remove v from g[a]
            g[a].remove(v)

            b = g[v].pop()
            g[b].remove(v)

            # Record the boomerang: (a, v, b)
            ans.append((a, v, b))

            # Now we have to check v, a, b: if they have at least 2 edges and not in_queue, then add to queue.
            for u in [v, a, b]:
                # Only if the vertex still has at least two edges and is not currently in the queue.
                if len(g[u]) >= 2 and not in_queue[u]:
                    in_queue[u] = True
                    q.append(u)

   But note: what if we remove an edge from a and then a becomes 2? Then we enqueue a. Similarly for b and v.

   However, what if a or b becomes less than 2? Then we skip.

   Also note: if a or b are the same as v? That shouldn't happen because we are popping distinct neighbors.

   But what if the same neighbor is popped twice? We popped two distinct neighbors because we remove the first one from the set and then the next one is different.

   However, what if the set changes during removal? Actually, we remove two distinct edges.

   But caution: what if after removing the edge (v, a), the vertex a is processed and then we remove (v, b) and then the graph state changes? 
   Actually, we are processing one boomerang at a time.

   However, note that we are removing the two edges from the graph and then updating the sets. This is done sequentially.

   But what if the two edges are the same? They are not: we pop two distinct elements from the set.

   But what if the set becomes empty after the first pop? Then we cannot pop the second. However, we check the condition: we require at least two edges. So after popping one, we still have at least one? Actually, we check at the beginning: we require at least two edges. Then we pop one and then we pop the second. But if the set becomes empty after the first pop? Then we have a problem. However, we are popping two in a row. So we must have at least two at the beginning.

   Therefore, the above procedure is valid.

   However, note: what if the vertex v has exactly two edges? Then after popping two, the set becomes empty. Then when we check v, we skip because len(g[v]) becomes 0.

   Similarly, for a: if a had exactly two edges (one of which was (a,v)) then after removing (a,v), a has one edge -> so we don't enqueue. If it had three, then we enqueue.

   But there's a catch: what if the same vertex is already in the queue? We avoid duplicate by the `in_queue` flag.

   However, consider: we are processing v, and then we remove an edge from a. Then we check a: if a is not in the queue and now has degree>=2, we enqueue. But what if a was already in the queue? Then we skip.

   But when we removed the edge from a, we did not immediately update the queue? Actually, we only update the queue for a at the end of processing the current vertex. So if a was already in the queue (from before) and now its degree is reduced to 2? Actually, we are removing one edge from a, so if a had 3 and becomes 2, we enqueue? But if a was already in the queue, we skip. However, we must note: if a was in the queue but then we reduced its degree, then when we later pop a from the queue we check and see that it has less than 2? Then we skip. That is acceptable.

   Alternatively, we could avoid enqueuing a vertex that is already in the queue.

   This algorithm is greedy and works because we are always taking two edges at a time and then updating the graph. Since each edge is used at most once, the algorithm runs in O(m) operations? But the set removals are O(degree) per vertex? Actually, the removals are O(1) for each edge removal? In Python, set removal is O(1) average.

   However, we are using a set for each vertex. The total number of edges is m, and each edge is stored in two sets. So the total memory is O(m). The total operations: each edge is removed once. Each time we remove an edge, we do two set removals. Then the total operations are O(m). However, the queue operations: each vertex may be enqueued at most (degree(v) // 2) times? Actually, each time we take two edges from a vertex, so the vertex can be processed at most (degree(v) // 2) times? But we enqueue the vertex again only when after removal it still has at least two edges. So the total queue operations are at most O(m) because each time we remove two edges.

   Therefore, overall time complexity is O(m) on average for the set operations? Actually, set removals and pops are O(1) average.

   But note: we are popping two edges from v. The set pop() for the first element: how is that done? `g[v].pop()`: for a set, pop() removes and returns an arbitrary element. It is efficient.

   However, worst-case set operations in Python are O(n) per operation? But typically we assume amortized O(1). But worst-case the entire set might be stored in a way that causes collisions? Actually, worst-case set operations are O(n) per operation only if there are many collisions. But the sets are for edges, and the total edges per vertex can be high. However, worst-case we have a star graph: one vertex with n-1 edges. Then we are popping two edges at a time and then updating the others. But the set operations for the star center: popping two edges is O(1) per pop? Actually, set pop is O(1) average.

   Given the constraints (m, n up to 100000), we hope that the set operations are efficient enough.

   But note: worst-case we might have 100000 edges for one vertex? Then the set for that vertex is large. But the operations (pop and remove) are O(1) on average. So overall the algorithm should run in O(m) time.

   However, worst-case the entire graph might be processed by repeatedly removing two edges from each vertex and updating the neighbors.

   We'll implement as described.

   Let's test with sample input #1:

        Edges: [ (1,2), (1,4), (2,3), (2,4), (2,5), (3,4), (3,5) ]

        Initially, the degrees:
           1: 2 -> enqueue
           2: 4 -> enqueue
           3: 3 -> enqueue
           4: 3 -> enqueue
           5: 2 -> enqueue

        We start by processing (the queue order depends: we can use deque and the order of insertion? The algorithm does not specify the order, so any order is acceptable as long as we get the maximum. But note: the sample output uses boomerangs: (4,1,2), (4,3,2), (2,5,3). 

        However, we must note: the boomerang (4,1,2) uses edges (4,1) and (1,2). Then (4,3,2) uses (4,3) and (3,2). Then (2,5,3) uses (2,5) and (5,3)? But wait, the sample output says: 
            "4 1 2"
            "4 3 2"
            "2 5 3"

        But the boomerang (2,5,3) uses (2,5) and (5,3). However, the edge (3,5) is given, but (5,3) is the same as (3,5). But note: the sample output does not have an edge (3,5) in the boomerangs? Actually, the third boomerang uses (2,5) and (2,3) is already used? 

        Actually, the sample output is:

            boomerang1: 4,1,2 -> edges (4,1) and (1,2)
            boomerang2: 4,3,2 -> edges (4,3) and (3,2)  [but note: the edge (3,2) is the same as (2,3)]
            boomerang3: 2,5,3 -> edges (2,5) and (5,3) [but wait, the edge (5,3) is the same as (3,5)]

        The edges used: 
            (1,4) -> used in boomerang1? Actually, the boomerang1 is (4,1,2): so (4,1) and (1,2). 
            Then boomerang2: (4,3,2): (4,3) and (3,2) [which is (2,3)].
            Then boomerang3: (2,5,3): (2,5) and (5,3) [which is (3,5)].

        The edges used: (1,4), (1,2), (4,3), (2,3), (2,5), (3,5). That's 6 edges. But the graph has 7 edges: the edge (2,4) is left? 

        However, the sample output says 3 boomerangs. And the sample input has 7 edges. We are using 6 edges. The sample output is one possible solution.

        But our algorithm: we can form a boomerang with center 1: 
            edges (1,2) and (1,4) -> boomerang (2,1,4) OR (4,1,2) -> we record (4,1,2) [if we pop 4 first then 2?]

        Then we remove edges (1,2) and (1,4). Then vertex 1 becomes isolated. Then we remove edges incident to 1? Then we update neighbors: 2 and 4.

        For vertex 2: originally had edges: [1,3,4,5]. After removing (1,2), we have [3,4,5]. Then we remove (1,4) from 4: so 4 originally had [1,2,3] -> becomes [2,3]. Then we update: 
            Now the graph has:
                2: [3,4,5] -> degree 3 -> still in the queue? Actually, we marked it as in_queue? But we removed one edge from 2? Then we did not update the queue for 2 during the first boomerang? We only update at the end of the boomerang? Actually, in the first boomerang we processed center 1. Then we update the three vertices: 1,4,2. But 1 is now degree 0 -> skip. 4: now degree 2 -> if it wasn't in the queue? Actually, we have a queue and we mark in_queue. After processing 1, we remove 1 from the queue? Then we mark in_queue[1] as false. Then we enqueue 4 (if not in queue) and 2 (if not in queue). But 2 was in the queue? Then we don't enqueue again. Similarly 4: we mark it as in_queue? Actually, we had enqueued 4 initially? Then we removed it? Then when we process the next vertex, we have to re-enqueue? 

        How we manage the queue: 
            We start with all vertices with deg>=2 in the queue and marked in_queue as True.
            Then we pop vertex 1 -> mark in_queue[1] = False.
            Then we remove two edges: (1,4) and (1,2). Then we update 1,4,2: 
                1: now deg=0 -> skip.
                4: deg becomes 2 -> and in_queue[4] was True (because initially we put it) but we haven't popped it? Actually, we haven't popped 4 yet. But we are going to check: after processing 1, we consider the three vertices: 1,4,2. 
                For 4: if deg>=2 and not in_queue[4] -> but in_queue[4] is True (from initial) -> so we skip? Then we don't enqueue 4 again.

            Similarly for 2: in_queue[2] is True -> we skip.

        Then the queue still has: 2,3,4,5.

        Then we pop the next vertex. Let's say we pop 2. Then we see: g[2] has [3,4,5] (size 3). Then we pop two edges: 
            a = g[2].pop() -> say we get 3. Then remove 2 from g[3] -> g[3] originally: [2,4,5] -> becomes [4,5]. 
            b = g[2].pop() -> say we get 4. Then remove 2 from g[4] -> g[4]: originally [2,3] -> becomes [3]. 
            Then we form boomerang: (3,2,4) -> but the sample output has (4,3,2) which is the same as (3,2,4) but with different order? Actually, the boomerang is represented as (a, v, b) = (3,2,4). But the problem does not specify the order of the two edges? However, the sample output writes the center in the middle. So we can output as (3,2,4) or (4,2,3)? But note the sample output: 
                "4 3 2" -> that would be center 3? Actually, no: the boomerang (4,3,2) means two edges: (4,3) and (3,2). So the center is 3.

        But we formed a boomerang with center 2: (3,2,4). That uses edges (2,3) and (2,4). Now the graph has:
            Edge (2,5) is still present? 
            Also, the edge (3,4) and (3,5) are still there.

        Then we update the three vertices: 2,3,4.
            g[2]: now has [5] -> deg=1 -> skip.
            g[3]: [4,5] -> deg=2 -> we enqueue 3 if not in_queue? Currently, in_queue[3] was True (from initial) and we haven't popped 3? So we skip? 
            g[4]: [3] -> deg=1 -> skip.

        Then we pop next: 3. Then g[3] has [4,5] (size 2). Then we pop two edges: 
            a = g[3].pop() -> 4 -> remove 3 from g[4]: g[4] becomes empty.
            b = g[3].pop() -> 5 -> remove 3 from g[5]: g[5] originally [2,3]? But we had edge (2,5) and (3,5). We haven't removed (2,5) yet? Actually, we did: we removed (2,5) from vertex 2? No, we didn't. When we processed vertex 2, we only removed (2,3) and (2,4). The edge (2,5) is still present. Then for vertex 5: we had edge (2,5) and (3,5). So after removing (3,5), g[5] becomes [2] -> so deg=1.

            Then we form boomerang: (4,3,5).

        Then we update: 3,4,5: 
            3: now empty -> skip.
            4: empty -> skip.
            5: [2] -> skip.

        Then we have three boomerangs: 
            (4,1,2)   -> edges (1,4), (1,2)
            (3,2,4)   -> edges (2,3), (2,4)   [but wait, we also had edge (2,5) still present? Then why did we not use it?]

        Actually, we formed the third boomerang: (4,3,5) -> edges (3,4) and (3,5). But the edge (2,5) is still present and not used? 

        Then we have used edges: 
            (1,4), (1,2), (2,3), (2,4), (3,4), (3,5) -> that's 6 edges. The edge (2,5) is left.

        But we have no boomerang for the edge (2,5)? Because we need two edges incident to 2? But after the second boomerang, vertex 2 only had one edge: (2,5). So we cannot form a boomerang with center 2. Similarly, vertex 5: had two edges: (2,5) and (3,5). But we used (3,5) in the third boomerang? Then the edge (2,5) is left.

        However, we could have formed a boomerang with center 5? But initially 5 had two edges: (2,5) and (3,5). Then after the first two boomerangs, we did not remove any edge incident to 5? Then when we processed 5? Actually, we enqueued 5 initially. Then we processed vertex 1, then vertex 2. After processing vertex 2, we updated: 5 was not updated? Actually, when we processed vertex 2, we only removed edges (2,3) and (2,4). The edge (2,5) remains. Then 5 still has two edges: (2,5) and (3,5). Then we should have processed 5 at some point.

        But after processing vertex 1, we updated 2 and 4 and 1. Then we processed vertex 2. After processing vertex 2, we updated 2,3,4. Then we enqueued 3? Actually, we didn't enqueue 3 because it was already in the queue? Then we then processed vertex 3? But then we also have vertex 5: which is still in the queue? Because we never popped it? 

        The queue initially: [1,2,3,4,5]. Then we pop 1 -> then we pop 2 -> then we pop 3? Then we still have 4 and 5? But after processing 2, we did not enqueue 5? Because 5 was updated only when we processed vertex 3? Actually, no: when we processed vertex 2, we did not remove any edge incident to 5? Then 5 still has two edges? Then it is still in the queue? 

        Then after processing vertex 3, we pop next: 4? Then g[4] has [3] -> skip. Then we pop 5: then g[5] has [2,3] -> size 2. Then we pop two edges: 
            a = pop from g[5] -> say 2 -> remove 5 from g[2]: g[2] becomes [5]? Actually, we had g[2] after the second boomerang: we removed two edges (3 and 4) so g[2] was left with [5]. Then we remove 5 from g[2] -> g[2] becomes empty. Then we pop another edge from g[5]: 
            b = pop from g[5] -> 3 -> remove 5 from g[3]: but g[3] is now empty? Actually, we already removed the edges from 3? 

        Actually, in the third boomerang we processed center 3 and we removed edges (3,4) and (3,5). So g[3] becomes empty? Then when we try to remove (5,3) from g[3] in the processing of center 5? It fails? 

        This is a problem: we must not have an edge (5,3) if we have already removed it in the third boomerang.

        Therefore, we must note: when we remove an edge, we remove it from both ends. So if we remove (3,5) when processing center 3, then the edge (5,3) is also removed. So when we process center 5, the set g[5] should not have 3? 

        How did we remove it? 
            When processing center 3: 
                a = g[3].pop() -> 4 -> then remove 3 from g[4] -> then we do: g[4].remove(3) -> then 
                b = g[3].pop() -> 5 -> then remove 3 from g[5] -> g[5].remove(3) -> then the edge (5,3) is gone.

        So after processing center 3, g[5] should be [2] only? Then we do not have two edges for center 5.

        Therefore, we have only two boomerangs? But the sample output has three.

        What went wrong? We should have formed the boomerang at center 5 earlier? 

        Alternative: 
            After the first boomerang (center 1): edges (1,4) and (1,2) are removed.
            Then the graph has:
                2: [3,4,5] -> deg=3
                3: [2,4,5] -> deg=3
                4: [2,3]    -> deg=2
                5: [2,3]    -> deg=2

            Then we have several choices: 
                Center 2: we can take two edges: for example (2,3) and (2,5) -> then form (3,2,5). Then remove these edges. Then the graph becomes:
                    2: [4] -> deg=1
                    3: [4] -> deg=1
                    4: [2,3] -> but (2,4) and (3,4) are still there? Actually, we removed (2,3) and (2,5) and (5,2) and (5,3) are still there? 
                Actually, we removed (2,3) and (2,5). Then we update:
                    g[2]: remove 3 and 5 -> becomes [4]
                    g[3]: remove 2 -> becomes [4,5] -> but we also have edge (3,5) still? Actually, we did not remove (3,5). Then g[3] has [4,5] -> deg=2 -> then we can form a boomerang at center 3: (4,3,5). Then we use edges (3,4) and (3,5). 
                Then we have three boomerangs: 
                    (4,1,2), (3,2,5), (4,3,5) -> then we have used 6 edges: (1,4), (1,2), (2,3), (2,5), (3,4), (3,5). The edge (2,4) is left? 

            But the sample output: 
                4 1 2
                4 3 2   -> which uses edges (4,3) and (3,2) [which is (2,3)]
                2 5 3   -> which uses edges (2,5) and (5,3) [which is (3,5)]

            Then the edge (2,4) is left? But the sample output does not use (2,4). So the sample output does not use the edge (2,4). 

        How did the sample output use 3 boomerangs? 
            They are: 
                (4,1,2): (4,1) and (1,2) -> edges 1-4 and 1-2.
                (4,3,2): (4,3) and (3,2) -> edges 4-3 and 3-2.
                (2,5,3): (2,5) and (5,3) -> edges 2-5 and 5-3.

            The edges used: 1-4, 1-2, 4-3, 3-2, 2-5, 5-3. The edge 2-4 is not used.

        Therefore, the algorithm must avoid using the edge (2,4) in any boomerang? 

        How can we achieve the sample output? 
            We must form a boomerang at center 1 first: (4,1,2) -> then remove edges (1,4) and (1,2). 
            Then the graph has:
                2: [3,4,5] -> deg=3
                3: [2,4,5] -> deg=3
                4: [2,3]    -> deg=2
                5: [2,3]    -> deg=2

            Then we form a boomerang at center 4: 
                We need two edges incident to 4: (4,2) and (4,3) -> then we form (2,4,3) -> which can be output as (2,4,3) or (3,4,2) or (2,4,3). But the sample output has (4,3,2) meaning center 3? 

            Alternatively, we form a boomerang at center 3: 
                We have edges: (3,2), (3,4), (3,5). 
                We choose (3,4) and (3,2) -> then form (4,3,2). Then we remove these edges. Then the graph becomes:
                    2: [5] -> and the edge (2,3) is removed, so 2 has [5] and the edge (2,4) remains? Actually, we removed (2,3) and (4,3) but not (2,4). 
                    Actually, we did not remove (2,4)? We removed (3,2) and (3,4). Then the edge (2,4) is still present? 
                Then we have: 
                    g[2]: [4,5] -> because originally 2: [3,4,5] -> we removed (2,3) -> then becomes [4,5]. Then we remove (2,3) from the set? Actually, when we form the boomerang at center 3: 
                        we remove (3,2) -> then we remove (2,3) from g[2]. Then g[2] becomes [4,5]. 
                    Then we remove (3,4) -> then we remove (4,3) from g[4]: then g[4] becomes [2] (because originally [2,3] -> remove 3 -> then [2]).
                Then we form boomerang (4,3,2). Then we update: 
                    Check 3: now has [5] -> skip.
                    Check 2: has [4,5] -> deg=2 -> enqueue? 
                    Check 4: has [2] -> skip.

            Then we have the queue: [2,5] (and 5 is still there). Then we pop 2: 
                g[2]: [4,5] -> we form a boomerang: 
                    pop one edge: say 4 -> then remove 2 from g[4]: g[4] becomes empty.
                    pop next: 5 -> then remove 2 from g[5]: g[5] becomes [3] (because originally [2,3] -> we removed (3,5) when processing center 3? Actually, we did not remove (3,5) in the center 3 boomerang? We only removed (3,2) and (3,4). Then the edge (3,5) is still there? 
                Then we form (4,2,5). Then we update: 
                    g[2] becomes empty -> skip.
                    g[4]: empty -> skip.
                    g[5]: [2,3]? But we removed (5,2) -> then g[5] becomes [3] -> skip.

            Then we have three boomerangs: 
                (4,1,2)
                (4,3,2)   -> but wait, we just did (4,2,5) -> that uses (2,4) and (2,5). 
                But the sample output has (4,3,2) and (2,5,3). 

        Therefore, we must form the boomerang at center 3 with edges (3,4) and (3,2) for the second boomerang, and then form the third boomerang at center 2 with edges (2,5) and (2,3)? But we already removed (2,3) in the second boomerang? 

        How to form (2,5,3)? That requires edges (2,5) and (5,3). The center is 5? Then we can form at center 5: 
            After the second boomerang, we have:
                g[2]: [4,5] -> but we removed (2,3) so that edge is gone? 
                g[5]: [2,3] -> deg=2 -> so we can form at center 5: 
                    pop one edge: 2 -> then remove 5 from g[2]: g[2] becomes [4]
                    pop next: 3 -> then remove 5 from g[3]: g[3] becomes [4] (because we removed (3,2) already, so now we remove (3,5) -> then g[3] becomes [4] -> but wait, we also had (3,4) removed? 
            Actually, we removed (3,4) in the second boomerang? Then after the second boomerang, g[3] is [5]? Then we cannot form a boomerang at center 5: because we need two edges? 

        Alternatively, after the first boomerang, we form a boomerang at center 5: 
            g[5]: [2,3] -> then we form (2,5,3). Then remove edges (5,2) and (5,3). Then the graph:
                g[2]: [3,4] -> deg=2 -> enqueue 2? 
                g[3]: [2,4] -> deg=2 -> enqueue 3?
                g[5]: empty -> skip.

            Then we form a boomerang at center 2: 
                edges: (2,3) and (2,4) -> then form (3,2,4). Then remove these edges. Then the graph has no more edges.

            Then we have three boomerangs: 
                (4,1,2) -> edges (1,4), (1,2)
                (2,5,3) -> edges (2,5), (5,3)  [which is (3,5)]
                (3,2,4) -> edges (2,3), (2,4)

            This uses all edges? But the graph has 7 edges: we used 6? The edge (3,4) is left? 

        How about: 
            After the first boomerang and the center 5 boomerang, we have:
                g[2]: [3,4] -> deg=2
                g[3]: [2,4] -> deg=2
                g[4]: [2,3] -> deg=2

            Then we form a boomerang at center 2: (3,2,4) -> then remove (2,3) and (2,4). Then we update:
                g[3]: [4] -> skip
                g[4]: [3] -> skip
            Then we form a boomerang at center 3? No, because g[3] has only one edge. 
            Then we form a boomerang at center 4? g[4] has one edge. 

        Then we have only three boomerangs? 

        But the sample output uses the edge (3,4) in the second boomerang? 

        The key: the algorithm is greedy and the order of processing affects the result. However, we are guaranteed that the maximum number is the same? 

        We are only required to output the maximum number of disjoint boomerangs and any set achieving that maximum.

        Therefore, we can output any valid set of disjoint boomerangs that achieves the maximum. 

        In the sample input, the maximum is 3. So we can output any set of 3 boomerangs that are disjoint. 

        Therefore, we do not have to match the sample output exactly.

        However, the sample output #1: 
            3
            4 1 2
            4 3 2
            2 5 3

        This set uses 6 edges: (4,1), (1,2), (4,3), (3,2), (2,5), (5,3). The edge (2,4) is left.

        Our algorithm might output a different set of 3 boomerangs.

        But the problem says: "If there is more than one valid solution, you can output any of them."

        Therefore, we are safe.

        However, we must be cautious: we are using a queue and the order of popping may affect the boomerangs we form. We are using a FIFO queue? 

        But we can use a deque: we append at the end and pop from the front.

        Alternatively, we can use a stack? The editorial does not specify. But we use a queue.

        Let's try to run the sample input #1 with our algorithm and see what we get.

        Steps:

          g = 
            1: {2,4}
            2: {1,3,4,5}
            3: {2,4,5}
            4: {1,2,3}
            5: {2,3}

          in_queue: initially [False]*(n+1)
          q = deque([1,2,3,4,5]) and mark in_queue[1..5] as True.

          Step1: pop 1 -> 
                g[1] = {2,4} -> pop two: 
                  a = 2 -> remove 1 from g[2]: g[2] becomes {3,4,5}
                  b = 4 -> remove 1 from g[4]: g[4] becomes {2,3}
                boomerang: (2,1,4) -> but we can output as (2,1,4) OR (4,1,2) -> we output as (a, v, b) = (2,1,4). 
                Then we check [1,2,4]: 
                  1: deg=0 -> skip
                  2: deg=3 -> and in_queue[2] is True? So skip (we don't enqueue again because it's still in the queue? Actually, we popped 1 and then we will pop next? The queue now has [2,3,4,5] and in_queue flags for these are True. Then we skip.

          Step2: pop 2 -> 
                g[2] = {3,4,5} -> pop two: 
                  a = 3 -> remove 2 from g[3]: g[3] becomes {4,5}
                  b = 4 -> remove 2 from g[4]: g[4] becomes {3}
                boomerang: (3,2,4)
                Then we check [2,3,4]:
                  2: now has {5} -> skip
                  3: deg=2 -> and in_queue[3] is True -> skip
                  4: deg=1 -> skip

          Step3: pop 3 -> 
                g[3] = {4,5} -> pop two:
                  a = 4 -> remove 3 from g[4]: g[4] becomes {} -> skip
                  b = 5 -> remove 3 from g[5]: g[5] becomes {2} -> skip
                boomerang: (4,3,5)
                Then we check [3,4,5]:
                  3: deg=0 -> skip
                  4: deg=0 -> skip
                  5: deg=1 -> skip

          Then we have three boomerangs: 
            (2,1,4)
            (3,2,4)
            (4,3,5)

          But the edges used: 
            (1,2), (1,4) -> from first boomerang
            (2,3), (2,4) -> from second boomerang
            (3,4), (3,5) -> from third boomerang

          The edge (2,5) is left. 

          Then we pop 5: 
                g[5] = {2} -> skip.

          Then we output:
            3
            2 1 4
            3 2 4
            4 3 5

        This is a valid solution? 
          The boomerangs: 
            (2,1,4): edges (2,1) and (1,4) -> valid, and center 1.
            (3,2,4): edges (3,2) and (2,4) -> valid, center 2.
            (4,3,5): edges (4,3) and (3,5) -> valid, center 3.

        The edges used: 
            (1,2), (1,4), (2,3), (2,4), (3,4), (3,5) -> 6 edges. The edge (2,5) is left.

        This is acceptable because the maximum number is 3.

        However, the sample output is:
            3
            4 1 2
            4 3 2
            2 5 3

        Which uses different boomerangs. 

        We are allowed to output any.

        But note: the problem does not require the boomerang to be output in a particular order? The boomerang representation: 
            The sample output: 
                "4 1 2" -> meaning (4,1) and (1,2) -> center 1.
                "4 3 2" -> meaning (4,3) and (3,2) -> center 3.
                "2 5 3" -> meaning (2,5) and (5,3) -> center 5.

        Our output: 
            (2,1,4): center 1 -> we can also represent as (4,1,2)? But the problem does not specify the order of the two endpoints. 
            Actually, the boomerang (u, v, w) is defined by the two edges (u,v) and (v,w). Therefore, we can output the two endpoints in any order? 

        However, the sample input and output: 
            Sample Input #1: 
                5 7
                1 2
                1 4
                2 3
                2 4
                2 5
                3 4
                3 5

            Our first boomerang: we have (2,1,4): which uses edges (1,2) and (1,4). 
            We can also output as (4,1,2) to match the sample? 

        But note: the problem does not require a particular order. However, the sample output uses the center in the middle and the two endpoints at the ends. The two endpoints are not ordered? 

        Actually, the boomerang is defined by the common center. The two edges are incident to the center. The representation \(\langle u, v, w \rangle\) must satisfy: the center is v, and the two edges are (u,v) and (v,w). 

        Therefore, we must output the center as the middle number. 

        In our first boomerang: center is 1. The two edges are (1,2) and (1,4). We can output as (2,1,4) or (4,1,2). Both are valid. 

        Similarly, the second boomerang: center 2, edges (2,3) and (2,4) -> we can output as (3,2,4) or (4,2,3). 

        The third: center 3, edges (3,4) and (3,5) -> (4,3,5) or (5,3,4).

        Therefore, we can output:

            3
            4 1 2
            3 2 4
            4 3 5

        But wait: the third boomerang is (4,3,5) -> that's center 3, with edges (4,3) and (3,5). 

        The sample output has a boomerang with center 5: (2,5,3). We did not form that.

        But we formed three boomerangs and that is acceptable.

        Alternatively, we can change the popping order? For example, when we pop the two neighbors, we are popping arbitrarily. We can try to pop the smallest neighbor? But the problem does not require.

        However, we have a problem: the sample input #2 and #3.

        Sample Input #2: 
            4 6
            1 2
            1 3
            1 4
            2 3
            2 4
            3 4

        The sample output: 
            3
            1 2 3
            1 3 4
            1 4 2

        How does our algorithm work?

          g[1]: {2,3,4}
          g[2]: {1,3,4}
          g[3]: {1,2,4}
          g[4]: {1,2,3}

          All vertices have degree 3 -> all in the queue.

          We pop vertex 1: 
                pop two edges: say 2 and 3 -> form boomerang (2,1,3)
                remove edges (1,2) and (1,3): 
                  g[1] becomes {4}
                  g[2] becomes {3,4}
                  g[3] becomes {2,4}
                Then we check [1,2,3]: 
                  1: deg=1 -> skip
                  2: deg=2 -> enqueue? but in_queue[2] is True? Then skip? (it's still in the queue) -> so we don't enqueue again.
                  3: deg=2 -> same.

          Then we pop vertex 2: 
                g[2] = {3,4} -> pop two: 3 and 4 -> form boomerang (3,2,4)
                remove edges (2,3) and (2,4): 
                  g[2] becomes {}
                  g[3] becomes {4}  [because originally {2,4} -> remove 2 -> then {4}]
                  g[4] becomes {1,3}  [because originally {1,2,3} -> remove 2 -> becomes {1,3}]
                Then check [2,3,4]:
                  2: skip
                  3: deg=1 -> skip
                  4: deg=2 -> and in_queue[4] is True -> skip.

          Then we pop vertex 3: 
                g[3] = {4} -> skip.

          Then we pop vertex 4: 
                g[4] = {1,3} -> pop two: 1 and 3 -> form boomerang (1,4,3)
                remove edges (4,1) and (4,3): 
                  g[4] becomes {}
                  g[1] becomes {} (from {4} -> remove 4 -> then {})
                  g[3] becomes {} (from {4} -> remove 4 -> then {})
                Then check [4,1,3]: skip.

          Then we have three boomerangs: 
            (2,1,3)
            (3,2,4)
            (1,4,3)

          But the sample output is:
            1 2 3
            1 3 4
            1 4 2

          Which are all centered at 1. 

          How? 
            They used:
              (1,2) and (1,3) for (2,1,3) -> same as our first.
              Then (1,3) is already used? -> so they use (1,3) again? -> not possible.

          Actually, the sample output: 
            boomerang1: (1,2,3) -> edges (1,2) and (2,3) -> center 2? 
            boomerang2: (1,3,4) -> edges (1,3) and (3,4) -> center 3?
            boomerang3: (1,4,2) -> edges (1,4) and (4,2) -> center 4?

          They used edges: (1,2), (2,3), (1,3), (3,4), (1,4), (4,2). That's all 6 edges.

          How can we form that? 

          Step by step:

            Start: 
              g[1]: {2,3,4}
              g[2]: {1,3,4}
              g[3]: {1,2,4}
              g[4]: {1,2,3}

            We can start with center 2: 
                pop two edges from g[2]: 1 and 3 -> form (1,2,3) -> then remove edges (1,2) and (2,3). 
                Then update:
                  g[1]: {3,4} -> deg=2 -> enqueue 1? 
                  g[2]: {4} -> skip
                  g[3]: {1,4} -> deg=2 -> enqueue 3?
                Then the graph:
                  g[1]: {3,4}
                  g[2]: {4}
                  g[3]: {1,4}
                  g[4]: {1,3}   [because we removed (2,3) and (1,2) from g[4]? Actually, we didn't remove any edge incident to 4?]

            Then we process center 3: 
                pop two edges from g[3]: 1 and 4 -> form (1,3,4) -> then remove (1,3) and (3,4). 
                Then update:
                  g[1]: {4} -> skip
                  g[3]: {} -> skip
                  g[4]: {1} -> skip

            Then we process center 1: 
                g[1]: {4} -> skip

            Then we have two boomerangs? 

          But we have center 4: 
            g[4] = {1,2,3} initially. Then after the first boomerang, g[4] = {1,3} -> then after the second boomerang, we remove (3,4) -> then g[4] = {1}. 

          Then we cannot form the third boomerang? 

          Alternatively, after the first boomerang, we process center 4: 
                g[4] = {1,3} -> then we form (1,4,3) -> but then we remove (1,4) and (4,3). Then the graph:
                  g[1]: {3} -> skip
                  g[4]: {} -> skip
                  g[3]: {1} -> skip
                Then we have two boomerangs.

          How to form three? 

          The sample output uses three boomerangs: 
            center 2: (1,2,3) -> edges (1,2) and (2,3)
            center 3: (1,3,4) -> edges (1,3) and (3,4)
            center 4: (1,4,2) -> edges (1,4) and (4,2)

          But note: the edge (4,2) is the same as (2,4). And the edge (1,4) is used in the third boomerang? But we used (1,4) in the third boomerang? 

          However, after the first boomerang, we removed (1,2) and (2,3). Then the edge (1,4) is still there? Then the edge (4,2) is also still there? 

          Then we can do:

            Step1: center 2: (1,2,3) -> remove (1,2) and (2,3). 
            Step2: center 4: we have g[4] = {1,2,3} -> we pop two edges: 1 and 2 -> form (1,4,2) -> then remove (1,4) and (4,2). 
                Then update:
                  g[1]: {3} -> skip
                  g[2]: {4} -> becomes { }? because we remove (4,2) -> but wait, g[2] originally had {1,3,4} -> then we removed (1,2) and (2,3) -> then g[2] became {4}. Then we remove (4,2) -> then g[2] becomes empty.
                  g[4]: {3} -> skip
            Step3: center 3: g[3] = {1,4} -> then we pop two: 1 and 4 -> form (1,3,4) -> remove (1,3) and (3,4). 

          Then we have three boomerangs. 

          Therefore, the order matters. 

          How to get the sample output? We must process the vertices in an order that allows us to form the three boomerangs. 

          The sample output does not have a fixed order: we must design the queue so that we process vertex 2 first, then vertex 4, then vertex 3.

          But our algorithm: we use a FIFO queue. We initially enqueue: [1,2,3,4]. Then we pop in the order 1,2,3,4? 

          How can we pop 2 first? 

          We can change the initial enqueue to be sorted by something? Or we can use a priority queue? But the problem does not require. 

          Alternatively, we can process vertices in any order? 

          How about we use a stack? Then we pop the last vertex first. 

          Let's try with a stack for sample input #2:

            Stack: [1,2,3,4] -> we push in increasing order, so stack: top=4, then 3, then 2, then 1.

            Step1: pop 1 -> 
                form (2,1,3) -> remove edges (1,2) and (1,3). 
                Then update: 
                  1: deg=1 -> skip
                  2: deg=2 -> push? but not in_stack? we maintain a flag? Actually, we use in_queue flag. When we pop 1, we mark in_queue[1]=False. Then we check 2: deg=2 and not in_queue? Then we push? But we haven't processed the others. 

                But initially, we marked in_queue for 1,2,3,4 as True. After popping 1, we set in_queue[1]=False. Then we check 2: deg=2 and in_queue[2] is True -> so we skip.

            Then we pop 2? -> no, the stack has [2,3,4] -> then we pop 4? 
                g[4]: {1,2,3} -> pop two: 1 and 2 -> form (1,4,2)
                remove (1,4) and (4,2): 
                  g[1]: becomes { } -> skip
                  g[2]: becomes {3} -> skip
                  g[4]: becomes {3} -> skip
                Then we check [4,1,2]: skip.

            Then we pop 3: 
                g[3]: {1,2,4} -> but we removed (1,3) and (1,4) and (4,2) -> actually, g[3] still has {1,2,4}? 
                But we removed (1,3) from g[3]? 
                Actually, when we removed (1,3) in the first boomerang, we removed 1 from g[3] -> then g[3] became {2,4}. 
                Then we removed (4,2) from the second boomerang? That doesn't affect g[3]. 
                Then g[3] = {2,4} -> deg=2 -> we form (2,3,4) -> remove (3,2) and (3,4). 
                Then update: 
                  3: skip
                  2: becomes { } -> skip
                  4: becomes { } -> skip

            Then we have three boomerangs: 
                (2,1,3)
                (1,4,2)
                (2,3,4)

            Which is valid.

          But the sample output used centers 2, 3, 4. We used centers 1,4,3.

          We can output:

            3
            2 1 3
            1 4 2
            2 3 4

          But the sample output is:
            1 2 3
            1 3 4
            1 4 2

          Which is different.

        How to get the sample output? 

          We need to form boomerangs at centers 2, 3, 4. 

          Step1: pop vertex 2 from the stack? 
            Initially, the stack is [1,2,3,4] (with 4 at the top). We want to pop 2 first? Then we should push in reverse order: so stack [4,3,2,1]? Then we pop 1, then 2, then 3, then 4. 

          Alternatively, we can use a queue that is not FIFO but LIFO? 

          But the problem does not require a particular order. 

        Therefore, we can use a stack (LIFO) to get different results. 

        However, the problem does not care about the particular set, as long as the number is maximum.

        For sample input #2, any set of 3 disjoint boomerangs is acceptable.

        For sample input #3: 
            3 3
            1 2
            1 3
            2 3

          The sample output: 
            1
            2 1 3

          How does our algorithm work?

            g[1]: {2,3}
            g[2]: {1,3}
            g[3]: {1,2}

            All vertices have degree 2 -> enqueue all.

            We use a queue: [1,2,3]

            Step1: pop 1 -> 
                pop two edges: 2 and 3 -> form (2,1,3)
                remove edges (1,2) and (1,3): 
                  g[1]: empty
                  g[2]: {3} -> skip
                  g[3]: {2} -> skip
                Then we have one boomerang.

            Then pop 2: 
                g[2]: {3} -> skip
            Then pop 3: 
                g[3]: {2} -> skip

            Output: 
                1
                2 1 3

          Which matches the sample output.

        Conclusion: we'll implement with a queue (FIFO) and hope it passes the constraints. 

        However, worst-case: a star graph with one center and n-1 edges. Then we will process the center repeatedly: 
            The center will be enqueued initially. Then we pop it, remove two edges, then the center has n-3 edges -> which is still >=2? Then we enqueue again. 
            Then we process it again: remove two edges -> then n-5 edges -> and so on.

            The center will be processed about (n-1)/2 times. Each time we remove two edges. The total operations are O(n). 

        Therefore, the overall complexity is O(m) because each edge is removed once.

        But note: we are using set operations which are O(1) average.

        We'll code accordingly.

        One more note: we are using a list for in_queue? We update in_queue when we pop: set to False, and when we enqueue: set to True.

        We must avoid duplicate enqueue.

        Let's code accordingly.

        Steps in code:

          import collections

          n, m = map(int, input().split())
          g = [set() for _ in range(n+1)]
          for i in range(m):
              u, v = map(int, input().split())
              g[u].add(v)
              g[v].add(u)

          in_queue = [False] * (n+1)
          q = collections.deque()
          # Initialize: for vertices 1 to n, if degree>=2, then add to queue and mark in_queue.
          for i in range(1, n+1):
              if len(g[i]) >= 2:
                  in_queue[i] = True
                  q.append(i)

          ans = []

          while q:
              v = q.popleft()
              in_queue[v] = False

              # If due to previous removals, the degree of v is less than 2, skip.
              if len(g[v]) < 2:
                  continue

              # Take two distinct neighbors
              a = g[v].pop()   # This removes an arbitrary element from the set
              g[a].remove(v)

              # Now if after popping the first, the set becomes empty? But we checked at least 2, so there is at least one more.
              b = g[v].pop()
              g[b].remove(v)

              ans.append((a, v, b))

              # Now we consider the three vertices: v, a, b for potential enqueue
              for u in [v, a, b]:
                  # Only if the vertex has at least two edges and is not currently in the queue.
                  if len(g[u]) >= 2 and not in_queue[u]:
                      in_queue[u] = True
                      q.append(u)

          # Output
          print(len(ans))
          for (a, v, b) in ans:
              # The boomerang: two edges (a,v) and (v,b). The problem representation: the center is v.
              print(f"{a} {v} {b}")

        But note: what if we cannot pop two distinct edges? We checked the degree at the beginning. But after popping the first, the set becomes smaller? Then we pop the second. So we assume the set has at least two at the beginning.

        This should work.

        However, we must be cautious: what if the two edges we remove are the same? They are not: we pop two distinct elements.

        Let's test with a small graph: two edges incident to v: 
            g[v] = {a, b} -> then we pop a and then b. Then we remove a and b.

        We'll run the sample input #1 and see the output.

        But note: we are using FIFO: 
            q: [1,2,3,4,5] -> pop 1: 
                g[1]: {2,4} -> pop: 2 and 4 -> then we append (2,1,4)
                Then update: 
                    g[1]: set() -> skip
                    g[2]: originally {1,3,4,5} -> remove 1 -> becomes {3,4,5} -> deg=3 -> and in_queue[2] is True (because we haven't popped it yet) -> so we skip enqueue.
                    g[4]: originally {1,2,3} -> remove 1 -> becomes {2,3} -> deg=2 -> and in_queue[4] is True -> skip.
            Then pop 2:
                g[2]: {3,4,5} -> pop two: 3 and 4 -> append (3,2,4)
                Then update:
                    g[2]: {5} -> skip
                    g[3]: originally {2,4,5} -> remove 2 -> becomes {4,5} -> deg=2 -> and in_queue[3] is True -> skip.
                    g[4]: originally {2,3} -> remove 2 -> becomes {3} -> skip.
            Then pop 3: 
                g[3]: {4,5} -> pop two: 4 and 5 -> append (4,3,5)
                Then update: 
                    g[3]: set() -> skip
                    g[4]: {3} -> remove 3 -> becomes set() -> skip.
                    g[5]: {2,3} -> remove 3 -> becomes {2} -> skip.

            Output: 
                3
                2 1 4
                3 2 4
                4 3 5

        We can also output the boomerangs in the alternative representation? 
            We have:
                (2,1,4) -> we can output as (4,1,2) if we want? But the problem does not require a particular order of the endpoints. 
                However, the representation: we have center 1: so the center is in the middle. The two endpoints are 2 and 4. We output as (2,1,4). 
                But we could have chosen to output as (4,1,2)? 

        The problem: the boomerang \(\langle u, v, w \rangle\) is defined by the two edges (u,v) and (v,w). 
        Therefore, we must have the center in the middle. The first and last are the endpoints. 

        But which endpoint is first? The problem does not specify. 

        However, our algorithm: 
            We pop the two neighbors arbitrarily. The first neighbor we pop is a, and the second is b. Then we output (a, v, b). 
            This corresponds to edges (a,v) and (v,b). 

        But note: the edge (v,b) is the same as (b,v) in an undirected graph. 

        Therefore, the output is valid.

        But the sample output for input1 is:
            4 1 2
            4 3 2
            2 5 3

        How is that valid? 
            First boomerang: (4,1,2) -> edges (4,1) and (1,2) -> center 1.
            Second: (4,3,2) -> edges (4,3) and (3,2) -> center 3.
            Third: (2,5,3) -> edges (2,5) and (5,3) -> center 5.

        We formed centers 1,2,3. 

        But our output is also valid.

        Therefore, we output the code as below.

        However, we note that the problem constraints (n, m up to 100000) and the set removals: worst-case the set removals are O(1) average, but worst-case O(n) per operation? But worst-case overall we do O(m) operations? 

        We hope it passes.

        But note: worst-case the graph might be large. We use sets for each vertex. The total memory is about the sum of the degrees = 2*m, which is acceptable for 100000.

        We'll run on the largest input: 100000 vertices and 100000 edges. The worst-case is a graph that is a collection of stars? 

        We'll submit.

        However, in Python, using set.pop() might be efficient? 

        Let's try.

        But note: the order of popping the two edges does not affect the correctness.

        We write the code accordingly.

        One more note: what if the graph has multiple connected components? The algorithm should work because we process each vertex with at least two edges, regardless of the component.

        Let's run sample input #3: we did.

        Code:

          We use collections.deque.

        We'll now write the code accordingly.

        IMPORTANT: The graph may not be connected? 

        Example: two triangles. 
          Vertices: 1,2,3 in one triangle and 4,5,6 in another.

          Then we can form two boomerangs? 
            In first triangle: 
                edges: (1,2), (2,3), (3,1)
            We can form one boomerang: for example at center 1: (2,1,3) -> then edges (1,2) and (1,3) are used. Then the edge (2,3) is left -> cannot form another boomerang? 
            But we could form at center 2: (1,2,3) -> then we use (1,2) and (2,3). Then the edge (1,3) is left. Then we cannot form a boomerang at center 1? 

          Actually, the maximum is 1 per triangle? 

          But the entire graph has 6 edges -> maximum boomerangs is 3? 

          However, in a triangle we can form only one boomerang? 

          But the sample input #3: a triangle -> maximum 1.

          Therefore, two triangles: maximum 2.

          How? 
            Triangle 1: 
              center 1: (2,1,3) -> uses (1,2) and (1,3) -> leaves (2,3) -> but we cannot form a boomerang with center 2? because (2,1) is gone and (2,3) is there -> but we need two edges at 2: only one. 
            Alternatively, in triangle 1: 
              center 2: (1,2,3) -> uses (1,2) and (2,3) -> leaves (1,3) -> then we can form a boomerang at center 1: no, because only one edge. 
            Then only one per triangle? 

          But wait: we could form a boomerang in the second triangle similarly.

          Then we get two boomerangs.

          Therefore, the algorithm should form one boomerang in each triangle.

          How? 
            We have two triangles: 
              g[1]: {2,3}
              g[2]: {1,3}
              g[3]: {1,2}
              g[4]: {5,6}
              g[5]: {4,6}
              g[6]: {4,5}

            We initialize: all vertices have degree 2 -> all in the queue.

            Suppose we process vertex 1 first: 
                pop two: 2 and 3 -> form (2,1,3)
                update: 
                  g[1] = {}
                  g[2] = {3} -> skip
                  g[3] = {2} -> skip
            Then we process vertex 2: skip (because g[2] has 1 edge)
            Then we process vertex 3: skip.
            Then we process vertex 4: 
                pop two: 5 and 6 -> form (5,4,6)
                update: 
                  g[4] = {}
                  g[5] = {6} -> skip
                  g[6] = {5} -> skip

            Then we have two boomerangs.

          So the algorithm works for disconnected graphs.

        We'll code accordingly.

        Let's write the code.

        Note: the graph vertices are from 1 to n.

        We use:
            import collections

        We'll run the sample inputs.

        Sample Input #1: 
            5 7
            1 2
            1 4
            2 3
            2 4
            2 5
            3 4
            3 5

        We expect 3 boomerangs.

        Sample Input #2: 
            4 6
            1 2
            1 3
            1 4
            2 3
            2 4
            3 4

        We expect 3 boomerangs.

        Sample Input #3:
            3 3
            1 2
            1 3
            2 3

        We expect 1.

        We'll run the code on these samples.

        Due to the non-determinism of set.pop(), we might get different outputs, but the number of boomerangs should be the same.

        But to match the sample output format, we output the center in the middle.

        We'll run.

        For sample input #1, our code outputs:

            3
            2 1 4
            3 2 4
            4 3 5

        But the sample output #1 is:

            3
            4 1 2
            4 3 2
            2 5 3

        However, we can also output:

            3
            4 1 2   # for the first boomerang: we can output (4,1,2) if we had popped 4 first? 

        How? In the set for vertex 1: we popped 2 first and then 4? But we can change the order? 

        Actually, the set.pop() in Python pops the first element in the set's iteration order? For integers, the iteration order is the sorted order? 

        But note: sets in Python do not guarantee order? However, for integers, the set is implemented as a hash set and the order is arbitrary but consistent? 

        But we cannot rely on that. 

        How about we try to pop the smallest? 

        The problem does not require the output of the boomerangs to be in a particular order of endpoints. 

        But if we want to match the sample output, we can choose to output the endpoints in a sorted order? 

        However, the problem does not require. 

        Alternatively, we can change the popping: we can choose to pop the smallest neighbor? 

        But that might add a log factor? 

        However, the degree of each vertex can be up to 100000? Then we cannot sort the entire set.

        Instead, we can use a min-heap for each vertex? But that would be O(degree) per vertex to build, and we are removing edges arbitrarily.

        Alternatively, we can do:

          a = min(g[v])
          then remove a from g[v] and then remove v from g[a]

          then b = min(g[v])   # then the next smallest

        But then we do two min operations. The set does not support min? We can use min(g[v]) which is O(degree). 

        Then the total time complexity: the sum of the degrees is 2*m, but each edge is removed once. However, each time we remove an edge, we do a min operation on the set of the center? 

        Then the total work is O(n^2) in the worst-case? 

        For a star graph: center vertex has n-1 edges. Then we do O(n) work for the first boomerang (because min over n-1 elements). Then the center has n-3 edges: then we do min over n-3 elements. Then the total is O(n^2). 

        n can be 100000 -> then n^2 is 10e9 -> too slow.

        Therefore, we avoid.

        We stick to arbitrary popping.

        The problem does not require a particular order of the endpoints.

        We output the code as below.

        However, we note: the sample output #1: 
            "4 1 2"
            "4 3 2"
            "2 5 3"

        How can we get the first boomerang to be (4,1,2)? 

          If we pop 4 first from the set of vertex 1, then a=4, then we pop 2, then we output (4,1,2). 

        How to force that? 

        We cannot without extra cost.

        But the problem says: "you can output any of them".

        Therefore, we output the code with set.pop().

        We run the sample inputs.

        Sample Input #1: we might get (4,1,2) if the set for vertex1 is {4,2} and when we pop, 4 comes first? 

        How to control? We can use a different data structure? 

        Actually, we can use a list and pop from the end? But then we lose efficient removal? 

        Alternatively, we can store the set and then pop an arbitrary element? 

        The problem does not require.

        We'll trust the set.pop() and hope that the judge's Python gives the same order? 

        But the judge may use a different Python version? 

        However, the problem does not require the exact output, only the count and disjoint boomerangs.

        We output the code.

        Note: the sample input #2: we get three boomerangs? 

        We tested above: we got three.

        Let's run the code for sample input #2:

          g[1]: {2,3,4} -> pop two: say 2 and 3 -> output (2,1,3)
          then g[1] becomes {4}, and update g[2] to {3,4}, g[3] to {2,4} (remove the edge from 2 and 3 to 1)

          Then we process vertex 4: 
                g[4]: {1,2,3} -> pop two: 1 and 2 -> output (1,4,2)
          then update: g[4] becomes {3}, g[1] becomes {}, g[2] becomes {3}

          Then we process vertex 2: 
                g[2]: {3} -> skip
          Then we process vertex 3: 
                g[3]: {2,4} -> deg=2 -> then pop two: 2 and 4 -> output (2,3,4)

          Then output:
            3
            2 1 3
            1 4 2
            2 3 4

        This is valid.

        But the sample output #2 is:
            3
            1 2 3
            1 3 4
            1 4 2

        Which is different.

        However, we are allowed to output any.

        Therefore, we output the code.

        We hope it passes the constraints.

        Let's run on the largest input: 100000 vertices and 100000 edges? 

        The worst-case time: each edge is removed once. The total set operations (removal and pop) are O(m) and each is O(1) average. 

        We hope.

        Code: