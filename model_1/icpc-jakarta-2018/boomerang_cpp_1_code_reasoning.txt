 Okay, we are going to implement the greedy algorithm as described in the editorial.
 Steps:
 1. Represent the graph using adjacency sets (unordered_set) for each vertex to allow O(1) average removal and insertion.
 2. Use a queue to process vertices that have at least two edges. Also, maintain a boolean array (inQ) to avoid duplicate enqueues.
 3. While the queue is not empty:
      a. Pop a vertex v.
      b. If v has less than two edges, skip.
      c. Remove two distinct edges from v: (v, a) and (v, b). Remove these edges from both ends (so remove v from a's set and b's set, and remove a and b from v's set).
      d. Record the boomerang (a, v, b). Note: the problem does not require a specific order of the two endpoints? But the sample outputs sometimes have the center in the middle. We output as (a, v, b) meaning the center is v.
      e. After removing edges, check the vertices a, b, and v (if they have at least two edges and are not in the queue, enqueue them).
 4. Output the number of boomerangs and then each boomerang.

 Note: The problem says the edges are given with u < v, but our graph representation doesn't require ordering. However, when outputting, we just output the three numbers as per the boomerang.

 Important: We must avoid duplicate enqueues. We use inQ[] to mark if a vertex is already in the queue.

 However, note: after removing edges, the degree of a vertex might drop below two, so we only enqueue if the current degree is at least two and it's not already in the queue.

 Let's test on the provided examples.

 Sample Input #1: 5 7 and the edges. We should get 3 boomerangs.

 But note: the sample output is:
      4 1 2
      4 3 2
      2 5 3

 However, our algorithm might form:
      Initially, we have vertices with degrees: 
        1: 2, 2: 4, 3: 3, 4: 3, 5: 2.
      We start with a vertex that has at least 2 edges, say we start with 2 (degree 4). 
        We take two edges from 2: say (2,1) and (2,4). Then we form boomerang (1,2,4). 
        Then we remove these two edges. Now the graph has:
          deg(1): 1 -> so we don't enqueue 1 (it's not in the queue and we don't care because degree<2)
          deg(2): 2 (edges: 3 and 5) -> so we leave 2 in the queue? Actually, we remove two edges so now 2 has two edges left? 
          But we removed (2,1) and (2,4), so now 2 has edges to 3 and 5.
          Then we enqueue: a=1 (but deg(1)=1 -> skip), b=4 (deg(4) becomes 2: originally 4 had edges to 1,2,3 -> now remove 2, so 4 has edges to 1 and 3 -> so deg(4)=2? Actually we removed the edge (2,4) so 4 loses one edge -> deg(4) becomes 2? Then we enqueue 4? Also we enqueue 2? But we just processed 2 and we mark it as not inQ? Actually, we remove it from the queue? Then we add 2 and 4? 

      Alternatively, we might get a different boomerang. But note the sample output uses a different center for the first boomerang: center 4? 

      How about if we start with vertex 4? 
        Vertex 4 has edges {1,2,3}. We remove two: say 1 and 2 -> form boomerang (1,4,2). 
        Then remove edges (4,1) and (4,2). 
        Then update:
          deg(1): originally 2 (edges to 2 and 4) -> becomes 1 (only 2) -> so we don't enqueue 1.
          deg(2): originally 4 (edges 1,4,3,5) -> becomes 2 (edges 3,5) -> so we enqueue 2 (if not in queue) and 4? deg(4) becomes 1 (only 3) -> so skip 4? 
        Then we have vertex 2 in the queue. 
        Then we process 2: has edges {3,5}. Remove two: form boomerang (3,2,5). 
        Then remove (2,3) and (2,5). 
        Then update:
          deg(3): originally 3 (edges 2,4,5) -> becomes 2 (edges 4,5) -> enqueue 3? 
          deg(5): originally 2 (edges 2,3) -> becomes 1 -> skip.
          deg(2): becomes 0 -> skip.
        Then we enqueue 3? 
        Then process 3: has edges {4,5}. Remove two: form boomerang (4,3,5). 
        Then remove (3,4) and (3,5). 
        Then update: 
          deg(4): becomes 0 -> skip
          deg(5): becomes 0 -> skip
          deg(3): becomes 0 -> skip

        Now we have 3 boomerangs: (1,4,2), (3,2,5), (4,3,5). 
        But note: the sample output has (4,1,2) which is the same as (1,4,2) because the center is 4? Then (4,3,2) is (3,4,2) or (4,3,2) but we have (4,3,5) which is different.

        Actually, the sample output is:
            4 1 2
            4 3 2
            2 5 3

        The second boomerang: 4 3 2 -> meaning center is 3? No: the center is the middle vertex? So 4, then 3, then 2? Actually, the boomerang is represented as <u, v, w> meaning edges (u,v) and (v,w). So the center is the second vertex.

        In the second boomerang: center is 3? But the edges are (4,3) and (3,2). However, we have already removed the edge (2,4) in the first boomerang? Actually, in the first boomerang we removed (1,4) and (2,4). Then the edge (2,4) is gone. But the second boomerang requires (3,2) and (4,3). The edge (4,3) is still there? Actually, we didn't remove (4,3) in the first boomerang. Then in the second boomerang we use (3,2) and (4,3). Then the third boomerang: (2,5,3) -> meaning edges (2,5) and (5,3). But we have already used (3,2) and (2,5) is still there? Actually, in the second boomerang we used (3,2) and (4,3). Then the third boomerang uses (2,5) and (5,3). However, the edge (3,5) is still there? 

        But wait, the sample input has edge (3,5) and we haven't used it until the third boomerang.

        However, in our processing when we did the second boomerang at vertex 3, we removed two edges: (3,4) and (3,2). Then the edge (3,5) is still present? Then when we process vertex 2 (if we enqueued it after the first boomerang) we found two edges: (2,3) and (2,5). But we removed (2,3) in the second boomerang? Then vertex 2 only has (2,5) -> so we skip? Then how do we form the third boomerang?

        Alternatively, after the first boomerang (1,4,2) and the second boomerang (4,3,2) [but note: the center in the second boomerang would be 3? But the sample output has center 4 in the first and center 4 in the second? Then the sample output has:
            boomerang1: edges (4,1) and (1,2) -> no, the boomerang is <4,1,2> meaning edges (4,1) and (1,2)? Actually, no: the problem defines a boomerang as two edges that share a common vertex. The triple is <u,v,w> meaning the edges are (u,v) and (v,w). So the center is the middle number.

        Therefore, the sample output:
            "4 1 2" -> center is 1? edges (4,1) and (1,2).
            "4 3 2" -> center is 3? edges (4,3) and (3,2).
            "2 5 3" -> center is 5? edges (2,5) and (5,3).

        Now, let's see the edges used: 
            boomerang1: (1,4) and (1,2) -> but note the input edge representation: the edges are given as (1,2), (1,4), ... so these are the same.
            boomerang2: (3,4) and (2,3) -> note the edge (2,3) is present and (3,4) is present.
            boomerang3: (2,5) and (3,5) -> but the boomerang is represented as (2,5,3) meaning edges (2,5) and (5,3) -> same as (2,5) and (3,5).

        Now, the problem: in our algorithm when we start with vertex 1? Actually, we start with any vertex that has at least two edges. 

        How about we do:
          Start with vertex 1: has edges {2,4}. Remove (1,2) and (1,4) -> form boomerang (2,1,4) [which we can output as 2 1 4 or 4 1 2?]. The problem doesn't specify the order of u and w? But the sample output has 4 1 2. We can output as (min(u,w)? Actually, the sample outputs sometimes have the center in the middle and the two endpoints in any order? The problem says: "representing a boomerang \(\langle u, v, w \rangle\)". The triple is ordered: u, v, w. The edges are (u,v) and (v,w). 

        We are forming the boomerang as (a, v, b). But note: the sample input has an edge (1,4) and (1,2). We can output as (4,1,2) or (2,1,4). The sample output uses (4,1,2). How do they choose? It doesn't matter as long as the two edges are present. But to match the sample, we can output the triple arbitrarily? 

        However, note the sample Input #2 output: 
            1 2 3
            1 3 4
            1 4 2

        So the center is the common vertex, and the two endpoints are arbitrary? 

        We will output the two endpoints as we get them: first we take an edge to a, then an edge to b. So we output (a, v, b). 

        But in the first sample, if we start with vertex 1: we get (2,1,4) -> but the sample output is (4,1,2). We can change the order? Actually, we can output the endpoints in any order? The problem doesn't specify. However, to match the sample output, we might need to output the triple in a particular order? 

        But the problem says: "If there is more than one valid solution, you can output any of them."

        So we are free. However, note: the sample output for the first sample uses centers 1, 3, 5? Actually, the centers are 1, 3, 5? But the sample output has the second boomerang as (4,3,2): center 3, and the third as (2,5,3): center 5? 

        Alternatively, we can also form:
          boomerang1: center 2: using (1,2) and (4,2) -> output as (1,2,4) or (4,2,1) -> but the sample output has center 1 and 3 and 5? 

        Actually, the sample output has:
          boomerang1: center 1 -> (4,1,2)
          boomerang2: center 3 -> (4,3,2)
          boomerang3: center 5 -> (2,5,3)

        So the centers are 1, 3, 5. 

        How do we form that? 
          Start with vertex 1: has edges to 2 and 4 -> remove (1,2) and (1,4) -> output (4,1,2) -> then vertex 1 is done. 
          Then update: 
             vertex 2: originally edges to 1,4,3,5 -> now remove 1 and 4? Actually, we only removed (1,2) and (1,4) from the graph. Then the graph now has for vertex 2: edges to 3,4,5? Actually, we did not remove the edge (2,4) from vertex 2? We did: when we remove (1,2) from vertex 1, we also remove it from vertex 2. Similarly, we remove (1,4) from vertex 4? So vertex 2 now has edges to 3,4,5? But wait, the edge (2,4) is still there? Actually, we only removed (1,4) from vertex 4 -> so vertex 4 now has edges to 1 (removed) and 2 and 3? Then we remove (1,4) from vertex 4, so vertex 4 now has edges to 2 and 3? 

          Then we enqueue: a=4 (degree 2: edges to 2 and 3) -> enqueue 4? and b=2: now has degree 3 -> enqueue 2? and v=1: degree 0 -> skip.

          Then we process the queue: we have vertex 2 and 4. Let's process 2: 
            vertex 2: edges: 3,4,5. Remove two: say 3 and 4 -> form boomerang (3,2,4) -> then remove (2,3) and (2,4). Then update:
                vertex 3: remove 2 -> now edges: 4,5 -> so enqueue 3? 
                vertex 4: remove 2 -> now edges: 3 -> skip? 
                vertex 2: now only has 5 -> skip? 
            Then we have vertex 3: has edges 4,5 -> remove both: form boomerang (4,3,5). 
            Then output (4,3,5). 

          Then we have two more boomerangs: (3,2,4) and (4,3,5). Then total three: (4,1,2), (3,2,4), (4,3,5). 

          But the sample output has (4,3,2) meaning center 3? and then (2,5,3) meaning center 5? 

        How can we form the sample output? 
          We want: 
            boomerang1: (4,1,2) -> center 1: uses edges (4,1) and (1,2). 
            boomerang2: (4,3,2) -> center 3: uses edges (4,3) and (3,2). 
            boomerang3: (2,5,3) -> center 5: uses edges (2,5) and (5,3). 

        How to form the second boomerang with center 3? We need to pick two edges from vertex 3: (3,4) and (3,2). 
        How to form the third? We need two edges from vertex 5: (5,2) and (5,3). 

        So we must avoid taking two edges from vertex 2 in the second step? 

        How about we do:
          After the first boomerang, we have:
             vertex 1: done.
             vertex 2: has edges to 3,4,5 -> we don't process vertex 2? Instead, we process vertex 4? 
          Process vertex 4: has edges to 2 and 3. Then we remove two: (2,4) and (3,4) -> then form (2,4,3) -> center 4: output as (2,4,3) -> but the sample output has a boomerang with center 3? 

        Alternatively, we can form the boomerang at vertex 3? But after the first boomerang, vertex 3 has edges to 2,4,5 -> so we can process vertex 3? 
          Remove two: (3,2) and (3,4) -> form (2,3,4) -> center 3: output as (2,3,4) -> but the sample output has (4,3,2) which is the same as (2,3,4) if we output the endpoints as we get? Actually, we output (a, v, b) so if we pick (3,2) first and then (3,4) then we output (2,3,4). But we want (4,3,2)? We can output the endpoints in any order? Actually, the problem doesn't care. But note: the sample output specifically writes "4 3 2", meaning the first endpoint is 4 and the last is 2. How can we control that? 

        We can choose the order arbitrarily? We can output as (a, v, b) or (b, v, a). Actually, it doesn't matter because the boomerang is defined by the two edges. However, if we want to match the sample output, we can note that the problem does not specify the order of u and w. So both (a, v, b) and (b, v, a) are valid.

        Therefore, we don't have to worry about the order of the endpoints. 

        But the sample output for the first boomerang is (4,1,2) meaning the first endpoint is 4 and the last is 2. How did they get 4 first? Because they removed the edge (4,1) first? Then (1,2) second? 

        In our algorithm, we take the first edge from the set as a and the next as b. The set is unordered. So we cannot guarantee the order? 

        However, the problem does not require a specific order. So we output as (a, v, b) and that is acceptable.

        But the sample input #2: 
          Output: 
            1 2 3
            1 3 4
            1 4 2

        This is formed by having center 1 for all? But wait, the first boomerang: center 2? No: the first boomerang: (1,2,3) -> edges (1,2) and (2,3)? Then the second: (1,3,4) -> edges (1,3) and (3,4)? Then the third: (1,4,2) -> edges (1,4) and (4,2). But note: the edge (1,4) is used in the third boomerang? Then the second boomerang used (1,3) and the third used (1,4). Then the first used (1,2). Then the center for the first boomerang is 2? for the second 3? for the third 4? 

        How do we form that? 
          We start with vertex 1: has edges 2,3,4 -> we can form one boomerang? But we can only remove two edges at a time. 
          We remove (1,2) and (1,3) -> form boomerang (2,1,3) -> output (2,1,3). Then vertex 1 now has edge 4. 
          Then we enqueue 2 and 3? 
          Then we process vertex 2: has edges? Initially: edges to 1,3,4? But we removed (1,2) so vertex 2 now has edges to 3 and 4? -> so we enqueue 2? 
          Similarly, vertex 3: has edges to 1 (removed) and 2 and 4? -> so we enqueue 3? 
          Then we process vertex 2: remove two edges: (2,3) and (2,4) -> form boomerang (3,2,4) -> output (3,2,4). 
          Then we enqueue 3 and 4? 
          Then we process vertex 3: now has edges to 2 (removed) and 4? -> so only one edge -> skip? 
          Then we process vertex 4: now has edges to 2 (removed) and 3? -> only one edge? 

        Then we only got two boomerangs? 

        Alternatively, the sample output has three boomerangs with centers 2,3,4? 

        How about we form:
          boomerang1: center 1: (2,1,3) -> uses (1,2) and (1,3). 
          boomerang2: center 1: (3,1,4) -> but we only have one edge left at 1: (1,4) -> cannot form. 
          boomerang3: center 2: (1,2,4) -> but we already removed (1,2) -> so we cannot use that edge again.

        So how did they form three? 

        Actually, the sample output uses:
          1 2 3 -> meaning center 2? No: the triple is <u,v,w> meaning edges (u,v) and (v,w). So the center is the middle number. 
          Therefore:
            1 2 3: edges (1,2) and (2,3) -> center 2.
            1 3 4: edges (1,3) and (3,4) -> center 3.
            1 4 2: edges (1,4) and (4,2) -> center 4.

        So each boomerang has a different center: 2, 3, 4. 

        How to form that? 
          We must avoid taking two edges from the same vertex at once? 

        Algorithm:
          We start with vertex 1: we cannot form a boomerang at vertex 1 because we need two edges? But we are going to form boomerangs at other centers? 

        We can process vertex 2: 
          vertex 2: has edges 1,3,4 -> we remove (2,1) and (2,3) -> form (1,2,3). 
          Then update: 
             vertex 1: remove 2 -> now has edges 3,4 -> so enqueue 1? 
             vertex 3: remove 2 -> now has edges 1,4 -> enqueue 3? 
          Then we process vertex 1: has edges 3,4 -> remove (1,3) and (1,4) -> form (3,1,4) -> but the next boomerang in sample output is (1,3,4) meaning center 3? 

        Alternatively, we can form the boomerang at vertex 3: 
          After the first boomerang, vertex 3 has edges 1,4. Then we remove (3,1) and (3,4) -> form (1,3,4). 
          Then update: 
             vertex 1: remove 3 -> now has only 4 -> skip
             vertex 4: remove 3 -> now has edges 1,2 -> enqueue 4? 
          Then we process vertex 4: has edges 1,2 -> remove (4,1) and (4,2) -> form (1,4,2). 

        Then we get:
            (1,2,3) -> center 2: output (1,2,3) -> matches the first.
            (1,3,4) -> center 3: output (1,3,4) -> matches the second.
            (1,4,2) -> center 4: output (1,4,2) -> matches the third.

        So how do we achieve that? 
          We must not be restricted to starting at a particular vertex? 

        The algorithm: we have a queue of vertices that have at least two edges. We start by enqueuing all vertices that have at least two edges. Then we process the queue. 

        The order of processing might affect the output? 

        For the second sample: 
          Vertices: 
            1: deg=3 -> enqueued
            2: deg=3 -> enqueued
            3: deg=3 -> enqueued
            4: deg=3 -> enqueued

          We start with vertex 1? Then we remove two edges: say (1,2) and (1,3) -> form (2,1,3). 
          Then we enqueue 2 and 3 (and 1? but 1 now has only one edge -> skip). 
          Then we process vertex 2: has edges 3,4 (and 1 removed) -> two edges? Then remove (2,3) and (2,4) -> form (3,2,4). 
          Then enqueue 3 and 4? 
          Then we process vertex 3: has edges 4 (and 1 removed and 2 removed) -> only one edge? -> skip. 
          Then we process vertex 4: has edges 3? -> skip. 

          We only got two boomerangs.

        How about we start with vertex 2? 
          Remove two edges: (2,1) and (2,3) -> form (1,2,3). 
          Then enqueue 1 and 3? 
          Then process vertex 1: has edges 3,4 -> remove (1,3) and (1,4) -> form (3,1,4). 
          Then enqueue 3 and 4? 
          Then process vertex 3: has edges 4 (and 2 removed, and 1 removed) -> only one edge? 
          Then process vertex 4: has edges 1 removed? and 3? -> only one edge? 

          Then we got two boomerangs: (1,2,3) and (3,1,4). 

        How to get the third? 

        We need to form the third boomerang at vertex 4: which requires two edges: (4,1) and (4,2) or (4,3) and (4,2) etc. But in the above, we removed (1,4) when processing vertex 1? 

        How about we start with vertex 1: but we remove (1,2) and (1,4) -> form (2,1,4). 
          Then update: 
            vertex 1: now has edge to 3 -> skip
            vertex 2: has edges 3,4 -> enqueue 2? 
            vertex 4: has edges 2,3 -> enqueue 4? 
          Then process vertex 2: remove (2,3) and (2,4) -> form (3,2,4). 
          Then update: 
            vertex 3: remove 2 -> now has edges 1,4 -> enqueue 3? 
            vertex 4: remove 2 -> now has edge 3 -> skip? 
          Then process vertex 3: has edges 1,4 -> remove (3,1) and (3,4) -> form (1,3,4). 

          Then we get three: (2,1,4), (3,2,4), (1,3,4). 

          Output: 
            2 1 4
            3 2 4
            1 3 4

          But the sample output is:
            1 2 3
            1 3 4
            1 4 2

          How can we get the sample output? 

        We must form the boomerangs at the centers 2,3,4. 

        How about we do:
          Start with vertex 2: remove (2,1) and (2,3) -> form (1,2,3) -> output (1,2,3).
          Then we have vertex 1: has edges 3,4 -> enqueue 1? 
          Then vertex 3: has edges 1,4 -> enqueue 3? 
          Then we process vertex 3: remove (3,1) and (3,4) -> form (1,3,4) -> output (1,3,4).
          Then we have vertex 1: now has edge 4 -> skip? 
          Then we process vertex 4: has edges 1? -> skip? 
          Then we haven't used the edge (2,4) and (1,4) is already used? 

        How do we form the third boomerang? 

        Actually, after the first boomerang, we have not removed the edge (2,4). Then when we process vertex 2 again? 
          But we removed two edges from vertex 2? So now vertex 2 has one edge: to 4. -> so we skip. 

        Then we form the third boomerang at vertex 4: but we need two edges? 

        Alternatively, we can start with vertex 4? 
          Remove (4,1) and (4,2) -> form (1,4,2) -> output (1,4,2). 
          Then update: 
            vertex 1: has edges 2,3 -> enqueue 1? 
            vertex 2: has edges 1,3 -> enqueue 2? 
            vertex 4: has edge 3 -> skip.
          Then process vertex 1: remove (1,2) and (1,3) -> form (2,1,3) -> output (2,1,3). 
          Then update: 
            vertex 2: remove 1 -> now has edge 3 -> skip
            vertex 3: remove 1 -> now has edge 4 -> skip
          Then we have two boomerangs.

        How to get three? 

        The key: after the first boomerang at vertex 2, we have the edges (2,4) and (4,3) and (1,3) and (1,4) still? 

        Actually, after the first boomerang (1,2,3): 
          edges used: (1,2) and (2,3). 
          remaining edges: 
            (1,3), (1,4), (2,4), (3,4), (2,3) is gone, (1,2) is gone. 
          Then we can form:
            boomerang at vertex 3: but vertex 3 has edges: 1,4? -> two edges? Then we remove (3,1) and (3,4) -> form (1,3,4). 
          Then we have one edge left: (2,4) -> cannot form a boomerang? 

        Then we have two boomerangs.

        How about we form the third boomerang at vertex 4? 
          But after the first two, the remaining edge is (2,4). 

        How about we form the second boomerang at a different vertex? 
          After the first boomerang: 
            vertex 4: has edges 1,2,3 -> we can form a boomerang: remove (4,1) and (4,2) -> form (1,4,2). 
          Then update: 
            vertex 1: remove 4 -> now has edge 3 -> skip
            vertex 2: remove 4 -> now has edge 3? -> skip? (because we removed (2,3) in the first boomerang? no, we only removed (2,1) and (2,3) in the first? Actually, we removed (2,3) in the first? Then vertex 2 now has no edges? 
          Then we have the edge (3,4) left? -> skip. 

        Then we only got two.

        How about we form the second boomerang at vertex 1? 
          After the first boomerang (1,2,3): 
            vertex 1: has edges 3,4 -> form (3,1,4) -> then we have edges (2,4) and (3,4) are removed? No: we remove (1,3) and (1,4). Then the remaining edge is (2,4) and (3,4)? 
          Then we can form a boomerang at vertex 4: has edges 2,3 -> form (2,4,3). 

          Then we get three: 
            (1,2,3), (3,1,4), (2,4,3) -> but the edge (3,4) is used twice? No: (3,4) is used in the third boomerang? But we removed (1,4) from vertex 1: so the edge (1,4) is gone. The edge (3,4) is still present? 

          Actually, the third boomerang uses (2,4) and (4,3) which is (3,4). 

          Then we have three boomerangs: 
            (1,2,3): edges (1,2) and (2,3)
            (3,1,4): edges (1,3) and (1,4) -> but wait: we removed (1,3) and (1,4) from vertex 1, so the edge (1,3) is used? Then the third boomerang: (2,4,3): edges (2,4) and (4,3) -> which are both present? 

          Then we have used: 
            (1,2), (2,3), (1,3), (1,4), (2,4), (3,4) -> that's all the edges? 

          Then output: 
            1 2 3
            3 1 4
            2 4 3

          But the sample output is:
            1 2 3
            1 3 4
            1 4 2

          How do they get the second boomerang: 1 3 4? That would require edges (1,3) and (3,4). But we used (1,3) in the second boomerang and (3,4) in the third? 

        Therefore, the sample output must be formed in a different sequence? 

        Actually, the sample input #2 is a complete graph of 4 vertices. The maximum number of boomerangs is 3 (since 6 edges -> 3 boomerangs). 

        How the sample output forms 3 boomerangs? 
          They use:
            (1,2,3): edges (1,2) and (2,3) -> center 2.
            (1,3,4): edges (1,3) and (3,4) -> center 3.
            (1,4,2): edges (1,4) and (4,2) -> center 4.

          Note: the edge (2,4) is not used? and the edge (3,2) is not used? Actually, no: 
            In the first boomerang: edge (2,3) is used -> so the edge (2,3) is used? 
            In the third boomerang: edge (4,2) is used -> but the edge (2,4) is the same as (4,2). 
            And the edge (3,4) is used in the second boomerang? 
            Also, the edge (1,2) in the first, (1,3) in the second, (1,4) in the third.

          So they use all edges? 

        Therefore, the algorithm must be able to form three boomerangs in any order? 

        How can we achieve that? 
          We use a queue: we start with any vertex that has at least two edges. 

          Steps for input #2:
            Vertices: 1,2,3,4 all have degree 3 -> enqueued.

            We choose vertex 2: 
              remove two edges: (2,1) and (2,3) -> form (1,2,3) -> output (1,2,3)
              Then update: 
                 vertex 1: remove 2 -> now has edges 3,4 -> enqueue 1? 
                 vertex 3: remove 2 -> now has edges 1,4 -> enqueue 3? 
                 vertex 2: now has edge 4 -> skip? 
              Then we enqueue 1 and 3.

            Then we choose vertex 3: 
              remove two edges: (3,1) and (3,4) -> form (1,3,4) -> output (1,3,4)
              Then update:
                 vertex 1: remove 3 -> now has edge 4 -> skip? 
                 vertex 4: remove 3 -> now has edges 1,2 -> enqueue 4? 
                 vertex 3: done -> skip? 
              Then we enqueue 4.

            Then we choose vertex 4: 
              has edges 1,2 -> remove (4,1) and (4,2) -> form (1,4,2) -> output (1,4,2)
              Then update:
                 vertex 1: remove 4 -> done.
                 vertex 2: remove 4 -> done.
                 vertex 4: done.

            Then we have three boomerangs: (1,2,3), (1,3,4), (1,4,2) -> which is the sample output.

        Therefore, the algorithm must process vertices in a queue and when a vertex is processed, it removes two edges and then we enqueue the two neighbors and the vertex itself (if they have at least two edges and are not in the queue). 

        But note: we also removed the center? Then we enqueue the center? 

        Actually, after removing two edges, the center might still have edges? For example, if a vertex originally had 3 edges, after removing two, it has one left -> then we skip. But if it had 4 edges, then after removing two, it has 2 -> then we enqueue.

        Also, the two neighbors: we removed one edge from each, so if they had 3 edges and now have 2, we enqueue? 

        So we do: 
          After removing two edges from v, we update a, b, and v. 
          Then we check: a, b, and v: if any of them now has at least two edges and is not in the queue, we enqueue it.

        However, note: we already removed the vertex v from the queue? And we mark inQ[v]=false? Then if v still has at least two edges, we enqueue it? 

        But what if v is the same as a or b? No, v is distinct.

        This matches the algorithm we described.

        Therefore, we write the code accordingly.

        Let's test on the third sample: 
          Input: 3 3
                  1 2
                  1 3
                  2 3

          Vertices: 
            1: deg=2 -> enqueued
            2: deg=2 -> enqueued
            3: deg=2 -> enqueued

          We start with vertex 1: 
            remove two edges: (1,2) and (1,3) -> form (2,1,3)
            Then update: 
                vertex 2: remove 1 -> now has edge 3 -> skip
                vertex 3: remove 1 -> now has edge 2 -> skip
                vertex 1: now has no edge -> skip
            Then we output (2,1,3) -> which matches the sample: 
                Output: 
                  1
                  2 1 3   -> but the sample output is: "2 1 3" meaning the center is 1? 

          However, the sample output is: 
                1
                2 1 3

          But the problem sample input #3 output is:
                1
                2 1 3

          So we output (2,1,3). 

        Therefore, the code is as written above.

        One more thing: when we remove an edge from a vertex, we must remove the neighbor from the set? 

        We do: 
          g[v].erase(a);
          g[a].erase(v);

        Similarly for b.

        We use an unordered_set? But removal is O(1) average? 

        Also, we use inQ[] to avoid duplicate enqueues.

        Code:

        Steps:
          Read n, m.
          Build graph: for each edge, add to both sets.

          Initialize: 
            inQ: array of size n+1, initially false.
            q: queue.

          For i from 1 to n: 
            if g[i].size()>=2: 
                q.push(i); inQ[i]=true.

          Then while q not empty:
            v = q.front(); q.pop(); inQ[v]=false;
            if g[v].size() < 2: continue;

            // Remove two edges: 
            a = *g[v].begin();
            g[v].erase(a);
            g[a].erase(v);

            b = *g[v].begin();   // now the set is not empty because we know g[v].size() was at least 1 after removing one? Actually, we just removed one so we check: but we know we had at least two, then after removing one, we have at least one? Then we can take the next one.
            g[v].erase(b);
            g[b].erase(v);

            ans.push_back({a, v, b});

            // Check v, a, b: if they have at least two edges and are not in the queue, then push and mark inQ.
            for (int u : {a, b, v}) {
                if (g[u].size() >= 2 && !inQ[u]) {
                    inQ[u] = true;
                    q.push(u);
                }
            }

          Then output.

        But note: what if the set of v becomes empty after removing the two edges? Then we skip enqueuing v? 

        This is the code we have above.

        Let me run the second sample with the algorithm:

          Vertices: 1,2,3,4 -> all have 3 edges.

          We start with vertex 2 (arbitrary? we can start with any). Let's start with vertex 2.

          Step1: v=2
            a = *g[2].begin(); -> say 1
            remove (2,1): 
                g[2]: {1,3,4} -> becomes {3,4}
                g[1]: remove 2 -> now {3,4} (so deg(1)=2 -> we will enqueue 1 later? but not yet)
            then b = *g[2].begin() -> 3
            remove (2,3): 
                g[2]: becomes {4}
                g[3]: remove 2 -> now {1,4} -> deg(3)=2

            Then we form boomerang (1,2,3).

            Then we check u in {1,3,2}:
                u=1: deg=2 and not inQ? (initially inQ[1] was set to true at the beginning? But then we popped 2 and set inQ[2]=false. Now we check: 
                    inQ[1] is initially false? -> then we set inQ[1]=true and push 1.
                u=3: deg=2, not inQ? -> push 3.
                u=2: deg=1 -> skip.

          Then we have q: [1,3]

          Step2: pop vertex 1? 
            v=1: 
                g[1]: {3,4} -> size=2 -> proceed.
                a = 3
                remove (1,3): 
                    g[1] becomes {4}
                    g[3]: {1,4} -> becomes {4} -> deg(3)=1 -> then we remove one edge from g[3] so now g[3] has only 4? 
                then b = 4
                remove (1,4):
                    g[1] becomes {}
                    g[4]: {1,2,3} -> becomes {2,3} (because we remove 1) -> deg(4)=2.

                Then form boomerang (3,1,4).

                Then check u in {3,4,1}:
                    u=3: deg=1 -> skip
                    u=4: deg=2 and not inQ? -> we haven't processed 4? We only pushed 1 and 3. So push 4? 
                    u=1: deg=0 -> skip.

          Step3: then we pop vertex 3? 
            v=3: 
                g[3]: {4} -> size=1 -> skip.

          Step4: pop vertex 4? 
            v=4: 
                g[4]: {2,3} -> size=2.
                a = 2
                remove (4,2): 
                    g[4] becomes {3}
                    g[2]: {4} -> becomes {} -> skip? 
                Then we try to get the next edge? But after removing a, the set has size 1? Then we cannot take a second edge? 

          This is a problem: we checked the size at the beginning, but after removing the first edge, the size becomes 1? Then we cannot form a boomerang? 

          We must not form a boomerang if after removing the first edge the vertex has less than one edge? But we need two edges at the beginning. But we remove one, then we still need one more? 

          Actually, we did: 
            We had g[4] = {2,3} -> size=2 -> we remove 2: then g[4] becomes {3} -> then we try to get the next edge: *g[4].begin() -> 3, then we remove (4,3). 

          But then we do:

            Step4: 
              v=4: 
                a = 2 -> remove (4,2): g[4] becomes {3}, g[2] becomes {}.
                then we get b = *g[4].begin() = 3 -> remove (4,3): 
                    g[4] becomes {}
                    g[3]: {4} -> becomes {}.

                Then we form boomerang (2,4,3).

          Then we have three boomerangs: 
            (1,2,3), (3,1,4), (2,4,3)

          But the sample output was (1,2,3), (1,3,4), (1,4,2). 

          However, the problem says: "If there is more than one valid solution, you can output any of them."

        Therefore, the code is correct.

        But note: what if after removing the first edge, the set becomes empty? Then we cannot take the second edge? 

        We must check: we start with at least two edges. Then after removing the first edge, we have at least one edge? 

        Actually, we start with at least two, so after removing one, we have at least one? Then we can remove the second edge? 

        Therefore, we are safe.

        However, what if the set is implemented in a way that after erasure, the set is modified? We are using unordered_set: erasure invalidates only the iterators to the erased element. The begin() after erasure is valid? 

        Yes, because we are not using iterators beyond the erasure. We call begin() again.

        But note: we remove the first edge, then we get the new begin() for the next edge.

        So the code is safe.

        Let me test with the sample input #1: 
          We start with vertex 1: deg=2 -> enqueued, vertex2: deg=4, vertex3: deg=3, vertex4: deg=3, vertex5: deg=2 -> all in the queue.

          We start with vertex 2? 
            Remove two edges: say (2,1) and (2,4) -> form (1,2,4). 
            Then update: 
                vertex1: deg becomes 1 (only 4? no: originally vertex1 had edges to 2 and 4 -> then remove (1,2): so deg1=1 -> skip
                vertex4: deg becomes 2 (edges: 1,3) -> enqueue? 
                vertex2: deg becomes 2 (edges: 3,5) -> enqueue? 
            Then we have vertex4 and vertex2 in the queue.

          Then we pop vertex4: 
                edges: {1,3} -> remove (4,1) and (4,3) -> form (1,4,3). 
                Then update: 
                    vertex1: becomes 0 -> skip
                    vertex3: becomes 2 (edges: 2,5) -> enqueue? 
                    vertex4: becomes 0 -> skip
          Then we pop vertex2: 
                edges: {3,5} -> remove (2,3) and (2,5) -> form (3,2,5). 
                Then update: 
                    vertex3: becomes 1 (edge:5) -> skip? 
                    vertex5: becomes 1 -> skip
                    vertex2: becomes 0 -> skip
          Then we have three boomerangs: (1,2,4), (1,4,3), (3,2,5). 

          How to output? 
            (1,2,4): output as "1 2 4"
            (1,4,3): output as "1 4 3"
            (3,2,5): output as "3 2 5"

          But the sample output is:
                3
                4 1 2
                4 3 2
                2 5 3

          They have the centers: 1, 3, 5.

          Our solution is different, but it is valid.

        Therefore, we output the code as written.

        However, note: the sample input #1 output uses the center 1 for the first boomerang: so they output (4,1,2) meaning the center is 1? 

        How can we get that? 
          We start with vertex1: 
            remove (1,2) and (1,4) -> form (2,1,4) -> we output (2,1,4) -> but the sample output is (4,1,2). 

          We can change the output to (min(a,b), v, max(a,b))? No, because the problem does not require.

        Alternatively, we can output as (a, v, b) as we get the edges. 

        But the sample output for the first boomerang is (4,1,2). How did they get 4 first? Because they took the edge (1,4) first and then (1,2)? 

        In our code, we take the first edge from the set. The set is unordered. So we get arbitrary order? 

        To match the sample output, we would have to control the order? But the problem says any valid solution.

        Therefore, we leave it as is.

        But note: the sample input #1: 
          The graph: 
            edges: (1,2), (1,4), (2,3), (2,4), (2,5), (3,4), (3,5)

          We want to form:
            (4,1,2): center 1: edges (4,1) and (1,2) -> which we can form at vertex1. 
            (4,3,2): center 3: edges (4,3) and (3,2) -> which we can form at vertex3? 
            (2,5,3): center 5: edges (2,5) and (5,3) -> at vertex5? 

          How to form that? 
            Step1: process vertex1: 
                    remove (1,4) and (1,2) -> form (4,1,2) -> output (4,1,2). 
            Then update: 
                vertex1: done.
                vertex4: remove 1 -> now has edges 2,3 -> enqueue 4? 
                vertex2: remove 1 -> now has edges 3,4,5 -> enqueue 2? 
            Step2: process vertex4: 
                    remove (4,2) and (4,3) -> form (2,4,3) -> but we want the center to be 3? 
                    How about we form the boomerang at vertex3? 
            We have vertex2 and vertex4 in the queue. 

            We process vertex2: 
                    remove (2,3) and (2,5) -> form (3,2,5) -> output (3,2,5). 
            Then update: 
                vertex3: remove 2 -> now has edges 4,5 -> enqueue 3? 
                vertex5: remove 2 -> now has edge 3 -> skip? 
                vertex2: now has edge 4 -> skip? 
            Then we process vertex3: 
                    remove (3,4) and (3,5) -> form (4,3,5) -> output (4,3,5). 
            Then we have three boomerangs: (4,1,2), (3,2,5), (4,3,5). 

          But the sample output has (4,3,2) and (2,5,3). 

          How about we output the second boomerang as (4,3,2) instead of (3,2,5)? 

          Actually, the boomerang (4,3,2) requires edges (4,3) and (3,2). But we used (3,2) in the second boomerang? and (4,3) in the third? 

        Alternatively, we form the second boomerang at vertex3? 
          After the first boomerang: 
            vertex3: has edges 2,4,5 -> we can form a boomerang: remove (3,4) and (3,2) -> form (4,3,2). 
          Then update: 
            vertex4: remove 3 -> now has edge 2 -> skip? 
            vertex2: remove 3 -> now has edges 4,5 -> enqueue 2? 
            vertex3: now has edge 5 -> skip? 
          Then we output (4,3,2). 
          Then we process vertex2: 
                remove (2,4) and (2,5) -> form (4,2,5). 
          Then output (4,2,5). 
          Then we have two boomerangs: (4,1,2) and (4,3,2) and (4,2,5). 
          But wait: the edge (2,4) is used in the third boomerang? And the edge (2,5) is used? 
          But the sample output's third boomerang is (2,5,3) -> center 5: which requires edges (2,5) and (5,3). 
          But we used (2,5) in the third boomerang? and (5,3) is still present? 

        Then we have not used the edge (3,5)? 

        Therefore, we can form the third boomerang at vertex5: 
          vertex5: has edges 2,3 -> remove (5,2) and (5,3) -> form (2,5,3). 
          Then we have three: (4,1,2), (4,3,2), (2,5,3). 

          This matches the sample output.

        How do we do that? 
          We need to choose which two edges to remove from a vertex? 

        In our algorithm, we take the first two from the unordered_set? The order is arbitrary? 

        But the problem says: any valid solution.

        Therefore, we don't care about the order. The sample output is one valid solution.

        But if we want to match the sample output exactly, we might need to choose the edges in a specific order? 

        However, the problem does not require that. We output any valid solution.

        Therefore, we stick to the algorithm: remove the first two edges arbitrarily.

        But note: the sample input #1: 
          The desired solution: 
            boomerang1: center 1: edges (1,4) and (1,2) -> so when we process vertex1, we must remove (1,4) first and then (1,2)? Then we output (4,1,2). 
            But in our code: 
                a = first edge in g[1] -> which could be 2 or 4? 
                then we output (a,1,b). 

          How to get 4 first? 
            If the first edge in the set is 4? 

        The set is unordered_set: the iteration order is arbitrary. 

        Therefore, we might get (2,1,4) or (4,1,2) arbitrarily? 

        To be consistent, we can use a set? Then the edges are sorted? But the problem does not require. 

        Alternatively, we can use a linked list? But the problem constraints are 100000, and unordered_set is O(1) on average.

        We can also use a vector? But removal would be O(deg). 

        The problem requires 0.5s and 256MB, and the graph has 100000 edges. 

        We use unordered_set: it is efficient.

        Therefore, we leave as unordered_set.

        However, to match the sample output, we note that the sample output for the first sample uses center 1 and then center 3 and then center 5. 

        Our algorithm might form centers in a different order? 

        But the problem does not require the boomerangs to be output in any specific order? 

        So we output the boomerangs in the order we form them.

        Therefore, the code is as follows.

        One more corner: what if the graph has no edge? Then we output 0.

        Let me run with a simple graph: 
          n=1, m=0 -> output 0.

        n=2, m=1: no boomerang -> output 0.

        n=3, m=2: two edges, but they might not share a common vertex? 
          For example: (1,2) and (2,3) -> then we have a boomerang? 
          Actually, we have vertex2: has two edges -> form boomerang (1,2,3). 
          Then output 1 and "1 2 3".

        But what if the two edges are (1,2) and (1,3)? Then we form (2,1,3). 

        What if the two edges are (1,2) and (3,4)? Then no boomerang.

        Therefore, the code is robust.

        We write the code accordingly.

        Note: the input edge format: u and v, and u < v. But we store the graph as undirected.

        Let's code accordingly.

        Important: We must avoid self-loops? The problem says simple undirected graph.

        We assume no self-loops.

        Code:

        We use:
          #include <iostream>
          #include <vector>
          #include <queue>
          #include <unordered_set>
          #include <tuple>
          using namespace std;

          const int N = 100010;   // since n up to 100000

          We declare:
            unordered_set<int> g[N+1];
            bool inQ[N+1] = {false};

        We read n and m.

        Then we build the graph.

        Then we create a queue and a vector for the answer.

        Then we loop for i=1 to n, and if g[i].size()>=2, push i and mark inQ[i]=true.

        Then the while loop.

        We note: the graph might have multiple connected components? The algorithm works regardless.

        We run and hope for the best.

        However, note: the unordered_set might have a worst-case O(n) per operation? But average is O(1). And the total operations: each edge is removed once. So total operations O(m). 

        But the constant factors might be high? 

        Alternatively, we can use a linked list for the adjacency list? But unordered_set is easier.

        Since m and n are 100000, and the average degree is low? Actually, worst-case degree can be 100000? Then the set operations are O(1) average? 

        But worst-case the set might be O(deg) for an operation? Actually, unordered_set has average O(1) for erase and begin, but worst-case O(deg) for a single erase? 

        However, the total cost of erasing all edges is O(m) because each edge is erased once from two sets. 

        Therefore, the overall time is O(m).

        But the queue: each vertex might be enqueued multiple times? But each time we enqueue a vertex only when it has at least two edges, and after we remove edges, the degree decreases. So each vertex is enqueued at most (deg(v)/2) times? 

        Then the total number of queue operations is O(m). 

        Therefore, the algorithm is O(m).

        Let's write the code accordingly.

        Note: we are using C++ and we use an array of unordered_set. The memory is O(m) because each edge is stored twice.

        We output the answer.

        Let me test on the provided samples.

        Sample Input #1: 
          5 7
          1 2
          1 4
          2 3
          2 4
          2 5
          3 4
          3 5

        We run: 
          g[1]: {2,4}
          g[2]: {1,3,4,5}
          g[3]: {2,4,5}
          g[4]: {1,2,3}
          g[5]: {2,3}

          We enqueue vertices: 1,2,3,4,5 (all have at least 2).

          The queue: [1,2,3,4,5] (but the order is arbitrary? we use a queue: FIFO? 

          We start with 1? 
            a = 2 -> remove: g[1] becomes {4}; g[2] becomes {3,4,5}
            b = 4 -> remove: g[1] becomes {}; g[4] becomes {2,3}
            push (2,1,4) -> we output (2,1,4) -> but the sample output has (4,1,2) -> but we output the first edge as 2 and then 4? 
            Then we enqueue: a=2: now has 3 edges -> if not inQ: we mark it? But it was in the queue? We haven't popped it? Actually, we popped 1, and then we enqueue 2? But 2 is already in the queue? We have inQ[2]=true? 

          We have to note: we popped 1, then we are going to push 2? But we have a boolean array: we set inQ[2]=false when we pop it? But we haven't popped 2 yet. 

          Actually, at the beginning we set inQ for all vertices with deg>=2 to true. Then we process one by one. When we pop a vertex, we set inQ[v]=false. Then when we update, we check if it is not in the queue and has deg>=2, then we push and mark inQ.

          So for vertex2: we haven't processed it yet? So inQ[2] is still true? Then we skip pushing it again.

          Similarly for vertex4: we set inQ[4]=true initially? Then we haven't popped it? So we skip.

          Then we only enqueue vertex1? -> no, we skip because deg1=0.

          Then we move to the next in the queue: vertex2? 
            g[2]: {3,4,5} -> size=3 -> at least 2.
            a = 3 -> remove: g[2] becomes {4,5}; g[3] becomes {4,5} (because we remove 2 from g[3]? originally g[3]={2,4,5} -> becomes {4,5})
            b = 4 -> remove: g[2] becomes {5}; g[4] becomes {3} (because g[4] was {2,3} -> remove 2 -> becomes {3})
            Then form boomerang (3,2,4) -> output (3,2,4)
            Then we enqueue: a=3: deg=2 -> but inQ[3] is still true? because we haven't popped it? Then skip.
                     b=4: deg=1 -> skip
                     v=2: deg=1 -> skip

          Then we process vertex3: 
            g[3] = {4,5} -> size=2
            a=4 -> remove: g[3] becomes {5}; g[4] becomes {} -> then we remove (3,4)
            b=5 -> remove: g[3] becomes {}; g[5] becomes {2} (because originally g[5]={2,3} -> remove 3 -> becomes {2})
            Then form (4,3,5) -> output (4,3,5)
            Then enqueue: 3,4,5: 
               3: deg=0 -> skip
               4: deg=0 -> skip
               5: deg=1 -> skip

          Then we have three boomerangs: (2,1,4), (3,2,4), (4,3,5)

          But the sample output is:
            3
            4 1 2
            4 3 2
            2 5 3

          How can we get the first one as (4,1,2)? 
            We must have started with a vertex that had the edge (1,4) as the first edge? 

          How about we start with vertex2? 
            Then we remove (2,1) and (2,3) -> form (1,2,3) -> output (1,2,3)
            Then we update: 
                vertex1: deg=1 -> skip
                vertex3: deg=2 -> enqueue? 
                vertex2: deg=2 -> enqueue? 
            Then we process vertex3: 
                remove (3,4) and (3,5) -> form (4,3,5) -> output (4,3,5)
            Then we update: 
                vertex4: deg=1 (only 2) -> skip? 
                vertex5: deg=1 -> skip
                vertex3: deg=0 -> skip
            Then we process vertex2: 
                remove (2,4) and (2,5) -> form (4,2,5) -> output (4,2,5)
            Then we have three: (1,2,3), (4,3,5), (4,2,5)

          This is valid.

        Therefore, the output is arbitrary.

        We output the code.

        Note: The sample input #2 and #3 we have tested.

        Let me run sample input #2: 
          n=4, m=6: complete graph.

          We start with vertex1: 
            a = 2 -> remove: g[1]={3,4}; g[2]={3,4} (because initially g[2]={1,3,4} -> becomes {3,4})
            b = 3 -> remove: g[1]={4}; g[3]={2,4} (from {1,2,4} -> remove 1 -> {2,4})
            form (2,1,3) -> output (2,1,3)
            Then enqueue: a=2: deg=2 -> push and mark? 
                     b=3: deg=2 -> push and mark?
                     v=1: deg=1 -> skip
            Now inQ[2]=true, inQ[3]=true.

          Then we pop vertex2: 
            g[2] = {3,4}
            a=3 -> remove: g[2]={4}; g[3]={4} (from {2,4} -> remove 2 -> {4})
            b=4 -> remove: g[2]={}; g[4]={3} (from {1,2,3} -> we had removed 1? so now we remove 2: g[4] becomes {3})
            form (3,2,4) -> output (3,2,4)
            Then enqueue: a=3: deg=1 -> skip; b=4: deg=1 -> skip; v=2: skip.

          Then we pop vertex3: 
            g[3] = {4} -> skip.

          Then we have two boomerangs? 

        But we expected three.

        What happened? 
          After the first boomerang, the edges are:
            (1,4) is still there? 
            (2,3) is removed? 
            (2,4) is removed? 
            (3,4) is still there? 
            (1,3) is removed? 
            (1,2) is removed? 

          Then we have edges (1,4) and (3,4) -> then we can form a boomerang at vertex4? 
          But we never enqueued vertex4? 

          After the first boomerang, we updated vertex4: 
            g[4]: initially {1,2,3} -> we removed nothing from vertex4 in the first boomerang? 
            Actually, we removed an edge from vertex4? 
              When we removed (1,2) and (1,3) from vertex1, we did:
                g[1].erase(2) -> then we do g[2].erase(1) -> so vertex2 lost an edge to 1, but vertex4 was not touched? 
            Then vertex4 still has edges {1,2,3}? -> deg=3, so we should have enqueued it? 

          How did we update vertex4? 
            In the first boomerang: we only removed edges incident to 1 and 2? 
            Specifically, we removed (1,2) and (1,3). 
            Then vertex4 is not touched? 

          Then after the first boomerang, vertex4 still has 3 edges? 

          Why did we not enqueue vertex4? 
            In the update step of the first boomerang, we updated vertices: 2,3,1. 
            We did not update vertex4? 

          But when we removed the edge (1,3), we updated g[3] (which is vertex3) and g[1]. 
          We did not update g[4]? 

          How did the edge (1,4) remain? 

          Actually, we did not remove (1,4) in the first boomerang? 
            We removed the first two edges from vertex1: which were 2 and 3. 
            The edge (1,4) remains? 

          Then after the first boomerang, vertex4 has edges 1,2,3 -> so we should have enqueued it? 

          But we did not update vertex4? 

          We only enqueue the neighbors that are directly affected: a and b, which were 2 and 3. 
          We did not update vertex4? 

          And we did not enqueue vertex4? 

          Then vertex4 remains in the queue? 

          How? 
            Initially, we enqueued all vertices with deg>=2: so vertex4 was enqueued and we set inQ[4]=true. 
            Then we popped vertex1? and we set inQ[1]=false. 
            But we never popped vertex4? 
            Then when we processed vertex1, we did not change the inQ status of vertex4? 

          Then after the first boomerang, vertex4 is still in the queue? 

          Then we should process it? 

          After processing vertex1, we then process the next in the queue? 

          The queue initially: [1,2,3,4] -> we popped 1, then we pushed 2 and 3? 
          Actually, we do:

            q: initially [1,2,3,4,5] for the first sample? For this sample: [1,2,3,4]

            Step1: pop 1 -> then we push 2 and 3? 
                But note: we only push a vertex if it is not in the queue. 
                We set inQ[2]=true initially? Then we don't push 2 again. 
                Similarly for 3. 
                Then the queue now: [2,3,4] (because we popped 1, and 2,3,4 were already in the queue).

            Then we pop vertex2: 
                ... 
            Then we pop vertex3: 
                ...
            Then we pop vertex4: 
                g[4]: {1,2,3} -> size=3 -> proceed.
                a = 1 -> remove: g[4] becomes {2,3}; g[1] becomes {4} -> but we had g[1]={4}? 
                b = 2 -> remove: g[4] becomes {3}; g[2] becomes {4}? -> but we had g[2] was {3,4}? Then after removing (2,4): g[2] becomes {3}? 
                Then we form (1,4,2) -> output (1,4,2)
                Then we enqueue: a=1: deg=1 -> skip; b=2: deg=1 -> skip; v=4: deg=1 -> skip.

            Then we have three boomerangs: (2,1,3), (3,2,4), (1,4,2) -> but the second boomerang was (3,2,4) and we have the edges? 
            The edges used: 
                (1,2), (1,3) from the first.
                (2,3) and (2,4) from the second? 
                (1,4) and (4,2) from the third? 
            But (4,2) is the same as (2,4) which was already used? 

          This is an error: we used edge (2,4) twice.

        What went wrong? 
          In the second boomerang (vertex2): 
            We removed edges (2,3) and (2,4). 
          Then in the third boomerang (vertex4): 
            We removed (4,1) and (4,2) -> but the edge (4,2) is the same as (2,4) and it was already removed? 

          How is it still in g[4]? 

          When we removed (2,4) in the second boomerang, we did:
            g[2].erase(4); 
            g[4].erase(2); 

          Then the edge (2,4) should be gone from g[4]? 

          Then when we process vertex4, the set g[4] should be {1,3}? 

          Then we remove (4,1) and (4,3) -> form (1,4,3). 

          Then the third boomerang is (1,4,3). 

          Then the output: 
            (2,1,3)
            (3,2,4)
            (1,4,3)

          And the edges: 
            (1,2), (1,3) -> first
            (2,3), (2,4) -> second
            (1,4), (3,4) -> third

          And we have used all edges? 

          Then it is valid.

          But the sample output is: 
                1 2 3
                1 3 4
                1 4 2

          We have a different solution.

        Therefore, the algorithm is correct.

        We output the code.

        However, we must be cautious: when we remove an edge, we remove it from both ends.

        Let me reexamine the second boomerang (vertex2) in the sample input #2:

          Before processing vertex2: 
            g[2]: {3,4} -> because we removed (2,1) in the first boomerang? 
          Then we remove (2,3): 
            g[2] becomes {4}
            g[3]: originally {2,4} -> becomes {4} -> so we remove 2 from g[3] -> then g[3]={4}
          Then we remove (2,4): 
            g[2] becomes {}
            g[4]: originally {1,2,3} -> we remove 2 -> becomes {1,3}

          Then after the second boomerang, g[4] = {1,3} -> so deg=2, then we enqueue 4? 

          Then we process vertex4: 
            a = 1 -> remove: g[4] becomes {3}; g[1] becomes {4} (because g[1] originally was {4} -> then we remove 4? -> becomes {})
            b = 3 -> remove: g[4] becomes {}; g[3] becomes {} (because g[3] was {4} -> remove 4 -> becomes {})
            Then we form (1,4,3) -> output (1,4,3)

          Then we have three: 
            (2,1,3)
            (3,2,4)
            (1,4,3)

          This is valid.

        Therefore, the code is correct.

        We output the code as below.

        Note: The order of the boomerangs in the output is the order we form them, and the order of the endpoints in a boomerang is arbitrary (the first edge we remove).

        Let me run the third sample: 
          3 3
          1 2
          1 3
          2 3

          g[1]={2,3}, g[2]={1,3}, g[3]={1,2}

          Enqueue: 1,2,3.

          Pop 1: 
            a=2: remove: g[1]={3}, g[2]={3}
            b=3: remove: g[1]={}, g[3]={2}
            form (2,1,3)
            Then enqueue: a=2: deg=1 (only 3) -> skip; b=3: deg=1 -> skip; v=1: skip.

          Then pop 2: 
            g[2]={3} -> skip.
          Then pop 3: 
            g[3]={2} -> skip.

          Output: 1 and "2 1 3"

        This matches.

        We are done.