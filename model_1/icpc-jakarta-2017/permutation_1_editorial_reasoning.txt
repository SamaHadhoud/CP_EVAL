We are given a permutation P of size N (at most 100) and Q queries (up to 300,000). We need to find the smallest integer M > 1 such that P^M = P (i.e., the identity of the cycle? but note: P^1 = P, and we are looking for the next time the permutation repeats). Actually, the condition is P = P^M, meaning that after M multiplications we get back P.

Note: The exponentiation is defined as:
  P^1 = P
  P^z = P^{z-1} * P   (which is the composition: apply P, then the result of P^{z-1}? Actually, note the definition: (A*B)_i = A_{B_i}. This is function composition: applying B first, then A? But note: 
      (P^2)_i = P_{P_i}   [because when z=2: P^2 = P^1 * P = P * P, so (P*P)_i = P_{P_i}]
      (P^3) = P^2 * P -> (P^2 * P)_i = (P^2)_{P_i} = P_{P_{P_i}}.

So the exponentiation is applying the permutation repeatedly.

We are to compute M: the smallest integer > 1 such that P^M = P.

But note: 
  P^1 = P
  We want P^M = P. 

So: 
  P^M = P 
  => P^{M-1} * P = P 
  => P^{M-1} * P = P * identity? 

Actually, we can write:
  P^M = P^1 
  => P^{M-1} = identity? 

But wait: 
  P^M = P^1 
  => P^{M-1} * P = P 
  => Multiply both sides (on the right) by the inverse of P (which exists since it's a permutation) we get:
      P^{M-1} = identity.

So the condition P^M = P is equivalent to P^{M-1} = identity. Therefore, M-1 is the order of the permutation P? 

But note: the order of a permutation is the smallest positive integer k such that P^k = identity. However, here we have:
  We want the smallest M>1 such that P^M = P. 
  => P^{M-1} = identity.

Therefore, M-1 is exactly the order of the permutation P. Let k = order(P). Then M = k+1.

But wait: in the sample, P = [2,3,1,5,4]. The identity permutation would be [1,2,3,4,5]. 
  We see that P^6 = identity. Then M-1 = 6, so M=7. This matches the sample.

Therefore, we can say:
  Let k = order of P (the smallest positive integer such that P^k = identity). Then M = k+1.

But note: the problem defines A as the array of P^i for i=1 to M-1 (so i from 1 to k) sorted in increasing order (as permutations).

So we have k permutations: P^1, P^2, ... , P^k (since M-1=k). Then we sort these k permutations.

Then for each query K_i, we are to find T_i such that P^{T_i} = A_{K_i}. 

So the steps are:
1. Compute the order k of permutation P. Since N is at most 100, we can do this by simulating the exponentiation until we get the identity. However, the order of a permutation can be as large as the least common multiple of the lengths of its cycles, which for N=100 might be as large as 2.3e4? (The maximum order for a permutation of n is given by Landau's function, and for n=100 it is around 44100). But 44100 is acceptable because we are only storing k permutations? But k might be up to 44100, and each permutation is 100 integers -> 44100 * 100 = 4.4e6 integers, which is about 17.6 MB (if integers are 4 bytes) which is acceptable. However, Q can be up to 300,000. We cannot sort 44100 permutations by comparing each pair (which would be O(k^2 * n) and k=44100, k^2=1.9e9, which is too slow). So we need a more efficient way.

Alternative plan:

Step 1: Factorize the permutation P into disjoint cycles. Then the order k is the LCM of the lengths of the cycles.

Step 2: We know that the permutations P^1, P^2, ... , P^k are all distinct until we hit the identity? Actually, the set {P^1, P^2, ..., P^k} is the cyclic subgroup generated by P. And k is the order. So we have k distinct permutations.

But note: the problem says that we have M-1 = k permutations. We have to generate all of them? Then sort them? But k might be up to 44100 which is acceptable for storing 44100 * 100 = 4.4e6 integers (about 17.6 MB). However, sorting 44100 elements with a comparison sort would be O(k log k) comparisons, but each comparison is O(N) so total O(N * k log k) = 100 * 44100 * log2(44100) ≈ 100 * 44100 * 16 = 70.56e6 which is acceptable in 3 seconds? Actually, worst-case Landau for n=100 is 44100? But the actual LCM might be smaller? However, worst-case we must assume 44100. Then 70e6 operations is acceptable in 3 seconds? (C++ might handle, but in Pyton we might need to be cautious, but the problem constraints say N=100, and k is the LCM of cycle lengths, and worst-case LCM for 100 is known to be 44100). 

But note: we are writing an editorial and the solution must run within 3 seconds and 256MB. We can do:

  k = order (by LCM of cycle lengths) -> we don't actually need to generate all permutations if we can avoid it? But we must sort the permutations.

However, we can generate the permutations without simulating the exponentiation for each exponent? 

How to generate P^i for a given i?
  We can do: 
      P^i = (cycle decomposition)^i

In a cycle, if we have a cycle (c0, c1, c2, ..., c_{L-1}), then applying the permutation i times is equivalent to rotating the cycle by i steps (to the right). But note: our permutation is applied as: 
      P: c0 -> c1, c1 -> c2, ... , c_{L-1} -> c0.

Then P^i: the element at position c_j goes to c_{(j+i) mod L}.

So we can compute P^i without composing i times. 

Therefore, we can generate each permutation P^i for i in [1, k] by:

  Precomputation: 
    Factor P into cycles. Let cycles = list of cycles (each cycle is a list of elements, and we note the positions?).

  For a fixed exponent i, we can build an array res[1..N] (or 0-indexed) such that for each cycle, for each element in the cycle, we know:
      The element at position j (which is the current element) in the cycle will be mapped to the element that is i steps ahead in the cycle.

But note: we have to build the entire permutation for exponent i. 

Since k can be 44100 and N=100, then the total work to generate all k permutations is O(k * N) = 44100 * 100 = 4.41e6, which is acceptable.

Then we have a list of k permutations. Each permutation is an array of N integers.

Then we need to sort these k permutations. How to compare two permutations? The problem defines:

  A < B if there exists an index i (starting from 1) such that A_i < B_i and for all j < i, A_j = B_j.

This is lexicographic order. We can compare two permutations in O(N). Then we can sort the list of k permutations using a standard sort, which will take O(k log k * N) = 44100 * log2(44100) * 100 ≈ 44100 * 16 * 100 = 70.56e6 comparisons. Since each comparison is O(N)=100, the total operations would be 70.56e6 * 100? Wait, no: the comparison of two permutations is O(N) per comparison. So the total cost is O(k log k * N) = 44100 * 16 * 100 = 70.56e6 operations (each operation is an integer comparison, which is cheap). 70.56e6 integer comparisons is acceptable in 3 seconds? In C++ it is, but in Python we must be cautious. However, note that 70.56e6 is about 70 million, which might be borderline in Python but the constraints say 3 seconds. Alternatively, we can try to avoid generating the entire list of permutations if we can map the queries without storing all permutations? But Q is 300,000 and we have to answer each query by index.

Alternatively, we can avoid storing all k permutations by generating them on the fly? But we need to sort them. We must store the sorted list because the queries ask for the T_i for a given K_i (which is the rank).

But note: k is about 44100, so storing 44100*100 integers (4.41e6 integers) is acceptable.

Steps:

1. Read N, Q and permutation P (0-indexed or 1-indexed? The problem uses 1-indexed. We'll store as 0-indexed internally, but output and input are 1-indexed? The problem says: the permutation is given as P1, P2, ... PN. So we can store as 0-indexed: index0 = P0 = P1, etc.

2. Factor P into cycles.

   Example: 
        P = [2,3,1,5,4] -> 0-indexed: [1,2,0,4,3] (because: 
            element at index0: 1 -> goes to index1
            element at index1: 2 -> goes to index2
            element at index2: 0 -> goes to index0 -> cycle (0,1,2)
            element at index3: 4 -> goes to index4
            element at index4: 3 -> goes to index3 -> cycle (3,4)

   So cycles = [[0,1,2], [3,4]]

3. Compute k = LCM(cycle lengths). The cycle lengths are 3 and 2, so LCM(3,2)=6. Then M = k+1 = 7.

   But note: the condition is P^{M} = P, which we have established is equivalent to P^{k}=identity. Then the set of exponents we consider is i from 1 to k (which are the exponents for the permutations we have to sort).

4. Precompute an array for each exponent i in [1, k] the permutation P^i.

   We can do:

      Let base = the identity permutation? Actually, we have to compute the permutation for exponent i from the cycles.

      We create an array `perm_i` of size N.

      For each cycle in cycles:
          Let L = len(cycle)
          For each index j in the cycle (0-indexed positions), we need to know: 
              In the cycle, the element at position j (which is the original element at that index) is moved by i steps in the cycle.

          But note: the cycle is a list of indices (the positions). Actually, we have stored the cycle as a list of the elements? Or as a list of the positions? 

          Actually, we have stored the cycle as a list of the indices (positions) that form the cycle. For example, cycle0 = [0,1,2] meaning:
              position0 -> goes to P[0] = 1 (which is the element at position1) -> but wait, in our representation: 
                  We have an array P of length N: P[0] = 1, P[1]=2, P[2]=0, P[3]=4, P[4]=3.

          How to compute the permutation for exponent i? 

          We note that the permutation for exponent i is the function that maps an element at position j to the element that is i steps along the cycle.

          But note: we are building a permutation array for exponent i: let Q = P^i. Then Q[j] = the element at the position that j goes to after i steps? 

          Actually, the permutation P^i is defined by: 
              (P^i)[j] = P applied i times to the element j? 

          However, note the composition: 
              P^1[j] = P[j] 
              P^2[j] = P[P[j]]

          So it is: starting at j, we apply P, i times.

          Therefore, we can precompute for each starting position j, the result of applying P, i times.

          How to do that with cycles? 

          For a given cycle: 
              Let the cycle be: [a0, a1, a2, ..., a_{L-1}], where 
                 P(a0) = a1, P(a1)=a2, ... , P(a_{L-1})=a0.

          Then P^i(a0) = a_{(0+i) mod L}? Actually, the index in the cycle: 
              The element at a0 goes to a_i (if we take i mod L, and if we consider the cycle as arranged in the order of the mapping).

          But note: we have the cycle as a list, and the mapping is: 
                 a0 -> a1 -> a2 -> ... -> a_{L-1} -> a0.

          Then after i steps, the element at a0 moves to a_i (if i < L) or a_{i mod L}. Similarly, the element at a_j moves to a_{(j+i) mod L}.

          Therefore, we can precompute for each position j (which is in the cycle) the image under P^i: 
                 image = the element at position: (current index in the cycle + i) mod L.

          However, we must know the position of j in the cycle. 

          We can precompute an array `mapping` for each position: 
            cycle_index: an array of length N that tells which cycle a position belongs to and what its offset is.

          Alternatively, we can precompute for each cycle the mapping for exponent i.

          Steps for building permutation for exponent i:

             Create an array res of length N (for the permutation) and initially set to -1.

             For each cycle c (list of positions, of length L):
                 For j from 0 to L-1:
                     position = c[j]
                     We want to know: what is the image of the element at position after i steps? 
                     The image is the element that is at the position: c[(j+i) % L]? 

                     But note: the permutation P^i is defined on the positions? 

                     Actually, the permutation P^i: 
                         Input: an index x (0-indexed). Then P^i(x) = the element at the position that we land after i steps? 

                     However, the problem defines the permutation as an array A such that A_i is the element at the i-th position of the array.

                     Specifically, the permutation P^i is an array A of length N such that:
                         A[x] = (P^i)(x)   [meaning the element that we get when we start at x and apply P, i times]

                     So for x = c[j], we have (P^i)(x) = c[(j+i) % L]? 

                     But note: the element at position x (which is the value of the permutation at index x) is the next position? 

                     Actually, no: the permutation is a mapping from index to element. 

                     Example: 
                         Original P: 
                             index0: element is 1 -> so P[0] = 1.
                         But when we apply P, the element at index0 (which is 1) is moved to the position that P maps 0 to? 

                     The permutation P is defined by: 
                         P: 0 -> 1, 1->2, 2->0, 3->4, 4->3.

                     Then P^2: 
                         P^2(0) = P(P(0)) = P(1) = 2.
                         P^2(1) = P(2) = 0.
                         P^2(2) = P(0) = 1.
                         P^2(3) = P(4) = 3.
                         P^2(4) = P(3) = 4.

                     So the permutation P^2 as an array: 
                         index0: 2
                         index1: 0
                         index2: 1
                         index3: 3   -> but wait, above we computed P^2(3)=3? 
                         But our sample: 
                             P^2 = [3,1,2,4,5] -> 0-indexed: [3,1,2,4,4]? 

                     Actually, the sample output: 
                         P^2 = [3,1,2,4,5] -> 1-indexed: 
                             So 0-indexed: [2,0,1,3,4]? 

                     How to get the element at index0? 
                         We have to apply the permutation twice to the index0? 

                     But note the definition: 
                         (A * B)_i = A_{B_i}

                     So P^2 = P * P: 
                         (P*P)[0] = P[ P[0] ] = P[1] = 2 -> which in 1-indexed is 3? (because 0-indexed 2 -> 1-indexed 3) -> no, the permutation array is stored in 0-indexed as the value at index0 is the element that the permutation assigns to the first element? 

                     The problem says: the permutation is [P1, P2, ..., PN]. So the first element (index0) is P1. 

                     Therefore, we have to be consistent: 
                         The given permutation: [2,3,1,5,4] -> 1-indexed: 
                             position1: 2, position2: 3, position3:1, position4:5, position5:4.

                     In 0-indexed, we store:
                         perm[0] = 1 (because the element for position0 (which is the first) is 2 -> but in 0-indexed, the element at position0 should be 2? Actually, we can store as:
                         perm[0] = 2-1? Or we can store the values as they are and then subtract 1 for indices? 

                     We have two options:
                         Option 1: store the permutation as given (so for the sample, we have [2,3,1,5,4]) and use 0-indexed indices for the array, but the values are 1-indexed? Then we have to be careful: 
                            When we do P[0] = 2, which is the element at the first position. But then when we do composition, we have to use: 
                                (A * B)[i] = A[B[i]-1]?   because B[i] is 1-indexed and we need to convert to index.

                     Alternatively, we can convert the entire permutation to 0-indexed: 
                         Subtract 1 from every element.

                     Then the permutation becomes: [1,2,0,4,3] for the sample.

                     Then P^1: 
                         index0: 1 -> which in 1-indexed is 2? 
                         index1: 2 -> 3
                         index2: 0 -> 1
                         index3: 4 -> 5
                         index4: 3 -> 4

                     So the array in 1-indexed: [2,3,1,5,4] -> matches.

                     Therefore, we convert the input permutation to 0-indexed.

          So step: 
             Read the permutation, subtract 1 from each element.

          Then when we output, we don't need to convert back because we are only dealing with exponents and then we are going to sort the 0-indexed permutations? And then we have to answer the queries by T_i, which is an exponent.

          But note: the problem output: for each query, we output T_i (an integer).

          Therefore, we can work entirely in 0-indexed.

          How to compute P^i for a given exponent i (from 1 to k) for a position x?

          We have the cycles. Precompute for each element x (0-indexed) the next element after i steps: 

          Precomputation for cycles:

             We break the permutation into cycles. For each cycle, we have a list of positions: [a0, a1, ..., a_{L-1}], and we know that 
                 P(a_j) = a_{(j+1) mod L}

             Then P^i(a_j) = a_{(j+i) mod L}

          However, note: we need the permutation P^i as an array: for each index j (0-indexed), we want the value P^i(j).

          So for each j, we know which cycle it belongs to and its index in the cycle. Then we can compute: 
             Let the cycle that j belongs to be c, and the position of j in the cycle be pos (so j = c[pos]).
             Then P^i(j) = c[(pos+i) % L]   -> but note: this is the index (position) that we get? 

          However, the permutation array: 
             The element at index j in the permutation array is the value that the permutation assigns to j? 

          But wait: the permutation is defined by: 
             P: j -> P(j) = the value stored in the permutation at index j.

          And in our 0-indexed representation, the permutation array we are given: 
             perm[j] = the image of j under the permutation.

          Then P^i(j) = the image of j after i applications.

          And that is exactly: if j is in a cycle and we know the cycle and the offset, then we can compute the image as the element at the cycle at offset (current_offset + i) mod cycle_length.

          But note: the element we get is an index? Actually, the permutation maps an index to an index (in 0-indexed). 

          Then the permutation array for P^i: 
             result[j] = the image of j under P^i.

          So we can set:
             result[j] = c[(pos + i) % L]   -> but wait: the image is an index? 

          Example: for j=0 (in the sample) in cycle [0,1,2] and i=1: 
             pos = 0, then result[0] = c[(0+1)%3] = c[1] = 1 -> which is the value we have for P^1: at index0 we have 1 (in 0-indexed) -> correct.

          For i=2: 
             result[0] = c[(0+2)%3] = c[2] = 2.

          But then we see: 
             P^2(0) = 2 -> which in 0-indexed is 2? But the sample in 0-indexed: P^2 = [2,0,1,4,3]? 
             Actually, from the sample: 
                 P^2 = [3,1,2,4,5] in 1-indexed -> 0-indexed: [2,0,1,3,4]? 
                 But wait: 
                    In the problem: 
                         P^2 = [3,1,2,4,5] -> 1-indexed: 
                         position1: 3 -> which is index0: 2 (0-indexed value 2) -> but 0-indexed we want: 
                         index0: 2, index1:0, index2:1, index3:3, index4:4.

          However, note: the problem says: 
              P^2 = [3,1,2,4,5] -> meaning:
                  element at position1 (index0) is 3 -> which in 0-indexed is 2.
                  element at position2 (index1) is 1 -> which is 0.
                  element at position3 (index2) is 2 -> which is 1.
                  element at position4 (index3) is 4 -> which is 3? But wait, 4 in 0-indexed is 3? 
                  element at position5 (index4) is 5 -> which is 4.

          So 0-indexed: [2,0,1,3,4] -> and our computation for index0: 2, index1:0, index2:1, index3:3, index4:4 -> matches.

          Therefore, for each j we set:
             result[j] = the element of the cycle at position (current_offset + i) mod L.

          But note: we have two cycles. For the cycle [3,4] (0-indexed): 
             positions: 3 and 4. 
             For j=3: 
                 i=1: result[3] = c1[(0+1)%2] = c1[1] = 4 -> which is 4 in 0-indexed? But we want 4? 
                 But the sample: P^1: at index3: 4? -> but the given permutation at index3: 5 in 1-indexed -> 4 in 0-indexed? Actually, the given permutation: [2,3,1,5,4] -> 0-indexed: [1,2,0,4,3]. So at index3: 4 -> so we want 4? 
                 But wait: our cycle representation for [3,4]: 
                     How did we get the cycle? 
                         Start at 3: P[3]=4 -> then P[4]=3 -> so cycle: [3,4] (in that order). 
                     Then for j=3 (which is the first element in the cycle, so offset0): 
                         P^1(3) = 4 -> correct.

          Therefore, the method is valid.

          Implementation for building the permutation for exponent i:

            Precomputation: 
               cycles = list of cycles (each cycle is a list of the indices in the cycle, in the order of the mapping: the first element is the starting point, then the next is the image of the first, etc.)

            We also create an auxiliary array: 
                cycle_map: array of length N, where 
                    cycle_map[j] = (cycle_index, position_in_cycle)   OR 
                We can create an array `next` for the entire permutation? Actually, we don't need the entire permutation, we need for each j the cycle and the offset.

            Alternatively, we can precompute an array `ans_i` of length N, and for each cycle we fill the positions.

            Steps for exponent i:
                res = [0] * N   # we will fill it
                For each cycle in cycles:
                    L = len(cycle)
                    For j in range(L):  # j is the current offset in the cycle
                        current_index = cycle[j]
                        # The image of current_index under P^i is the element in the cycle at position (j+i) mod L
                        next_offset = (j + i) % L
                        next_index = cycle[next_offset]
                        res[current_index] = next_index   # but wait: we are storing the image as an index? 

                But note: the permutation P^i: at index = current_index, the value is next_index? 
                    This is exactly: P^i(current_index) = next_index.

            This builds the permutation for exponent i.

5. Now we generate k permutations: for exponents i=1,2,...,k.

   Note: we do not generate exponent0? because the problem says i from 1 to M-1, and M-1=k.

   But note: the identity is P^k. We do not generate P^0? 

   So we generate for i in range(1, k+1) [but note: k is the order, and we want i from 1 to k].

6. Then we have a list: 
        permutations = [ P1, P2, ..., Pk ] 
   where P1 = P^1, P2 = P^2, ... , Pk = P^k (the identity).

   Then we sort this list lexicographically.

   Lexicographic comparison: 
        We compare two permutations A and B: 
            for j from 0 to N-1:
                if A[j] != B[j]: 
                    then if A[j] < B[j] then A < B, else B < A.

   Then we get a sorted list: A_sorted = sorted(permutations)

   Then we also store the exponent i for each permutation? Because we have to know: for the sorted array A_sorted, the j-th element (A_sorted[j]) is which exponent? 

   So we create a list of tuples: 
        arr = []
        for exponent i from 1 to k:
            perm_i = the permutation for exponent i (as a tuple? so we can sort) and store (perm_i, i)

        Then sort arr by perm_i.

   Then we have an array: 
        sorted_arr = sorted(arr, key=lambda x: x[0])   # but we are comparing the permutation array lexicographically.

   Then for a query K_i (which is 1-indexed: the K_i-th element in the sorted list), we get:
        T_i = the exponent stored in the (K_i-1)-th element of sorted_arr.

   But note: the problem says: 
        A = [P^6, P^3, P^4, P^1, P^2, P^5] for the sample.

        And the queries: 
            K_i from 1 to 6 -> output: 6,3,4,1,2,5.

        So in our sorted_arr, the 0-th element (the smallest) is P^6 -> which is the identity: [0,1,2,3,4] in 0-indexed? 
        Then next: P^3: 
            P^3: 
                cycle0: [0,1,2]: 
                    i=3: 
                        j=0: (0+3)%3=0 -> so 0->0
                        j=1: (1+3)%3=1 -> 1->1
                        j=2: (2+3)%3=2 -> 2->2
                cycle1: [3,4]:
                    j=0: (0+3)%2=1 -> 3->4
                    j=1: (1+3)%2=0 -> 4->3
                So permutation: [0,1,2,4,3] -> 0-indexed: [0,1,2,4,3]

        Now compare: 
            identity: [0,1,2,3,4] 
            P^3: [0,1,2,4,3] -> 
                compare: 
                    index0: 0==0
                    index1: 1==1
                    index2: 2==2
                    index3: 3 vs 4 -> 3<4 -> so identity is less than P^3? 

        But the problem says A = [P^6, P^3, ...] meaning P^6 is the smallest. 

        So indeed the identity is the smallest.

        Then next: P^3: [0,1,2,4,3] -> then we have to compare with P^4? 

        How about P^4: 
            cycle0: (0+4)%3=1 -> 0->1; 1-> (1+4)%3=2; 2-> (2+4)%3=0 -> [1,2,0, ...]
            cycle1: (0+4)%2=0 -> 3->3; (1+4)%2=1%2=1 -> 4->4? 
            But wait: our cycle1: [3,4]: 
                for j=0: (0+4)%2=0 -> so 3->3? 
                for j=1: (1+4)%2=1 -> so 4->4? 
            So P^4: [1,2,0,3,4] -> 0-indexed.

        Now compare P^3: [0,1,2,4,3] and P^4: [1,2,0,3,4]:
            index0: 0 vs 1 -> 0<1 -> so P^3 is less than P^4.

        Then the sorted list: 
            [0,1,2,3,4] -> identity (exponent6) -> T=6
            [0,1,2,4,3] -> exponent3 -> T=3
            [1,2,0,3,4] -> exponent4 -> T=4
            then next: 
            P^1: [1,2,0,4,3] -> 
            P^2: [2,0,1,3,4] -> 
            P^5: [0,1,2,3,4]? no, wait: P^5 = P^4 * P -> [1,2,0,3,4] * [1,2,0,4,3]? 

            Actually, we compute by our method: 
                P^5: 
                    cycle0: (0+5)%3=2 -> 0->2; 1-> (1+5)%3=0; 2-> (2+5)%3=1 -> [2,0,1, ...]
                    cycle1: (0+5)%2=1 -> 3->4; (1+5)%2=0 -> 4->3 -> [4,3] for indices 3 and 4?
                So P^5: [2,0,1,4,3] -> 0-indexed.

            Now compare:
                After P^4: [1,2,0,3,4] -> next we have to compare with P^1: [1,2,0,4,3] -> 
                    index0: 1==1
                    index1: 2==2
                    index2: 0==0
                    index3: 3 vs 4 -> 3<4 -> so P^4 < P^1? 

            But the problem says the sorted order is: 
                A = [P^6, P^3, P^4, P^1, P^2, P^5]

            So the next after P^4 is P^1? 

            Then we have:
                P^1: [1,2,0,4,3] 
                P^2: [2,0,1,3,4] -> 
                    P^1: index0=1, P^2: index0=2 -> so 1<2 -> P^1 < P^2.

            Then P^5: [2,0,1,4,3] -> 
                index0: 2 (same as P^2: 2) 
                index1: 0 (same as P^2: 0) 
                index2: 1 (same as P^2: 1) 
                index3: 4 vs 3 -> 4>3 -> so P^2 < P^5.

            Therefore, the sorted list by lex order: 
                [0,1,2,3,4] -> T=6
                [0,1,2,4,3] -> T=3
                [1,2,0,3,4] -> T=4
                [1,2,0,4,3] -> T=1
                [2,0,1,3,4] -> T=2
                [2,0,1,4,3] -> T=5

            Which matches the sample output: 
                Query1: K=1 -> T=6
                Query2: K=2 -> T=3
                ... 

7. Then we process the queries: 
        We have an array `answers` of length k: 
            answers[i] = the exponent T for the i-th smallest permutation (i from 0 to k-1).

        Then for a query K_i (which is at least 1 and at most k), we output answers[K_i-1].

8. However, note: k can be large (up to 44100) and we have Q up to 300,000. We can precompute the answers for all ranks and then answer each query in O(1).

Complexity: 
   Step 1: cycle decomposition: O(N)
   Step 2: compute k = LCM(cycle_lengths): O(N) (since the number of cycles is at most 50, and LCM computation is efficient for small integers)
   Step 3: Precomputation for each exponent i (from 1 to k) of the permutation: 
        We generate k permutations, each in O(N) -> total O(k * N) = 44100 * 100 = 4.41e6.
   Step 4: Sort the k permutations: O(k * N * log k) = 4.41e4 * log(44100) * 100 -> worst-case about 4.41e4 * 16 * 100 = 70.56e6 comparisons, each comparison in the worst-case O(N) but actually we break early? The lexicographic comparison is O(N) per pair. But the sort algorithm will do O(k log k) comparisons, each O(N) -> total O(N * k log k) = 100 * 44100 * 16 = 70.56e6 operations. This is acceptable in C++ but in Python? We must hope that 70e6 operations is acceptable in 3 seconds? (It is in C++ easily, and in Pyton it might be borderline but note: 70e6 operations is about 70 million, and in Pyton 3 seconds might be acceptable? But worst-case Landau number for 100 is 44100, and we have 70.56e6 operations, which is acceptable in Pyton in 3 seconds? We should test with worst-case, but the constraints say N=100 and worst-case k=44100, and 70.56e6 is acceptable in Pyton? Actually, worst-case 70.56e6 operations (each operation a few integer comparisons) is acceptable in Pyton in 3 seconds? We might need to optimize the comparison by using tuples and letting the built-in sort (which is efficient in Pyton for tuples? but we are comparing lists). Alternatively, we can convert each permutation to a tuple of N integers and then sort the list of tuples. The built-in sort in Pyton for tuples is lexicographic and optimized. 

   Alternatively, we can avoid storing the entire permutation if we can generate a key? But the permutation has 100 integers, so we can represent it as a tuple. Then the sort will be comparing tuples, which is lexicographic.

   Step 5: Then we store for each exponent the permutation as a tuple and store (tuple, exponent). Then sort by the tuple.

   Then we create an array `ans_arr` of length k: 
        sorted_list = sorted( list_of_tuples, key=lambda x: x[0] )   # but we don't need a key because the tuple is the permutation and we want to sort by that.
        Actually: 
            list_of_tuples = [ (tuple_perm1, exp1), (tuple_perm2, exp2), ... ]

        Then we sort: sorted_list = sorted(list_of_tuples)  # by default, the tuple is compared lexicographically.

   Then we extract the exponents in the sorted order: 
        answers = [ exp for (perm, exp) in sorted_list ]

   Then for each query K_i: 
        output answers[K_i-1]

9. Edge: when k=1? 
        But the problem: M is the smallest integer >1 such that P^M = P. 
        Then M-1 = k must be at least 1? 
        But note: if P is the identity? 
            Then P^1 = identity = P.
            But we are looking for the smallest integer M>1 such that P^M = P. 
            P^2 = identity = P? -> only if P is identity then P^2 = identity = P? 
            So M=2, then k=1? 

        However, the problem states: 
            "Let M be the smallest integer greater than 1 such that P = P^M"

        For the identity: 
            P^1 = identity
            P^2 = identity -> so P^2 = P? -> yes, because identity = identity.

        Then M=2, so k = M-1 = 1.

        Then we have to generate P^i for i=1 to 1 (only one permutation: P^1 = identity).

        Then we sort the list of one permutation: trivial.

        Then for a query: K_i must be in [1, M-1] = [1,1]. So we have one query: K_i=1 -> output T_i=1.

        This works.

Implementation:

   Steps:

      N, Q = map(int, input().split())
      P = list(map(int, input().split()))
      # Convert to 0-indexed: subtract 1 from each element
      P0 = [x-1 for x in P]

      # Factor into cycles
      visited = [False] * N
      cycles = []
      for i in range(N):
          if not visited[i]:
              cycle = []
              cur = i
              while not visited[cur]:
                  visited[cur] = True
                  cycle.append(cur)
                  cur = P0[cur]
              cycles.append(cycle)

      # Compute k = LCM of the lengths of cycles
      from math import gcd
      cycle_lengths = [len(cycle) for cycle in cycles]
      k = 1
      for L in cycle_lengths:
          k = k * L // gcd(k, L)

      # Now, we want to generate k permutations: for exponent i from 1 to k (inclusive)
      # Precompute an auxiliary structure for each cycle: we have the list of indices, and we also precompute an array `which_cycle` and `offset_in_cycle` for each element? 
      # Actually, we can create an array `pos_in_cycle` of length N: for each node, we store the cycle it belongs to and the offset? 
      # But we don't need the entire cycle, we only need the length and the offset? 
      # Alternatively, we can precompute a list: 
      #   For each element, we store: 
      #       cycle_index: not needed, but we store the cycle that contains it? 
      #   Actually, we can precompute an array `cycle_info` for each index: 
      #       cycle_info[i] = (cycle_ref, offset) 
      #   But we can do without: we can precompute an array `next_pos` for the entire permutation? 
      #   Actually, we can do without: when building the permutation for exponent i, we can iterate by cycles.

      # However, we have the cycles. For each exponent i, we can build the permutation by:
      #   res = [0] * N
      #   for cycle in cycles:
      #       L = len(cycle)
      #       for j in range(L):
      #           cur_index = cycle[j]
      #           next_index_in_cycle = (j + i) % L
      #           next_index = cycle[next_index_in_cycle]
      #           res[cur_index] = next_index
      #
      # Then we have the permutation for exponent i.

      permutations_list = []   # each element: (perm_tuple, exponent i)
      # Note: we generate for i from 1 to k
      # But note: we must avoid generating the identity for exponent0? we start at i=1.

      # However, note: k might be large (44100) but we can generate 44100 permutations? 44100*100=4.41e6 -> acceptable.

      for exponent in range(1, k+1):
          perm_arr = [0] * N
          for cycle in cycles:
              L = len(cycle)
              for j in range(L):
                  cur_index = cycle[j]
                  next_offset = (j + exponent) % L
                  next_index = cycle[next_offset]
                  perm_arr[cur_index] = next_index
          # Convert to tuple for sorting
          perm_tuple = tuple(perm_arr)
          permutations_list.append( (perm_tuple, exponent) )

      # Sort the list by perm_tuple (which is lex order)
      permutations_list_sorted = sorted(permutations_list, key=lambda x: x[0])

      # Extract the exponents in the sorted order
      exponents_sorted = [exp for (perm, exp) in permutations_list_sorted]

      # Now process queries:
      for _ in range(Q):
          K = int(input())
          # K is between 1 and k (since M-1=k and queries are from 1 to k)
          # We have exponents_sorted[K-1]
          print(exponents_sorted[K-1])

But note: worst-case k=44100, which is acceptable. But Q can be 300,000, and we precomputed exponents_sorted, so each query is O(1).

However, the sample: 
   Input: 
        5 6
        2 3 1 5 4
        1
        2
        3
        4
        5
        6
   Output: 
        6
        3
        4
        1
        2
        5

Let me test with the sample: 
   We have cycles: [0,1,2] and [3,4] -> lengths 3 and 2 -> k = LCM(3,2)=6.

   Then we generate for exponent=1 to 6:

      exponent1: 
          cycle0: 
              0: (0+1)%3=1 -> 1
              1: (1+1)%3=2 -> 2
              2: (2+1)%3=0 -> 0
          cycle1:
              3: (0+1)%2=1 -> 4
              4: (1+1)%2=0 -> 3
          So perm_arr: [1,2,0,4,3] -> tuple: (1,2,0,4,3)

      exponent2: 
          cycle0: 
              0-> (0+2)%3=2 -> 2
              1-> (1+2)%3=0 -> 0
              2-> (2+2)%3=1 -> 1
          cycle1:
              3-> (0+2)%2=0 -> 3
              4-> (1+2)%2=1 -> 4
          perm_arr: [2,0,1,3,4] -> tuple: (2,0,1,3,4)

      exponent3: 
          cycle0: 
              0-> (0+3)%3=0 ->0
              1-> (1+3)%3=1 ->1
              2-> (2+3)%3=2 ->2
          cycle1:
              3-> (0+3)%2=1 ->4
              4-> (1+3)%2=0 ->3
          perm_arr: [0,1,2,4,3] -> tuple: (0,1,2,4,3)

      exponent4: 
          cycle0: 
              0-> (0+4)%3=1 ->1
              1-> (1+4)%3=2 ->2
              2-> (2+4)%3=0 ->0
          cycle1:
              3-> (0+4)%2=0 ->3
              4-> (1+4)%2=1 ->4
          perm_arr: [1,2,0,3,4] -> tuple: (1,2,0,3,4)

      exponent5: 
          cycle0: 
              0-> (0+5)%3=2 ->2
              1-> (1+5)%3=0 ->0
              2-> (2+5)%3=1 ->1
          cycle1:
              3-> (0+5)%2=1 ->4
              4-> (1+5)%2=0 ->3
          perm_arr: [2,0,1,4,3] -> tuple: (2,0,1,4,3)

      exponent6: 
          cycle0: 
              0->0, 1->1, 2->2
          cycle1: 
              3->3, 4->4
          perm_arr: [0,1,2,3,4] -> identity.

   Now we build the list of tuples:

        ( (1,2,0,4,3), 1 )
        ( (2,0,1,3,4), 2 )
        ( (0,1,2,4,3), 3 )
        ( (1,2,0,3,4), 4 )
        ( (2,0,1,4,3), 5 )
        ( (0,1,2,3,4), 6 )

   Now sort lexicographically:

        (0,1,2,3,4) -> 6
        (0,1,2,4,3) -> 3
        (1,2,0,3,4) -> 4
        (1,2,0,4,3) -> 1
        (2,0,1,3,4) -> 2
        (2,0,1,4,3) -> 5

   So the sorted list of exponents: [6,3,4,1,2,5]

   Then for K=1: 6, K=2:3, ... K=6:5.

   This matches.

But note: the problem says the permutation for exponent4 is [1,2,0,3,4] -> which is (1,2,0,3,4) in 0-indexed. 

However, in the sample problem statement: 
   P^4 = [2,3,1,4,5] -> 1-indexed. 
   Convert to 0-indexed: 
        [2-1, 3-1, 1-1, 4-1, 5-1] = [1,2,0,3,4] -> which matches.

Therefore, the solution is correct.

But note: worst-case when N=100, the LCM might be as large as about 44100, which is acceptable. However, worst-case Landau number for 100 is 44100, and we have 44100 * 100 = 4.41e6 for generating the permutations, and then sorting 44100 elements with 100 elements each: 44100*log2(44100)*100 ≈ 70e6 comparisons, which in Python might be borderline in 3 seconds? 

But note: we are using the built-in sort in Python, which is Timsort. The worst-case for Timsort is O(n log n) and 44100 is about 4.4e4, so log2(44100) is about 16. Then the number of comparisons is about 44100 * 16 = 705600, and each comparison compares two tuples: which in the worst-case might compare all 100 elements. So total operations 705600 * 100 = 70.56e6. 

In Python, 70e6 operations might take a few seconds? We should try to optimize the comparison by using a precomputed key? 

Alternative: we can represent each permutation as a tuple, and then the sort will be comparing tuples. The tuple comparison is lexicographic and is implemented in C so it is fast. 70e6 comparisons of 100-element tuples might be acceptable in 3 seconds? 

We can try to run a test in Python: create 44100 tuples of 100 integers, and sort them. The total memory is 44100 * 100 * size_of_int? about 44100 * 100 * 8 (if int is 8 bytes) = 44100*800 = 35.28e6 bytes = 35 MB? which is acceptable. Then the sort: worst-case O(n log n) comparisons, each comparison O(100) -> 70.56e6 comparisons? Actually, the number of comparisons in the sort is O(n log n) = 44100 * 16 = 705600 comparisons, and each comparison compares two tuples: in the worst-case it might compare all 100 elements. So the total number of integer comparisons is 705600 * 100 = 70.56e6. In Pyton, 70e6 integer comparisons might take about 1-2 seconds? 

But worst-case, we have 300,000 queries? The precomputation is the heavy part, and then each query is O(1).

Therefore, we code as described.

Let me write the code in the editorial? But the problem says avoid writing actual code. So we'll stick to the plan.

However, note: the problem says the permutation is given as [P1, P2, ..., PN] and we subtract 1 to get 0-indexed.

Edge: when k is 0? 
   But k is the LCM of cycle lengths, and each cycle length is at least 1, so k>=1.

We are done.

Summary:

   Steps:

     Read N, Q.
     Read permutation P (convert to 0-indexed).

     Factor P into cycles.

     Compute k = LCM(cycle_lengths).

     Generate k permutations: for exponent i from 1 to k:
          For each cycle in cycles:
              L = length(cycle)
              For each index j in the cycle (from 0 to L-1):
                  current_index = cycle[j]
                  next_index = cycle[(j+i) % L]
                  perm_arr[current_index] = next_index

          Store (tuple(perm_arr), i)

     Sort the list of (tuple, i) by the tuple (lexicographically).

     Create an array `ans` of the exponents i in the sorted order.

     For each query K_i (from input):
          output ans[K_i-1]

Time complexity: O(k * N) for generating permutations, and O(k * N * log k) for sorting. 
Space: O(k * N) to store the permutations.

This meets the constraints since k <= 44100 and N=100.

We'll hope that in Pyton, 4.4e4 * 100 = 4.4e6 integers for storing the permutations (about 35.2 MB) and the sort with 70e6 integer comparisons is acceptable in 3 seconds.

But note: worst-case Q=300,000, but we only do O(1) per query.

Let me run the numbers for the worst-case:

   k = 44100, N=100 -> 
        Generating permutations: 44100 * 100 = 4.41e6 assignments -> fast.

   Sorting: 
        Number of comparisons in the sort: about 44100 * log2(44100) ≈ 44100 * 16 = 705600 comparisons.
        Each comparison: worst-case we compare all 100 integers -> 705600 * 100 = 70.56e6 integer comparisons.

   In Pyton, integer comparisons are fast. 70e6 might take about 1 second? 

   So total within 3 seconds.

We are good.

Final editorial:

We are given a permutation P of size N and Q queries. We must compute the smallest integer M>1 such that P^M = P (which is equivalent to P^{M-1} = identity). Then we consider the set of permutations {P^1, P^2, ..., P^{M-1}} and sort them in increasing order (lexicographic order). For each query K_i, we must return the exponent T_i such that P^{T_i} is the K_i-th permutation in the sorted list.

Key steps:

1. **Cycle decomposition**: Break the permutation into disjoint cycles. The order of the permutation (the smallest positive integer k such that P^k = identity) is the LCM of the lengths of the cycles. Then M = k+1.

2. **Generating the permutations**: For each exponent i from 1 to k, we generate the permutation P^i. This is done by, for each cycle of length L, moving each element in the cycle i steps forward (cyclically). Specifically, for an element at position j in the cycle (0-indexed in the cycle list), its image is the element at position (j+i) mod L in the same cycle.

3. **Sorting**: We collect the k permutations (each represented as a tuple for easy comparison) along with the exponent i. Then we sort this list of tuples by the permutation (lexicographic order).

4. **Query processing**: We precompute an array that lists the exponents in the sorted order. Then for each query K_i, we output the exponent at position K_i-1 in that array.

Complexity: 
   - Cycle decomposition: O(N)
   - Computing LCM: O(N) (since the number of cycles is at most N, and the LCM computation for numbers up to 100 is efficient)
   - Generating permutations: O(k * N) = O(LCM(cycle_lengths) * N). Worst-case LCM for N=100 is 44100, so 4.41e6 operations.
   - Sorting: O(k * log k * N) = O(44100 * 16 * 100) = 70.56e6 operations (which is acceptable in 3 seconds in Pyton? We hope so, and in C++ it is fast).
   - Query processing: O(Q)

This approach is efficient and meets the constraints.

Note: We work in 0-indexed internally for simplicity.

Let me run the provided sample: it matches.

Therefore, the solution is correct.