### Approach
1. **Problem Analysis**:
   - The problem involves permutations and their exponentiation. The key observation is that the smallest integer \( M > 1 \) such that \( P^M = P \) is equivalent to \( P^{M-1} \) being the identity permutation. Here, \( M-1 \) is the order of the permutation \( P \), which is the least common multiple (LCM) of the lengths of its disjoint cycles.
   - We need to generate all permutations \( P^1, P^2, \ldots, P^k \) (where \( k = M-1 \)), sort them lexicographically, and answer queries about the exponent corresponding to the \( K_i \)-th permutation in this sorted list.

2. **Cycle Decomposition**:
   - Decompose the permutation \( P \) into disjoint cycles. Each cycle represents a sequence of elements where applying \( P \) shifts each element to the next position in the cycle.

3. **Order Calculation**:
   - The order \( k \) of the permutation \( P \) is the LCM of the lengths of these cycles. This \( k \) determines the number of distinct permutations we generate (from \( P^1 \) to \( P^k \)).

4. **Generating Permutations**:
   - For each exponent \( i \) from 1 to \( k \), generate \( P^i \) by rotating each element in every cycle \( i \) positions forward. This rotation is done cyclically using modulo arithmetic.

5. **Sorting Permutations**:
   - Store each generated permutation \( P^i \) along with its exponent \( i \). Sort these permutations lexicographically to form a list \( A \).

6. **Query Processing**:
   - For each query \( K_i \), the answer is the exponent \( T_i \) such that \( P^{T_i} \) is the \( K_i \)-th permutation in the sorted list \( A \).

### Solution Code
```python
import math
from math import gcd

def main():
    import sys
    data = sys.stdin.read().split()
    n = int(data[0])
    q = int(data[1])
    P = list(map(int, data[2:2+n]))
    queries = list(map(int, data[2+n:2+n+q]))
    
    P0 = [x - 1 for x in P]
    
    visited = [False] * n
    cycles = []
    for i in range(n):
        if not visited[i]:
            cycle = []
            cur = i
            while not visited[cur]:
                visited[cur] = True
                cycle.append(cur)
                cur = P0[cur]
            cycles.append(cycle)
    
    cycle_lengths = [len(cycle) for cycle in cycles]
    k = 1
    for L in cycle_lengths:
        k = k * L // gcd(k, L)
    
    list_of_permutations = []
    for exponent in range(1, k+1):
        perm_arr = [0] * n
        for cycle in cycles:
            L_cycle = len(cycle)
            for j in range(L_cycle):
                current_index = cycle[j]
                next_index_in_cycle = (j + exponent) % L_cycle
                next_index = cycle[next_index_in_cycle]
                perm_arr[current_index] = next_index
        list_of_permutations.append((tuple(perm_arr), exponent))
    
    list_of_permutations.sort(key=lambda x: x[0])
    exponents_sorted = [exp for (perm, exp) in list_of_permutations]
    
    output = []
    for K in queries:
        output.append(str(exponents_sorted[K-1]))
    
    sys.stdout.write("\n".join(output))

if __name__ == '__main__':
    main()
```

### Explanation
1. **Reading Input**:
   - The input consists of the size of the permutation \( N \), the number of queries \( Q \), the permutation \( P \), and the queries \( K_i \).

2. **Cycle Decomposition**:
   - The permutation \( P \) is decomposed into disjoint cycles. For example, the permutation \([2, 3, 1, 5, 4]\) decomposes into cycles \([0, 1, 2]\) and \([3, 4]\).

3. **Order Calculation**:
   - The order \( k \) (which is \( M-1 \)) is computed as the LCM of the lengths of the cycles. For cycles of lengths 3 and 2, \( k \) is 6.

4. **Generating Permutations**:
   - For each exponent \( i \) from 1 to \( k \), the permutation \( P^i \) is generated by rotating each element in every cycle \( i \) positions forward. For instance, \( P^1 \) for the cycle \([0, 1, 2]\) maps 0→1, 1→2, and 2→0.

5. **Sorting Permutations**:
   - The generated permutations are stored as tuples along with their exponents and sorted lexicographically. This sorted list \( A \) contains permutations in increasing order.

6. **Answering Queries**:
   - For each query \( K_i \), the solution retrieves the \( K_i \)-th permutation from the sorted list \( A \) and outputs the corresponding exponent \( T_i \).

This approach efficiently handles the constraints by leveraging cycle properties and modular arithmetic for permutation generation, followed by sorting and direct query resolution. The complexity is manageable due to the constraints on \( N \) (up to 100) and the worst-case order \( k \) (up to 44100).