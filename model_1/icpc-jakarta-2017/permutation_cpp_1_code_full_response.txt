To solve this problem, we need to handle multiple queries on the sorted list of permutations generated by exponentiating a given permutation. The key insight is recognizing that the permutations repeat after a certain exponent, known as the order of the permutation. The order is determined by the least common multiple (LCM) of the lengths of the disjoint cycles in the permutation. 

### Approach
1. **Cycle Decomposition**: Decompose the given permutation into its disjoint cycles. Each cycle represents a sequence where applying the permutation shifts elements cyclically.
2. **Order Calculation**: Compute the order of the permutation as the LCM of the lengths of these cycles. This order, denoted as \( k \), indicates the number of distinct permutations generated by exponentiating the original permutation from 1 to \( k \).
3. **Permutation Generation**: For each exponent from 1 to \( k \), generate the corresponding permutation by rotating each cycle in the decomposition by the exponent positions. This involves computing the new positions of elements within each cycle using modulo arithmetic.
4. **Lexicographical Sorting**: Sort the generated permutations lexicographically. To handle the sorting efficiently, especially given the constraints, we use a radix sort algorithm. Radix sort is chosen because it processes each digit (position in the permutation) in linear time, making it suitable for large \( k \) (up to 44,100 for \( N = 100 \)).
5. **Query Processing**: For each query, retrieve the exponent corresponding to the \( K_i \)-th smallest permutation from the sorted list.

### Solution Code
```cpp
#include <iostream>
#include <vector>
using namespace std;

int gcd(int a, int b) {
    if (b == 0) return a;
    return gcd(b, a % b);
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    int n, q;
    cin >> n >> q;
    vector<int> P(n);
    for (int i = 0; i < n; i++) {
        cin >> P[i];
        P[i]--;
    }

    vector<bool> visited(n, false);
    vector<vector<int>> cycles;
    for (int i = 0; i < n; i++) {
        if (!visited[i]) {
            vector<int> cycle;
            int cur = i;
            while (!visited[cur]) {
                visited[cur] = true;
                cycle.push_back(cur);
                cur = P[cur];
            }
            cycles.push_back(cycle);
        }
    }

    vector<int> cycle_lengths;
    for (auto &cycle : cycles) {
        cycle_lengths.push_back(cycle.size());
    }
    int k = 1;
    for (int L : cycle_lengths) {
        int g = gcd(k, L);
        k = (k / g) * L;
    }

    vector<vector<int>> perms(k, vector<int>(n));
    for (int i = 0; i < k; i++) {
        int exponent = i + 1;
        for (auto &cycle : cycles) {
            int L = cycle.size();
            for (int j = 0; j < L; j++) {
                int new_index_in_cycle = (j + exponent) % L;
                perms[i][cycle[j]] = cycle[new_index_in_cycle];
            }
        }
    }

    vector<int> idx(k);
    for (int i = 0; i < k; i++) {
        idx[i] = i;
    }

    for (int d = n - 1; d >= 0; d--) {
        vector<int> count(n, 0);
        for (int i = 0; i < k; i++) {
            int x = perms[idx[i]][d];
            count[x]++;
        }

        vector<int> pos(n, 0);
        if (n > 0) {
            for (int x = 1; x < n; x++) {
                pos[x] = pos[x - 1] + count[x - 1];
            }
        }

        vector<int> new_idx(k);
        for (int i = 0; i < k; i++) {
            int perm_index = idx[i];
            int x = perms[perm_index][d];
            new_idx[pos[x]] = perm_index;
            pos[x]++;
        }

        idx = new_idx;
    }

    vector<int> result_exponent(k);
    for (int i = 0; i < k; i++) {
        result_exponent[i] = idx[i] + 1;
    }

    for (int i = 0; i < q; i++) {
        int K;
        cin >> K;
        cout << result_exponent[K - 1] << '\n';
    }

    return 0;
}
```

### Explanation
1. **Cycle Decomposition**: The permutation is decomposed into disjoint cycles. For example, the permutation \([2, 3, 1, 5, 4]\) decomposes into cycles \([0 \rightarrow 1 \rightarrow 2 \rightarrow 0]\) and \([3 \rightarrow 4 \rightarrow 3]\).
2. **Order Calculation**: The order \( k \) is the LCM of the cycle lengths. For cycles of lengths 3 and 2, \( k = 6 \).
3. **Permutation Generation**: For each exponent \( i \) from 1 to \( k \), the permutation \( P^i \) is generated by rotating each cycle \( i \) positions. For instance, \( P^1\) is the original permutation, \( P^2\) rotates each cycle by 2 positions, etc.
4. **Radix Sort**: The generated permutations are sorted lexicographically using radix sort. This involves sorting digit by digit (from least significant to most significant) to ensure linear time complexity per digit, making the overall sorting efficient.
5. **Query Handling**: Each query asks for the exponent of the \( K_i \)-th smallest permutation. The sorted list of exponents is used to answer each query in constant time by direct lookup.

This approach efficiently handles the constraints by leveraging cycle properties, modular arithmetic for permutation generation, and radix sort for efficient lexicographical sorting, ensuring optimal performance even for large inputs.