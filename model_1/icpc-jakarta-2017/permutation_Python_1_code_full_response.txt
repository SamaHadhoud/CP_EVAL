To solve this problem, we need to handle multiple queries on permutations generated by exponentiating a given permutation. The key insight is recognizing that the permutations generated by exponentiating the given permutation form a cyclic group, and the order of this group is determined by the least common multiple (LCM) of the lengths of the disjoint cycles in the permutation. 

### Approach
1. **Cycle Decomposition**: Decompose the given permutation into its disjoint cycles. Each cycle represents a sequence where applying the permutation shifts elements cyclically within the cycle.
2. **Order Calculation**: The order of the permutation, denoted as \( k \), is the LCM of the lengths of these cycles. This \( k \) determines the number of distinct permutations generated by exponentiating the original permutation from \( P^1 \) to \( P^k \).
3. **Generating Permutations**: For each exponent from 1 to \( k \), generate the permutation \( P^i \) by rotating each element in every cycle \( i \) positions forward (using modulo arithmetic).
4. **Sorting Permutations**: Store each generated permutation along with its exponent in a list. Sort this list lexicographically to form the sorted list \( A \).
5. **Query Processing**: For each query \( K_i \), retrieve the exponent \( T_i \) such that \( P^{T_i} \) is the \( K_i \)-th permutation in the sorted list \( A \).

### Solution Code
```python
import math
from math import gcd
import sys

def main():
    data = sys.stdin.read().split()
    n = int(data[0])
    q = int(data[1])
    P = list(map(int, data[2:2+n]))
    queries = list(map(int, data[2+n:2+n+q]))
    
    P0 = [x - 1 for x in P]
    
    visited = [False] * n
    cycles = []
    for i in range(n):
        if not visited[i]:
            cycle = []
            cur = i
            while not visited[cur]:
                visited[cur] = True
                cycle.append(cur)
                cur = P0[cur]
            cycles.append(cycle)
    
    cycle_lengths = [len(cycle) for cycle in cycles]
    k = 1
    for L in cycle_lengths:
        k = k * L // gcd(k, L)
    
    list_of_permutations = []
    for exponent in range(1, k+1):
        arr = [0] * n
        for cycle in cycles:
            L_cycle = len(cycle)
            for j in range(L_cycle):
                current_index = cycle[j]
                next_index_in_cycle = (j + exponent) % L_cycle
                next_index = cycle[next_index_in_cycle]
                arr[current_index] = next_index
        list_of_permutations.append((tuple(arr), exponent))
    
    list_of_permutations.sort(key=lambda x: x[0])
    exponents_sorted = [exp for (perm, exp) in list_of_permutations]
    
    output_lines = []
    for K in queries:
        output_lines.append(str(exponents_sorted[K-1]))
    
    sys.stdout.write("\n".join(output_lines))

if __name__ == '__main__':
    main()
```

### Explanation
1. **Cycle Decomposition**: The permutation is decomposed into disjoint cycles. For example, the permutation \([2, 3, 1, 5, 4]\) decomposes into cycles \([0, 1, 2]\) and \([3, 4]\) (0-indexed).
2. **Order Calculation**: The order \( k \) of the permutation is the LCM of the cycle lengths. For cycles of lengths 3 and 2, \( k = 6 \).
3. **Generating Permutations**: For each exponent \( i \) from 1 to \( k \), the permutation \( P^i \) is generated by rotating each element in its cycle \( i \) positions forward. For instance, for exponent 2 in the cycle \([0, 1, 2]\), element at position 0 moves to position 2.
4. **Sorting Permutations**: Each generated permutation is stored as a tuple along with its exponent. These tuples are sorted lexicographically to form the list \( A \).
5. **Query Processing**: For each query \( K_i \), the solution retrieves the exponent at position \( K_i - 1 \) in the sorted list of exponents, which corresponds to the \( K_i \)-th permutation in \( A \).

This approach efficiently handles the constraints by leveraging cycle properties and modular arithmetic for permutation generation, followed by sorting and direct query resolution. The complexity is manageable due to the constraints on \( N \) (up to 100) and the worst-case order \( k \) (up to 44100).