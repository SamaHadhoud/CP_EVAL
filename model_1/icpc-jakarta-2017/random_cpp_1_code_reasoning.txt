 Okay, we are going to follow the editorial guidelines. The key is to precompute the DP table for each distinct N only once and then process all test cases with that N.

 Steps:
 1. Read T test cases.
 2. Since the total K across test cases is <= 100,000, we can process each test case by counting frequencies to get (a, b). However, note that T can be up to 100,000 but the constraint on the sum of K is 100,000. Also, the distinct N values: note that N is at most 3000, but T can be up to 100,000. However, we are told that the sum of K is <= 100,000. Also, note that N is in [1,3000]. So the distinct N values we get in the test cases might be up to 3000, but we can group by N.

 However, worst-case if we have 100,000 test cases and each with a different N (but N only goes up to 3000), then actually distinct N values are at most 3000. But note: T can be 100,000, but the distinct N in the test cases might be much fewer because N is bounded by 3000. So we can group by N.

 Important: The recurrence in the editorial:

   E(0,0) = 0.

   For state (a, b):
      E(a, b) = [N + a * E(a-1, b+1) + b * E(a, b-1)] / (a+b)

   But note: when we pick a number that is not in the unseen (a) or the seen once (b) but already seen twice, then we stay at (a, b). However, the recurrence above does not explicitly show that. Actually, the recurrence is derived from:

      E(a, b) = 1 + [ (a/N) * E(a-1, b+1) + (b/N) * E(a, b-1) + ((N - a - b)/N) * E(a, b) ]

   Rearranging:

      E(a, b) - ((N - a - b)/N) * E(a, b) = 1 + (a/N) * E(a-1, b+1) + (b/N) * E(a, b-1)
      => ( (a+b)/N ) * E(a, b) = 1 + (a/N) * E(a-1, b+1) + (b/N) * E(a, b-1)
      => E(a, b) = (N + a * E(a-1, b+1) + b * E(a, b-1)) / (a+b)

   So the recurrence is correct.

 Implementation:

   We iterate by s = a + b, from 0 up to N. But note: we have to iterate in increasing order of s? Actually, when we compute state (a,b), we need:
        (a-1, b+1) -> s = a-1+b+1 = a+b = s (so same s) but then also (a, b-1) which is s-1.

   However, the recurrence for (a, b) depends on:
        (a-1, b+1): same s? because (a-1) + (b+1) = a+b = s.
        (a, b-1): which is s-1.

   So we have to iterate by s in increasing order? But note: (a, b-1) has s-1, which is lower and we can compute first. However, (a-1, b+1) is the same s? Then we must iterate within the same s in a particular order? 

   Actually, if we iterate by s from 0 to N, and for each s, we can iterate a from 0 to s (then b = s - a). But then when we compute state (a, b), we need:
        (a-1, b+1): which is (a-1, s - a + 1) -> but note that s = a+b, so if we are at (a, b) then (a-1, b+1) is (a-1, s - a + 1). Now, note that a-1 + (s - a + 1) = s, so same s.

        Also, (a, b-1) is (a, s-1 - a) -> but wait, if we are at (a, b) then b = s - a, so b-1 = s - a - 1. Then the state is (a, s - a - 1) which has s' = a + (s - a - 1) = s - 1.

   Therefore, we can iterate s from 0 to N, and for each s, we iterate a from 0 to s. However, the state (a-1, b+1) is at the same s and we might not have computed it yet.

   How to order within the same s? The recurrence for (a, b) uses (a-1, b+1) and (a, b-1). Note that (a, b-1) is at s-1, which we have computed. But (a-1, b+1) is at the same s. So we need to compute states with the same s in an order that ensures (a-1, b+1) is computed before (a, b)? Actually, if we iterate a from 0 to s, then:

        For a=0: then we have state (0, s). This state depends on:
            (0-1, s+1) -> invalid? so we have to handle a=0 separately: then the recurrence becomes:

            E(0, s) = (N + s * E(0, s-1)) / s   [because a=0, so the term a * ... vanishes, and the b term becomes s * E(0, s-1) because b = s]

        Similarly, for a=s, then b=0: then the recurrence becomes:
            E(s, 0) = (N + s * E(s-1, 1)) / s   [here, a=s, so the term a * E(s-1, 1) remains and the b term vanishes]

        For a in [1, s-1]: we have both terms.

   But note: when we compute (0, s) we need E(0, s-1) which is at s-1 (so computed) and also (a-1, b+1) for (0, s) would be (-1, s+1) which is invalid -> so we skip that term? Actually, the recurrence we wrote above for the general case assumed a>=1 and b>=1. So we must handle boundaries.

   Actually, the recurrence in the editorial says:

        If a==0: then E(0, b) = (N + b * E(0, b-1)) / b   [but note: then we require b>=1? because otherwise division by zero]

        Similarly, if b==0: then E(a, 0) = (N + a * E(a-1, 1)) / a   [a>=1]

        If both a>0 and b>0: then the general recurrence.

   However, what about state (0,0)? That is the base: E(0,0)=0.

   But note: the problem states that at least one number hasn't appeared at least twice, so we won't have (0,0) as the starting state? Actually, we are only going to be called for states that are not (0,0). However, we need to compute (0,0) as base.

   Also, note: the recurrence for (0, b) when b>=1: we have:

        E(0, b) = (N + b * E(0, b-1)) / b

        But this is a recurrence that goes from b to b-1. So if we iterate s (which is a+b = 0+b = b) from 0 to N, then we can compute (0, b) by increasing b? Actually, we can compute for s=0: (0,0) -> then for s=1: (0,1) and (1,0). But (0,1): we have E(0,1) = (N + 1 * E(0,0)) / 1 = N. Then (1,0): E(1,0) = (N + 1 * E(0,1)) / 1 = (N + N) = 2*N.

   Then for s=2: 
        (0,2): E(0,2) = (N + 2 * E(0,1)) / 2 = (N + 2*N) / 2 = (3N)/2.
        (1,1): E(1,1) = (N + 1*E(0,2) + 1*E(1,0)) / 2 = (N + (3N/2) + 2N) / 2 = (N + 3N/2 + 2N) = ( (2N + 3N + 4N) / 2 ) / 2? Actually:

            E(1,1) = [N + 1*E(0,2) + 1*E(1,0)] / 2
                   = [N + (3N/2) + 2N] / 2
                   = [ (2N/2) + (3N/2) + (4N/2) ] / 2
                   = [ (9N/2) ] / 2 = 9N/4.

        (2,0): E(2,0) = (N + 2 * E(1,1)) / 2 = (N + 2*(9N/4)) / 2 = (N + 9N/2) / 2 = ( (2N + 9N) / 2 ) / 2 = (11N/2) / 2 = 11N/4.

   But note: the recurrence for (1,1) uses E(0,2) which we just computed and E(1,0) which was computed at s=1. So we can compute within the same s by iterating a in any order? Actually, (0,2) is computed when a=0 and then (1,1) is computed when a=1. So we can iterate a from 0 to s. This order: a=0, then a=1, then a=2, ... then a=s. Then when computing (a, b) we have already computed (a-1, b+1) if we did lower a first? Actually, (a-1, b+1) has a'=a-1 which is less than a. So if we iterate a in increasing order, then when we get to a, we have already computed a-1 (which is lower) so the state (a-1, b+1) is already computed.

   Therefore, we can do:

        for s from 0 to N:
            for a from 0 to s:
                b = s - a
                if s==0: dp[0][0]=0.0
                else if a==0: 
                    dp[0][b] = (N + b * dp[0][b-1]) / b;
                else if b==0:
                    dp[a][0] = (N + a * dp[a-1][1]) / a;
                else:
                    dp[a][b] = (N + a * dp[a-1][b+1] + b * dp[a][b-1]) / s;

   However, note: the state (a-1, b+1) for the same s: we are iterating a from 0 to s. When we are at a, then a-1 is less than a and we have already computed all states with a'=a-1 (and any b') in the same s? Actually, when a'=a-1, then we had state (a-1, s - (a-1)) = (a-1, s - a + 1). But note: in the same s, we are iterating a from 0 to s. So when a is 1, we compute state (1, s-1). Then when we get to a, we need (a-1, s - a + 1) which is (a-1, (s) - (a-1) - 1? Actually, we have s = a + b -> so at state (a, b) we have b = s - a. Then the state (a-1, b+1) has a' = a-1 and b' = b+1 = s - a + 1. And the sum a' + b' = (a-1) + (s - a + 1) = s. So it is in the same s. And we have a' = a-1, which is less than a, so we have already computed that state in the same s because we iterate a in increasing order.

   Therefore, the order is valid.

 4. Precomputation per distinct N: we create a 2D dp table of size (N+1) x (N+1). But note: we only need to compute for states with a+b <= N. Actually, a+b can be from 0 to N. And we iterate s from 0 to N.

 5. Memory: For N=3000, the dp table has about (3001 * 3001) = 9e6 states, which is acceptable? Each state is a double (8 bytes) so 72e6 bytes = 72 MB. But we are only storing one N at a time. Also, T up to 100,000, but we are grouping by N and only storing one table at a time. So the memory is acceptable.

 6. However, worst-case distinct N: 3000 distinct N values? Then we would do 3000 DP tables? The total memory would be 3000 * (3001*3001) * 8 bytes = 3000 * 9e6 * 8 = 216e9 bytes = 216 GB -> which is too much.

 How to avoid that?

   The problem says: T up to 100,000, but the distinct N values in the test cases might be at most 3000 (because N in [1,3000]). However, worst-case we might get 3000 distinct N values. But 3000 distinct N values would require 3000 * (N_max^2) = 3000 * (3000^2) = 3000 * 9e6 = 27e9 states, which is 27e9 * 8 bytes = 216 GB. That is too much.

   We need to optimize: note that the constraints say that the sum of K is <= 100,000. But the distinct N values we have to precompute for? The problem says T can be up to 100,000 and distinct N up to 3000. But 3000 distinct N values is too many to precompute all DP tables because the memory and time would be O(3000 * (N^2)) which is about 3000 * 9e6 = 27e9 states, which is too slow and too much memory.

   Alternative idea:

   Actually, we note that the recurrence for E(a,b) for a fixed N is independent of the test case. But the total distinct N values we get might be up to 3000, but 3000 is the maximum N, and we might have many test cases with the same N? Actually, we can precompute only for the N that actually appear. However, worst-case we might have 3000 distinct N values. But note: N is in [1,3000], so we can precompute all N from 1 to 3000? That would be 3000 * (N^2) = 3000 * (3000^2) = 27e9 states -> which is 27e9 * 8 bytes = 216 GB, which is too much.

   We must avoid precomputing all N from 1 to 3000 if we are going to get 3000 distinct N values? But note T can be 100,000 and the distinct N values in the test cases might be up to 3000. How about time? The precomputation for one N: O(N^2). For one N=3000: about 9e6 states, which is acceptable in C++? Maybe a few seconds per N? Then 3000 distinct N would be 3000 * 9e6 = 27e9 states, which is too slow.

   We need a different approach.

   Observing the recurrence:

        E(a,b) = (N + a * E(a-1, b+1) + b * E(a, b-1)) / (a+b)

   We see that the recurrence only depends on states with the same N. And note: the value of E(a,b) might be computed independently for each N? But we cannot precompute for every N from 1 to 3000 because that is 3000 * (3000^2) = 27e9 states, which is too many.

   Alternative: we note that the constraints on the total K is 100,000, but that doesn't help the precomputation.

   However, note: the problem states that the sum of K over test cases is <= 100,000. But that doesn't bound the distinct N? It bounds the total numbers we have to read. But the distinct N values we get in the test cases might be many. But worst-case distinct N is 3000.

   How to reduce precomputation? We might precompute only the required states for the test cases. But the test cases require states (a,b) for a given N. And we don't know which (a,b) we need until we process the test case. However, we must precompute the entire DP table for a given N to answer any state (a,b) for that N.

   Another idea: can we avoid precomputation for every N? Or is there a closed form? 

   Actually, we can use generating functions or known formulas? But the recurrence is complex.

   Alternatively, note that the problem constraints on T: up to 100,000, but the sum of K is 100,000. Also, the distinct N values that appear in the test cases might be at most 3000. However, 3000 distinct N values, each requiring O(N^2) time, would be 3000 * (3000^2) = 27e9 states, which is about 27e9 * (a few operations) -> in C++ we can do about 1e9 operations per second, so 27 seconds? But worst-case 3000 distinct N values? And 27 seconds might be borderline for the worst-case? And the problem says T up to 100,000, but the total K is 100,000, so we might have 100,000 test cases? Actually, worst-case T=100,000 and each test case has a distinct N? Then we have 100,000 distinct N? But N is bounded by 3000, so we cannot have 100,000 distinct N. The distinct N values in the test cases are at most 3000. So worst-case distinct N is 3000.

   But 3000 distinct N, and for each N we do O(N^2) which is about 9e6 for N=3000. Then total operations: 3000 * 9e6 = 27e9, which is about 27 seconds in C++. But the problem time limit is 2 seconds? We need to optimize.

   We must avoid precomputing for every distinct N independently? Or we can precompute a global table for all N? Actually, we can try to compute the entire 3D array for N from 1 to 3000? But that is 3000 * 3000 * 3000 = 27e9 states -> too much.

   Alternatively, we note that the recurrence for one N: we can compute the table for a fixed N in O(N^2). And the distinct N we get in test cases: we can cache the computed tables in a map? But worst-case 3000 distinct N, and each takes 9e6 states (for N=3000) and 9e6 * 8 bytes = 72 MB per table. Then total memory 3000 * 72 MB = 216 GB -> too much.

   Therefore, we need a smarter solution.

   Insight: the recurrence is linear and we can express E(a,b) for a fixed N as:

        E(a,b) = c_{a,b} * N

   Why? Because the recurrence:

        E(a,b) = (N + a * E(a-1, b+1) + b * E(a, b-1)) / (a+b)

        Let E(a,b) = N * F(a,b)

        Then: 
            N * F(a,b) = (N + a * N * F(a-1, b+1) + b * N * F(a, b-1)) / (a+b)
            => N * F(a,b) = N * (1 + a * F(a-1, b+1) + b * F(a, b-1)) / (a+b)
            => F(a,b) = (1 + a * F(a-1, b+1) + b * F(a, b-1)) / (a+b)

        So F(a,b) is independent of N.

        Therefore, we can precompute F(a,b) for a and b such that a+b <= 3000 (the maximum N is 3000, but a and b are at most 3000) and then:

            E(a,b) = F(a,b) * N

   Then we only need one global DP table for F(a,b) for a,b in the range [0, 3000] (with a+b<=3000) and then for a test case with parameters (N, a, b) we do:

        result = F(a,b) * N

   How to compute F(a,b)?

        F(0,0) = 0.

        For (a,b) not (0,0):

            if a==0: 
                F(0,b) = (1 + b * F(0, b-1)) / b
            if b==0:
                F(a,0) = (1 + a * F(a-1, 1)) / a
            else:
                F(a,b) = (1 + a * F(a-1, b+1) + b * F(a, b-1)) / (a+b)

   Then we precompute a 2D table F for a in [0, 3000] and b in [0, 3000] such that a+b <= 3000? Actually, we can precompute for a from 0 to 3000 and b from 0 to 3000, but then we only consider states with a+b<=3000. The total states: about (3000*3001)/2 * 2? Actually, the number of states is about (3001*3002)/2 ~ 4.5e6. But note: we need to cover all states with a+b<=3000, so we can iterate s from 0 to 3000, and for each s, a from 0 to s, then b = s - a.

   Precomputation:

        Let M = 3000 (max possible a+b? actually max a+b is the max N, which is 3000).

        Precompute F for s=0 to M (M=3000) and for a=0 to s.

        Then for each test case: 
            given N, and we compute a and b (the state for that test case) -> then the expected additional steps = F(a,b) * N.

   This way, we precompute one global table F of size about (3001*3001) states? Actually, we only need for s<=3000, so we can do:

        vector<vector<double>> F(3001, vector<double>(3001, 0.0));

        for s from 0 to 3000:
            for a from 0 to s:
                b = s - a;
                if s==0:
                    F[0][0] = 0.0;
                else if a==0:
                    F[0][b] = (1.0 + b * F[0][b-1]) / b;
                else if b==0:
                    F[a][0] = (1.0 + a * F[a-1][1]) / a;
                else:
                    F[a][b] = (1.0 + a * F[a-1][b+1] + b * F[a][b-1]) / s;

   But note: for the state (a-1, b+1): we have a-1+b+1 = a+b = s, and we are iterating a from 0 to s. Since we are iterating a in increasing order, then when we compute state (a, b), we have already computed (a-1, b+1) because a-1 < a.

   However, note: when a=0, we skip the a term. Similarly, when b=0, we skip the b term. So it's safe.

   But what about the indices? For (a-1, b+1): 
        We require that a-1 >=0 and b+1>=0, and also a-1 + b+1 = s, so it's in the same s. But also, we require that the state (a-1, b+1) has been computed? Since we iterate a from 0 to s, then when we are at a, we have already computed a'=a-1 (which is less than a) in the same s.

   Therefore, we can precompute one global table F for a in [0,3000] and b in [0,3000] with a+b<=3000? Actually, we only need for a+b<=3000. But we can iterate s from 0 to 3000 and then a from 0 to s.

   Memory: (3001 * 3001) doubles -> 3001*3001*8 bytes ~ 72e6 bytes = 72 MB. And the time: O( (3001*3002)/2 ) = about 4.5e6 states, each with a few operations -> acceptable.

   Then we process the test cases:

        For each test case:
            Read T, then for each test case: 
                Read N, K, then the list A of size K.
                Count frequencies of numbers 1..N? But note: the list A might contain numbers not in [1, N] if N changes? But the problem says: "It is guaranteed that at least one of the integer between 1 to N inclusive has not been returned at least twice" and "1<=A_i<=N", so we are safe.

                Count: 
                    a = count of numbers in [1, N] that have frequency 0.
                    b = count of numbers in [1, N] that have frequency 1.

                Then expected additional steps = F[a][b] * N

   But note: the recurrence we derived was for the entire process? Actually, the recurrence we derived:

        E(a,b) = F(a,b) * N

        and F(a,b) is independent of N? 

        Why? We set E(a,b) = F(a,b) * N, and then:

            F(a,b) = (1 + a * F(a-1, b+1) + b * F(a, b-1)) / (a+b)

        This does not depend on N. So the same F(a,b) table works for any N.

   Therefore, we precompute one global table F for a and b such that a+b <= 3000.

   However, note: the recurrence for F(a,b) does not use N? So we can precompute it once at the beginning.

   But note: the state (a,b) must satisfy a+b<=3000, and the maximum a and b we need: a+b<=3000, which is the maximum N we can have. Since N<=3000, then the state (a,b) we get from a test case: a+b <= N <=3000, so it is within the precomputed table.

   Steps:

        Precomputation:
            M = 3000
            F = 2D vector of (M+1) by (M+1) with zeros.

            for s from 0 to M:
                for a from 0 to s:
                    b = s - a;
                    if s==0:
                        F[a][b] = 0.0;   // but a=0, b=0
                    else:
                        if a==0:
                            // then b>0
                            F[0][b] = (1.0 + b * F[0][b-1]) / b;
                        else if b==0:
                            F[a][0] = (1.0 + a * F[a-1][1]) / a;
                        else:
                            F[a][b] = (1.0 + a * F[a-1][b+1] + b * F[a][b-1]) / s;

        Then, for each test case:
            read N, K, and list A of K numbers.

            vector<int> count(N+1, 0);
            for each number in A:
                if the number is between 1 and N (inclusive), then count[number]++.

            a = 0, b = 0;
            for (int i=1; i<=N; i++) {
                if (count[i]==0) a++;
                else if (count[i]==1) b++;
            }

            // Then we have state (a, b) -> but note: a+b <= N, so we can use our precomputed F.

            double result = F[a][b] * N;

            Print result with 9 decimal places.

   But note: the sample:

        "1 0" -> state: a=1, b=0? Actually, for N=1, and K=0 -> no numbers generated. Then:
            numbers from 1 to 1: frequency of 1 is 0 -> so a=1, b=0.

            result = F[1][0] * 1.

        How to compute F[1][0]:
            s = a+b = 1.
            a=1, b=0 -> use the branch: b==0 -> F[1][0] = (1 + 1 * F[0][1]) / 1.

            Now compute F[0][1]:
                s = 0+1 = 1 -> a=0, b=1: then F[0][1] = (1 + 1 * F[0][0]) / 1 = (1 + 1*0)/1 = 1.

            So F[1][0] = (1 + 1*1) / 1 = 2.

            Then result = 2 * 1 = 2.0 -> matches sample.

        Second sample: "1 1" -> one number generated: which must be 1. Then:
            count[1] = 1 -> so a=0, b=1? But wait: we have one number generated and it is 1. Then the numbers that haven't appeared at all: a=0, and the numbers that appeared once: b=1.

            result = F[0][1] * 1 = 1 * 1 = 1.0 -> matches.

        Third sample: "2 10" -> but then the list of 10 numbers? It is: "3 0" -> wait the sample input:

            "4
             1 0

             1 1
             1

             2 10
             3 0

             2 2 2 2 2 2 2 2 2 2"

        Actually, the sample input has 4 test cases.

        The third test case: 
            "2 10" -> then the next line: 10 numbers: "3 0" -> wait, but the numbers must be between 1 and 2? Actually, the sample input says:

                2 10
                3 0

            But then the next test case is:

                2 2 2 2 2 2 2 2 2 2

            So the third test case: N=2, K=10, and the numbers: 3,0? But the constraints say 1<=A_i<=N, and N=2 -> then 3 and 0 are invalid? 

        Actually, the sample input as provided:

            "4
             1 0

             1 1
             1

             2 10
             3 0

             2 2 2 2 2 2 2 2 2 2"

        This is confusing. But the problem says: "The second line of each testcase contains $K$ integers: $A_1$ $A_2$ $\cdots$ $A_K$". So the third test case: N=2, K=10, and then the list of 10 numbers: the next line is "3 0" -> but that is only two numbers? 

        Actually, the sample input might be:

            T=4

            Test case 1: N=1, K=0 -> then the next line is empty? But the sample input says: 
                "1 0"

            Then the next test case: 
                "1 1"
                "1"

            Then the next test case:
                "2 10"
                "3 0" -> but that's two numbers? but K=10, so we expect 10 numbers.

            Then the next test case:
                "3 0" -> N=3, K=0? then the next line is empty? but then the next line is "2 2 2 2 2 2 2 2 2 2" -> that's 10 numbers? but the test case is N=3, K=0? then the next test case is missing.

        Actually, the sample input provided in the problem statement:

            "4
             1 0

             1 1
             1

             2 10
             3 0

             2 2 2 2 2 2 2 2 2 2"

        This is four test cases:

            Test1: N=1, K=0 -> then no numbers -> so we read the next line as empty? But the problem says: "The second line of each testcase contains $K$ integers". So for K=0, the second line is empty? Or the next line might be the next test case? 

        Actually, the sample input is:

            Line1: "4"
            Line2: "1 0"   -> test case 1: N=1, K=0 -> then the next line (line3) is the next test case: "1 1" -> but wait, that would be the first line of test case 2? Then the second line of test case 1 is missing? 

        Correction: the problem sample input:

            "4"
            "1 0"   -> test case 1: N=1, K=0 -> then the second line of this test case: since K=0, the next line is the next test case? But the problem says: the second line of each test case contains K integers. So for K=0, we skip the second line? 

        Actually, the problem says: "The first line of each testcase contains two integers: N K", then "The second line of each testcase contains K integers". So if K=0, then there is no second line? 

        Therefore, the sample input:

            Line1: "4"
            Line2: "1 0"   -> test case 1: N=1, K=0 -> no second line for this test case.
            Line3: "1 1"   -> test case 2: N=1, K=1 -> then next line (line4) has 1 integer: "1"
            Line4: "1"
            Line5: "2 10"   -> test case 3: N=2, K=10 -> then next line (line6) has 10 integers? But the sample input then has: "3 0" -> that is two integers? and then the next line: "2 2 2 2 2 2 2 2 2 2" -> that is 10 integers? So the sample input is:

                4
                1 0
                1 1
                1
                2 10
                3 0
                2 2 2 2 2 2 2 2 2 2

            But that is 6 lines? 

        Actually, the problem says:

            Input:
                4
                1 0
                1 1
                1
                2 10
                3 0
                2 2 2 2 2 2 2 2 2 2

        So:

            Test case 1: N=1, K=0 -> then the next line is the next test case: "1 1" -> that is the first line of test case 2. Then the next line is "1", which is the second line of test case 2. Then the next line: "2 10" -> test case 3. Then the next line: "3 0" -> that is only two numbers? but K=10 -> wait, that is the first line of test case 4? 

        Actually, the problem says the next test case:

            "3 0" -> N=3, K=0? Then the next line: "2 2 2 2 2 2 2 2 2 2" -> that is the 10 numbers for test case 3? But test case 3 is N=2, K=10, so that line must be the 10 numbers. Then test case 4: N=3, K=0 -> then no numbers.

        So the test cases:

            Test1: N=1, K=0 -> state: a=1, b=0 -> result = F[1][0]*1 = 2.0
            Test2: N=1, K=1, and the number is 1 -> state: a=0, b=1 -> result = F[0][1]*1 = 1.0
            Test3: N=2, K=10, numbers: 2,2,2,2,2,2,2,2,2,2 -> 
                    count: 
                        1: 0 -> a=1
                        2: 10 -> so 10>=2 -> then b=0? because we only care about numbers that are 0 or 1? 
                    Actually, we need a = count of numbers that are 0 -> 1 (for number 1)
                    b = count of numbers that are 1 -> 0 (because number 2 has 10, which is more than 1) -> but note: the condition: we only count numbers that have not been returned at least twice? Actually, we are counting: 
                        0 times: a=1
                        1 time: b=0
                    So state (1,0) -> result = F[1][0]*2 = 2*2 = 4.0 -> matches sample output 4.0.

            Test4: N=3, K=0 -> state: a=3, b=0 -> result = F[3][0] * 3.

            How to compute F[3][0]:
                s=3: a=3, b=0 -> F[3][0] = (1 + 3 * F[2][1]) / 3.

            Now compute F[2][1]:
                s=3: a=2, b=1 -> 
                    F[2][1] = (1 + 2 * F[1][2] + 1 * F[2][0]) / 3.

            Now compute F[1][2]:
                s=3: a=1, b=2 -> 
                    F[1][2] = (1 + 1 * F[0][3] + 2 * F[1][1]) / 3.

            Now compute F[0][3]:
                s=3: a=0, b=3 -> F[0][3] = (1 + 3 * F[0][2]) / 3.

            Compute F[0][2]:
                s=2: a=0, b=2 -> F[0][2] = (1 + 2 * F[0][1]) / 2 = (1 + 2*1)/2 = 3/2 = 1.5.

            Then F[0][3] = (1 + 3*1.5)/3 = (1+4.5)/3 = 5.5/3.

            Now compute F[1][1]:
                s=2: a=1, b=1 -> 
                    F[1][1] = (1 + 1 * F[0][2] + 1 * F[1][0]) / 2 = (1 + 1.5 + 2) / 2 = (4.5)/2 = 2.25.

            Then F[1][2] = (1 + 1*(5.5/3) + 2*2.25) / 3
                         = (1 + 5.5/3 + 4.5) / 3
                         = (5.5 + 5.5/3) / 3   -> wait: 1+4.5=5.5, then plus 5.5/3 -> 5.5*(1+1/3)=5.5*(4/3)=22/3? 
                    Actually: 1 + 5.5/3 + 4.5 = 1 + 4.5 = 5.5, then 5.5 + 5.5/3 = 5.5*(1+1/3) = 5.5 * 4/3 = 22/3? 
                    Then divided by 3: 22/(3*3)=22/9.

            Now compute F[2][0]:
                s=2: a=2, b=0 -> F[2][0] = (1 + 2 * F[1][1]) / 2 = (1 + 2*2.25)/2 = (1+4.5)/2 = 5.5/2 = 2.75.

            Then F[2][1] = (1 + 2*(22/9) + 1*2.75) / 3
                         = (1 + 44/9 + 2.75) / 3
                         = (1 + 4.888... + 2.75) = 8.63888... 
                         Then divided by 3: about 2.879...

            Then F[3][0] = (1 + 3 * 2.879...) / 3 = (1+8.63888...)/3 = 9.63888.../3 = 3.21296...

            Then result = 3 * 3.21296... = 9.63888...

            Which matches the sample output: 9.638888889.

        So the method is correct.

   Implementation:

        Precompute F for s=0 to 3000 (max s=3000).

        We need a 2D array F[0..3000][0..3000]? But note: we only compute for states with a+b<=3000. And we iterate s from 0 to 3000, and for each s, a from 0 to s, then b=s-a.

        We can index by a and b.

        We must be cautious: when s=0, then a=0, b=0.

        For s>=1, we iterate a from 0 to s.

        We use:

            for (int s = 0; s <= M; s++) {
                for (int a = 0; a <= s; a++) {
                    int b = s - a;
                    if (s == 0) {
                        F[a][b] = 0.0;
                    } else if (a == 0) {
                        // then b>0
                        F[0][b] = (1.0 + b * F[0][b-1]) / b;
                    } else if (b == 0) {
                        F[a][0] = (1.0 + a * F[a-1][1]) / a;
                    } else {
                        F[a][b] = (1.0 + a * F[a-1][b+1] + b * F[a][b-1]) / s;
                    }
                }
            }

        But note: when a=0 and b=0, s=0 -> we skip the else if branches.

        Also, note: when a=0 and b>0, then we use the first branch.

        However, we must be cautious for the indices: we are using F[a][b] for a and b. The array must be defined for a in [0,3000] and b in [0,3000]. But we only compute for a+b<=3000. For states with a+b>3000, we don't compute and we don't use.

        Then process the test cases.

        Important: the state (a,b) must have a+b<=N, and we precomputed for a+b<=3000, which is the maximum possible.

        Also note: the problem states that the total K across test cases is <=100,000 -> so we can read the numbers and count frequencies.

        Steps for each test case:

            Read T.
            Precompute F for M=3000 (only once at the beginning).

            Then for each test case:
                Read N, K.
                If K>0, read K integers for the list A.

                vector<int> freq(N+1,0);
                for (int i=0; i<K; i++) {
                    int x = A[i];
                    if (x>=1 && x<=N) {
                        freq[x]++;
                    }
                }

                int a=0, b=0;
                for (int i=1; i<=N; i++) {
                    if (freq[i]==0) a++;
                    else if (freq[i]==1) b++;
                }

                double ans = F[a][b] * N;

                Print with 9 decimal places.

   Let's test with the provided samples.

   Note: The sample input has 4 test cases, and the last one: N=3, K=0 -> we get a=3, b=0 -> F[3][0] * 3 = 9.638888889.

   We must be cautious: the array F is defined for a and b up to 3000, but we only compute for a+b<=3000. For states with a+b>3000, we don't need.

   However, note: our state (a,b) from a test case: a+b<=N<=3000, so we are safe.

   Code:

        We set M = 3000.

        Precomputation: we do a double loop: s from 0 to M, then a from 0 to s.

        We must use a 2D array of (M+1) x (M+1) -> but note: when we do F[a][b] for a=3000 and b=0, that is within the array. But when we do F[0][b] for b=3000, that is also within the array? 

        Actually, we only compute for a+b<=3000. But we have to store states where a and b individually can be up to 3000? For example, state (0,3000) -> that's a+b=3000, which we compute. But state (3000,0) is also computed. And state (1500,1500) is computed? But we don't compute states with a+b>3000.

        We allocate a 2D vector: vector<vector<double>> F(M+1, vector<double>(M+1, 0.0)); -> but that is (3001x3001) = 9e6 states, which is acceptable.

        However, we only compute for a+b<=M. For states with a+b>M, we leave them as 0.0? But we never use them.

   Implementation:

        Precomputation:

            const int M = 3000;
            vector<vector<double>> F(M+1, vector<double>(M+1, 0.0));

            for (int s=0; s<=M; s++) {
                for (int a=0; a<=s; a++) {
                    int b = s - a;
                    if (s==0) {
                        F[a][b] = 0.0;
                    } else if (a==0) {
                        // then b>=1
                        F[0][b] = (1.0 + b * F[0][b-1]) / b;
                    } else if (b==0) {
                        F[a][0] = (1.0 + a * F[a-1][1]) / a;
                    } else {
                        F[a][b] = (1.0 + a * F[a-1][b+1] + b * F[a][b-1]) / s;
                    }
                }
            }

        But note: in the branch for a==0, we use F[0][b-1]. And if b>=1, then b-1>=0 -> we have computed that state at s'=b-1 (which is s-1) so we have computed it in an earlier s.

        Similarly, for the branch b==0: we use F[a-1][1] -> which is state (a-1,1) with s'=a-1+1 = a, which is less than the current s (which is a+0 = a) -> but wait: current s = a (since b=0) -> then we are at s=a. Then state (a-1,1) has s'=a-1+1=a -> same s? Then we must have computed it already? 

        However, we iterate s from 0 to M. For a fixed s, we iterate a from 0 to s. Then when we compute state (a,0) (with a>0 and b=0), we need state (a-1,1) which has s'=a-1+1=a, so same s. But we are iterating a from 0 to s. For state (a-1,1): a'=a-1, which is less than a -> we have already computed it in the same s (because we iterate a in increasing order).

        Therefore, the order is valid.

   Let's run for s=1:
        a=0: b=1 -> F[0][1] = (1.0 + 1 * F[0][0]) / 1 = (1+0)/1=1.0.
        a=1: b=0 -> F[1][0] = (1.0 + 1 * F[0][1]) / 1 = (1+1)/1=2.0.

   s=2:
        a=0: b=2 -> F[0][2] = (1.0 + 2 * F[0][1]) / 2 = (1+2*1)/2=3/2=1.5.
        a=1: b=1 -> F[1][1] = (1.0 + 1*F[0][2] + 1*F[1][0]) / 2 = (1 + 1.5 + 2.0)/2 = 4.5/2=2.25.
        a=2: b=0 -> F[2][0] = (1.0 + 2 * F[1][1]) / 2 = (1+2*2.25)/2 = (1+4.5)/2=5.5/2=2.75.

   Then F[3][0] = (1.0 + 3 * F[2][1]) / 3.

        We need F[2][1]: that is state (2,1) -> s=3: we compute when s=3, a=2, b=1.

        s=3:
            a=0: b=3 -> F[0][3] = (1.0 + 3 * F[0][2]) / 3 = (1+3*1.5)/3 = (1+4.5)/3=5.5/3.
            a=1: b=2 -> F[1][2] = (1.0 + 1*F[0][3] + 2*F[1][1]) / 3 = (1 + 5.5/3 + 2*2.25)/3 = (1 + 1.83333 + 4.5) = 7.33333 -> /3 = 2.44444? 
                   Actually: 1 + 5.5/3 = 1 + 1.83333 = 2.83333; then 2.83333+4.5=7.33333 -> /3 = 2.44444.
            a=2: b=1 -> F[2][1] = (1.0 + 2 * F[1][2] + 1 * F[2][0]) / 3 = (1 + 2*2.44444 + 2.75) / 3 = (1+4.88888+2.75)=8.63888 -> /3 = 2.8796296.
            a=3: b=0 -> F[3][0] = (1.0 + 3 * F[2][1]) / 3 = (1+3*2.8796296)/3 = (1+8.6388888)/3 = 9.6388888/3 = 3.21296296.

        Then for state (3,0) in the test case: result = 3.21296296 * 3 = 9.63888888 -> which matches.

   However, note: the recurrence for F[1][2] was computed with F[0][3] and F[1][1] -> and both were computed earlier in the same s? Actually, for s=3, we do a from 0 to 3. We computed a=0 first: F[0][3], then a=1: F[1][2] -> which uses F[0][3] (computed in the same s at a=0) and F[1][1] (which was computed at s=2) -> so it's safe.

   Therefore, we write the code accordingly.

   One more note: the problem says the total K across test cases <=100,000 -> so we can safely read the numbers and count frequencies.

   Code:

        #include <iostream>
        #include <vector>
        #include <iomanip>
        #include <cstring>
        using namespace std;

        const int M = 3000;
        vector<vector<double>> F;

        int main() {
            ios_base::sync_with_stdio(false);
            cin.tie(nullptr);

            // Precompute F for all a,b with a+b<=M (M=3000)
            F.assign(M+1, vector<double>(M+1, 0.0));
            for (int s=0; s<=M; s++) {
                for (int a=0; a<=s; a++) {
                    int b = s - a;
                    if (s == 0) {
                        // a=0, b=0
                        F[a][b] = 0.0;
                    } else if (a == 0) {
                        // b must be >=1
                        F[0][b] = (1.0 + b * F[0][b-1]) / b;
                    } else if (b == 0) {
                        F[a][0] = (1.0 + a * F[a-1][1]) / a;
                    } else {
                        F[a][b] = (1.0 + a * F[a-1][b+1] + b * F[a][b-1]) / (a+b); // a+b = s
                    }
                }
            }

            int T;
            cin >> T;
            while (T--) {
                int N, K;
                cin >> N >> K;
                vector<int> A(K);
                for (int i=0; i<K; i++) {
                    cin >> A[i];
                }

                vector<int> freq(N+1, 0);
                for (int x : A) {
                    if (x>=1 && x<=N) {
                        freq[x]++;
                    }
                }

                int a = 0, b = 0;
                for (int i=1; i<=N; i++) {
                    if (freq[i] == 0) a++;
                    else if (freq[i] == 1) b++;
                }

                // Note: we precomputed F for a and b in [0, M] with a+b<=M, and M=3000, and N<=3000 so a+b<=N<=3000, so it's safe.
                double ans = F[a][b] * N;
                cout << fixed << setprecision(9) << ans << '\n';
            }

            return 0;
        }

   Let me test with the sample: T=4.

   But note: the last test case: 
        Input: 
            3 0
        Then the next test case: 
            2 2 2 2 2 2 2 2 2 2

        Actually, the last test case in the sample input is the fourth: 
            "2 2 2 2 2 2 2 2 2 2" -> but that is 10 numbers? and the test case before was "2 10", so that test case has K=10 and then the next line is the 10 numbers.

        The fourth test case: 
            The problem sample input:

                4
                1 0
                1 1
                1
                2 10
                3 0
                2 2 2 2 2 2 2 2 2 2

            This is:

                Test1: N=1, K=0
                Test2: N=1, K=1, and the number is 1
                Test3: N=2, K=10, and the numbers are: 3,0 -> but wait, that's two numbers? then the next line has 10 numbers? 

            Actually, it's 6 lines:

                Line1: 4
                Line2: "1 0" -> test case 1
                Line3: "1 1" -> test case 2: first line: N=1, K=1
                Line4: "1" -> the 1 number for test case 2.
                Line5: "2 10" -> test case 3: N=2, K=10
                Line6: "3 0" -> that's two numbers? but we need 10. 

            Then the problem says the next test case:

                "2 2 2 2 2 2 2 2 2 2"

            So it's 10 numbers? 

            Actually, the problem says:

                "2 10
                 3 0
                 2 2 2 2 2 2 2 2 2 2"

            That is: 
                The third test case: N=2, K=10 -> then the next line is the 10 numbers: "3 0 2 2 2 2 2 2 2 2 2" -> no, that is 10 numbers? 

            Actually, the input says: "3 0" and then the next line is "2 2 2 2 2 2 2 2 2 2" -> that is two lines? So the third test case has two lines? 

            Correction: the problem sample input has:

                4
                1 0
                1 1
                1
                2 10
                3 0
                2 2 2 2 2 2 2 2 2 2

            This is six lines. The fourth test case: 
                first line: "3 0" -> N=3, K=0? Then there is no second line for that test case? But the next line is the 10 numbers for the third test case? 

            How the input is read:

                T=4

                Test case 1: 
                    Read: "1 0" -> N=1, K=0 -> then we skip reading numbers.

                Test case 2:
                    Read: "1 1" -> N=1, K=1
                    Then we read the next line: "1" -> one number.

                Test case 3:
                    Read: "2 10" -> N=2, K=10
                    Then we read the next 10 numbers: but the next token is "3" -> then we read 10 numbers from the next tokens? But the next tokens: 
                        3,0,2,2,2,2,2,2,2,2,2 -> that's 11 tokens? 

            Actually, the input has:

                Line5: "3 0" -> two tokens? 
                Line6: "2 2 2 2 2 2 2 2 2 2" -> 10 tokens.

            So for test case 3: we read 10 numbers: we read the next 10 integers. But the next token after "2 10" is the next line: "3" -> then we read 10 integers: we read the next 10 integers: "3", "0", "2", "2", ... until we have 10 numbers.

            Then test case 4: 
                Read: "3 0" -> N=3, K=0 -> then we don't read any numbers.

            But the sample input only has 6 lines? Then after reading 10 numbers for test case 3, we have no more input? Then test case 4 is missing.

        Actually, the problem sample input has 4 test cases and 6 lines. The fourth test case is the last line? 

        The problem says:

            Input:
                4
                1 0
                1 1
                1
                2 10
                3 0
                2 2 2 2 2 2 2 2 2 2

        This is:

            Test1: N=1, K=0 -> no numbers
            Test2: N=1, K=1, numbers: [1]
            Test3: N=2, K=10, numbers: [3,0,2,2,2,2,2,2,2,2,2] -> wait, that would be 11 numbers? 

        Actually, the line "3 0" is the first line of test case 3? Then the next line is the 10 numbers? But then the next test case (test4) is missing.

        Alternatively, the problem intended:

            Test1: N=1, K=0 -> no numbers.
            Test2: N=1, K=1, then the number is 1 -> so the second line of test case 2 is "1".
            Test3: N=2, K=10, and the 10 numbers are: 3,0,2,2,2,2,2,2,2,2,2 -> but that is 10 numbers? Actually, the line "3 0" is the beginning of the 10 numbers? Then the next 8 numbers are in the same line? But the next line is "2 2 2 2 2 2 2 2 2 2", which is 10 numbers? 

        How the input is read:

            After reading T=4:

            Test case 1: reads "1 0" -> then we don't read any numbers.

            Test case 2: reads "1 1" -> then we read one number: the next token is the first token of the next line: "1". Then we have read the one number.

            Test case 3: reads "2 10" -> then we read 10 integers. We read the next 10 integers. The next token is the first token of the next line? That is "3" (from the line "3 0"), then the next token is "0", then we need 8 more? Then we go to the next line: "2 2 2 2 2 2 2 2 2 2" -> that is 10 tokens? So we read 2 from the next line? Then we read 10 numbers: 
                tokens: 3,0,2,2,2,2,2,2,2,2 -> that is 10 tokens? But the line "3 0" only has two tokens, and then the next line has 10 tokens -> total 12 tokens? 

        Actually, the input for test case 3: the 10 numbers are the 10 tokens that follow the "2 10". The next two tokens are "3" and "0" (from the same line as "2 10"? No, the "2 10" is one line, then the next line is "3 0", which is two tokens, and then the next line is "2 2 2 2 2 2 2 2 2 2", which is 10 tokens -> total 12 tokens? 

        But K=10 -> we need 10 numbers. So we read the next 10 tokens: 
            The tokens after "2 10" are: 
                Line: "3 0" -> tokens: 3, 0
                Line: "2 2 2 2 2 2 2 2 2 2" -> tokens: 2,2,2,2,2,2,2,2,2,2

            That is 2+10=12 tokens -> we only read 10? Then we leave the last two tokens for the next test case? 

        Then the next test case: 
            We read the next line: the first token is "2" -> then we try to read N and K: but we read a string "2" and then we expect an integer K? but the next token is "2", then we try to read 2 for K? Then we get N=2, K=2? and then we read the next 2 tokens: the next two tokens are the remaining 2's? 

        This is messy.

        Actually, the problem says: the second line of each test case contains K integers. So for test case 3: K=10 -> we read one line with 10 integers? Or we can read from multiple lines? 

        The problem does not specify that the numbers are in one line. So we read 10 integers, regardless of newlines.

        Therefore, our code:

            cin >> N >> K;
            vector<int> A(K);
            for (int i=0; i<K; i++) {
                cin >> A[i];
            }

        This will read the next K integers from the input, which may span multiple lines.

        For the sample:

            Test case 3: 
                We read: 
                    N=2, K=10.
                Then we read 10 integers: 
                    first integer: 3 (from the next token)
                    second: 0
                    then the next 8: the next 8 tokens from the next line: the first 8 tokens of the line "2 2 2 2 2 2 2 2 2 2" -> that is 8 of the 10 tokens? Then we leave the last two tokens for the next test case? 

        Then test case 4: 
            We read: 
                cin >> N: we read the next token: which is the next token after the 8 tokens we read? That is the 9th token of the line "2 2 2 2 2 2 2 2 2 2" -> which is 2? Then we read K: the next token: 2? 
                Then we have N=2, K=2 -> then we read 2 numbers: the next two tokens: which are the last two 2's? 

        But the problem says the fourth test case is:

            "3 0"

        So the fourth test case should have N=3, K=0.

        How the input is actually given:

            The tokens (ignoring newlines) are:

                T=4
                test1: "1", "0"
                test2: "1", "1" -> then the next token is "1" (for the list)
                test3: "2", "10", then 10 integers: 
                    the next tokens: 
                        3,0, 2,2,2,2,2,2,2,2 -> that is 10 tokens? 
                Then the next token: 2 (from the next line) -> that is the 11th token? 

            Then test4: we read the next two tokens: 
                N: 3 -> from the next token? But we already read 2? 

        This is very confusing.

        Actually, the problem sample input is:

            Line1: "4"
            Line2: "1 0"
            Line3: "1 1"
            Line4: "1"
            Line5: "2 10"
            Line6: "3 0"
            Line7: "2 2 2 2 2 2 2 2 2 2"

        But wait, that is 7 lines? 

        The problem says:

            "4
             1 0

             1 1
             1

             2 10
             3 0

             2 2 2 2 2 2 2 2 2 2"

        That is 7 lines? 

        How we read:

            Test1: 
                Line2: "1 0" -> we read N=1, K=0 -> then we don't read any more for this test case.

            Test2:
                Line3: "1 1" -> we read N=1, K=1.
                Then we read the next token: which is the first token of Line4: "1" -> so we read A[0]=1.

            Test3:
                Line5: "2 10" -> we read N=2, K=10.
                Then we read 10 integers: 
                    Line6: "3 0" -> tokens: 3,0 -> two tokens.
                    Line7: "2 2 2 2 2 2 2 2 2 2" -> 10 tokens? Actually, that is 10 tokens? 
                So we read the next 10 integers: 
                    from Line6: 3,0 -> two integers.
                    from Line7: the first 8 integers: the first 8 '2's? 
                Then we have read 10 integers? 

            Then Test4: 
                We read the next two tokens: which are the last two tokens of Line7: the 9th and 10th '2'? -> then we read: 
                    cin >> N: we read 2 -> then cin >> K: we read 2? 
                Then we read two integers: but there are no more tokens? 

        This is wrong.

        Actually, the problem sample input has 4 test cases and the input tokens are:

            T: 4
            Test1: N=1, K=0 -> tokens: "1", "0"
            Test2: N=1, K=1 -> tokens: "1", "1", then the number: "1"
            Test3: N=2, K=10 -> tokens: "2", "10", then the 10 numbers: the next 10 tokens: which are "3", "0", and then 8 times "2" from the next line? But the next line has 10 times "2" -> so we read the first 8 of the 10? 
            Then we are left with two "2" at the end.

            Test4: we read: 
                N: next token is the next token after the 10 numbers? -> which is the 9th token of the last line? -> which is "2", then we read K: the next token is "2" (the 10th token) -> then we try to read 2 numbers: but there are no more tokens -> fails.

        This is not the intended.

        The problem intended that the 10 numbers for test case 3 are the 10 tokens: "3", "0", "2", "2", ... (8 times) -> total 10? But the last line only has 10 tokens: then we read 10 tokens: the entire last line? 

        Actually, the last line: "2 2 2 2 2 2 2 2 2 2" is 10 tokens? Then test case 3: we read 10 tokens: 
            first two from the line "3 0" -> that is two tokens: 3 and 0.
            then the next 8 from the next line? But the next line is the entire 10 tokens? Then we read the first 8 of that line? 

        How does cin work? It reads tokens regardless of the line. So we read:

            Test3: 
                We read N=2, K=10.
                Then we read 10 integers: 
                    The next token is "3" (from the next line, the first token of the line after "2 10")
                    then "0" (second token of that line)
                    then we move to the next line: and read 10 tokens: but we only need 8 more? So we read the first 8 tokens of the next line? 

        But the problem sample input says the 10 numbers for test case 3 are: 
            "3 0
             2 2 2 2 2 2 2 2 2 2"

        That is 12 tokens? 

        Actually, the problem sample input has:

            Test3: 
                Line5: "2 10"
                Line6: "3 0"
                Line7: "2 2 2 2 2 2 2 2 2 2"

        Then the 10 numbers for test case 3 are the next 10 tokens: which are:

            Line6: "3", "0" -> 2 tokens.
            Line7: "2", "2", "2", "2", "2", "2", "2", "2" -> 8 tokens.

            Total 10.

        Then the next test case: 
            We read: 
                Line7: we have two tokens left: the last two "2" of the 10? -> but we already read 8 tokens from Line7? Then the next token is the next line? But there is no next line.

        And the fourth test case: 
            The problem says: 
                "3 0"

            But we don't have that token.

        The problem sample input has 7 lines. The fourth test case is missing? 

        Actually, the problem says the sample input has:

            "4
             1 0

             1 1
             1

             2 10
             3 0
             2 2 2 2 2 2 2 2 2 2"

        And then the next test case? 

        But the problem sample output has 4 outputs.

        I see: the fourth test case is:

            "3 0" -> that is the first line of test case 4? Then the next line is missing? 

        Actually, the problem sample input has:

            Test4: 
                First line: "3 0" -> meaning N=3, K=0 -> then no numbers.

        And the last line: "2 2 2 2 2 2 2 2 2 2" is the 10 numbers for test case 3.

        Therefore, the tokens:

            Test1: tokens: "1", "0"
            Test2: tokens: "1", "1", "1"
            Test3: tokens: "2", "10", then the 10 numbers: "3", "0", "2", "2", "2", "2", "2", "2", "2", "2", "2", "2" -> wait, we have 10 numbers: so we read the next 10 tokens: 
                    Line5: "2", "10" -> that's for test3 first line.
                    Then the next 10 tokens: 
                         Line6: "3", "0"
                         Line7: "2", "2", "2", "2", "2", "2", "2", "2" -> that is 8 more? -> total 10.
            Test4: tokens: we are at the next token after the 10 numbers? -> then we read the next token? but there is none? 

        But the sample input has:

            Line5: "2 10"
            Line6: "3 0" -> this is two tokens for the 10 numbers? 
            Line7: "2 2 2 2 2 2 2 2 2 2" -> 10 tokens.

            Total tokens for the 10 numbers: 12? 

        How do we reconcile?

        The problem says the fourth test case is:

            "3 0"

        That is: 
            First line: "3 0" -> so we read N=3, K=0 -> then no numbers.

        But then the 10 numbers for test case 3 must be in one line? 

        Actually, the problem sample input is:

            Line1: 4
            Line2: 1 0
            Line3: 1 1
            Line4: 1
            Line5: 2 10
            Line6: 3 0   [this is the first line of test case 4?] 
            Line7: 2 2 2 2 2 2 2 2 2 2   [this is the 10 numbers for test case 3?]

        This is inconsistent.

        After reexamining the problem statement:

            Sample Input:
                "4
                 1 0

                 1 1
                 1

                 2 10
                 3 0

                 2 2 2 2 2 2 2 2 2 2"

        And the sample output:

                2.000000000
                1.000000000
                4.000000000
                9.638888889

        The fourth test case output is 9.638888889, which we know corresponds to N=3, K=0.

        Therefore, the fourth test case is: N=3, K=0 -> so the input for test case 4 is:

            First line: "3 0"

        Then the last line: "2 2 2 2 2 2 2 2 2 2" is the 10 numbers for test case 3.

        Therefore, the input tokens:

            Test1: "1", "0"
            Test2: "1", "1", then the number "1"
            Test3: "2", "10", then the 10 numbers: the next 10 tokens -> which are from the next two lines: 
                    Line6: "3", "0" -> but that is two tokens, and then Line7: "2", "2", ... (10 times) -> but we only need 10? So we read the entire Line6 and then the first 8 tokens of Line7? 
            Then Test4: we read: "3", "0" -> but we already consumed Line6? 

        This is not the intended.

        The problem must have intended that the 10 numbers for test case 3 are provided in the next line after "2 10", and then the next test case is provided in the next two lines.

        But the sample input has:

            Line5: "2 10"   -> test case 3 first line
            Line6: the 10 numbers for test case 3? -> but they wrote "3 0", which is only two numbers? 
            Line7: "2 2 2 2 2 2 2 2 2 2" -> which is 10 numbers? 

        Then test case 3: K=10, so we read 10 numbers: 
            We read Line6: that has two numbers: 3 and 0 -> then we read the entire Line7: 10 numbers? -> total 12 numbers? 

        That is not acceptable.

        The problem must have intended that the 10 numbers for test case 3 are the line: "2 2 2 2 2 2 2 2 2 2", and the line "3 0" is the first line of test case 4.

        Therefore, the input:

            Test1: N=1, K=0
            Test2: N=1, K=1, number: 1
            Test3: N=2, K=10, numbers: 2,2,2,2,2,2,2,2,2,2   (one line)
            Test4: N=3, K=0

        Then the sample input should be:

            4
            1 0
            1 1
            1
            2 10
            2 2 2 2 2 2 2 2 2 2
            3 0

        But the problem sample input is:

            4
            1 0
            1 1
            1
            2 10
            3 0
            2 2 2 2 2 2 2 2 2 2

        This suggests that the 10 numbers for test case 3 are spread over two lines: the first two numbers are 3 and 0, and then the next 8 are the first 8 of the next line? and the last two numbers of the next line are for the next test case? 

        But the next test case is "3 0", so the first token should be 3, not 2.

        Therefore, the only logical conclusion is that the sample input has a mistake.

        How to resolve: we read the next K integers regardless of newlines.

        For the sample input as given:

            Test case 3: 
                N=2, K=10.
                Then we read 10 integers: 
                    The next token is "3" (from the next line) -> but 3 is not in [1,2]? 
                The problem guarantees: 1<=A_i<=N, so in test case 3, N=2, so A_i should be in [1,2]. But we read 3 and 0 -> that is invalid.

        The problem states: "It is guaranteed that at least one of the integer between 1 to $N$ inclusive has not been returned at least twice" and "1<=A_i<=N". So we should not get 3 or 0.

        Therefore, the sample input provided in the problem statement is inconsistent.

        But the sample output for test case 3 is 4.0, which we get if the 10 numbers are all 2. So the intended test case 3: the numbers are ten 2's.

        And the fourth test case: N=3, K=0.

        So the intended input is:

            4
            1 0
            1 1
            1
            2 10
            2 2 2 2 2 2 2 2 2 2
            3 0

        We will assume the judge provides valid input.

        Conclusion: our code is as above.

        Note: the constraints say the total K<=100,000 -> so reading 100,000 integers is acceptable.

        Let me run the code on the sample:

            Test1: N=1, K=0 -> a=1, b=0 -> F[1][0]=2.0, then ans=2.0 * 1 = 2.0 -> output 2.000000000.

            Test2: N=1, K=1, and the number is 1 -> 
                    freq[1]=1 -> a=0, b=1 -> ans = F[0][1]*1 = 1.0 -> output 1.000000000.

            Test3: N=2, K=10, numbers: ten 2's -> 
                    freq[1]=0 -> a=1
                    freq[2]=10 -> so b=0
                    ans = F[1][0] * 2 = 2.0 * 2 = 4.0 -> output 4.000000000.

            Test4: N=3, K=0 -> a=3, b=0 -> 
                    ans = F[3][0] * 3 = 3.21296296 * 3 = 9.63888888 -> output 9.638888889.

        So we output:

            2.000000000
            1.000000000
            4.000000000
            9.638888889

        Which matches.

   Code:

        We precompute F for M=3000.

        Then read T test cases.

        For each test case: 
            read N, K.
            read K integers.

            freq[1..N] = 0
            for each number in the list: if it is between 1 and N, then freq[x]++.

            a = count of i in [1, N] with freq[i]==0.
            b = count of i in [1, N] with freq[i]==1.

            ans = F[a][b] * N.

        Print.

   Let's run the sample test case 4: N=3, K=0 -> a=3, b=0 -> F[3][0] we computed as 3.21296296 -> then 3.21296296 * 3 = 9.63888888.

   We output with 9 decimal places: 9.638888889.

   We'll write the code accordingly.

   Note: We must set M=3000.

   However, note: the state (a,b) must have a+b<=3000, and we precomputed F for a and b in [0,3000] and a+b<=3000.

   But what if a+b>3000? We have M=3000, and N<=3000, so a+b<=N<=3000, so it's safe.

   Final code:

        #include <iostream>
        #include <vector>
        #include <iomanip>
        using namespace std;

        const int MAX_M = 3000;

        int main() {
            ios_base::sync_with_stdio(false);
            cin.tie(nullptr);

            // Precompute F table for a, b in [0, MAX_M] with a+b<=MAX_M
            vector<vector<double>> F(MAX_M+1, vector<double>(MAX_M+1, 0.0));
            for (int s=0; s<=MAX_M; s++) {
                for (int a=0; a<=s; a++) {
                    int b = s - a;
                    if (s == 0) {
                        F[a][b] = 0.0;
                    } else if (a == 0) {
                        F[0][b] = (1.0 + b * F[0][b-1]) / b;
                    } else if (b == 0) {
                        F[a][0] = (1.0 + a * F[a-1][1]) / a;
                    } else {
                        F[a][b] = (1.0 + a * F[a-1][b+1] + b * F[a][b-1]) / (a+b);
                    }
                }
            }

            int T;
            cin >> T;
            while (T--) {
                int N, K;
                cin >> N >> K;
                vector<int> A(K);
                for (int i=0; i<K; i++) {
                    cin >> A[i];
                }

                vector<int> freq(N+1, 0);
                for (int x : A) {
                    // It's guaranteed 1<=x<=N? The problem says 1<=x<=N, but the input might have numbers outside if the test case has a different N? 
                    // But the problem says: "1<=A_i<=N", so we assume x in [1, N].
                    if (x>=1 && x<=N) {
                        freq[x]++;
                    }
                }

                int a = 0, b = 0;
                for (int i=1; i<=N; i++) {
                    if (freq[i] == 0) {
                        a++;
                    } else if (freq[i] == 1) {
                        b++;
                    }
                }

                double ans = F[a][b] * N;
                cout << fixed << setprecision(9) << ans << '\n';
            }

            return 0;
        }

   We hope the sample input is provided in the corrected format.

   Let me test with the sample test case 3: 
        N=2, K=10, and the numbers: ten 2's -> 
        freq[1]=0 -> a=1
        freq[2]=10 -> b=0
        ans = F[1][0] * 2 = 2.0 * 2 = 4.0.

   It should be 4.0.

   Run: 
        F[1][0] = (1.0 + 1 * F[0][1]) / 1.
        F[0][1] = (1.0 + 1 * F[0][0]) / 1 = (1.0+0)/1=1.0.
        Then F[1][0] = (1+1)=2.0.

   So 2.0 * 2 = 4.0.

   This is correct.

   We output the code as below.

   Note: We assume the input tokens are as described.

   Also note: the worst-case T=100,000, but the total K<=100,000, so the loop for reading the numbers is O(100,000) overall.

   And the inner loop for counting frequencies: O(N) per test case, and the sum of N over test cases? Not the sum of N, but the problem says the total K<=100,000, but the N values: the distinct N might be up to 3000, and the test cases T up to 100,000, so the sum of N over test cases might be 100,000 * (average N). But worst-case average N = 3000, then 100,000 * 3000 = 300e6, which might be borderline in C++? 

   However, the problem states: the sum of the value of K on all test cases is not more than 100,000. It does not say the sum of N.

   We must optimize the frequency counting: we only do a loop for i from 1 to N for each test case. The total cost: T * N_max? But T can be 100,000 and N_max=3000 -> 100,000 * 3000 = 300e6 = 300 million, which is acceptable in C++ in 2 seconds? 

   But worst-case 100,000 test cases, each with N=3000, then 100,000*3000 = 30e9, which is too slow.

   How to avoid? 

        The problem says: the sum of K (the number of integers in the lists) is <=100,000. But it does not say the sum of N.

        We must note: we are doing a loop for i=1 to N for each test case. The total work is the sum of N over test cases.

        And the problem does not guarantee the sum of N, only the sum of K.

        Alternative: we can avoid the loop for i=1 to N by using the frequency array only for the numbers that appear? But we also need the numbers that never appear.

        We can do:

            a = N - (number of distinct numbers that appear at least once) 
            but we also need b: count of numbers that appear exactly once.

        How to get b? 

            We can iterate over the distinct numbers that appear? But we don't know which numbers.

        Actually, we can:

            Initially, a = N, b = 0.
            Then we traverse the list A: we update frequency and then we know when a number appears for the first time: then a--, and then when it appears the second time: then b--, etc.

        But we need to know the frequency counts.

        We can do:

            vector<int> freq(N+1,0);
            a = N, b = 0;
            for (int x : A) {
                if (x<1 || x>N) continue;
                freq[x]++;
                if (freq[x] == 1) {
                    a--;   // because it is no longer unseen
                    b++;
                } else if (freq[x] == 2) {
                    b--;
                }
                // if more than 2, then no change to a or b.
            }

        Then at the end, a = count of numbers that never appear, b = count of numbers that appear exactly once.

        This is O(K) per test case, and total K<=100,000 -> so total O(100,000).

        We can do that.

        Steps for each test case:

            Read N, K.
            Read the K numbers.

            vector<int> freq(N+1, 0);
            int a = N, b = 0;
            for (int x : A) {
                if (x>=1 && x<=N) {
                    freq[x]++;
                    if (freq[x]==1) {
                        a--;
                        b++;
                    } else if (freq[x]==2) {
                        b--;
                    }
                }
            }

        Then we have the state (a,b).

        This is more efficient.

        For example, if N=3000 and K=100,000, then the frequency counting is O(K) and the initial a=N and then we update for each number: O(1) per number -> total O(K) per test case, and overall sum of K<=100,000.

        But note: the problem says the sum of the value of K on all test cases is not more than 100,000.

        Therefore, we can do:

            int T;
            cin >> T;
            while (T--) {
                int N, K;
                cin >> N >> K;
                vector<int> A(K);
                for (int i=0; i<K; i++) {
                    cin >> A[i];
                }

                vector<int> freq(N+1, 0);
                int a = N, b = 0;
                for (int x : A) {
                    if (x>=1 && x<=N) {
                        freq[x]++;
                        if (freq[x] == 1) {
                            a--;
                            b++;
                        } else if (freq[x] == 2) {
                            b--;
                        }
                    }
                }

                double ans = F[a][b] * N;
                cout << fixed << setprecision(9) << ans << '\n';
            }

        This is efficient.

   Final code with efficient counting.