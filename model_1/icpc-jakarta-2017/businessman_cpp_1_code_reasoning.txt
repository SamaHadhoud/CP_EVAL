 We are given a connected undirected graph. We first check if the graph is bipartite.
 If the graph is not bipartite (i.e., contains an odd cycle), then the two businessmen can meet at the same city after some days (because they can adjust to meet at the same city by going around the odd cycle). Therefore, the answer for every query of type 1 is 0.

 If the graph is bipartite, then we color the graph with two colors (0 and 1). Note: the two businessmen start at two cities. After X days, they will be at two cities with colors that depend on the parity of X and their starting colors.
 Specifically:
   Let the starting cities be u and v, with colors c1 and c2.
   After X days, the color of the city for the first businessman will be (c1 + X) mod 2.
   Similarly, for the second businessman: (c2 + X) mod 2.

 They can choose any non-negative integer X. Therefore, they can choose an X such that both end up at cities of color 0, or both at 1, or one at 0 and the other at 1? Actually, note:

   The businessman starting at u can only be at a city of color (c1 + X) mod 2.
   The businessman starting at v can only be at a city of color (c2 + X) mod 2.

 So the two businessmen will end up at two cities with colors that are:
   (c1 + X) mod 2 and (c2 + X) mod 2.

 The difference between these two colors modulo 2 is: (c1 - c2) mod 2, which is independent of X.

 Therefore:
   If c1 == c2, then (c1+X) mod 2 == (c2+X) mod 2, so they can meet at the same color. Moreover, since the graph is connected and bipartite, they can actually meet at the same city? Actually, not necessarily the same city, but they can both be at a city with the same economic value? However, note that we are allowed to choose any cities in the same color. Since the graph is connected, they can both go to any city of the same color? Actually, the movement is constrained by the graph: after X days, they can be at any city that is at distance X modulo 2? But note: they can revisit nodes arbitrarily. So if they have the same color, then after a sufficiently large even number of days, they can both be at the same city (if the graph is connected and we can traverse arbitrarily). However, note: we are not constrained to the same city. We can choose two different cities as long as they are in the same color? Actually, the problem does not require them to be at the same city, but the same color set.

 Since we want the minimum absolute difference in economic values, and we can choose any two cities in the same color (if they start at the same color) then we can get 0 (if there are two cities with the same economic value? Actually, we can even choose the same city? But note: they cannot stay in the same city for two consecutive days? However, the problem does not say they have to move to a different city. It says "move to any city adjacent to the current city". They can move to the same city? Actually, the problem says "they move to any city adjacent", meaning they can choose any adjacent city. But note: they cannot stay? The problem says: "They cannot stay in the same city for two consecutive days". So they must move to an adjacent city. However, they can move to the same city? Only if there is a self-loop? But the graph has no self-loops. Therefore, they must move to a different city. However, they can revisit a city. So after two days, they can come back to the starting city? 

 But note: the problem does not require them to be at the same city. They can be at two different cities that have the same economic value. So if there are two cities in the same color with the same value, then we can get 0. However, that is not necessary. Actually, we are allowed to choose any two cities in the same color? But we are constrained by the starting points? Actually, the businessmen start at u and v. After X days, they are at two cities: one in the set of nodes of color (c1 + X mod 2) and the other in (c2 + X mod 2). However, we can choose X arbitrarily. So:

   If c1 == c2, then we can set X to be any even number? Actually, we can set X to any nonnegative integer, but note that the color of the node they end at is fixed: both will be at the same color. Then we can choose two cities in that color arbitrarily? But note: we are constrained by the graph: we can only reach nodes that are at distance X from the starting point? However, by taking X large enough, we can cover the entire connected component? Actually, the graph is connected and bipartite, so from a starting node of color c, after an even number of moves, we can be at any node of color c? Actually, that is true if the graph is connected and bipartite: the entire set of nodes of color c is reachable from the start in an even number of moves? Not exactly: if the graph is bipartite, then from a node of color c, we can only reach nodes of color c in an even number of moves and color c^1 in an odd number.

 Therefore, if c1 == c2, then we can choose an even X to have both at color c1, and then we can have both businessmen at any two cities in the set of nodes with color c1. Then the minimum difference we can get is the minimum absolute difference between any two values in the set of color c1? But note: we are not forced to have two distinct cities? Actually, the problem does not require distinct cities? The problem says: "the two cities can be the same city". So we can have both at the same city? Then the difference is 0. However, can they be at the same city? Only if they start at the same city? Actually, no: they start at different cities. But after moving, they can meet at a common city? That is possible if the graph is connected? Actually, they can meet at any city that is reachable from both in the same number of moves? But note: the graph is connected and bipartite. If they start at the same color, then the distance from u to w and from v to w must have the same parity? Actually, if we let w be a common city, then the distance from u to w must be even (since u and w have the same color) and the distance from v to w must be even. But the distance between u and v is even? Actually, since they are the same color, the distance between u and v is even. Then the entire graph being connected and bipartite, we can indeed have them meet at a common city w? For instance: 
   Let d(u, v) = d (which is even). Then we can choose w = u. But the second businessman would have to go from v to u in X days. Since d is even, we can set X = d, then the first businessman can stay at u? But wait, they cannot stay: they must move every day. So how to stay? They cannot. However, we can have them move in a cycle? For example, after reaching u at day d, the first businessman can move to an adjacent node and then come back? Actually, we can use a cycle of length 2: so if we set X = d + 2*k, then the first businessman can go from u to u by going to a neighbor and back k times, and the second businessman can go from v to u in d moves and then do the same cycle. Therefore, we can have them meet at u (if we choose w=u) at day d+2*k. Then the difference is 0.

 Therefore, if the two starting cities have the same color, the businessmen can meet at the same city (by choosing X sufficiently large and even) and the difference is 0.

 But wait: what if there is no cycle? In a tree, which is bipartite, we cannot form a cycle? Actually, the problem states that the graph has M edges and is connected, but a tree has no cycles. However, note: the problem says "each road directly connects two different cities" and the graph is connected. In a tree, we don't have cycles. How can the first businessman stay at u? He cannot: because he must move. Therefore, after an even number of moves, he must leave u and then come back. But if u has a neighbor, then he can move to the neighbor and then back to u. So even in a tree, if a node has at least one neighbor, we can form a cycle of length 2. Only if a node is isolated? But the graph is connected and has at least one edge? Actually, if there is only one node, but the problem states N>=1 and M>=1? Actually, the constraints say N>=1 and M>=200000? Actually, no: M>=1. But we have M>=1, so every node? Actually, the graph has M edges, so if a node has no neighbor, then we cannot form a cycle? But the graph is connected and has at least one edge? Actually, the graph is connected and M>=1, so there are no isolated nodes? Actually, no: a graph with two nodes and one edge: then each node has one neighbor.

 Therefore, in a bipartite graph, if the two starting cities have the same color, then we can achieve the same city (by meeting at one of the cities, say u, by the second businessman traveling from v to u, and then both can do a back-and-forth on an edge to use up any extra even days). Therefore, the answer is 0.

 What if the two starting cities have different colors? Then after any X days, the first businessman will be at a city of color (c1 + X) mod 2, and the second at (c2 + X) mod 2. Since c1 != c2, we have (c1+X) mod 2 = (c2+X) mod 2? Actually, no: 
   Let c1 = 0, c2 = 1.
   Then for X even: 
        businessman1: 0+even -> 0
        businessman2: 1+even -> 1 -> so they are at different colors.
   For X odd:
        businessman1: 0+odd -> 1
        businessman2: 1+odd -> 0 -> so they are again at different colors.

 Therefore, they will always end up at two cities of different colors. Then the problem reduces to: what is the minimum absolute difference between the economic value of any two cities that are in different color sets?

 But note: they can choose X arbitrarily, so they can choose to be at any pair of cities (u', v') such that u' is in the set of color (c1+X mod2) and v' in (c2+X mod2). Since the colors of u' and v' are different (because (c1+X) mod2 != (c2+X) mod2), then we are effectively looking for the minimum absolute difference between a node in set0 and a node in set1.

 Therefore, we can precompute the entire set of economic values for set0 and set1, and then we want the minimum |a - b| for a in set0 and b in set1.

 However, the problem has updates. So we need to support:
   - Updating the economic value of a node (which is in either set0 or set1).
   - Querying the minimum absolute difference between any node in set0 and any node in set1.

 How to do this efficiently? We can maintain two sets: one for set0 and one for set1? But then the query is the minimum gap between the two sets. We can also maintain a global set of pairs (value, color) and then consider adjacent pairs in the global sorted order? Because the minimum gap must occur between two consecutive numbers that have different colors? Why? Because if we sort by value, then the minimum gap between set0 and set1 must occur between two consecutive numbers in the sorted order that are of different colors? Actually, if we have a sorted list of (value, color), then the minimum gap between set0 and set1 can be found by scanning adjacent pairs that are of different colors? But note: the gap between two values of different colors that are not adjacent might be large, but the minimum gap must occur between two consecutive values in the entire sorted array? Actually, if we have three values: a (color0), b (color1), c (color0) such that a < b < c, then the gap between a and b is b-a, and between b and c is c-b. The gap between a and c is c-a, which is larger than the gaps to b. Therefore, we only need to consider adjacent pairs in the entire sorted array that have different colors.

 So we can:
   - Maintain a set (or multiset) of all economic values (with their color) sorted by value.
   - Also maintain a multiset of the gaps between consecutive nodes that have different colors. Then the answer for the query (when the two starting cities have different colors) is the smallest gap in this multiset.

 Steps for bipartite case:
   Step 1: We have the initial array S and the color for each node.
   Step 2: Create a sorted set (e.g., set of pairs (value, node index) or (value, color) but we need to update by node index). Actually, we need to update the value of a node, so we need to know the old value. So we can use a set of pairs (value, node_id) and also store the current value of each node in an array.

   Step 3: Build the multiset of gaps: traverse the sorted set and for every consecutive pair, if the two nodes have different colors, then add the gap (difference) to the multiset.

   Step 4: For each query:
        Type 0: update the value of a node B_i to C_i.
            We remove the old value and insert the new value. This affects the gaps with the immediate predecessor and successor. We remove the gaps that involved the old value (and the gap that might have been between the predecessor and successor) and then add gaps for the new value with its new neighbors.

        Type 1: if the two starting cities have the same color -> output 0.
                else -> output the smallest gap in the multiset (if the multiset is empty, then output 0? Actually, the multiset might be empty if there are no consecutive pairs? But that only happens if there is at most one node? But the graph has at least one node. However, if there is only one node, then we have only one color? Actually, the graph has at least two nodes? Not necessarily: N>=1. But the query has two distinct cities? So if N=1, then the graph has only one city? But the input says M>=1, and two distinct cities. So the graph has at least two nodes? Actually, the constraints: M>=1 and each road connects two distinct cities, and the graph is connected. So if N=1, then M must be 0? But the input says M>=1. Therefore, N>=2.

        However, we must consider: the multiset of gaps might be empty if there are no consecutive pairs of different colors? For example, if the entire set0 is less than set1? Then the gaps we consider are between the maximum of set0 and the minimum of set1? But that gap would be in our multiset? Actually, no: because we traverse the entire sorted array and for every consecutive pair, we check the colors. So if we have set0 = [1,3] and set1=[2,4], then the consecutive pairs are:
           (1,2): colors (0,1) -> gap=1 -> add to multiset
           (2,3): colors (1,0) -> gap=1 -> add
           (3,4): colors (0,1) -> gap=1 -> add

        But note: we don't need to consider non-adjacent? Actually, we only consider consecutive in the sorted array.

        How to update:
          Let the node to update be u with old value = old, new value = new_val.
          Steps:
            Remove u from the sorted set. This breaks the consecutive links: we remove the gaps between u and its left neighbor, and between u and its right neighbor. Also, if the left and right neighbors become consecutive, we add the gap between them (if they are of different colors).

            Then insert u with new_val. Then we break the link between the two nodes that become separated (the left and right neighbor of the new position) and then add the gaps for the new u with its new left and right.

          We maintain a multiset (or a heap) of gaps. But note: the same gap might appear multiple times? Actually, no: each consecutive pair is unique. But we might have multiple gaps of the same value? Then the multiset will store multiple copies.

          Implementation:
            We use a set for the sorted list: set<pair<ll, int>> sorted_set; // (value, node_index)

            We also maintain current_value[i] for each node i.

            Steps for update:
              Let u = B_i, new_val = C_i, old_val = current_value[u]

              Find the old element: (old_val, u) in sorted_set.

              Let it = sorted_set.find({old_val, u})

              Then:
                Let prev = the element before it (if exists)
                Let next = the element after it (if exists)

                Remove:
                  If prev exists, remove the gap between prev and it (if the colors of prev and u are different, then remove that gap from the multiset).
                  If next exists, remove the gap between it and next (if the colors of u and next are different, then remove that gap).
                  If both prev and next exist, then we create a gap between prev and next (if the colors of prev and next are different, then add that gap to the multiset).

                Then remove it from sorted_set.

                Then insert the new value: insert (new_val, u) -> get a new iterator.

                Then update current_value[u] = new_val.

                Then:
                  Let it_new = iterator to (new_val, u)
                  Let prev_new = element before it_new (if exists)
                  Let next_new = element after it_new (if exists)

                Remove the gap between prev_new and next_new if they were consecutive (if both exist and if their colors are different, then we remove the gap that we previously had between them? Actually, when we inserted the new node, we broke the consecutive link between prev_new and next_new. So we must remove the gap between prev_new and next_new (if it exists) from the multiset.

                Then:
                  If prev_new exists, add the gap between prev_new and it_new (if colors of prev_new and u are different) to the multiset.
                  If next_new exists, add the gap between it_new and next_new (if colors of u and next_new are different) to the multiset.

            Note: when we remove a gap from the multiset, we remove one occurrence. Similarly, when we add, we add one occurrence.

          The answer for a type-1 query (with different colors) is the smallest element in the multiset (if the multiset is non-empty). But what if the multiset is empty? That would happen only if there is no consecutive pair of different colors? Then we have no adjacent pair? Actually, that can happen only if the entire set of nodes has the same color? But we have two sets: set0 and set1. If one set is empty? Then we have no consecutive pair of different colors? But the graph is bipartite and connected, and we have at least two nodes? Actually, the coloring must have both colors? Because the graph is connected and has at least one edge, so we have both colors. Therefore, we have at least one node in set0 and one in set1. Then the entire sorted array must have at least one consecutive pair of different colors? Not necessarily: if all set0 are less than all set1? Then the gap between the last set0 and the first set1 is the only gap? But we traverse consecutive pairs, so we will have that gap? Actually, we will have the consecutive pairs that cross the boundary? But also, within set0 and within set1 we have consecutive pairs? But we don't care about same color consecutive pairs. So the multiset of gaps is non-empty? Actually, if there is only one node in set0 and one in set1, then we have one consecutive pair? But if there are two nodes: both in set0? Then the consecutive pair between them is same color -> not added. Then we have no gap? Actually, no: we have two nodes: one set0 and one set1? Then the entire sorted array: [a0, b1] -> one consecutive pair -> gap = |a0-b1| -> added. If we have two set0 and one set1: [a0, b0, c1]: then consecutive pairs: 
            a0 and b0: same -> skip.
            b0 and c1: different -> gap = |b0-c1| -> added.

          However, what if we have set0 = {1,3} and set1={2}? Then the sorted array: [1,2,3]. The consecutive pairs:
            1 and 2: different -> gap=1 -> added.
            2 and 3: different -> gap=1 -> added.

          But note: the gap between 1 and 3 is 2, which is not considered.

          Therefore, the multiset of gaps might be non-empty as long as there is at least one node in set0 and one in set1.

          However, if there is only one node in set0 and no node in set1? That cannot happen because the graph is connected and has at least one edge: the coloring must assign both colors? Actually, the graph is connected and we started at node1 with color0. Then we color all nodes. So we have both colors? Actually, the graph is connected and we have at least one edge: so if we have at least two nodes, then we have both colors. Therefore, the multiset of gaps is non-empty? Actually, no: if we have two nodes: one set0 and one set1, then we have one gap? Yes. But if we have more? We have at least one gap? Actually, if we have two nodes, we have one gap. So the multiset is non-empty? Actually, if we have one node? Then the problem says M>=1, so we have at least two nodes? Therefore, we assume at least two nodes.

          But the problem constraints: N>=1, M>=1. The graph is connected. So the smallest graph is two nodes and one edge. Then we have two nodes: one color0 and one color1? Then the sorted_set has two elements? Then the consecutive pair is the only one? Then the multiset has one gap.

          Therefore, we can safely say that the multiset is non-empty? Actually, no: what if we update and remove the only two nodes? No, we update the values, but we don't remove nodes. The set always has N nodes.

          So we can assume that the multiset is non-empty? Actually, no: we have at least two nodes, but if the two nodes have the same value? Then the gap is 0? Then we have 0 in the multiset. So the smallest gap is 0.

          Therefore, we can output the smallest gap.

        However, note: it is possible that the entire set0 is to the left of set1? Then the gaps we are storing are the consecutive adjacent pairs that cross the sets? But we have at least one such gap? Actually, we have the entire sorted array, and the sets are interleaved? Actually, the sets might be interleaved arbitrarily.

          The important point: we are storing every consecutive pair in the entire sorted array that has different colors.

        But note: the entire set0 and set1 might be separated by a large gap? Then the smallest gap might be within the interleaving? Actually, the minimum gap between set0 and set1 must occur at a consecutive pair in the sorted array? Because if we have a0, a1, a2, ... in increasing order, then the gap between a0 and a1 is the smallest gap? Not necessarily: the gap between a0 and a1 might be large, but the gap between a0 and some a_i in the other set that is not consecutive might be smaller? Actually, no: the consecutive pairs in the sorted array are the smallest possible gaps? For example, if we have:
            set0: [1, 5]
            set1: [2, 6]
          Then the consecutive pairs: 
            1 (0) and 2 (1): gap=1
            2 (1) and 5 (0): gap=3
            5 (0) and 6 (1): gap=1
          The minimum gap is 1, which appears at the consecutive pairs (1,2) and (5,6). Also, the gap between 1 and 6 is 5, which is not the minimum. Therefore, we only need to consider consecutive pairs.

        Therefore, the algorithm for bipartite graph:

          sorted_set: set of pairs (value, node_id) for all nodes.
          gap_set: a multiset of gaps (differences) for consecutive pairs in sorted_set that have different colors.

          For update (node u, new_value):
            old_value = current_value[u]
            Remove the old_value from sorted_set: 
                Find the element (old_value, u) -> iterator it.
                Let L = the element immediately before it (if exists), R = the element immediately after it (if exists).
                Remove the gap between L and it (if L exists and color[L] != color[u]) from gap_set.
                Remove the gap between it and R (if R exists and color[u] != color[R]) from gap_set.
                If both L and R exist, then add the gap between L and R (if color[L] != color[R]) to gap_set? Actually, because L and R become consecutive after removing u? Then we add the gap between L and R (if they are different colors) to gap_set.
            Then remove (old_value, u) from sorted_set.

            Insert (new_value, u) into sorted_set. Let it_new be the iterator to the new element.
            Then:
                Let L_new = element immediately before it_new (if exists)
                Let R_new = element immediately after it_new (if exists)

                If both L_new and R_new exist, then they were consecutive before inserting u? Now we break that consecutive link? So we must remove the gap between L_new and R_new (if they are of different colors) from gap_set? Because they are no longer consecutive? Actually, after inserting u, L_new and R_new are separated by u. So we remove the gap that we previously had between L_new and R_new? But note: we had stored that gap? Only if L_new and R_new were consecutive? Yes, we had stored the gap for the consecutive pair (L_new, R_new) if their colors were different.

            Then:
                If L_new exists, then add the gap between L_new and u (if color[L_new] != color[u]) to gap_set.
                If R_new exists, then add the gap between u and R_new (if color[u] != color[R_new]) to gap_set.

          For query (type 1, with two cities of different colors): 
                Answer = *gap_set.begin()   [the smallest gap in the multiset]

        But note: what if the gap_set becomes empty? Actually, we have at least two nodes? And we are updating without removing nodes? We are always keeping N nodes. And we have at least one node in set0 and one in set1? Therefore, we should always have at least one gap? Actually, no: if the entire set0 is less than set1, then the consecutive pairs that cross sets are only the one between the last set0 and the first set1? Then we have one gap? And after update, we might break that gap? Actually, no: we update the value of a node, so we remove it and then insert it again. The set0 and set1 remain non-empty? Yes. So we always have at least one consecutive pair of different colors? Actually, if we have two nodes: one set0 and one set1, then we have one gap. When we update one of them, we remove the gap and then reinsert it? Actually, when we remove the node, we break the gap? But then we add it back? So we break and then form two gaps? Actually, if we update the set0 node, then when we remove it, we break the gap between the set0 and set1? Then we add the new value? Then we form two gaps: one between the new set0 and the set1? Actually, if we update the set0 node to a value that is between the set1 node and the other set0 nodes? But we only have one set0 node? Then when we remove that set0 node, there is no consecutive pair? Then when we add the new value, we form one gap? So the multiset might become empty only if we remove the gap and then don't form a new one? But we have at least two nodes? Then when we remove a node, we break the gaps, but then we reinsert the same node? Then we form new gaps? Actually, we have two nodes: u (set0) and v (set1). We update u: 
            Remove u: then the set has only v -> no consecutive pair? Then we remove the gap between u and v? Then the multiset becomes empty? Then we insert the new u: then we form a gap between the new u and v? Then we add that gap. So the multiset becomes non-empty again.

          However, during the update, after removing u and before inserting, the set has only one element? Then the gap_set becomes empty? Then we break the gap between u and v? Then we try to remove the gap between L and R? But there is no L and R? Actually, in the removal step: 
                We remove the gap between L and u: but if u was the first element, then L doesn't exist -> skip.
                We remove the gap between u and R: if u was the first, then R is v? Then we remove the gap between u and v? Then the multiset becomes empty? 
            Then we insert u: then we have two nodes again. Then we form the gap between the new u and v? Then we add that gap.

          Therefore, in the query step, we must check if the gap_set is empty? Actually, the query comes after the update. So after the update, we have inserted the new value and the multiset is non-empty? But during the update, we might have a temporary empty multiset? But the update is done and we have two nodes? Then we have at least one gap? Actually, we have two nodes: then we have one gap? So we can assume that after the update, the multiset is non-empty? Actually, no: if we update the only set0 node to a value that is exactly the same as the set1 node? Then the gap is 0? Then we add that gap? So the multiset becomes {0}. Then the next query will return 0.

          Therefore, we do not need to worry about the multiset being empty? Actually, we have at least two nodes? And we have both colors? Then the entire sorted array has at least two elements? And we have at least one consecutive pair? Actually, the consecutive pairs in the sorted array are the gaps between consecutive elements. The number of consecutive pairs is (n-1). But we only store the ones that have different colors. And we have at least one node in set0 and one in set1? Then there is at least one consecutive pair that crosses the sets? Actually, the entire set might be interleaved arbitrarily? But we can guarantee that there is at least one consecutive pair of different colors? Actually, no: consider two nodes: one set0 and one set1: then we have one consecutive pair -> different colors -> stored. For three nodes: two set0 and one set1? Then we have two consecutive pairs: 
            node0: a0, node1: b0, node2: c1 -> then consecutive pairs: (a0,b0): same -> skip; (b0,c1): different -> stored.
          So we always have at least one consecutive pair of different colors? Actually, if the entire set0 is on one side and set1 on the other? Then the consecutive pair at the boundary is stored. Therefore, after the update, the multiset is non-empty? Actually, we break the gaps during removal, but then we form new gaps during insertion? So the multiset is non-empty at the end of the update? Therefore, we don't have to worry about the multiset being empty at the time of a type-1 query? But what if we update and the new value is such that the gaps we form are same color? Then we don't add any gap? Actually, that is possible? For example, we have three nodes: 
                [ (1, color0), (2, color1), (3, color0) ]
            We update the node with value 2 to 4? Then we remove 2: 
                Remove: 
                  gap between (1,0) and (2,1): remove gap 1
                  gap between (2,1) and (3,0): remove gap 1
                  then we add the gap between (1,0) and (3,0)? But same color? -> skip.
            Then we insert (4,1): 
                Now the sorted set: [1,3,4]
                We break the consecutive pair between 1 and 3: which was same color -> we didn't have that gap? Actually, we had the gap between 1 and 3? But we only store consecutive pairs? When we remove 2, we break the consecutive pairs (1,2) and (2,3). Then we add the consecutive pair (1,3) -> which is same color -> we don't add to gap_set. Then we add the consecutive pair between 3 and 4: which is (0,1) -> so we add gap=1.

            Then the multiset becomes {1}? So non-empty.

          Therefore, the multiset might become empty only if we have no consecutive pairs of different colors? That would require that the entire sorted array is one color? But we have both colors? Then the only way is that the two sets are separated and we break the boundary? But when we update, we might merge the two sets? Actually, no: we update one node. The sets remain non-empty? Then we will form a gap at the boundary? Actually, if we update a node that is at the boundary to a value that moves it to the middle of a same-color block? Then we break the boundary gap? But then we form two new gaps? One with the previous boundary and the next boundary? Actually, the boundary gap might be the gap we break? Then we form two new gaps: one between the updated node and the left block? and one with the right block? Then we add those if they are different colors? Actually, the updated node is in one set, and the adjacent nodes might be in the same set? Then we don't form a gap? But the boundary gap was the only gap? Then the multiset becomes empty? 

          Example: 
            Initially: [a0, b1] -> gap_set = { |a-b| }
            Update b to a value that is between a0 and the next set0 node? But we have no next set0 node? Actually, we have only two nodes: a0 and b1. Then we update b1 to a new value that is less than a0? Then the sorted array becomes [new_b1, a0]. Then we break the gap between a0 and b1? Then we form a gap between new_b1 and a0? And that is different colors? So we add |new_b1 - a0|? Then the multiset becomes { |new_b1 - a0| }.

          But what if we update b1 to a value that is greater than a0? Then the sorted array remains [a0, new_b1]. Then we break the gap? Then we form the gap between a0 and new_b1? Then we add |a0 - new_b1|.

          However, if we have three nodes: 
                [a0, b1, c0] -> gaps: a0 and b1: gap1, b1 and c0: gap2 -> stored.
          Now update b1 to a value that is greater than c0? Then the sorted array becomes [a0, c0, new_b1]. 
          Removal of b1: 
                Remove gap between a0 and b1 -> remove gap1
                Remove gap between b1 and c0 -> remove gap2
                Then we add the gap between a0 and c0? -> same color? skip.
          Insertion of new_b1 at the end:
                Break the consecutive pair between c0 and nothing? Actually, we only have a0 and c0? Then when we insert new_b1 after c0, we break the consecutive pair between c0 and nothing? Actually, we don't break any consecutive pair? Because c0 was the last. Then we form a gap between c0 and new_b1? -> different colors? -> add gap3 = |c0 - new_b1|.
          Then the multiset becomes {gap3}. So non-empty.

          The only scenario where the multiset becomes empty: if we have only two nodes: one set0 and one set1. And we update one node so that the gap we form is same color? That cannot happen because the updated node has a fixed color? Then the gap we form is between set0 and set1? So we add it.

          Therefore, we can safely assume that after the update, the multiset is non-empty? Actually, we cannot: consider if we have three nodes: 
                a0, b0, c1
          Then the gaps: 
                a0 and b0: skip (same)
                b0 and c1: gap = |b0-c1| -> stored.
          Now update c1 to a value that is between a0 and b0? Then we remove the gap between b0 and c1? Then we break the consecutive pair? Then we form two gaps:
                a0 and new_c1: different -> add gap1 = |a0 - new_c1|
                new_c1 and b0: different -> add gap2 = |new_c1 - b0|
          Then the multiset becomes {gap1, gap2}. So non-empty.

          Actually, we cannot get an empty multiset? Because we have at least two nodes and both colors, and we always have at least one consecutive pair of different colors? Actually, the entire set is sorted and the two sets are non-empty, so there must be at least one consecutive pair that crosses the two sets? For example, the last element of set0 and the first element of set1? Or the last element of set1 and the first element of set0? Actually, the consecutive pairs in the sorted array include the boundary between the two sets? So we have at least one gap? Therefore, we can assume the multiset is non-empty.

          However, during the update, after removal and before insertion, the multiset might be empty? But then we insert and add gaps? So at the end of the update, the multiset is non-empty.

        Therefore, we do not need to check for emptiness in the query? Actually, we do: because the update might have just happened, and the query comes after the update. So we can output the smallest gap.

        But what if the entire set0 and set1 are separated by a gap, and the consecutive pairs we store are the gaps at the boundary? Then the smallest gap might be the gap at the boundary? Actually, the minimum gap between the two sets is the minimum gap in the multiset? Because we have stored every consecutive pair that crosses the sets? And the minimum gap must be one of these? As argued.

        Therefore, the solution for bipartite graph is as described.

        However, note: the problem sample input: 
          "6 6
           0 0 0 0 0 0
           1 2
           1 6
           5 1
           2 3
           3 4
           3 5
           7
           1 1 2
           0 1 10
           0 3 20
           1 1 2
           0 4 11
           1 1 3
           1 1 6"

        For the first query: the two starting cities are 1 and 2. What are the colors? 
          We run BFS: 
            color[1]=0
            Then neighbors: 2,6,5 -> color=1
            Then from 2: neighbors 3 -> color=0
            Then from 3: neighbors 4,5 -> color=1 for both? But 5 is already colored as 1? Then we check: 5 has color1 and 3 has color0 -> edge (3,5) is valid? Then the graph is bipartite.

          Therefore, the two starting cities: city1 (color0) and city2 (color1) -> different colors. Then we need the minimum gap between set0 and set1? But initially, all values are 0? Then the gaps are 0? Then the answer is 0? But the sample output for the first query is 0.

        Second query: update city1 to 10 -> then set0: {10,0,0} -> actually we have to store the values per node? 
          The set0: nodes 1,3,4? 
          The set1: nodes 2,5,6.

          Then the sorted_set: 
            set0: node1:10, node3:0, node4:0 -> actually we store by value: 
            sorted_set: 
                (0,3), (0,4), (0,2), (0,5), (0,6), (10,1) -> no, we store all nodes: 
                (0,3) -> color0
                (0,4) -> color0
                (0,2) -> color1
                (0,5) -> color1
                (0,6) -> color1
                (10,1) -> color0

          Then the sorted_set: 
                (0,2), (0,3), (0,4), (0,5), (0,6), (10,1)  -> but we have to store by value, and then by node id? Actually, we use (value, node_id) so that two nodes with the same value are stored and we break ties by node_id? Actually, the set uses lexicographical order: first value, then node_id.

          Then consecutive pairs:
            (0,2) and (0,3): color1 and color0 -> gap=0 -> add 0 to gap_set.
            (0,3) and (0,4): color0 and color0 -> skip.
            (0,4) and (0,5): color0 and color1 -> gap=0 -> add 0.
            (0,5) and (0,6): color1 and color1 -> skip.
            (0,6) and (10,1): color1 and color0 -> gap=10 -> add 10.

          Then the gap_set = {0,0,10}. The smallest gap is 0.

          Then the third query: update city3 to 20 -> then node3 (color0) becomes 20.

          Then we remove (0,3) and insert (20,3). 
          Removal of (0,3): 
            neighbors: (0,2) and (0,4) -> both exist? 
            Gap between (0,2) and (0,3): gap=0 -> remove one 0 from gap_set.
            Gap between (0,3) and (0,4): gap=0 -> remove one 0 from gap_set? But we skipped the gap between (0,3) and (0,4) because same color? Actually, (0,3) is color0 and (0,4) is color0 -> so we didn't have that gap? Then we only remove the gap between (0,2) and (0,3) -> which was 0.

            Then we add the gap between (0,2) and (0,4)? 
                (0,2) and (0,4): color1 and color0 -> gap=0 -> add 0.

          Then insert (20,3): 
            It will be at the end: 
                ... (0,6) -> (20,3)
            Then we break the consecutive pair between (0,6) and nothing? Actually, we break the consecutive pair between (0,6) and (10,1)? Then we remove the gap between (0,6) and (10,1)? which was 10? Then we add the gap between (0,6) and (20,3): gap=20? and then the gap between (20,3) and (10,1)? Actually, no: the sorted_set becomes:

                (0,2), (0,4), (0,5), (0,6), (10,1), (20,3)

            Actually, no: (10,1) is 10 and (20,3) is 20 -> so (10,1) comes before (20,3). So after insertion, the sorted_set is:

                (0,2), (0,4), (0,5), (0,6), (10,1), (20,3)

            Then the consecutive pairs:
                (0,6) and (10,1): gap=10 -> different colors? (0,6) is color1, (10,1) is color0 -> add 10.
                (10,1) and (20,3): gap=10 -> different colors? (10,1) is color0, (20,3) is color0 -> same color? skip.

            Therefore, the gap_set after update: 
                  after removal: we removed the gap (0,2) and (0,3) -> which was 0, then we added the gap (0,2) and (0,4) -> 0.
                  then we removed the gap (0,6) and (10,1) -> which was 10? But we didn't remove it? Actually, during removal we did not remove that gap? Because when we removed (0,3), we only broke the consecutive pairs (0,2)-(0,3) and (0,3)-(0,4). The consecutive pair (0,6) and (10,1) was not adjacent to (0,3)? So we didn't break it? Then we don't remove it? 

            Then we break the consecutive pair between (0,6) and (10,1) when we insert (20,3)? Actually, we insert (20,3) at the end? Then we break nothing? Actually, the consecutive pair (0,6) and (10,1) remains? Then we form a new consecutive pair between (10,1) and (20,3) -> same color? skip.

            Therefore, the gap_set after update: 
                  we have: 
                    (0,2) and (0,4): 0 -> stored.
                    (0,4) and (0,5): same color? (0,4): color0, (0,5): color1 -> gap=0 -> stored.
                    (0,5) and (0,6): same color? skip.
                    (0,6) and (10,1): gap=10 -> stored.
                    (10,1) and (20,3): skip.

            Then gap_set = {0,0,10}. The smallest gap is 0.

          But the sample output for the fourth query is 10.

        Why?

        The fourth query: 
            "1 1 2": 
                starting cities: city1 (color0) and city2 (color1) -> different colors? Then we output the smallest gap? 0.

        But the sample output is 10.

        What's happening?

        The problem: 
          After updating city1 to 10 and city3 to 20, we have:
            city1: 10 (color0)
            city2: 0 (color1)
            city3: 20 (color0)
            city4: 0 (color0)
            city5: 0 (color1)
            city6: 0 (color1)

          The two businessmen start at city1 and city2. They have different colors. Therefore, they must end at two cities of different colors. What are the available pairs? 
            The set0: {10,20,0} (cities 1,3,4) -> but city4:0
            The set1: {0,0,0} (cities 2,5,6)

          The minimum absolute difference between set0 and set1: 
            |10-0| = 10
            |20-0| = 20
            |0-0| = 0? But wait: set0 has a 0? Then we can get 0? But how? 
                The businessmen can choose to be at city4 (set0, value0) and city2 (set1, value0)? Then the difference is 0.

          Therefore, the answer should be 0.

        Why did we get 0 in our gap_set? 
          We stored:
            (0,2) and (0,4): gap=0 -> because (0,2) is city2 (set1) and (0,4) is city4 (set0) -> different colors -> gap=0.

          Then the smallest gap is 0.

        But the sample output for the fourth query is 10? 

        Actually, the sample output says:
            0
            10
            0
            1

        The queries:
          Query1: 1 1 2 -> output 0
          Query2: update city1 to 10
          Query3: update city3 to 20
          Query4: 1 1 2 -> output 10
          Query5: update city4 to 11
          Query6: 1 1 3 -> output 0
          Query7: 1 1 6 -> output 1

        So the fourth query is 1 1 2 -> and the output is 10.

        Why is our reasoning for 0 wrong?

        The problem: 
          The two businessmen must move for the same number of days. The one starting at city1 (value10) must move for X days and end at a city of color (0+X) mod2. The one starting at city2 (value0) must move for X days and end at a city of color (1+X) mod2.

          Since the two ending cities must be of different colors? Actually, we have: 
            (0+X) mod2 = (1+X) mod2? 
            This is equivalent to: (0+X) - (1+X) = -1 mod2 = 1 mod2 -> always odd? so they are always different? Then they must end at two cities of different colors.

          Therefore, they cannot both be at set0 or both at set1? They must be at one set0 and one set1.

          Then the minimum difference is the minimum |a-b| for a in set0 and b in set1.

          In the updated state: 
              set0: {10, 20, 0} -> but note: the city4 was updated to 11? Actually, not yet: the fourth query is after updating city1 and city3, and before updating city4. So at the fourth query, city4 is still 0.

          Then set0: {10,20,0} and set1: {0,0,0}. Then the minimum difference is min( |10-0|, |20-0|, |0-0| ) = min(10,20,0) = 0.

          How can they achieve 0? 
            The businessman starting at city1 (value10, color0) must end at a set1 city? Actually, no: 
                After X days, the first businessman must be at a city of color (0+X) mod2, and the second at (1+X) mod2. Since these are different, we cannot have the same city? But we can have two different cities: one set0 and one set1? Then if we choose a set0 city with value0 and a set1 city with value0, the difference is 0.

          Therefore, the answer should be 0.

        But the sample output is 10.

        Let me reexamine the sample input and output.

        The sample input:
          "6 6
           0 0 0 0 0 0
           1 2
           1 6
           5 1
           2 3
           3 4
           3 5
           7
           1 1 2
           0 1 10
           0 3 20
           1 1 2
           0 4 11
           1 1 3
           1 1 6"

        The sample output:
          0
          10
          0
          1

        The fourth query is the second type-1 query: "1 1 2", and the output is 10.

        Why?

        I see: the problem states that the two businessmen start at city1 and city2. They move for the same number of days. But note: they cannot choose to move independently to any city? They are constrained by the graph.

          They start at city1 and city2.
          After X days, they must be at two cities that are reachable in exactly X moves from their starting cities.

          The problem says: "they can move to any city adjacent to the current city" and they do this for X days. This implies that after X days, they are at a city that is at distance X from their starting city? But note: they can revisit nodes? So they are not limited to the shortest path.

          Actually, in a graph, after X moves, they can be at any city that is at distance <= X and has the same parity as X? Because the graph is bipartite. 

          Therefore, for a fixed X, the first businessman can be at any city of color (0+X) mod2 that is at distance <= X and has the same parity? Actually, the entire set of nodes of the color (0+X) mod2 that are at distance d (with d<=X and d mod2 = X mod2) from the starting city? But note: we can extend the walk by looping? So we can be at any node of the correct color that is in the connected component? Actually, the graph is connected. Therefore, after X moves (if X is at least the distance to the node), the businessman can be at any node of the correct color.

          Why? Because we can go to the node and then do a back-and-forth on an edge to use up the remaining moves? Therefore, if X is large enough, they can be at any node of the correct color.

          But what is the minimum X required? We require X to be at least the diameter of the graph? Then for sufficiently large X (larger than the diameter), they can be at any node of the correct color.

          Therefore, the minimum difference is the minimum |a-b| for a in set0 and b in set1? Because by choosing X sufficiently large, they can be at any two nodes of the correct colors.

          In the fourth query: the set0 has a node with value0 (city4) and set1 has nodes with value0 (cities2,5,6). Then the difference can be 0.

          But the sample output is 10.

        I see the issue: the problem does not require them to be able to go to any node arbitrarily. It requires that they move for the same number of days. But the number of days X is chosen by them. They can choose any nonnegative integer X. Therefore, they can choose an X that is large enough to allow both to reach any node of the correct color.

        However, the sample output is 10, not 0.

        Let me read the problem statement again: 
          "After $X$ days, they should be in the cities such that the difference of the economic value between those two cities are minimum."

        And the sample input: 
          After updating: 
            city1: 10, city2:0, city3:20, city4:0, city5:0, city6:0.

        The starting cities: 
          businessman1: city1 (value10)
          businessman2: city2 (value0)

        How can they achieve a difference of 10? 
          If they choose X=0, then they don't move. Then the first is at city1 (10) and the second at city2 (0) -> difference=10.
          If they choose X=1, then they move to adjacent cities. 
              From city1: can go to 2,5,6.
              From city2: can go to 1,3.
              Then we can have:
                 businessman1 at city2 (0) and businessman2 at city1 (10) -> difference=10.
                 or businessman1 at city5 (0) and businessman2 at city3 (20) -> difference=20.
                 etc.
          If they choose X=2, then they can be at:
              businessman1: from 1->2->1, 1->2->3, 1->5->1, 1->5->3, 1->6->1, 1->6->5.
              businessman2: from 2->1->2, 2->1->5, 2->1->6, 2->3->2, 2->3->4, 2->3->5.
              Then we can have:
                 (1,2): (10,0) -> 10
                 (1,1): not allowed? They cannot be at the same city at the same day? But after two days, they can be at the same city? The problem does not restrict them to distinct cities. But they cannot stay in the same city for two consecutive days? But they can be at the same city at day2 if they didn't meet at an intermediate city? 
                    However, the problem says: "They cannot stay in the same city for two consecutive days", meaning they must move. It doesn't restrict them from being at the same city at the final day.

                 But can they both be at city1 at day2? 
                    businessman1: 1->2->1: allowed? 
                    businessman2: 2->1->2: but then at day2, he is at city2, not city1.
                 How to get to city1 for businessman2? 
                    businessman2: 2->1->5: then at day2, he is at city5.
                 Or 2->1->6: then at day2, he is at city6.

                 So they cannot be at the same city at day2? 
                 They can be at different cities: 
                   businessman1 at city1 (10) and businessman2 at city5 (0) -> difference=10.
                   businessman1 at city2 (0) and businessman2 at city1 (10) -> difference=10.

          In fact, the difference 0 is not achieved? Why? Because to achieve difference 0, we need one of them to be at city4 (value0) and the other at city2 (value0) or city5 (value0) or city6 (value0). 
          But city4 is in set0, and the first businessman (starting at city1, set0) can only be at set0 after even moves and set1 after odd moves. 
          Similarly, the second businessman (starting at city2, set1) can only be at set1 after even moves and set0 after odd moves.

          Therefore, to have the first businessman at city4 (set0), we need even moves.
          To have the second businessman at city2 (set1), we need even moves? because (1+even) mod2 = 1 -> set1.
          But then the first is at set0 and the second at set1, and the values are 0 and 0 -> difference0.

          How many moves to get the first to city4? 
            The shortest path: city1->2->3->4: length=3 (odd) -> so after 3 moves, the first businessman is at a set1 city? 
                city1 (0) -> city2 (1) -> city3 (0) -> city4 (1) -> no, city4 is set0? 
            The coloring: 
                city1:0
                city2:1
                city3:0
                city4:1? -> but we said city4 is set0? 

          Let me recolor the graph:
            city1:0
            neighbors: 2,5,6 -> color1
            city2:1 -> neighbors: 1 (0), 3 -> then city3:0
            city3:0 -> neighbors: 2 (1), 4,5 -> then city4:1, city5:1 (already by 1) -> conflict? 
                city5: already colored 1 (from city1) -> valid.
            city4:1
            city5:1
            city6:1

          Therefore, the colors are:
            city1:0
            city2:1
            city3:0
            city4:1
            city5:1
            city6:1

          Then set0: {1,3} -> values: city1:10, city3:20.
          set1: {2,4,5,6} -> values:0,0,0,0.

          So city4 is set1, not set0.

          Therefore, the node with value0 in set0 is only city3? But city3 has value20 now.

          What about city4: value0, but it is set1.

          Then set0 has no node with value0? 
            set0: city1:10, city3:20.
          set1: city2:0, city4:0, city5:0, city6:0.

          Then the minimum difference is min(|10-0|, |20-0|) = 10.

          How can they achieve 10?
            With X=0: they are at city1 (10) and city2 (0) -> difference=10.
            With X=1: 
                businessman1: from city1 to city2 (0), city5 (0), or city6 (0) -> value0.
                businessman2: from city2 to city1 (10) or city3 (20) -> if to city1: then difference=|0-10|=10? But the first is at city2 (0) and the second at city1 (10): difference=10.
                         or the first is at city5 (0) and the second at city3 (20): difference=20.
            So the minimum difference achievable is 10.

          Therefore, the answer for the fourth query is 10.

        What was the flaw in our gap_set? 
          Our gap_set should be:
            sorted_set: 
                set0: (10,1), (20,3)
                set1: (0,2), (0,4), (0,5), (0,6)
            Then the sorted_set: 
                (0,2), (0,4), (0,5), (0,6), (10,1), (20,3)

          Consecutive pairs:
            (0,2) and (0,4): same set (set1) -> skip.
            (0,4) and (0,5): same set -> skip.
            (0,5) and (0,6): same set -> skip.
            (0,6) and (10,1): different set -> gap=10.
            (10,1) and (20,3): same set -> skip.

          Then gap_set = {10}. The smallest gap is 10.

        So we missed the gap between (0,2) and (10,1)? They are not consecutive? But the consecutive pair (0,2) and (0,4) are in the same set, so we skip. Then the next different set gap is between (0,6) and (10,1).

        How about the gap between the last set1 node and the first set0 node? 
          The last set1 node: (0,6) and the first set0 node: (10,1) -> gap=10.

        Is there a gap of 10 between set0 and set1? 
          The set0 has 10 and 20, set1 has 0. The gaps: 10-0=10, 20-0=20 -> minimum is 10.

        Therefore, our gap_set is correct.

        The mistake in the initial example was the coloring: we had assumed city4 was set0, but in a bipartite coloring of the given graph, city4 is set1.

        How to color the graph: 
          We did a BFS from city1:
            city1:0
            city2:1, city5:1, city6:1
            Then from city2: city3:0
            Then from city3: city4:1, and city5: already 1 (no change).

          Therefore, city4 is 1.

        So the solution is as described.

        Let me run the seventh query: 
          "1 1 6": 
            starting at city1 (set0) and city6 (set1) -> same as different colors? 
            Then answer = smallest gap in gap_set = 10? 

          But the sample output is 1.

        Why 1? 
          After the updates: 
            Query5: update city4 to 11.
          Then the values:
            city1:10, city2:0, city3:20, city4:11, city5:0, city6:0.

          set0: {10,20}   // city1, city3
          set1: {0,11,0,0} // city2, city4, city5, city6

          The sorted_set: 
            set1: (0,2), (0,5), (0,6), (11,4)
            set0: (10,1), (20,3)

          The sorted array:
            (0,2), (0,5), (0,6), (10,1), (11,4), (20,3)

          Consecutive pairs of different sets:
            (0,6) and (10,1): gap=10 -> add.
            (10,1) and (11,4): gap=1 -> add.   [because (10,1) is set0, (11,4) is set1]
            (11,4) and (20,3): gap=9 -> add.

          Then the gap_set = {1,9,10} -> smallest gap=1.

          Therefore, the answer is 1.

        So the code is fixed.

        Summary:
          Step1: Check if the graph is bipartite. If not, answer 0 for every type1 query.
          Step2: If bipartite, color the graph.
          Step3: Build a sorted_set (set of pairs (value, node_id)) and a gap_set (multiset of gaps for consecutive pairs in the sorted_set that have different colors).

          For update:
            Let u = B_i, new_val = C_i.
            Let old_val = current_value[u].
            Remove (old_val, u) from sorted_set, and update the gap_set by:
                Let it = iterator to (old_val, u) in sorted_set.
                Let L = the previous element (if exists), R = the next element (if exists).
                If L exists and color[u] != color[L.second], then remove the gap between L and it from gap_set.
                If R exists and color[u] != color[R.second], then remove the gap between it and R from gap_set.
                If L and R exist and color[L.second] != color[R.second], then add the gap between L and R to gap_set.

            Then insert (new_val, u) into sorted_set, and update:
                Let it_new = iterator to (new_val, u).
                L_new = previous element (if exists), R_new = next element (if exists).
                If L_new and R_new exist and color[L_new.second] != color[R_new.second], then remove the gap between L_new and R_new from gap_set? 
                    Why? Because they were consecutive before the insertion, and now they are separated by the new node.

            Then:
                If L_new exists and color[L_new.second] != color[u], then add the gap between L_new and it_new to gap_set.
                If R_new exists and color[u] != color[R_new.second], then add the gap between it_new and R_new to gap_set.

          For type1 query (A_i=1):
            Let u = B_i, v = C_i.
            If the graph is not bipartite: output 0.
            Else if the graph is bipartite:
                if color[u] == color[v]: output 0.
                else: 
                   if gap_set is empty: output 0?  // but we assume non-empty? 
                   else: output *gap_set.begin()

          But note: it is possible that the gap_set is empty? We argued that in a connected bipartite graph with at least two nodes and both colors present, there should be at least one consecutive pair of different colors? But what if the sorted_set has only one element? That cannot happen because we have at least two nodes? Therefore, we can assume the gap_set is non-empty? Actually, during the update, we might temporarily break the only gap? But then we add new gaps? So at the end of the update, the gap_set should be non-empty.

          However, to be safe, we output 0 if the gap_set is empty.

        Let me test with the sample after the updates for the seventh query: 
            After the update for city4 to 11, we have the sorted_set: 
                (0,2), (0,5), (0,6), (10,1), (11,4), (20,3)

          Consecutive gaps of different colors:
            (0,6) and (10,1): gap=10 -> stored.
            (10,1) and (11,4): gap=1 -> stored.
            (11,4) and (20,3): gap=9 -> stored.

          Then for the query "1 1 6": 
            u=1 (color0), v=6 (color1) -> different -> output 1.

        This matches.

        One more: the sixth query: "1 1 3"
            starting at city1 (0) and city3 (0) -> same color -> output 0.

        Therefore, the sample output: 
            Query1: 0
            Query4: 10
            Query6: 0
            Query7: 1

        Which matches.

        Code note: 
          We must be careful when iterating the set: use std::set and its iterators.

          We maintain:
            vector<ll> current_value; // current_value[i] for node i.
            set<pair<ll, int>> sorted_set;
            multiset<ll> gap_set;   // note: multiset can have duplicates.

          When removing a gap, we must remove one occurrence: we can use gap_set.erase(gap_set.find(gap_value)), but note: if there are multiple gaps of the same value, we only remove one? But we are removing one gap. So we should remove one occurrence.

          Similarly, when adding, we add one gap.

        Implementation of the update:

          // Removal:
          auto it_old = sorted_set.find({old_val, u});
          if (it_old == sorted_set.end()) { /* This should not happen */ }

          auto prev_it = it_old;
          if (prev_it != sorted_set.begin()) {
              prev_it = prev(it_old);
          } else {
              prev_it = sorted_set.end();
          }
          auto next_it = next(it_old);
          if (next_it == sorted_set.end()) {
              next_it = sorted_set.end();
          }

          Actually, we can do:
            auto it_old = sorted_set.find({old_val, u});
            vector<tuple<int, int, ll>> gaps_to_remove; // not necessary, we can do:

          Alternatively, we can:

            if (it_old != sorted_set.begin()) {
                auto left_it = prev(it_old);
                // gap between left_it and it_old
                if (color[left_it->second] != color[u]) {
                    ll gap_val = it_old->first - left_it->first;
                    gap_set.erase(gap_set.find(gap_val)); // find one occurrence
                }
                // Also, check the gap between left_it and the next of it_old (if exists) after removal? Not here.
            }
            if (next(it_old) != sorted_set.end()) {
                auto right_it = next(it_old);
                if (color[u] != color[right_it->second]) {
                    ll gap_val = right_it->first - it_old->first;
                    gap_set.erase(gap_set.find(gap_val));
                }
            }
            // Now, if both left and right exist, then after removal, left and right become consecutive? And we add the gap between them if they are different colors.
            if (it_old != sorted_set.begin() && next(it_old) != sorted_set.end()) {
                auto left_it = prev(it_old);
                auto right_it = next(it_old);
                if (color[left_it->second] != color[right_it->second]) {
                    ll gap_val = right_it->first - left_it->first;
                    gap_set.insert(gap_val);
                }
            }
            sorted_set.erase(it_old);

          Then for insertion:

            auto it_new = sorted_set.insert({new_val, u}).first;
            // Check left and right of it_new
            auto left_new = (it_new != sorted_set.begin()) ? prev(it_new) : sorted_set.end();
            auto right_new = next(it_new);
            if (right_new == sorted_set.end()) right_new = sorted_set.end();

            // First, if left_new and right_new are both valid, then they were consecutive? And we need to remove the gap between them?
            if (left_new != sorted_set.end() && right_new != sorted_set.end()) {
                if (color[left_new->second] != color[right_new->second]) {
                    ll gap_val = right_new->first - left_new->first;
                    auto it_gap = gap_set.find(gap_val);
                    if (it_gap != gap_set.end()) {
                        gap_set.erase(it_gap);
                    }
                }
            }

            // Then add gaps for it_new and left_new, and it_new and right_new.
            if (left_new != sorted_set.end()) {
                if (color[left_new->second] != color[u]) {
                    ll gap_val = it_new->first - left_new->first;
                    gap_set.insert(gap_val);
                }
            }
            if (right_new != sorted_set.end()) {
                if (color[u] != color[right_new->second]) {
                    ll gap_val = right_new->first - it_new->first;
                    gap_set.insert(gap_val);
                }
            }

          However, note: in the insertion, we break the consecutive pair (left_new, right_new) only if both exist? And then we remove the gap between them? But we might not have that gap stored? Because we only store gaps for different colors. So we should only remove if it exists? But our gap_set is a multiset, and we try to find and remove. But if the gap between left_new and right_new was not stored (because they were same color), then we don't remove anything.

          Alternatively, we can avoid the condition and do:

            if (left_new != sorted_set.end() && right_new != sorted_set.end()) {
                // Check if we had a gap between left_new and right_new? Only if they are different colors.
                if (color[left_new->second] != color[right_new->second]) {
                    // We remove the gap that was stored between left_new and right_new.
                    ll gap_val = right_new->first - left_new->first;
                    auto it_gap = gap_set.find(gap_val);
                    if (it_gap != gap_set.end()) {
                        gap_set.erase(it_gap);
                    }
                }
            }

          But note: we might have stored that gap? Only if they are consecutive and we had inserted it? And we did insert it when they became consecutive? Yes, we did. So it should be there.

        Let me test the sample update for city1 initially: 
            Initially: 
               sorted_set: (0,1) -> but then we update to 10? 
            Removal: 
               it_old = (0,1)
               left_new: if exists? Initially, the set has multiple zeros: 
                  We have: (0,2), (0,3), ... 
               We remove (0,1): 
                 If there are other zeros, then the left might be (0,2) and the right might be (0,3) for example? But we need to find the actual left and right.

          How to debug? We'll trust the set ordering.

        Given the complexity, we'll code accordingly.

        One more note: the gap_set might have duplicate gaps? For example, if we have two consecutive pairs with the same gap value? Then we store two. When we remove one, we remove one occurrence.

        Also, the multiset's find will find the first occurrence? But we don't care which occurrence we remove? We remove one.

        Therefore, the code below implements the above.

        Important: We assume that the graph is connected.

        Let's code accordingly.

        Note: We must update current_value[u] after the update.

        We also must store the color of each node.

        The graph is connected, so we only run BFS once.

        We assume 1-indexed.

        Time complexity: O((N+Q) * log(N))

        We hope it runs within 2 seconds for N, Q up to 100,000.

        Let's code accordingly.

        Note: We must be cautious with iterators: 
          - When we remove an element, the iterators to the next and prev might be invalid? Actually, we are using the set and we get the prev and next before removal.

        We do not store iterators, we use the set and then get the prev and next.

        The code for removal:

          auto it = sorted_set.find(make_pair(old_val, u));
          if (it == sorted_set.end()) {
             // This should not happen, skip.
             continue;
          }

          auto prev_it = it, next_it = it;
          if (it != sorted_set.begin()) {
             prev_it = prev(it);
          } else {
             prev_it = sorted_set.end();
          }
          if (next(it) != sorted_set.end()) {
             next_it = next(it);
          } else {
             next_it = sorted_set.end();
          }

          But note: we can use:

          vector<tuple<ll, int, int>> to_remove; // not necessary.

          Actually, we can:

          // We'll store the values for the gaps to remove and to add.

          // Removal phase:
          if (prev_it != sorted_set.end()) {
              // gap between *prev_it and *it
              if (color[prev_it->second] != color[u]) {
                  ll gap_val = it->first - prev_it->first;
                  auto it_gap = gap_set.find(gap_val);
                  if (it_gap != gap_set.end()) {
                      gap_set.erase(it_gap);
                  }
              }
          }
          if (next_it != sorted_set.end()) {
              if (color[u] != color[next_it->second]) {
                  ll gap_val = next_it->first - it->first;
                  auto it_gap = gap_set.find(gap_val);
                  if (it_gap != gap_set.end()) {
                      gap_set.erase(it_gap);
                  }
              }
          }
          if (prev_it != sorted_set.end() && next_it != sorted_set.end()) {
              if (color[prev_it->second] != color[next_it->second]) {
                  ll gap_val = next_it->first - prev_it->first;
                  gap_set.insert(gap_val);   // because after removal, they become consecutive? So we add the gap if different colors.
              }
          }

          Then remove it.

          Then insert the new value:

          pair<ll, int> new_pair = {new_val, u};
          auto it_new = sorted_set.insert(new_pair).first;
          // Get neighbors
          auto prev_new = it_new, next_new = it_new;
          if (it_new != sorted_set.begin()) {
              prev_new = prev(it_new);
          } else {
              prev_new = sorted_set.end();
          }
          if (next(it_new) != sorted_set.end()) {
              next_new = next(it_new);
          } else {
              next_new = sorted_set.end();
          }

          // First, if there is a consecutive pair (prev_new, next_new) that was existing, then we break it? So remove the gap between them?
          if (prev_new != sorted_set.end() && next_new != sorted_set.end()) {
              if (color[prev_new->second] != color[next_new->second]) {
                  ll gap_val = next_new->first - prev_new->first;
                  auto it_gap = gap_set.find(gap_val);
                  if (it_gap != gap_set.end()) {
                      gap_set.erase(it_gap);
                  }
              }
          }

          if (prev_new != sorted_set.end()) {
              if (color[prev_new->second] != color[u]) {
                  ll gap_val = new_val - prev_new->first;
                  gap_set.insert(gap_val);
              }
          }
          if (next_new != sorted_set.end()) {
              if (color[u] != color[next_new->second]) {
                  ll gap_val = next_new->first - new_val;
                  gap_set.insert(gap_val);
              }
          }

        However, note: in the insertion, we break the consecutive pair (prev_new, next_new) by inserting in between. But we only stored the gap between them if they were consecutive? Yes, and we are about to form two gaps: (prev_new, new) and (new, next_new). So we break the gap between (prev_new, next_new) and then form two gaps.

        But the above code for insertion: we first remove the gap between prev_new and next_new (if it exists) and then add the gaps for (prev_new, new) and (new, next_new) if they are different colors.

        This matches.

        But note: what if the new node is inserted at the beginning or the end? Then we don't break any consecutive pair? Then we skip the removal of a gap between prev_new and next_new? Because one of them is end.

        Therefore, we are safe.

        Finally, update current_value[u] = new_val.

        Let me test with a small example: two nodes, update one.

        Initially: 
          node1: value0, color0.
          node2: value0, color1.

          sorted_set: [(0,1), (0,2)] -> assume node_id:1 and 2, and we break tie by node_id? 
          Then consecutive pair: (0,1) and (0,2): gap=0, and colors different -> stored.

        Update node1 to 10:
          Remove (0,1):
             prev: none, next: (0,2)
             remove gap between (0,1) and (0,2): gap=0 -> remove one occurrence of 0 from gap_set.
             Then add nothing for the consecutive pair (because prev and next: only next exists, so skip the adding of gap between prev and next).
          Then insert (10,1):
             Inserted at the end: 
                sorted_set: (0,2), (10,1)
             Then:
                prev_new: (0,2) -> exists.
                next_new: none.
             Then we add the gap between (0,2) and (10,1): gap=10, and colors: node2: color1, node1: color0 -> different -> add 10.

          Then gap_set = {10}

          Query between node1 and node2: different colors -> output 10.

        This is correct.

        Now, update node1 back to 0:
          Remove (10,1): 
              prev: (0,2) -> exists -> remove gap between (0,2) and (10,1): gap=10 -> remove.
              next: none.
              Then add nothing for the consecutive pair? 
          Insert (0,1): 
              The sorted_set: (0,1), (0,2) -> but we break tie by node_id? So (0,1) comes before (0,2) because 1<2.
              Then:
                 prev: none, next: (0,2)
                 So we add gap between (0,1) and (0,2): gap=0 -> stored.

          Then gap_set = {0}

          Query: output 0.

        This is correct.

        We'll code accordingly.

        Edge: we assume the graph has at least 2 nodes? But the problem says M>=1 and the graph is connected -> so at least 2 nodes.

        We assume the bipartite check: if the graph is not bipartite, then we answer 0 for type1 queries.

        We store the color array from the BFS.

        Note: the graph might be disconnected? But the problem says: "from any city, it is possible to reach any other cities" -> connected.

        So we are good.

        Let me run the provided sample.

        We'll do the sample step by step.

        The graph: 6 nodes, 6 edges.

        BFS coloring (starting at node1=0):
          node1:0
          neighbors: 2,5,6 -> color1
          node2:1 -> neighbors:1 (0) -> skip, and 3 -> color0
          node3:0 -> neighbors:2 (1), 4,5 -> 
                 node4: color1 (from node3:0)
                 node5: already 1 -> skip
          node4:1 -> done.
          node5:1 -> done.
          node6:1 -> done.

          So colors: 
            node1:0
            node2:1
            node3:0
            node4:1
            node5:1
            node6:1

        Initial values: all 0.

        sorted_set: 
          (0,1), (0,2), (0,3), (0,4), (0,5), (0,6)  -> but we sort by value, then by node_id? 
          So: (0,1), (0,2), (0,3), (0,4), (0,5), (0,6)

        Consecutive gaps of different colors? 
          (0,1) and (0,2): color0 and color1 -> gap0 -> store.
          (0,2) and (0,3): color1 and color0 -> gap0 -> store.
          (0,3) and (0,4): color0 and color1 -> gap0 -> store.
          (0,4) and (0,5): color1 and color1 -> skip.
          (0,5) and (0,6): color1 and color1 -> skip.

        gap_set = {0,0,0}

        Query1: (1,1,2) -> same as (1,2): color0 and color1 -> different -> output the smallest gap=0.

        Then update: 
          Query2: (0,1,10): update node1 to 10.

          Remove (0,1) from sorted_set:
             prev: none
             next: (0,2) -> exists -> remove gap between (0,1) and (0,2): gap0 -> remove one 0.
             Then add nothing for the consecutive pair (because no prev and next exists?).
          Then insert (10,1): 
             The sorted_set: (0,2), (0,3), (0,4), (0,5), (0,6), (10,1)
             For (10,1): 
                 prev: (0,6) -> exists -> gap = 10-0 = 10 -> and color: node6:1, node1:0 -> different -> add 10.

          Then gap_set = {0,0,10}   (because we removed one 0, but we still had two 0's from the other consecutive pairs).

          Query3: update node3 to 20: 
             Remove (0,3): 
                 prev: (0,2) -> exists -> gap between (0,2) and (0,3):0 -> and colors: node2:1, node3:0 -> different -> remove one 0.
                 next: (0,4) -> exists -> gap between (0,3) and (0,4):0 -> and colors: node3:0, node4:1 -> different -> remove one 0.
                 Then add the gap between (0,2) and (0,4): gap0? and colors: node2:1, node4:1 -> same? skip.
             Then gap_set becomes {10} (because we remove two 0's and then the last 0 was from (0,3) and (0,4) but we removed it, so the only gap left is 10? But we also had the gap from (0,2) to (0,3) and (0,3) to (0,4) and then we removed them, and we didn't add any gap for (0,2) and (0,4) because same color? 
                 Then the gap_set now has only the gap 10 from (0,6) to (10,1).

             Then we insert (20,3): 
                 The sorted_set: (0,2), (0,4), (0,5), (0,6), (10,1), (20,3)
                 For (20,3): 
                    prev: (10,1) -> exists -> gap=20-10=10 -> and colors: node1:0, node3:0 -> same -> skip.
                    next: none.
                 Then we break the consecutive pair between (10,1) and nothing? none.
                 And we add the gap between (0,6) and (10,1): already there? Actually, we didn't remove it? 
                 But we did not break any consecutive pair? The insertion is at the end, so we break nothing? 
                 Therefore, gap_set remains {10}.

          Query4: (1,1,2): output 10.

        Then update: Query5: update node4 to 11.
          Remove (0,4): 
             node4: color1 -> 
             prev: (0,2) -> exists? 
                 sorted_set: (0,2), (0,5), (0,6), (10,1), (20,3) -> but we are removing (0,4) which is not there? 

          What went wrong? 
            We updated node4 to 11, so we remove the old value of node4: which is 0? 
            The old value of node4 is 0.

          In the sorted_set, we have (0,4) at the beginning? 

          The sorted_set before update5:
            (0,2), (0,5), (0,6), (10,1), (20,3)   -> but we are missing (0,4)? 

          Actually, we updated node3 to 20, and we removed (0,3) and inserted (20,3). But we did not update node4? 

          Then the current_value for node4 is still 0.

          So the sorted_set: 
            (0,2), (0,4), (0,5), (0,6), (10,1), (20,3)

          Then we update node4 to 11: 
            Remove (0,4): 
               prev: (0,2) -> exists -> gap:0? and colors: node2:1, node4:1 -> same? -> skip removal? 
               next: (0,5) -> exists -> gap:0? and colors: node4:1, node5:1 -> same -> skip.
               Then add the gap between (0,2) and (0,5): 
                   gap=0, and colors: node2:1, node5:1 -> same -> skip.
            Then remove (0,4).

            Then insert (11,4): 
               The sorted_set: (0,2), (0,5), (0,6), (10,1), (11,4), (20,3)
               For (11,4): 
                   prev: (10,1) -> exists -> gap=11-10=1 -> and colors: node1:0, node4:1 -> different -> add 1.
                   next: (20,3) -> exists -> gap=20-11=9 -> and colors: node4:1, node3:0 -> different -> add 9.
                   Also, we break the consecutive pair between (10,1) and (20,3)? 
                         Before insertion, the consecutive pair: (10,1) and (20,3): gap=10, and colors:0 and 0? same -> we didn't have it in gap_set? So we skip the removal.

            Then gap_set becomes: {10, 1, 9}   // but the 10 was from (0,6) to (10,1) -> we didn't remove that.

          Then Query6: (1,1,3): 
             u=1 (0), v=3 (0) -> same color -> output 0.

          Query7: (1,1,6): 
             u=1 (0), v=6 (1) -> different -> output min(gap_set)=1.

          This matches.

        Therefore, we'll code accordingly.

        One last note: the multiset for gaps: we use multiset<ll> and we do:

          gap_set.begin() is the smallest element.

        We'll do:

          if (gap_set.empty()) {
              answer = 0;   // though it should not happen, but safe.
          } else {
              answer = *gap_set.begin();
          }

        We output the answer for each type1 query.

        Let's code accordingly.

        Note: The graph might be large, so we use efficient data structures.

        We'll run BFS only once.

        We assume the graph is connected.

        Code structure:

          Read N, M
          Read S[1..N]
          Build graph (0-indexed or 1-indexed? we use 1-indexed)

          // BFS for coloring
          vector<int> color(N+1, -1);
          vector<vector<int>> graph(N+1);
          // Build graph: M edges

          Then do BFS from node1.

          Then check if the graph is bipartite.

          Then if not bipartite: handle Q queries.

          Else: 
              Build sorted_set: 
                 for (int i=1; i<=N; i++) {
                     sorted_set.insert({S[i], i});
                     current_value[i] = S[i];
                 }
              Build gap_set: 
                 auto it = sorted_set.begin();
                 auto next_it = it; 
                 if (it != sorted_set.end()) next_it = next(it);
                 while (next_it != sorted_set.end()) {
                     if (color[it->second] != color[next_it->second]) {
                         gap_set.insert(next_it->first - it->first);
                     }
                     it++;
                     next_it++;
                 }

          Then process Q queries.

        We'll do as described.

        Let me test with the sample.

        We'll run the sample and hope it passes.

        But note: the consecutive pairs: we only traverse adjacent pairs? Yes.

        We'll run the sample.

        Note: the initial gap_set for the sample: 
          We have: (0,1), (0,2), (0,3), (0,4), (0,5), (0,6)
          Adjacent pairs:
            (0,1) and (0,2): gap0 -> add.
            (0,2) and (0,3): gap0 -> add.
            (0,3) and (0,4): gap0 -> add.
            (0,4) and (0,5): skip (same color) -> node4:1, node5:1 -> same.
            (0,5) and (0,6): skip.

          Then gap_set = {0,0,0}

        Then the first query: 1 1 2 -> output 0.

        Then update node1 to 10: 
          Remove (0,1): 
             prev: none -> skip
             next: (0,2) -> gap0 -> remove one 0.
          Then add nothing for the consecutive pair (none and next? skip).
          Then insert (10,1): 
             The set: (0,2), (0,3), (0,4), (0,5), (0,6), (10,1)
             Then we break the consecutive pair between (0,6) and (10,1)? Actually, (0,6) and (10,1) are consecutive? 
                 But we had stored the gap between (0,5) and (0,6)? We didn't store it because same color? 
                 And we didn't store the gap between (0,6) and (10,1) yet? 
             So we break nothing? Actually, the insertion at the end doesn't break any consecutive pair? 
             Then we add the gap between (0,6) and (10,1): gap=10 -> add.

          Then gap_set = {0,0,10}   // because we removed one 0, but we had three 0's: now we have two 0's and one 10.

        Then update node3 to 20: 
          Remove (0,3): 
             prev: (0,2) -> gap0 -> remove one 0.
             next: (0,4) -> gap0 -> remove one 0.
             Then add gap between (0,2) and (0,4): gap0? and colors: node2:1, node4:1 -> same -> skip.
          Then insert (20,3): 
             The set: (0,2), (0,4), (0,5), (0,6), (10,1), (20,3)
             We break the consecutive pair between (10,1) and (20,3)? They are consecutive? 
                 But we didn't have a gap between them? because they were not consecutive? Actually, before insertion, the consecutive pairs were:
                    (0,2) and (0,4): same -> skip.
                    (0,4) and (0,5): same -> skip.
                    (0,5) and (0,6): same -> skip.
                    (0,6) and (10,1): different -> stored (10) -> we did not break this by inserting (20,3) at the end? 
                 Actually, we insert (20,3) at the end, so we break the consecutive pair (0,6) and (10,1)? No, because (10,1) is before (20,3). 
                 The new consecutive pairs: 
                    (0,6) and (10,1): gap=10 -> still there? 
                    (10,1) and (20,3): gap=10 -> and colors: node1:0, node3:0 -> same -> skip.
                 Then we add the gap between (10,1) and (20,3)? skip.

             Then we break nothing? 
             Then we add the gap between (10,1) and (20,3): skip.

          Then gap_set = {10}   // because we removed two 0's and the last 0 was the one between (0,6) and (10,1)? But we didn't remove that? We only removed the gaps that involved (0,3). The gap between (0,6) and (10,1) was not touched? 

          So the gap_set remains with 10? Then the fourth query: 10.

          Then update node4 to 11: 
             Remove (0,4): 
                 prev: (0,2) -> gap0? and colors: node2:1, node4:1 -> same -> skip.
                 next: (0,5) -> gap0? and colors: node4:1, node5:1 -> same -> skip.
                 Then add the gap between (0,2) and (0,5): same -> skip.
             Then insert (11,4): 
                 The set: (0,2), (0,5), (0,6), (10,1), (11,4), (20,3)
                 We break the consecutive pair (10,1) and (20,3)? 
                    But we didn't have it stored (same color) -> skip removal.
                 Then we add:
                    between (10,1) and (11,4): gap=1 -> different -> add.
                    between (11,4) and (20,3): gap=9 -> different -> add.

             Then gap_set = {10, 1, 9}

          Then Query6: 0 (same color) -> output0.
          Query7: output1.

        Therefore, it matches.

        We'll write the code accordingly.

        Note: The removal of an element might invalidate iterators? But we are storing the value and node_id. We are using set of pairs.

        We are careful: we get the next and prev before removal.

        We'll code accordingly.

        Let me code.

        IMPORTANT: The gap_set is a multiset. When we remove a gap, we remove one occurrence (by finding it). But if there are multiple gaps of the same value, we remove one occurrence. But we store each gap once per consecutive pair? So each gap is stored exactly once? Yes, because each consecutive pair is stored once.

        Therefore, we can do:

          gap_set.erase(gap_set.find(gap_value));

        But note: if the gap_value is not in the set, then we get an error? So we must check? But we only remove if we had stored it? 

        Alternatively, we can store the gaps in a multiset and use:

          auto it_gap = gap_set.find(gap_value);
          if (it_gap != gap_set.end()) {
              gap_set.erase(it_gap);
          }

        This is safe.

        We'll do that.

        Code.