We are given a connected undirected graph with N nodes and M edges. Each city has an economic value S_i. There are two types of queries: updating the economic value of a city, and querying for the minimum absolute difference of economic values that can be achieved by two businessmen starting at two given cities after moving for X days (with X chosen arbitrarily).

Key observations:

1. The movement: In one day, each businessman moves to an adjacent city. They can choose any adjacent city arbitrarily (like independent walks). Note that they can revisit cities and the graph is connected.

2. The goal is to choose a nonnegative integer X (which can be zero) and two walks of length X (one starting from B_i and the other from C_i) such that the absolute difference between the economic values of the two ending cities is minimized.

3. Note that the two walks are independent and each step is arbitrary (so they can choose their paths arbitrarily as long as each step goes to an adjacent city). Therefore, the set of cities reachable by a businessman starting at a city u in exactly X days is the set of all cities at an even distance (if X is even) or odd distance (if X is odd) from u? Actually, not exactly: because the graph is connected and we can have cycles, the set of cities that can be reached from u in exactly X days is the set of cities v for which the distance from u to v has the same parity as X and is at most X. However, note that we are allowed to choose arbitrarily large X? But we are minimizing the absolute difference.

4. However, note that we are allowed to choose X arbitrarily (nonnegative integer). Therefore, for a starting city u, the set of cities that can be reached by a businessman starting at u for some X is:

   - All the cities that are at an even distance from u? Actually, we can also go to an odd distance by choosing an odd X. But note: we can also wait by going back and forth? Actually, the entire graph is connected and we can use the following:

   Lemma: For a connected undirected graph, the set of cities reachable from u in exactly k steps is:
     - If the graph is bipartite: then we can only reach cities in the same bipartite set as u for even k, and the opposite set for odd k.
     - But if the graph is non-bipartite (i.e., contains an odd cycle), then we can reach any city at a distance of at least the distance from u to that city and having the same parity as k, and also we can reach any city beyond a certain k (because we can use the odd cycle to adjust parity).

   Actually, a more complete statement:

     Let d(u, v) be the shortest path distance from u to v.

     In a bipartite graph, we can reach v from u in k steps if and only if k >= d(u,v) and k ≡ d(u,v) (mod 2).

     In a non-bipartite graph, we can reach v from u in k steps if and only if k >= d(u,v) and k ≡ d(u,v) (mod 2) OR if k >= d(u,v)+1? Actually, no: once we have an odd cycle, we can change parity arbitrarily beyond a certain point. Specifically, for any sufficiently large k (>= the girth?), we can actually reach any city? Actually, the following is known:

        In a connected non-bipartite graph, for any two vertices u and v, and for any integer k such that k >= d(u,v) and k ≡ d(u,v) mod 2? Actually, that condition is necessary but not sufficient: we also need to be able to change the parity arbitrarily. Actually, we can use the odd cycle to add an even number of extra steps? So we can achieve any k >= d(u,v) that has the same parity as d(u,v). But also, if we have an odd cycle, we can get stuck? No, because we can traverse the cycle to add 2 steps (by going around the cycle which has an odd length: going around once adds an odd number, then to get the same parity we can go around twice? Actually, going around an odd cycle twice adds an even number? So that doesn't change parity. However, if we have an odd cycle, then we can adjust by 1? Actually, we can achieve both parities beyond a certain distance.

     Actually, the following is standard: In a non-bipartite connected graph, for any two vertices u and v, there exists an integer L such that for every k >= L, there is a walk from u to v of length k. However, we don't need the exact walk, but we note that the businessman is free to choose any walk of length X.

5. Therefore, the set of cities that the businessman starting at u can reach in X days (for some X) is:

     - If the graph is bipartite: then the businessman starting at u can only reach cities in the same connected component (which is the entire graph) and the set of cities is partitioned by the bipartite coloring: one set for even distances and one for odd. But note: we can choose X arbitrarily. So for a fixed u, the businessman can reach any city in the same bipartite set as u (by choosing an even X that is at least the distance) and any city in the opposite set (by choosing an odd X that is at least the distance). However, wait: from u, in an even number of steps we can only reach the same color, and in an odd number we can only reach the opposite color. Therefore, the entire set of cities is partitioned: the businessman at u can reach every city? Yes, because for any city v, we can choose X = d(u,v) (if the graph is bipartite) and then we can reach v? But note: if the graph is bipartite, then we can only reach v in X days if X has the same parity as d(u,v). Therefore, we can reach every city: for a city v, we can choose X = d(u,v) (if we want to end at v) but we are not forced to end at a particular city. Actually, we are free to choose any walk of length X? So we might not go directly to v, but we might go to a farther city? However, we are allowed to go to any city that is at a distance with the same parity as X? And we can choose X arbitrarily? So for a fixed starting city u, the set of cities that can be reached by the businessman for some X is:

        - The entire set of cities? Because for any city v, we can choose X = d(u,v) (if the graph is bipartite) and then we can reach v? But actually, we are not required to go to v, we can go to any city that is in the same bipartite set as u (if we choose an even X) or the opposite set (if we choose an odd X). Since the graph is bipartite, every city is either in the same set or the opposite set. Therefore, the businessman can end at any city? Actually, yes: for a city v in the same bipartite set, choose X = d(u,v) (which is even) and then we can take a path of length d(u,v). For a city w in the opposite set, we can choose X = d(u,w) (which is odd) and take a path of length d(u,w). Therefore, the businessman starting at u can end at any city in the entire graph.

     - If the graph is non-bipartite: then we can also reach every city? Actually, yes: because we can get to any city v in d(u,v) steps, and then we can also use an odd cycle to extend the walk arbitrarily without changing the ending? Actually, we can change the ending? But note: we are allowed to choose any walk. So we can go from u to v in d(u,v) steps, and then if we want to stay at v? But we cannot stay: we must move each day. However, we can leave v and then come back? So if the graph has a cycle, we can extend the walk arbitrarily. Therefore, the businessman starting at u can end at any city? Actually, not exactly: after X steps, we can be at any city that has a walk of length X from u. But as we argued, in a non-bipartite graph, for any city v, and for any sufficiently large X (with the same parity as d(u,v)), we can reach v? Actually, we can also reach v with an X of the opposite parity? Because we have an odd cycle: we can take a detour that adds an odd number of steps. Therefore, we can reach any city for any sufficiently large X? But note: we are allowed to choose X arbitrarily. Therefore, for any city v, there exists an X such that we can reach v? Actually, yes: because we can take the shortest path to v (of length d) and then if we want to use a larger X, we can take a detour that adds 2 steps (by going back and forth on an edge) or, if we have an odd cycle, we can also adjust by 1. Therefore, in a non-bipartite graph, the businessman can reach any city? Actually, for any city v, there is a walk from u to v of length k for every k >= d(u,v) and k ≡ d(u,v) mod 2? But also, if we have an odd cycle, we can also get walks of the opposite parity? Actually, no: if we use the odd cycle, we can add an odd number. So if we take the shortest path and then an extra loop around an odd cycle (which adds an odd number), then the total parity is changed. Therefore, we can reach v in both parities? Actually, the necessary condition is that we can reach v in any parity? But what if the graph is non-bipartite? Then we can indeed reach any city v in both an even and an odd number of steps? Actually, we can: because we can take the shortest path and then an extra loop of an odd cycle (which adds an odd number) so that we can get both parities? However, we cannot get arbitrarily small? Actually, we can get any parity beyond a certain step count? Therefore, for any city v, we can reach it in any sufficiently large step count (of either parity). But note: we are free to choose X arbitrarily, so we can choose X to be the minimum k such that k >= d(u,v) and k has the parity we want? Actually, we don't care about the path as long as we can end at v. Therefore, we can end at any city? Yes.

   Therefore, regardless of whether the graph is bipartite or not, the businessman starting at u can end at any city in the graph? 

   But wait: in a bipartite graph, we cannot: we can only end at cities in the same bipartite set as u if we choose an even X, and the opposite set if we choose an odd X. But we are free to choose X arbitrarily. Therefore, we can choose to end at any city: for a city v in the same set, choose an even X (for example, X = d(u,v)); for a city w in the opposite set, choose an odd X (for example, X = d(u,w)). Therefore, in a bipartite graph we can also reach any city? 

   So the conclusion: for a connected graph (whether bipartite or not), the businessman starting at u can end at any city in the entire graph? 

   However, note: in a bipartite graph, if we choose an even X, we can only be at cities in the same bipartite set as u. Similarly, if we choose an odd X, we can only be at cities in the opposite set. Therefore, the businessman starting at u can end at any city, but the parity of X constrains the bipartite set. But since we can choose X arbitrarily, we can choose the parity arbitrarily? Therefore, we can cover the entire graph.

   But wait: what about the constraints of the problem? The problem says: "they cannot stay in the same city for two consecutive days" -> but that is automatically satisfied because they must move to an adjacent city. 

   Therefore, the key is: the two businessmen can independently choose to end at any city in the entire graph? 

   However, note: they must choose the same X. So both have to move for the same number of days. Therefore, the two walks are of the same length.

   Now, for the two businessmen starting at B_i and C_i, they choose the same X arbitrarily. Then each can independently choose to end at any city? But with the constraint that the length of the walk must be X. However, as we argued, for a fixed X, the first businessman can be at any city in the set of cities that are at a distance from B_i that has the same parity as X? Actually, no: the set of cities that can be reached in exactly X steps from B_i is the set of cities v for which there exists a walk of length X from B_i to v. And we know:

        In a connected graph (non-bipartite): for any city v, there exists an integer L (which may depend on v) such that for every k >= L, there is a walk of length k from B_i to v. And the parity condition: if the graph is non-bipartite, then beyond a certain point, we can reach v for both parities? Actually, we can reach v in any sufficiently large k (without parity restriction). 

        In a bipartite graph: we can only reach v if k ≡ d(B_i, v) mod 2, and k >= d(B_i, v).

   Therefore, if the graph is non-bipartite, then for a fixed X (as long as X is sufficiently large) both businessmen can be at any city? But note: they are constrained by the same X. So we have:

        Businessman1: can be at any city as long as X is sufficiently large (for that city) and without parity restrictions? Actually, no: we can reach any city with any sufficiently large X? Then for large enough X, both businessmen can be at any city? Then they can both be at the same city? Then the minimum absolute difference is 0? But that is not always the case (see sample).

   Alternatively, we must consider the entire set of cities that are reachable by the two businessmen for a common X. But note: we are free to choose X arbitrarily (even 0). Therefore, we can choose X=0: then the first businessman is at B_i and the second at C_i. Then the absolute difference is |S[B_i] - S[C_i]|. But we can also choose X=1: then the first businessman moves to any adjacent city, and the second to any adjacent city. Then we get a set of pairs (v, w) for v adjacent to B_i and w adjacent to C_i. And then we minimize |S[v] - S[w]|. And then for larger X, we can get more pairs.

   Therefore, the problem reduces to: 

        Find the minimum absolute difference |S[a] - S[b]| for any two cities a and b such that there exists a nonnegative integer X for which:

            a is reachable from B_i in exactly X steps, and 
            b is reachable from C_i in exactly X steps.

   But note: the same X must be used for both.

   Now, what is the condition for a city a to be reachable from B_i in exactly X steps? 

        Let d1 = the shortest distance from B_i to a, and d2 = the shortest distance from C_i to b.

        Then we require that:

            X >= d1 and X ≡ d1 (mod 2)   [if the graph is bipartite] 
            but if the graph is non-bipartite, then we have more flexibility: we require that either:
                (a) X >= d1 and X ≡ d1 mod 2, or 
                (b) actually, if there is an odd cycle, then we might also be able to reach a in X steps even if X mod 2 != d1 mod 2? But wait: we argued that in a non-bipartite graph, we can reach a in any sufficiently large step count. Therefore, for a fixed a, there exists an X0 such that for any X>=X0, there is a walk from B_i to a? Then the condition for a is: there is no parity restriction? 

        Actually, the necessary condition for a to be reachable from B_i in X steps is that X >= d1 and that if the graph is bipartite, then X ≡ d1 (mod 2). But if the graph is non-bipartite, then we can remove the parity constraint? Actually, we can: because we can add a loop of an odd cycle to change the parity arbitrarily? Therefore, for a non-bipartite graph, for a fixed a, we can reach a in any X >= d1? 

        This is not entirely true: we cannot necessarily remove the parity constraint for a particular a? Actually, the standard result is:

            In a non-bipartite connected graph, for any two vertices u and v, and for any integer k>=d(u,v) such that k ≡ d(u,v) mod 2, there is a walk of length k? Actually, that is true for bipartite too. For non-bipartite, we can also get the opposite parity? 

        Actually, the complete result:

            In a connected graph, the set of lengths of walks from u to v is:

                { k : k >= d(u,v) and k ≡ d(u,v) (mod g) } 

            where g is the greatest common divisor of the lengths of all cycles in the graph? Actually, no: the set of lengths is periodic with period 2 in bipartite graphs? And in non-bipartite, we can get both parities? 

        Actually, we can use the following: 

            Let d = d(u,v). 
            Let A be the set of lengths of walks from u to v.

            Then there exists an integer L such that for every k>=L, k is in A if and only if k ≡ d (mod 2) in bipartite graphs? 

            But in non-bipartite graphs, we have: for any k>=d, k is in A? 

        However, consider: if the graph has an odd cycle, then we can get both parities? Actually, we can: we can go from u to v in d steps, and then we can go around an odd cycle arbitrarily many times? Therefore, we can get any k >= d? 

        But note: we can only add even multiples of an odd cycle? Actually, no: if we go around an odd cycle once, we add 1 to the parity? Actually, if we go around an odd cycle once, we add an odd number. So if we take the direct path of length d, then we can add 0, 1, 2, ... times the odd cycle? But the odd cycle might not be incident to v? 

        Actually, we can do: take the shortest path to v, and then from v, we can go into an odd cycle and then come back to v. The length of the cycle is odd, say 2t+1. Then we can add 2t+1, 2*(2t+1), ...? Actually, we can also do a multiple of 1 cycle? Then the total length becomes d + (2t+1). Therefore, we can achieve d and d+(2t+1). Now, note that d and d+(2t+1) have opposite parities. Therefore, we can achieve both parities? 

        Actually, we can achieve any k >= d? Because:

            We can achieve d, d+1 (by going the cycle and then subtract one? Actually, we cannot subtract. But note: we can also use the cycle arbitrarily many times? Actually, we can achieve:

                d, d + (2t+1), d + 2*(2t+1), ...   -> these are d mod (2t+1)? 

            And we can also achieve: d + (2t+1) + 1? 

        Actually, a better approach: once we have an odd cycle, we can form a closed walk of length 1? Actually, no: we need at least 3 for a triangle. But we can form a closed walk of length 2? Only if we have a multiple edge? 

        The standard result is: 

            In a connected graph, the set of walk lengths from u to v is periodic with period 2 beyond the distance? Actually, no: the period might be 1? 

        Actually, the following is known: 

            Let d = d(u,v). 
            Let g = g(u,v) be the greatest common divisor of the set of all closed walks (or cycles) that are accessible? Actually, the entire graph? 

        But we don't need the exact set. We need to know: for a fixed city a and starting city u, what are the step counts X for which we can go from u to a? 

        We know:

            There exists a constant L (which depends on u and a) such that for every k>=L, we can go from u to a in k steps if and only if k ≡ d(u,a) mod g, where g is the greatest common divisor of the lengths of cycles in the graph? 

        Actually, the entire graph is connected, so we can take the gcd over all cycles? Let g = the gcd of the lengths of all cycles in the graph. Then the condition is k ≡ d(u,a) mod g? 

        But note: if the graph is bipartite, then all cycles are even, so g is at least 2? Actually, we can have g=2. Then the condition is k ≡ d(u,a) mod 2? 

        And if the graph is non-bipartite, then there is an odd cycle, so g=1? Then the condition is that k>=d(u,a). 

        Therefore, we have:

            Let g = the gcd of the lengths of all cycles in the entire graph? Actually, the entire graph is connected, so we can consider the entire graph.

        How to compute g? Note: the entire graph is connected. The gcd of the lengths of all cycles is also called the cycle gcd. It is known that the set of cycles in a connected graph generates a cyclic group? Actually, the gcd of all cycles is the same as the gcd of a basis? 

        However, note: we are not going to compute this for every u and a? 

        But note: the two businessmen are constrained by the same X. Therefore, we want:

            Find two cities a and b such that:

                X ≡ d1 (mod g) and X ≡ d2 (mod g)   [where d1 = d(B_i,a), d2 = d(C_i,b)]

            and X >= max(L1, L2) for some constants L1 and L2.

        But if g=1 (non-bipartite), then the condition is simply that X>=d1 and X>=d2. Then we can choose X arbitrarily large, so the condition for a and b is that they are any two cities? 

        Therefore, if the entire graph is non-bipartite, then both businessmen can be at any city (if we choose X sufficiently large). Then the answer for the query is the minimum absolute difference over any two cities? 

        But wait: we are not forced to choose X large. We can also choose X=0. So we can get the starting cities. However, the minimum absolute difference over all pairs of cities is at most |S[B_i]-S[C_i]|? But it could be smaller if there is a pair (a,b) with a smaller difference.

        Therefore, if the graph is non-bipartite, then the answer is the minimum absolute difference of the economic values of any two cities? 

        And if the graph is bipartite, then g=2. Then we require that:

            X ≡ d1 (mod 2) and X ≡ d2 (mod 2)  => that is, d1 ≡ d2 (mod 2). 

        But note: we can choose X arbitrarily? So we can choose X to be any integer that is at least max(d1, d2) and that has the same parity as both d1 and d2? Since g=2, the condition is that d1 and d2 must have the same parity? Actually, no: we can choose X to be any integer that is >= max(d1,d2) and X mod 2 = d1 mod 2 and also X mod 2 = d2 mod 2. Therefore, we require that d1 ≡ d2 mod 2. 

        Then the condition for the two cities a and b is that d(B_i, a) and d(C_i, b) must have the same parity? 

        But note: we can also consider small X? Actually, the above condition with g=2 and the existence of X>=max(d1,d2) with X ≡ d1 ≡ d2 mod 2 is always possible if d1 ≡ d2 mod 2? 

        Therefore, in a bipartite graph, the set of pairs (a,b) that we can achieve are those for which:

            d(B_i, a) ≡ d(C_i, b) mod 2.

        But note: also, we can achieve a pair (a,b) only if there exists an X that is at least the distances and with the same parity. But if d1 and d2 have the same parity, then we can choose X = max(d1,d2) if max(d1,d2) has that parity? Or if not, then max(d1,d2)+1? Actually, we can choose X = max(d1,d2) if max(d1,d2) has the same parity as d1 (which it must: because d1 mod2 = d2 mod2, then max(d1,d2) mod2 is that same value) or if not, then we can add 2? Actually, we can always choose X = max(d1,d2) + 2*k for k>=0? So yes.

        Therefore, in a bipartite graph, the answer is the minimum absolute difference |S[a]-S[b]| for any two cities a and b such that d(B_i, a) and d(C_i, b) have the same parity.

        But note: the parity of d(B_i, a) is fixed by the bipartite coloring: if we fix a bipartite coloring (say, color each city by 0 or 1) then d(B_i, a) mod 2 is the color of a relative to B_i? Actually, we can define:

            Let col[u] = the bipartite color (0 or 1) of u, with col[B_i] = 0.

            Then d(B_i, a) mod 2 = col[a].

            Similarly, if we do for C_i: we want d(C_i, b) mod 2 = col[b] relative to C_i? But note: the bipartite coloring is unique up to swapping? And if we fix the color of B_i to 0, then the color of C_i might be 0 or 1? 

        Actually, the condition is: we want col[a] = col[b]? 

            Let d1 = d(B_i, a) -> col[a] = d1 mod 2.
            Let d2 = d(C_i, b) -> col[b] = d2 mod 2.

            We require d1 mod 2 = d2 mod 2.

            Also, the distance from B_i to C_i: let d0 = d(B_i, C_i). Then col[C_i] = d0 mod 2.

            And the distance from C_i to b: d2 = d(C_i, b) = ? 

            But note: col[b] = (d0 + d(C_i, b)) mod 2? Actually, no: because the graph is bipartite, the coloring is consistent: col[b] = col[C_i] + d(C_i,b) mod 2? 

            Actually, col[b] = col[C_i] + d(C_i,b) mod 2? But then:

                col[a] = col[B_i] + d(B_i,a) mod 2 = 0 + d1 mod 2.
                col[b] = col[C_i] + d2 mod 2 = (d0 mod 2) + d2 mod 2.

            Then the condition d1 mod 2 = d2 mod 2 is equivalent to:

                col[a] = (d0 mod 2) + d2 mod 2.

            But we also have: we want d1 mod 2 = d2 mod 2, so:

                col[a] = d1 mod 2 = d2 mod 2 = col[b] - (d0 mod 2) mod 2.

            => col[a] = col[b] - (d0 mod 2) mod 2.

            => col[a] + (d0 mod 2) = col[b] mod 2.

        Therefore, the condition is: col[a] ≡ col[b] - (d0 mod 2) mod 2? 

        Alternatively, we can reassign the bipartite coloring relative to the starting cities? Actually, we can fix the entire coloring arbitrarily? 

        How about we do:

            Let the entire graph be colored by 0 and 1 arbitrarily as long as adjacent are different. Then:

                The condition: d(B_i,a) mod 2 = (col[a] - col[B_i]) mod 2? Actually, if we fix col[B_i]=0, then col[a] = d(B_i,a) mod 2.

                Similarly, for b: we want d(C_i,b) mod 2 = (col[b] - col[C_i]) mod 2.

                Then the condition: (col[a] - col[B_i]) mod 2 = (col[b] - col[C_i]) mod 2.

                => col[a] - col[b] ≡ col[B_i] - col[C_i] (mod 2)

                But col[B_i] = 0, so:

                    col[a] - col[b] ≡ - col[C_i] (mod 2)

                => col[a] ≡ col[b] - col[C_i] (mod 2)

        But note: col[C_i] is either 0 or 1? 

        Actually, we can precompute a fixed coloring. Then the condition is:

            col[a] ≡ col[b] - col[C_i] (mod 2)

        But note: we can also express it as:

            col[a] + col[C_i] ≡ col[b] (mod 2)

        Therefore, we can define for each city u: 

            We have two sets: 
                Set0: { u: col[u] = 0 }
                Set1: { u: col[u] = 1 }

        Then the condition for the pair (a,b) is:

            col[a] + col[C_i] ≡ col[b] mod 2   => col[b] = (col[a] + col[C_i]) mod 2.

        Then we can reindex the economic values:

            For each city u, we assign an index: 

                If col[u] = 0, then we put S[u] in a set A.
                If col[u] = 1, then we put S[u] in a set B.

        Then for a given query (B_i, C_i):

            We need to consider two cases for a:

                Case 1: a in set0 -> then b must be in set0 if col[C_i]=0? 
                         because: col[b] = (0+col[C_i]) mod 2 = col[C_i] mod 2 -> so if col[C_i]=0 then b in set0, if col[C_i]=1 then b in set1.

                Case 2: a in set1 -> then b must be in set1 if col[C_i]=0? 
                         because: col[b] = (1+col[C_i]) mod 2 = (1+0)=1 mod2 -> set1; if col[C_i]=1 then (1+1)=2 mod2=0 -> set0.

            Alternatively, we can note: for a fixed a, the set of b is determined by: 
                col[b] = (col[a] + col[C_i]) mod 2.

        Therefore, we can rewrite:

            We want to minimize |S[a] - S[b]| over a in all cities and b in the set:

                T = { v: col[v] = (col[a] + col[C_i]) mod 2 }

            But note: a is also arbitrary? 

        Alternatively, we can iterate over the entire set? But that is O(n^2). 

        Instead, we can precompute:

            For each distinct color class (0 and 1) and for each distinct residue of (col[u] + col[C_i]) mod 2? Actually, col[C_i] is fixed for the query. Therefore, for the query we have two sets:

                Let T0 = { S[u] for u such that col[u] = col[C_i] mod 2? } -> actually, no.

            Actually, the condition is: we are free to choose a and b independently as long as:

                col[b] = (col[a] + col[C_i]) mod 2.

            This can be rewritten as:

                Let k = col[C_i] (which is 0 or 1).

                Then for a fixed a, we must choose b from the set of cities with color (col[a] + k) mod 2.

            Then the problem becomes: 

                Find min_{a} { min_{b: col[b] = (col[a]+k) mod 2} |S[a] - S[b]| }

            = min ( min_{a: col[a]=0} min_{b: col[b] = k} |S[a]-S[b]|, 
                   min_{a: col[a]=1} min_{b: col[b] = (1+k) mod 2} |S[a]-S[b]| )

            But note: we can also consider the same a and b? Actually, we are minimizing over pairs.

        Therefore, the answer in a bipartite graph for a query (B_i, C_i) is:

            k = col[C_i]   [we fixed col[B_i]=0, so col[C_i] = d(B_i, C_i) mod 2]

            Then:

                candidate1 = min_{a in set0, b in set_k} |S[a]-S[b]|
                candidate2 = min_{a in set1, b in set_{ (1+k) mod 2}} |S[a]-S[b]|

            Then answer = min(candidate1, candidate2)

        But note: we can also achieve the same a and b? 

        However, this candidate1 and candidate2 are independent. We want the overall minimum.

        But wait: is this correct? Consider: we are minimizing over a and b arbitrarily. Then the entire set of pairs we consider is:

            { (a,b) such that col[b] = (col[a] + col[C_i]) mod 2 }

        And we take the min |S[a]-S[b]|.

        This is equivalent to: 

            min( 
                min_{a in set0, b in set_k} |S[a]-S[b]|, 
                min_{a in set1, b in set_{1+k}} |S[a]-S[b]| 
            )

        And that is the answer for the bipartite graph.

        Now, what if the graph is non-bipartite? Then the two businessmen can be at any two cities? Then the answer is the minimum absolute difference of any two cities? 

        Therefore, we have:

            If the graph is bipartite: 
                ans = min( 
                          min{ |S[a]-S[b]| : a in set0, b in set_k } 
                          min{ |S[a]-S[b]| : a in set1, b in set_{1+k} } 
                         )
            If the graph is non-bipartite:
                ans = min_{a,b} |S[a]-S[b]|   [over all pairs of cities? but note: we can also choose the same city? and then |S[a]-S[a]|=0?]

        But note: in the non-bipartite case, we can choose the same city? Then the minimum absolute difference is 0? But that is the minimum over any two cities? Actually, the minimum absolute difference over all pairs of cities is 0 only if there are two cities with the same economic value? Otherwise, it might be the minimum difference between distinct cities? 

        Actually, we can choose the same city: because we can have a=b. Therefore, the minimum absolute difference in the non-bipartite case is 0 if there is at least two cities with the same value? But if all values are distinct, then we have to find the minimum difference between distinct values? 

        However, note: the problem does not require distinct cities. The two businessmen might end at the same city? Then the difference is 0. Therefore, if there are at least two cities with the same economic value, then we can get 0? Actually, no: we can get 0 by having both end at a city with value v? But we can also have both end at the same city? Then the difference is 0. Therefore, the minimum absolute difference in the non-bipartite case is 0? 

        But wait: we can have both end at the same city? How? We require that the two walks end at the same city? 

            Yes: choose X sufficiently large so that both can reach that city? 

        Therefore, the answer for the non-bipartite case is 0? 

        However, the sample: 

            "6 6
             0 0 0 0 0 0"

            Then the answer for the first query is 0? 

            Then we update: city1 becomes 10, city3 becomes 20, city4 becomes 11.

            Then the next queries:

                Query: 1 1 2 -> answer 10? 
                Query: 1 1 3 -> answer 0? 
                Query: 1 1 6 -> answer 1? 

            But wait: in the sample, the graph is non-bipartite? Let's check: the graph has a cycle of length 3 (1-2-3-5-1? Actually, 1-2-3-5: 1-2, 2-3, 3-5, 5-1: that's a cycle of length 4? Actually, 1-2-3-5-1: 1-2,2-3,3-5,5-1 -> 4 edges -> even cycle? 

            But also: 1-6? and 5-1? and 3-5? and 3-4? and 2-3? and 1-2? 

            The cycle 1->2->3->5->1: 4 edges -> even? Then the graph is bipartite? 

            Then the sample graph is bipartite? 

            So the sample answers are for a bipartite graph.

        Therefore, we must first check if the graph is bipartite.

        Steps:

            Step 1: Precompute the bipartiteness of the graph? We can do a BFS to assign colors and check for odd cycles.

            Step 2: 

                If the graph is bipartite:
                    We assign colors (0 or 1) to each node, with color[1]=0 (we fix the first city as 0? but note: the queries start at arbitrary cities). Actually, we can fix an arbitrary root (say node 1) and then assign colors.

                    For each query (1, B_i, C_i):
                         Let k = color[C_i]   [because our coloring is relative to node1? but we need the color of C_i relative to B_i?]

                    Actually, we have the entire coloring. The condition we derived earlier: 

                         We require: col[a] ≡ col[b] - col[C_i] mod 2? 

                    But we have a fixed coloring. How do we relate the color of B_i? 

                    Note: we defined the coloring from a fixed root. Then the color of a node is the parity of the distance from the root? 

                    Then the distance from B_i to a is: 
                         d(B_i, a) = |d(root, a) - d(root, B_i)|? Actually, no: the graph is not a tree. But the parity: 
                         d(B_i, a) mod2 = (d(root, a) - d(root, B_i)) mod2? Actually, modulo 2: 
                         d(B_i, a) mod2 = (d(root, a) mod2 - d(root, B_i) mod2) mod2 = (color[a] - color[B_i]) mod2.

                    Similarly, d(C_i, b) mod2 = (color[b] - color[C_i]) mod2.

                    Then the condition: 
                         (color[a] - color[B_i]) mod2 = (color[b] - color[C_i]) mod2
                         => color[a] - color[b] ≡ color[B_i] - color[C_i] (mod2)

                    But note: the two businessmen start at B_i and C_i. We can precompute:

                         Let delta = (color[B_i] - color[C_i]) mod2.

                    Then we require: 
                         color[a] - color[b] ≡ delta (mod2)

                    Then we can write:

                         color[a] ≡ color[b] + delta (mod2)

                    Then we can iterate over:

                         candidate1: for a in set0, then b must be in set_{ (0 - delta) mod2 }? 
                         candidate2: for a in set1, then b must be in set_{ (1 - delta) mod2 }? 

                    Actually, we can also swap: we are free to choose any a and b. We can precompute:

                         Let A0 = sorted list of economic values for nodes with color0.
                         Let A1 = sorted list of economic values for nodes with color1.

                    Then for a given query, we have:

                         delta = (color[B_i] - color[C_i]) mod2.

                         Then we want:

                             min ( 
                                   min_{a in A0, b in A_{ (0 - delta) mod2 } } |a-b|, 
                                   min_{a in A1, b in A_{ (1 - delta) mod2 } } |a-b|
                                 )

                    But note: (0-delta) mod2 = ( -delta) mod2 = (2-delta) mod2 = delta? because delta is 0 or 1? Actually, no: 
                         If delta=0: then (0-0)=0 mod2 -> so for a in A0, we require b in A0? 
                         If delta=1: then (0-1) mod2 = 1? so for a in A0, we require b in A1.

                    Similarly, for a in A1: 
                         (1-delta) mod2: 
                         if delta=0: then 1 mod2 -> A1
                         if delta=1: then (1-1)=0 mod2 -> A0.

                    Therefore, we can write:

                         if delta=0:
                             candidate1 = min_{a in A0, b in A0} |a-b|   [but note: we can choose the same element? then 0? but the problem allows the same city?]
                             candidate2 = min_{a in A1, b in A1} |a-b|

                         if delta=1:
                             candidate1 = min_{a in A0, b in A1} |a-b|
                             candidate2 = min_{a in A1, b in A0} |a-b|   [which is the same as candidate1?]

                    But note: the absolute value is symmetric. Therefore, in delta=1, we only need to compute min_{a in A0, b in A1} |a-b|.

                    And in delta=0, we need min( min_{a,b in A0} |a-b|, min_{a,b in A1} |a-b| )

                    However, note: the min_{a,b in A0} |a-b| includes pairs with the same a (which gives 0) if we have two cities with the same value? Actually, we can choose the same city? Then we can have a=b? Then the minimum difference in a set is 0? But only if there is a duplicate? 

                    Actually, we can have the same city for both? Then the difference is 0. Therefore, if there is any duplicate value in the set (for the same color) then we get 0? 

                    But note: the set A0 might have multiple cities with the same economic value? Then we can have a=b? 

                    Therefore, in delta=0:

                         candidate = min( min_{x in A0} (0 if there is duplicate? or the minimum difference in A0), min_{x in A1} (minimum difference in A1) )

                         = min( min_diff(A0), min_diff(A1) )   [where min_diff(S) is the minimum absolute difference between any two elements in S, including the same element? Actually, the same element gives 0, so the min_diff(S) is 0 if there is any duplicate?]

                    Actually, the minimum absolute difference in a set S is 0 if there are duplicates? Otherwise, it is the minimum difference between distinct values? 

                    But note: we are allowed to choose the same city? Then we can have a=b? Then the difference is |S[a]-S[b]|=0. Therefore, the minimum difference in a set is always 0? 

                    Then why in the sample:

                         "0 0 0 0 0 0" -> then A0 and A1 have many 0's -> then min_diff(A0)=0, min_diff(A1)=0? Then for any query with delta=0 or 1? 

                    But the first query: (1,1,2): 
                         B_i=1, C_i=2.
                         color[1]=0 (if we fix node1 as 0). 
                         color[2]: adjacent to 1, so color[2]=1.
                         delta = (0-1) mod2 = 1? 

                         Then we are in delta=1: so we compute min_{a in A0, b in A1} |a-b|. But all values are 0, so |0-0|=0.

                    Then the answer is 0? 

                    But the sample output for the first query is 0.

                    Then the second query: update city1 to 10 and city3 to 20? 
                    Then we have:

                         city1: 10, color0
                         city2: 0, color1
                         city3: 20, color0? [because: 1->2->3: distance2 -> same as 1? so color0? 
                         city4: 0, color1? [1->2->3->4: distance3 -> color1?]
                         city5: 0, color1? [1->5: distance1 -> color1?]
                         city6: 0, color1? [1->6: distance1 -> color1?]

                    Then A0 = {10, 20}  -> min_diff(A0) = 10? 
                         A1 = {0,0,0,0} -> min_diff(A1)=0? 

                    Then for a query (1,1,2): 
                         B_i=1 (color0), C_i=2 (color1) -> delta = (0-1) mod2 = 1 -> we need min_{a in A0, b in A1} |a-b|.

                         A0: {10,20}, A1: {0,0,0,0} -> the minimum |a-b| is min( |10-0|=10, |20-0|=20 ) = 10.

                    Then the answer is 10? which matches.

                    Then next: update city4 to 11? 
                         Then A0 = {10,20}, A1 = {0,0,0,11}? 

                    Then for query (1,1,3): 
                         B_i=1 (color0), C_i=3 (color0) -> delta = (0-0)=0 mod2 -> we need min( min_diff(A0), min_diff(A1) ) 
                         min_diff(A0) = |10-20|=10? 
                         min_diff(A1) = min( |0-0|=0, |0-11|=11, |0-11|=11, ... ) = 0? 
                         Then answer = min(10,0)=0.

                    Then for query (1,1,6): 
                         B_i=1 (color0), C_i=6 (color1) -> delta=1 -> we need min_{a in A0, b in A1} |a-b| = min( |10-0|=10, |10-11|=1, |20-0|=20, |20-11|=9 ) = 1.

                    So the answers: 0, 10, 0, 1? which matches the sample.

        Therefore, the solution:

            Precomputation:

                Step 1: Check if the graph is bipartite and compute the bipartite coloring (using BFS). If we find an edge connecting two nodes of the same color, then the graph is non-bipartite.

                Step 2: 
                    If the graph is non-bipartite:
                         Then the answer for any query of type 1 is 0? Because we can always have both businessmen end at a city that has the same economic value? But wait: we can end at the same city? Then the difference is 0. Therefore, the answer is 0? 

                    But note: the sample output for non-bipartite? The problem says the graph is connected and we have at least one query. 

                    However, what if all economic values are distinct? Then the minimum difference over all pairs is not 0? But we can have both end at the same city? Then the difference is 0. How? 

                    We require that the two businessmen end at the same city? Then we need to choose a city that is reachable from both B_i and C_i in the same number of steps? 

                    But in a non-bipartite graph, for any two nodes u and v and any sufficiently large X (beyond a constant), we can reach any city? Then we can choose a city that has an economic value that appears at least twice? Actually, we don't need two distinct cities: we can choose the same city for both. Then the difference is |S[a]-S[a]|=0.

                    Therefore, regardless of the economic values, we can always get 0? 

                    Then the answer for any query in a non-bipartite graph is 0.

                But wait: what if we cannot get to the same city? Actually, we can: because the graph is connected and non-bipartite, for any two starting nodes and any target node a, there exists an X such that both can reach a? 

                    Actually, we can: for each starting node, we can reach a in a sufficiently large number of steps? And since we are free to choose X arbitrarily large, we can choose the same X for both. Therefore, we can have both end at a. Then we choose a city a arbitrarily? Then the difference is 0? Only if we choose the same city? But then the difference is 0.

                    Therefore, the answer for non-bipartite is always 0.

            However, consider the sample: 
                "1 1 3" in the sample: which was bipartite and gave 0? But if the graph were non-bipartite, then we would also get 0? 

            But the problem has a query that outputs 10 and 1? 

            Therefore, the graph in the sample is bipartite.

            How to check the sample: 
                Nodes: 1,2,3,4,5,6.
                Edges: 
                    1-2, 1-6, 5-1, 2-3, 3-4, 3-5.

                Check for odd cycle: 
                    Start at 1: color0.
                    1: color0 -> neighbors 2,6,5: color1.
                    2: color1 -> neighbors 3: color0.
                    6: color1 -> no new neighbor? 
                    5: color1 -> neighbors 3: color0? 
                    Then 3: from 2 and 5, both say color0 -> then 3 is color0? 
                    Then 3 has neighbor 4: color1? 
                    Then 4: color1 -> no conflict? 
                    Then 3 is connected to 5: 3 (color0) and 5 (color1) -> edge 3-5: 0 and 1 -> ok.
                    Then 3 is connected to 2: 0 and 1 -> ok.

                But wait: 1-5: 0-1 -> ok. 
                Then 5-3: 1-0 -> ok. 
                Then 3-2: 0-1 -> ok. 
                Then 1-2: 0-1 -> ok.

                So the graph is bipartite? 

            Then the answer for non-bipartite is always 0? 

        Therefore, the algorithm for queries:

            if the graph is non-bipartite:
                For every query of type 1, output 0.

            else: // bipartite
                Precompute the bipartite coloring (we already did in the BFS) and then:

                Build two sorted lists:
                    A0 = sorted list of economic values of nodes with color0.
                    A1 = sorted list of economic values of nodes with color1.

                Also, we note: we will support updates? 

                The queries include:

                    Type 0: update the economic value of a city.

                Therefore, we need to update the sorted lists? 

                We can use a data structure that supports:

                    - Updating an element (removing the old value and inserting the new value) in the sorted lists.

                    - Querying the minimum absolute difference in a set? Actually, we don't need the entire set difference, but we need:

                         For the entire set A0: the minimum absolute difference between any two elements? But note: we can also get 0 by having the same element? So we need the minimum difference between distinct elements? Actually, no: we are allowed to pick the same element? Then the minimum difference is 0? 

                    Actually, the minimum absolute difference in a set S is 0 if there is at least one duplicate? Otherwise, it is the minimum gap between consecutive elements? 

                    But note: if we have multiple copies of the same value, we can have a duplicate? Then the minimum difference is 0.

                    Therefore, we can maintain:

                         min0 = minimum absolute difference in A0 (if there is a duplicate, then 0; otherwise the minimum gap between consecutive elements? but note: we can also get 0 by picking the same element twice? So if there is at least two nodes with the same value in A0, then min0=0? 

                    Actually, we can maintain the entire set and then the minimum difference is 0 if the set has duplicates? But how to maintain the minimum gap? 

                    Alternatively, we note: the minimum absolute difference in a set of numbers (allowing the same element) is 0 if there is at least one duplicate? Otherwise, we can compute the minimum gap between distinct elements? 

                    But note: we are allowed to choose the same element? Then we can always get 0? Only if there are at least two nodes in the set? But if there is only one node, then we cannot choose two distinct nodes? Actually, we can choose the same node? Then we have a=b, so |S[a]-S[b]|=0? 

                    Therefore, the minimum absolute difference in a set is always 0? 

                    Then why did we have to compute min_diff(A0) in the sample? 

                    Actually, in the bipartite case, we are not considering a set by itself? We are considering pairs (a,b) that might be in the same set (for delta=0) or in different sets (for delta=1). 

                    And for a fixed set (say A0) we can choose a and b from A0 arbitrarily? Then the minimum |a-b| is 0? 

                    Therefore, for delta=0, the answer is always 0? 

                    But the sample after update: 

                         Query: 1 1 2 -> 10 (not 0)

                    Why? Because for delta=1, we are forced to take one from A0 and one from A1? And the minimum |a-b| for a in A0 and b in A1 is 10? 

                    And for delta=0, we take the minimum of the min_diff(A0) and min_diff(A1). In the sample after update:

                         For the query (1,1,3): delta=0 -> then we take min( min_diff(A0), min_diff(A1) ) = min(10,0)=0? 

                    But note: min_diff(A0) is the minimum difference between any two elements in A0? But we can also take the same element? Then min_diff(A0)=0? 

                    However, in the sample after update, A0 = {10,20}. The minimum difference in A0: we can choose the same element? Then we can choose a=10 and b=10? But there is only one city with value 10 (city1) and one with 20 (city3). So we cannot choose the same element? 

                    How can we choose the same element? We need two different cities with the same value? 

                    Therefore, we must be careful: the set A0 is the list of economic values for cities with color0. We have:

                         city1: 10 -> in A0
                         city3: 20 -> in A0

                    Then we have two cities? Then we can choose two different cities? But to choose the same element, we need a city that appears twice? 

                    Therefore, the minimum difference in A0 is:

                         min( |10-10|, |10-20|, |20-10|, |20-20| )? 

                    But we have only two distinct values: 10 and 20. We can choose:

                         (city1, city1): not possible? because we have only one city1? 

                    Actually, the two businessmen can choose the same city? Then we need only one city? 

                    How? We can have both end at city1? 

                        For the businessman starting at 1: can we end at city1? 
                            In an even number of steps: because city1 is at distance0 from itself -> even. 
                        For the businessman starting at 3: we need to end at city1? 
                            The distance from 3 to 1: 
                                3->2->1: 2 steps? -> even? 
                            Then we can choose X=2? 

                    Therefore, we can have both at city1? Then the difference is |10-10|=0.

                    But wait: the businessman starting at 3: can he be at city1 in 2 steps? 
                        3->2->1: that works.

                    Then the answer for (1,1,3) is 0.

                    How do we represent that in our sets? 

                         We have A0: [10,20] -> we have the value 10. Then we can choose a=10 and b=10? 

                    How? We choose the same city (city1) for both? Then we need to consider the same element twice? 

                    Therefore, we must allow a and b to be the same element? 

                    Then the minimum difference in A0 is min_{i} |x_i - x_i| = 0? 

                    But if we have the same value appearing twice? Then we can choose two different cities? 

                    Therefore, we can do:

                         min_diff(S) = 0 if there is at least two nodes in S? 

                    Actually, no: we can choose the same node? Then we get 0? 

                    Therefore, the minimum difference in a set S (as long as the set is non-empty) is 0? 

                    But note: the set must be non-empty? 

                    Then why do we need the min_diff(S)? Actually, we don't: for delta=0, we can always get 0? 

                    Then the answer for any query in a bipartite graph is 0? 

                    But the sample has a query that returns 10.

        We must revisit:

            In the bipartite case, the two businessmen must choose the same X. Then for a given X, they can choose any walks of length X. 

            For a given city a (for the first businessman) and city b (for the second), we require that:

                 d(B_i, a) ≡ d(C_i, b) mod 2   [which is the condition we had]

            But we can choose the same city a for both? Only if a is reachable from both B_i and C_i in the same X? And then we require that d(B_i,a) and d(C_i,a) have the same parity? 

            So the condition for the same city a is:

                 d(B_i,a) mod2 = d(C_i,a) mod2.

            But note: the distance from B_i to a and from C_i to a: 
                 d(B_i,a) mod2 = (color[a]-color[B_i]) mod2
                 d(C_i,a) mod2 = (color[a]-color[C_i]) mod2

            Then the condition: 
                 (color[a]-color[B_i]) mod2 = (color[a]-color[C_i]) mod2
                 => color[B_i] ≡ color[C_i] mod2   [because the color[a] cancels?]

            Therefore, we can have the same city only if color[B_i] ≡ color[C_i] mod2? 

            But note: we have already defined delta = (color[B_i]-color[C_i]) mod2. Then the condition for the same city is that delta=0? 

            Therefore, if delta=0, then we can have the same city? Then the difference is 0.

            If delta=1, then we cannot have the same city? Because the condition for the same city requires the distances to a to have the same parity, but then we require:

                 (color[a]-color[B_i]) mod2 = (color[a]-color[C_i]) mod2
                 => color[B_i] ≡ color[C_i] mod2, which is false.

            Therefore, for delta=1, we cannot have the same city. Then the minimum difference we can get is the minimum |S[a]-S[b]| for a in A0 and b in A1? 

            And for delta=0, we can always get 0 (by having both at the same city) so the answer is 0.

        Therefore, we can simplify:

            In a bipartite graph:

                Let delta = (color[B_i] - color[C_i]) mod2.

                If delta == 0:
                    answer = 0   [because we can have both at the same city?]

                Else (delta==1):
                    answer = min_{a in A0, b in A1} |S[a] - S[b]|

            But note: in the sample after update: 
                Query (1,1,2): 
                    B_i=1: color0, C_i=2: color1 -> delta=1 -> answer = min_{a in A0, b in A1} |S[a]-S[b]| = min( |10-0|, |10-0|, ... |20-0|, ... ) = 10.

                Query (1,1,3): 
                    B_i=1: color0, C_i=3: color0 -> delta=0 -> answer=0.

                Query (1,1,6): 
                    B_i=1: color0, C_i=6: color1 -> delta=1 -> answer = min( |10-0|, |10-0|, |10-0|, |10-11|, |20-0|, ... ) = min(10, 1, ...) = 1.

            This matches the sample.

        However, what if there is no city in A0 or in A1? 

            The graph has at least one city? 

        Therefore, the algorithm:

            Precomputation:

                Step 1: Run BFS from node1 to check bipartite and assign colors.

                    color[1]=0
                    for each node u: 
                         for each neighbor v: 
                              if v is not visited: color[v] = color[u]^1
                              else if color[v] == color[u]: then non-bipartite.

                Step 2: 
                    If non-bipartite: 
                         Then for every type-1 query, the answer is 0.

                    Else (bipartite):
                         Build two sets: 
                             A0 = sorted list of S[i] for i with color[i]==0
                             A1 = sorted list of S[i] for i with color[i]==1

                         But note: we will update the economic values. Therefore, we need to maintain these two sorted lists and also a data structure to answer: min_{x in A0, y in A1} |x-y|.

                Step 3: For updates (type0: update city B_i to C_i):

                         We need to know the color of city B_i.

                         Remove the old value (old_value) from the set that corresponds to its color (if it was in A0, remove from A0; if in A1, remove from A1). Then insert the new value C_i.

                Step 4: For queries (type1: B_i, C_i):

                         If the graph is non-bipartite: output 0.

                         Else:
                              delta = (color[B_i] - color[C_i]) % 2   [but modulo 2, so we can use bit: if color[B_i] == color[C_i] then delta=0, else 1]

                         If delta == 0:
                              output 0

                         Else:
                              output = min_{x in A0, y in A1} |x-y|

            But how to compute min_{x in A0, y in A1} |x-y| quickly? 

                We can maintain a separate data structure that stores the entire set of values in A0 and A1 and then we want the minimum absolute difference between a value in A0 and a value in A1.

                However, note: we are updating the sets. We need to support:

                    - Insertion and deletion of values in A0 and A1.

                    - Query: min |x-y| for x in A0 and y in A1.

                Alternatively, we can maintain a single sorted list T that contains all the economic values, but we also store the color? Then the query is: min |x-y| for x and y of different colors? 

                But note: we also have to update: when we update a city, we change its value. Then we remove the old value (with its old color) and insert the new value (with the same color? the city doesn't change color).

                How about we maintain two sorted lists: A0 and A1. Then the minimum difference between A0 and A1 can be computed by:

                    We iterate over the values in A0, and for each value, we do a binary search in A1 to find the closest value? Then take the min over A0? 

                But Q and n can be up to 100,000, and we have up to 100,000 queries. Then the worst-case for a query is O(|A0| * log|A1|) -> 100,000 * log(100,000) which is about 100,000 * 17 = 1.7e6 per query? and 100,000 queries would be 170e6, which might be borderline in C++ but the problem time limit is 2 seconds? 

                But note: the problem has 100,000 queries, and we have to do one query per type1 with delta=1. And the number of type1 queries can be up to 100,000? Then worst-case total time O(100,000 * 100,000) = 10e9? which is too slow.

            We need a faster approach.

            Alternative: we maintain the entire set of values in a balanced BST? 

            Actually, we can maintain a Fenwick tree or segment tree for all values? But we care about the minimum gap between A0 and A1.

            We can maintain a global set T that contains all economic values, and then for each value we know its color. But the query is the minimum gap between a value in A0 and a value in A1. 

            Note: the minimum gap between A0 and A1 is the minimum over all pairs (x in A0, y in A1) of |x-y|. This is equivalent to the minimum over all x in A0 of (min_{y in A1} |x-y|). And we can precompute the entire set and then update? 

            We can maintain a separate data structure for the entire set of values? 

            Idea:

                Maintain a sorted list L of all economic values, and along with each value, store the color. But then how to quickly compute the minimum gap between two values of different colors? 

                We can maintain a segment tree that stores the minimum gap in an interval? But the gap is defined between two elements? 

            Alternatively, we can maintain the following: 

                The minimum gap between a value in A0 and a value in A1 can be updated by considering the neighbors in the entire sorted list. Specifically, the candidate for a value x (say in A0) is the closest value to x in A1 (which is either the predecessor or the successor in the entire sorted order?).

                Then the overall minimum gap is the minimum over all x in A0 and its closest neighbor in A1? 

            We can maintain:

                A multiset for A0 and a multiset for A1.

                Then we maintain a variable: min_gap = the current minimum absolute difference between A0 and A1.

                But updating one value might change min_gap by a lot? 

            Alternatively, we can maintain a balanced BST that stores all the economic values and then for each value we know the set (A0 or A1) it belongs to. Then the minimum gap between A0 and A1 must occur between two consecutive values in the entire sorted list that have different colors? 

                Why? Because if we have ... x, y ... with x<y, and if x is in A0 and y in A1, then the gap is y-x. And if there is a gap between two consecutive values that have different colors, then one candidate is y-x.

                Then the overall minimum gap is the minimum over all consecutive values (in the entire sorted list) that have different colors.

            Why is that? 

                Consider three values: a0 (in A0), a1 (in A1), a2 (in A0) with a0 <= a1 <= a2.

                The gaps: 
                    gap1 = a1 - a0
                    gap2 = a2 - a1

                The gap between a0 and a2 is a2 - a0 = gap1+gap2, which is at least min(gap1, gap2). 

                Therefore, the minimum gap between a value in A0 and a value in A1 is the minimum over consecutive pairs in the entire sorted list that have different colors.

            Therefore, we can:

                Maintain a sorted list T of all economic values, and we also store the color for each city. But note: multiple cities can have the same value? 

                Then we maintain a global multiset of the entire list? 

                We also maintain a multiset (or a heap) of the gaps between consecutive elements that have different colors? 

                Steps:

                    We maintain a balanced BST or a sorted list of all values? Actually, we can use a balanced BST that also stores the color.

                    We maintain a data structure for the entire sorted list that supports:

                         - Insertion and deletion of a value (with its color)
                         - Update the gaps: the gaps between consecutive elements that have different colors.

                    Specifically, we can store the entire set in a sorted list (or a balanced BST) and then also maintain a separate min-heap for the gaps that are between consecutive elements with different colors? 

                But when we insert or delete, we affect the neighbors: 

                    For insertion:

                         Suppose we insert a value x with color c.

                         We find its immediate predecessor and successor.

                         Then we break the gap between the predecessor and successor, and create two new gaps: (predecessor, x) and (x, successor).

                         Then we remove the old gap (predecessor, successor) and add the two new gaps.

                         And then we check: the gap (predecessor, x) is a candidate only if the colors of predecessor and x are different? Similarly for (x, successor).

                    We also maintain a global min-heap (priority queue) of the current gaps (that are between consecutive elements with different colors). But note: if the consecutive elements have the same color, we ignore that gap for our candidate? 

                However, we are only interested in the gaps between consecutive elements that have different colors? 

                Then we can do:

                    We maintain a sorted list L of pairs (value, color) for all cities.

                    We maintain a Fenwick tree? Or we can use a heap for the gaps? But the gaps change dynamically.

                We can maintain:

                    A set (balanced BST) for the entire list of values? 

                    And we also maintain a multiset (or a heap) of candidate gaps: which are the gaps between consecutive elements that have different colors. Then the minimum gap is the top of the heap.

                Steps for update:

                    When updating a city from old_value to new_value:

                         Step 1: remove the old_value (with its color c) from the sorted list.

                              - Find the neighbors: left and right.
                              - Remove the gaps: (left, old_value) and (old_value, right)
                              - Add a new gap (left, right) if left and right exist? and if the gap (left, right) is for different colors? 
                              - But note: the gap (left, old_value) was only in the candidate set if the colors of left and old_value were different? Similarly for (old_value, right). And the new gap (left, right) is a candidate only if the colors of left and right are different.

                         Step 2: insert the new_value (with the same color c) into the sorted list.

                              - Find the neighbors: left and right for the new_value.
                              - Break the gap (left, right) (if exists) and remove it from the candidate set? 
                              - Add gaps (left, new_value) and (new_value, right) if the colors are different? 

                    Then the candidate set of gaps is updated.

                Then the answer for a query of type1 with delta=1 is the minimum candidate gap? 

                But note: what if the candidate set is empty? Then there are no consecutive elements with different colors? Then the entire set is one color? 

                    But we have two non-empty sets? Then there must be at least one gap between different colors? 

                Actually, if both A0 and A1 are non-empty, then there is at least one consecutive pair (in the sorted order) that has different colors? 

            Implementation:

                We can use a balanced BST? In C++ we can use std::set. We maintain:

                    std::set<std::pair<long long, int>> all;   // (value, city_index) or (value, color) ? 

                But we need to know the color? Actually, we have the color for each city stored in an array. And when we update, we know the city's color doesn't change.

                Alternatively, we store (value, color, id)? But we don't need id? We only care about the gaps between consecutive values? 

                Actually, we can store:

                    std::set<std::pair<long long, int>> all;   // (value, color)  -> but multiple cities can have the same value? Then we store (value, color, id) to distinguish? 

                But if we have the same value, then we can store multiple times? 

                Alternatively, we store by value and then we don't care about duplicates? Actually, we do: if we have two cities with value 10: one in A0 and one in A1, then the gap between them is 0? 

                How do we represent that? 

                    We can store a multiset? 

                Actually, we can use:

                    std::map<long long, int> freq0, freq1;   // but then we lose the ordering for consecutive? 

                Alternatively, we store the entire sorted list of values with their colors? But with duplicates? 

                We can store a multiset for A0 and a multiset for A1. Then the minimum gap between A0 and A1 is the minimum of:

                    - The minimum |x-y| for x in A0 and y in A1? 

                And we can compute this by iterating over the entire set? 

            Given time constraints, we note that the total number of type1 queries with delta=1 might be large, but we must update the candidate gaps in O(log n) per update.

            The method using the consecutive pairs in the global sorted list:

                Let T = sorted list of all economic values, along with a color for each. But if there are duplicates, we store each occurrence? 

                Then the consecutive pairs: if we have two values x and y (x<=y) that are consecutive in T, and they have different colors, then the gap = y-x.

                Then the minimum gap between A0 and A1 is the minimum gap over consecutive pairs that have different colors? 

                But consider: 
                    A0: {10, 20}
                    A1: {15}

                Then the consecutive pairs: 
                    10 and 15: gap=5
                    15 and 20: gap=5

                The minimum gap is 5? 

                But also, we have |10-15|=5, |20-15|=5, and |10-20|=10. 

                Now, what if we have:
                    A0: {10, 20}
                    A1: {11, 21}

                Then consecutive pairs: 
                    10 (A0) and 11 (A1): gap=1
                    11 (A1) and 20 (A0): gap=9
                    20 (A0) and 21 (A1): gap=1

                Then the minimum gap is 1? 

                But the minimum gap overall is min(|10-11|, |10-21|, |20-11|, |20-21|) = min(1, 11, 9, 1) = 1.

                So it is the minimum of the consecutive gaps? 

                Why? 

                    The minimum gap between two sets in a sorted array must occur at consecutive elements? 

                Yes, because if we have a0 in A0 and a1 in A1, and they are not consecutive, then there is an element between them? But that element might be from A0 or A1? 

                If the element between is from A0, then we have a0 and then a0' (another A0) and then a1? Then the gap |a0 - a1| >= |a0' - a1|? Not necessarily: but we can consider the gap between a0 and the next element (which is a0') and then a0' and a1? Then the gap |a0 - a1| is not minimal if there is a closer pair? 

                Actually, the standard: the closest pair in two sets in one dimension is the minimum over consecutive pairs? 

                Therefore, we can do:

                    Maintain a sorted list of all (value, color) for all cities? But duplicates: we can store multiple entries? 

                    Actually, we can store in a std::set<long long> for the entire set of values? But then we lose the color per occurrence. 

                Alternatively, we store:

                    std::set<std::pair<long long, int>> events;   // (value, id)   and we store the color in an array col[city_id]? 

                But when we do a predecessor and successor, we only care about the value? 

                Actually, we can store the entire set in a std::set<long long> but then we cannot have duplicates? 

                So we need to store multiple values? 

                We can use a multiset: 

                    std::multiset<long long> all_values;

                    And then we also store per city: its value and color.

                Then we also maintain an array for the current value of each city.

                And we maintain a global min-heap (priority_queue) for the gaps between consecutive values that have different colors? But when we insert, we only know the value, not the color? 

            Alternatively, we can maintain two sets: 

                We maintain the entire set of economic values in a balanced BST that allows duplicates? 

                But we also need to know the colors of the neighbors? 

            Given the complexity, and the constraints (n, q up to 100,000), we can do the following for a query of type1 with delta=1:

                We iterate over the smaller set? But worst-case the two sets are of size 50,000, and we iterate over one set and do a binary search in the other: 50,000 * log(50,000) = 50,000 * 16 = 800,000 per query? Then 100,000 queries would be 80e6, which is acceptable in C++ but in Pyton might be borderline? 

                But the problem has at least one query of type1, but we don't know how many. In worst-case, all queries are type1 with delta=1, and there are 100,000 queries. Then 80e6 per 100,000 queries? That's 8e9, which is too slow.

            We need a faster method.

            How about we maintain for the set A0 and A1 separately, and then we also maintain a data structure that can answer: what is min |x-y| for x in A0 and y in A1? 

                We can maintain a Fenwick tree or segment tree over the entire range of values? But the values can be up to 1e9.

            Alternatively, we use a balanced BST that stores the entire set of values in A1, and then for each value in A0, we query the closest value in A1? And we do this only if the value in A0 is updated? But then we have to do it for every update of A0? 

            Another idea: we maintain a separate data structure that is a balanced BST for the entire set of values, and then we mark whether it is in A0 or A1? Then the closest value of a different color for a given value x is the closest value in the BST that has a different color? 

            But we want the global minimum gap? 

            We can maintain a separate data structure that is a heap for the candidate answers? 

                For each value in A0, we store the closest value in A1? And then the global answer is the minimum of these? 

                But when we update a value in A0, we remove the old candidate and add a new candidate? 

                And when we update a value in A1, we have to update all values in A0 that might have this as their closest? 

            This is complex.

        Considering time, and that the problem expects an answer, we note that the sample does not have to be done by the most efficient method. However, we must handle 100,000 queries.

        We can do:

            Maintain A0 and A1 as std::set (balanced BST) of the values.

            Then for a query with delta=1, we do:

                ans = a big number.

                // iterate over the smaller set? 
                if (A0.size() <= A1.size()) {
                    for (each x in A0) {
                         auto it = A1.lower_bound(x);
                         if (it != A1.end()) ans = min(ans, abs(*it - x));
                         if (it != A1.begin()) {
                              it--;
                              ans = min(ans, abs(*it - x));
                         }
                    }
                } else {
                    for (each x in A1) {
                         // similarly in A0
                    }
                }

                Then output ans.

            Then the worst-case for one query is O( min(|A0|, |A1|) * log(max(|A0|,|A1|)) ). 

            In the worst-case, one set has 100,000 elements, then one query would be 100,000 * log(100,000) = 100,000 * 17 = 1.7e6.

            And if there are 50,000 queries of type1 with delta=1, then 50,000 * 1.7e6 = 85e9, which is too slow.

        Alternatively, we can do the consecutive gap method and maintain the gaps in a global heap? 

            We maintain:

                std::set<std::pair<long long, int>> sorted;   // (value, id) 
                std::multiset<long long> candidate_gaps;   // only gaps for consecutive elements that have different colors.

            Steps for update (city i, new_value):

                Let old_value = old value of city i.

                // Step 1: remove old_value
                auto it = sorted.find({old_value, i});
                auto prev = it, next = it; 
                if (it != sorted.begin()) {
                    prev = prev_edge; 
                    // we'll remove the gap between prev and it, and the gap between it and next.
                }
                if (next is not the last) {
                    next = next_edge;
                }

                // But we need the neighbors: 
                Let left = the element before it, and right = the element after it.

                If left exists and right exists, then we add a new gap: (left.value, right.value) if they have different colors? 

                We remove the gap between left and it, and the gap between it and right.

                Then we remove it.

                // Step 2: insert new_value
                sorted.insert({new_value, i});
                it = sorted.find({new_value, i});
                // Find left and right neighbors.

                If left exists: then we add a gap (left.value, new_value) if they have different colors.
                If right exists: then we add a gap (new_value, right.value) if they have different colors.
                And if left and right exist, we remove the gap between left and right (if it was there).

                Then we maintain candidate_gaps as a multiset of all such gaps (for consecutive pairs with different colors).

                And the candidate for the query is the smallest gap in candidate_gaps.

            But note: the gap between two consecutive elements might be 0 if they have the same value? 

            Also, we must store for each city: its current value and its color (which doesn't change).

            How to check the color of a city in the sorted set? We have an array col[].

            Steps in pseudocode for removal:

                sorted_set: a set of (value, id) 
                gap_set: a multiset of gaps (values) for consecutive pairs that have different colors.

                removal(id, old_value):
                    Let it = sorted_set.find({old_value, id})
                    Let left = it - 1, right = it + 1   // if exist

                    // Remove the gaps: 
                    if (left exists):
                         gap = old_value - left.value
                         if (col[id] != col[left.id]): 
                              // This gap was in gap_set? 
                              gap_set.erase(gap_set.find(gap))
                    if (right exists):
                         gap = right.value - old_value
                         if (col[id] != col[right.id]):
                              gap_set.erase(gap_set.find(gap))
                    if (left exists and right exists):
                         gap_new = right.value - left.value
                         if (col[left.id] != col[right.id]):
                              gap_set.insert(gap_new)

                    sorted_set.erase(it)

                insertion(id, new_value):
                    sorted_set.insert({new_value, id})
                    it = sorted_set.find({new_value, id})
                    left = it-1, right = it+1

                    if (left exists and right exists):
                         gap_old = right.value - left.value
                         if (col[left.id] != col[right.id]):
                              gap_set.erase(gap_set.find(gap_old))

                    if (left exists):
                         gap = new_value - left.value
                         if (col[id] != col[left.id]):
                              gap_set.insert(gap)
                    if (right exists):
                         gap = right.value - new_value
                         if (col[id] != col[right.id]):
                              gap_set.insert(gap)

            Then for a query of type1 with delta=1: 
                if gap_set is not empty: 
                    ans = *gap_set.begin()
                else: 
                    // then there are no consecutive pairs with different colors? 
                    // but this should not happen if both A0 and A1 are nonempty? 
                    // but what if one set is empty? 
                    // In our gap_set, we only consider consecutive pairs, so if the entire set is one color, then gap_set is empty? 
                    // then we must return a big number? 

                However, if one of the sets is empty, then we cannot do the query? 

                But the graph is connected and both A0 and A1 are nonempty? Because the graph is bipartite and connected? 

                But note: it is possible that after updates, one set becomes empty? 

                    Example: only one city? 

                The problem says: from any city, it is possible to reach any other -> so n>=1.

                If n=1: 
                    Then A0: [city1] -> color0? 
                    A1: empty? 
                    Then for a query: if we are to compute min_{a in A0, b in A1} ... then we cannot? 

                Therefore, we must check: 

                    In a bipartite graph, if one of the sets is empty, then the condition for a query with delta=1 cannot be satisfied? 

                But note: in a connected bipartite graph with n>=1, we have at least one node. Then the set that contains the node is nonempty, but the other set might be empty? 

                    Example: n=1: then there is only one node, so the other set is empty. 

                Therefore, in the query, if we have delta=1 and one of the sets is empty, then there is no pair? 

                But wait: the condition for the same X: we require two cities a and b? 

                How can we get a city in the empty set? 

                Therefore, if A0 is empty or A1 is empty, then the query for delta=1 should not happen? 

                Actually, the query is: two businessmen start at B_i and C_i. 

                In a bipartite graph, if the entire graph has only one set (say A0), then what? 

                    That means the graph has only one node? Because if there is an edge, then we have two nodes of different sets. 

                Therefore, if n>=2, then both sets are nonempty? 

                But what if n=1? 

                    Then there is no road? But the input: M bidirectional roads, and it is guaranteed that from any city to any other -> so if n=1, then M=0.

                Then in the query: 
                    The businessmen start at B_i and C_i: 
                        If n=1, then B_i=C_i=1.

                    Then delta = (color[1]-color[1])%2 = 0 -> so we don't go into the else branch.

                Therefore, the else branch (delta=1) requires that both A0 and A1 are nonempty? 

                So in our gap_set, we can assume both sets are nonempty? 

                Then the gap_set should be nonempty? 

            But note: the gap_set might be empty if there are no consecutive pairs with different colors? 

                For example: 
                    A0: [1, 3, 5]
                    A1: [2, 4]

                Then the sorted list: [1,2,3,4,5]

                Consecutive pairs: 
                    1(A0) and 2(A1): gap=1 -> candidate
                    2(A1) and 3(A0): gap=1 -> candidate
                    3(A0) and 4(A1): gap=1
                    4(A1) and 5(A0): gap=1

                Then the gap_set = {1} -> min=1.

                But if we remove the value 2 and 4? 
                    Then we have: [1,3,5] -> all A0? 
                    Then consecutive pairs: 
                         1 and 3: same color -> not candidate
                         3 and 5: same color -> not candidate
                    Then gap_set is empty.

                And then the query would fail? 

                But in this case, A1 becomes empty, so the query should not happen? 

                But if we have a query with delta=1, we require to find a pair with one in A0 and one in A1, but A1 is empty -> then we should output a big number? 

                But the problem: the minimum over an empty set? 

                We must output the minimum difference, which would be infinity? 

                But the problem guarantees that the graph is connected and has n>=1, and the query has valid cities? 

                However, after updates, we might have A1 nonempty initially but become empty? 

                Example: 
                    n=2: city1: color0, city2: color1.
                    Then we update city2 to a new value? but we don't remove it from A1? 

                Actually, in an update: we remove the old value and insert the new value. The city remains in A1? 

                So the sets A0 and A1 are defined by the color of the city, not by its value. The value is updated, but the color is fixed.

                Therefore, the sets A0 and A1 are always the same size? (unless we remove a city, but we don't remove cities, only update values).

                And initially, both sets are nonempty (if n>=2) or if n==1 then only one set.

                Therefore, for a connected bipartite graph with n>=2, both sets are nonempty? 

            Then the gap_set should not be empty? 

                Why? Because the sorted list has at least one consecutive pair that spans the two sets? 

                Yes: the entire set is sorted, and if there is at least one element in A0 and one in A1, then there is at least one consecutive pair that has different colors? 

                Actually, not necessarily: consider 
                    A0: [1, 100]
                    A1: [50]

                Then the sorted list: [1,50,100]
                Consecutive pairs: 
                    1 (A0) and 50 (A1): gap=49 -> candidate
                    50 (A1) and 100 (A0): gap=50 -> candidate

                Then the gap_set has {49,50}. 

                But if we have:
                    A0: [1, 3]
                    A1: [2]

                Then consecutive pairs: 
                    1 and 2: gap=1 -> candidate
                    2 and 3: gap=1 -> candidate

            Therefore, the gap_set will always have at least one candidate if both sets are nonempty.

            Then for a query with delta=1, we output gap_set.begin()? 

        Summary for bipartite graph:

            Precomputation:

                - BFS to assign colors.

                - Build the sorted set of (value, id) for all cities, and an array for the current value of each city.

                - Build a multiset for the gaps between consecutive elements in the sorted set that have different colors.

                - Also, we need to initialize the gap_set: 
                      Sort all cities by value, then iterate and for each consecutive pair, if they have different colors, add the gap.

            Update (type0: city i to new_value):

                - Let old_value = current_value[i]
                - Remove (old_value, i) from the sorted set, and update the gap_set as described.
                - Set current_value[i] = new_value
                - Insert (new_value, i) and update the gap_set.

            Query (type1: B_i, C_i):

                - delta = (color[B_i] - color[C_i]) % 2   [if negative, adjust: (2 + ...)%2, but in bit we can do: (color[B_i] != color[C_i])? then delta=1, else 0]
                - If delta==0: output 0.
                - Else: output gap_set.begin()   // the smallest gap in the multiset

            Note: we must be careful with duplicates: if we have two elements with the same value and different colors, then the gap is 0? and we will have that in the gap_set.

        However, what if there are duplicates? 

            Example: two cities: city1: value=10, color0; city2: value=10, color1.

            Then the sorted set: 
                (10, id1), (10, id2)   -> we consider the order? 

            How do we insert? 

                We use a set by (value, id)? Then we can have duplicates in value? 

                Then consecutive pairs: 
                    (10, id1) and (10, id2): gap = 0, and they have different colors -> then we insert gap=0.

            Then the gap_set has 0.

            And the query outputs 0.

        This is correct.

        But note: if we have two cities with the same value and the same color, then the gap between them is 0, but they have the same color -> not added to gap_set? 

            But they are not consecutive if there is an element in between? 

            Actually, they might be consecutive? 

            Example: 
                (10, id1, color0), (10, id2, color0): 
                    We store: (10,id1), (10,id2) -> but if we compare by value, they are equal, so we break by id? 

                Then consecutive: 
                    (10,id1) and (10,id2): gap=0, but both color0 -> skip.

        Therefore, we must break ties by id to ensure we have a total order? 

            We can store: 
                std::set<std::pair<long long, int>> sorted;   // (value, id)

            Then we can have multiple values with the same value, but distinct id.

        Steps for the sample update in the problem for the last query (1,1,6): 

            Initially: 
                All values: 
                    city1: 10 -> color0
                    city2: 0 -> color1
                    city3: 20 -> color0
                    city4: 11 -> color1
                    city5: 0 -> color1
                    city6: 0 -> color1

                Then sorted by value: 
                    (0,2), (0,5), (0,6), (10,1), (11,4), (20,3)

                Consecutive gaps with different colors:

                    (0,2:1) -> (0,5:1): gap=0, same color? -> skip.
                    (0,5:1) -> (0,6:1): gap=0, same -> skip.
                    (0,6:1) -> (10,1:0): gap=10, different -> add 10.
                    (10,1:0) -> (11,4:1): gap=1, different -> add 1.
                    (11,4:1) -> (20,3:0): gap=9, different -> add 9.

                Then gap_set = {1,9,10} -> min=1.

            Then the query (1,1,6): 
                B_i=1: color0, C_i=6: color1 -> delta=1 -> output 1.

            Correct.

        But what if we update city1 to 10 (no change) and then do the query? 

        Therefore, we design:

            Non-bipartite: 
                For type1: output 0.

            Bipartite: 
                Let delta = (color[B_i] != color[C_i])   [if true then 1, else 0]
                if delta==0: output 0
                else: 
                    if gap_set is empty: 
                         // should not happen, but in case, we output a big number? 
                    else: output the smallest gap in gap_set.

        Note: we must maintain the gap_set as a multiset to allow removal of specific gaps.

        In C++, we can use std::multiset, and to remove one occurrence: 
            auto it = gap_set.find(gap_value);
            gap_set.erase(it);

        But careful: if there are duplicate gaps, this only removes one.

        Also, we must not use a priority_queue because it doesn't support removal.

        We use a multiset for the gaps.

        Complexity: O(log n) per update for the sorted_set operations, and O(log n) for the multiset gap_set.

        Then total updates: O(q * log(n+q))

        And queries: O(1) for non-bipartite, and O(1) for bipartite (if we maintain the min gap separately? or we do gap_set.begin() which is O(1)).

        Actually, we can also maintain the minimum gap separately? 

            We can have a variable min_gap, but then if we remove a gap that is the min_gap, we need to update? 

        Alternatively, we use the multiset and then min = *gap_set.begin().

        This is O(1) if we store the begin()? 

        In std::multiset, begin() is O(1).

        Therefore, we can do.

        Finally, note: the graph might be non-bipartite? Then we don't need any of the gap_set.

        Implementation:

            Step 0: 
                Read n, m, the values, and the edges.

            Step 1: 
                Build an array color[1..n] and a flag is_bipartite = true.
                Do BFS/DFS to assign colors and check for an edge (u,v) with color[u]==color[v].

            Step 2:
                if is_bipartite:
                    Build:
                         sorted_set: a set of (value, id) for all cities, initially with the given values.
                         gap_set: a multiset of the gaps between consecutive elements in sorted_set that have different colors.

                    Precomputation for gap_set:
                         Insert all the initial values: 
                              std::set<std::pair<long long, int>> sorted_set;
                              for i=1..n: sorted_set.insert( {S[i], i} )

                         Then iterate through the sorted_set to build the consecutive gaps.

                    Also, we maintain an array current_value[1..n] = S[i]

                else: 
                    // nothing

            Step 3: 
                Read Q.

                For each query:
                    If the query is type0: 
                         update city i to new_value.

                         if the graph is non-bipartite: do nothing (but update the value for if later it becomes bipartite? no, the graph remains non-bipartite).

                         else (bipartite):
                              Let i = B_i (the city to update)
                              Let old = current_value[i], new = C_i.

                              // Remove the old value
                              //   Find the current element and its neighbors.
                              auto it = sorted_set.find({old, i});
                              auto prev = it, next = it;
                              if (it != sorted_set.begin()) prev = prev(it); else prev = null;
                              next = next(it); if (next is end) next = null;

                              // Also, we need the gap between prev and it, and between it and next, and between prev and next (if both exist)

                              // We'll simulate: 
                              vector<long long> gaps_to_remove;
                              vector<long long> gaps_to_add;

                              // If exists: prev and it: 
                              if (prev) {
                                  gap_prev_it = it->first - prev->first;
                                  if (col[i] != col[prev->second]) {
                                      gaps_to_remove.push_back(gap_prev_it);
                                  }
                              }
                              if (next) {
                                  gap_it_next = next->first - it->first;
                                  if (col[i] != col[next->second]) {
                                      gaps_to_remove.push_back(gap_it_next);
                                  }
                              }
                              if (prev && next) {
                                  gap_prev_next = next->first - prev->first;
                                  if (col[prev->second] != col[next->second]) {
                                      gaps_to_add.push_back(gap_prev_next);
                                  }
                              }

                              // Then remove the element.
                              sorted_set.erase(it);

                              // Now, insert the new_value: 
                              sorted_set.insert({new_value, i});
                              it = sorted_set.find({new_value, i});
                              // Find the new neighbors: 
                              auto prev = it, next = it;
                              if (it != sorted_set.begin()) prev = prev(it); else prev = null;
                              next = next(it); if (next is end) next = null;

                              if (prev) {
                                  gap_prev_it = new_value - prev->first;
                                  if (col[i] != col[prev->second]) {
                                      gaps_to_add.push_back(gap_prev_it);
                                  }
                              }
                              if (next) {
                                  gap_it_next = next->first - new_value;
                                  if (col[i] != col[next->second]) {
                                      gaps_to_add.push_back(gap_it_next);
                                  }
                              }
                              if (prev && next) {
                                  gap_prev_next = next->first - prev->first;
                                  // But we added the new element, so we broke the gap_prev_next? so we need to remove it if it was in gap_set?
                                  if (col[prev->second] != col[next->second]) {
                                      gaps_to_remove.push_back(gap_prev_next);   // because we will break it
                                  }
                              }

                              // Now update gap_set: 
                              for (auto gap: gaps_to_remove) {
                                  auto it_gap = gap_set.find(gap);
                                  if (it_gap != gap_set.end()) {
                                      gap_set.erase(it_gap);
                                  }
                              }
                              for (auto gap: gaps_to_add) {
                                  gap_set.insert(gap);
                              }

                              // Update current_value[i] = new_value

                    Else (type1: B_i, C_i):
                         if the graph is non-bipartite: 
                              output 0
                         else:
                              if (color[B_i] == color[C_i]): 
                                  output 0
                              else:
                                  if gap_set is empty: 
                                      // This should not happen, output 0? or an error?
                                      // But we assume both sets are nonempty, so gap_set should be nonempty.
                                      output 0   // or output the min gap in the entire set? but we have gap_set, so if empty, we try to compute the minimum gap by scanning? 
                                      // Actually, we have the gap_set, so if empty, it means there's no pair? but that should not happen.
                                  else:
                                      output *gap_set.begin()

        However, note: the gap_set stores gaps for consecutive elements, and the minimum gap is the minimum in the gap_set. 

        This should be the minimum gap between any two values in A0 and A1? 

        Therefore, we output that.

        But note: the gap_set may contain a zero? which is the best.

        This solution should work.

        Let's hope.

        Note: In the bipartite BFS, we use node1 as the start.

        But the cities are 1-indexed.

        We assume the graph is connected? yes.

        We'll do:

            queue = {1}
            color[1]=0
            while queue not empty:
                u = queue.pop()
                for each neighbor v of u:
                    if not visited: 
                         color[v] = color[u]^1
                         visited[v]=true, push v.
                    else:
                         if color[v] == color[u]: then is_bipartite=false.

        But note: the graph is connected.

        This concludes the editorial.

        Note: The solution for non-bipartite is very efficient: output 0 for every type1 query.

        For bipartite, we have to maintain the sorted_set and gap_set, which is O(n log n) for initialization and O(q log n) for updates.

        The total time is O((n+q) log n) which is acceptable for n,q<=100,000.

        We output the answer for each type1 query accordingly.

        We hope this covers all cases.

        Let's run the sample as described above.

        Note: the sample is bipartite.

        We are done.