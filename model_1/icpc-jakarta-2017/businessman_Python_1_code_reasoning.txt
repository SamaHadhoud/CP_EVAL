 We are going to implement the solution as described in the editorial.
 Steps:
 1. Read input: N, M, the list of economic values, and the graph edges.
 2. Check if the graph is bipartite using BFS. We'll color the graph and if we find an edge connecting two same colors, the graph is not bipartite.
 3. If the graph is not bipartite, then for every query of type 1, we output 0 (because they can meet at the same city eventually).
 4. If the graph is bipartite:
    - We maintain two sorted lists (or sets) for each color? Actually, we can use one sorted set of (value, node) for all nodes, but we also need the color of each node to compute adjacent gaps only for different colors.
    - We also maintain a multiset (or a heap) of the gaps that are between two consecutive values in the sorted set and that are of opposite colors.

 However, note: the gap we care about is the absolute difference between two values of opposite colors. But the sorted set is sorted by value. We can store the entire set and then for each new insertion, we consider the neighbors (prev and next) and update the gaps that are between opposite colors.

 How to update:
   We maintain:
     sorted_set: a sorted set of (value, node) for all nodes.
     gap_set: a multiset (min-heap or sorted list? but we need to remove arbitrary gaps) of the gaps that are between two consecutive elements in sorted_set that are of opposite colors.

   When updating a node (B_i) from old_value to new_value:
     Step 1: Remove the old_value from sorted_set. But before removal, we note the neighbors (prev and next) and remove the gaps that involve the old_value and its neighbors (if they are opposite in color) and also the gap between the neighbors (if they exist and are opposite) which we will then add back when the old_value is removed? Actually, when we remove the old_value, we break the chain. So:
        - Remove the gap between the old_value and its left neighbor (if exists and opposite colors) from gap_set.
        - Remove the gap between the old_value and its right neighbor (if exists and opposite colors) from gap_set.
        - Then, if the left and right neighbors exist, we add the gap between them (if they are opposite colors) to gap_set? Actually, when we remove the old_value, the left and right become consecutive? So we add the gap between left and right if they are of opposite colors? But note: we had not stored that gap because there was an element in the middle.

     Step 2: Insert the new_value. Then we do the reverse:
        - Remove the gap between left and right (if they are consecutive and opposite) that we might have added when removing? Actually, when we remove the old_value, we broke the chain and then we added the gap between left and right. Now when we insert, we break the left-right gap? So we must remove that gap (if we had added it) and then add the gaps: left to new and new to right.

   However, we must be cautious: the left and right neighbors of the new_value in the sorted_set after insertion.

   Alternatively, we can do:

   Removal:
     Let it = pointer to (old_value, B_i)
     Let left = the element immediately before it (if exists)
     Let right = the element immediately after it (if exists)

     Then:
        If left exists and the color of left's node and the current node (B_i) are different, then remove the gap (old_value - left.value) from gap_set.
        If right exists and the color of right's node and the current node (B_i) are different, then remove the gap (right.value - old_value) from gap_set.
        If both left and right exist and the color of left's node and right's node are different, then add the gap (right.value - left.value) to gap_set.

   Insertion:
     Insert the new_value and get an iterator to it (it_new).
     Let left = the element immediately before it_new (if exists)
     Let right = the element immediately after it_new (if exists)

     Then:
        If both left and right exist and the color of left's node and right's node are different, then remove the gap (right.value - left.value) from gap_set (because we break the consecutive chain of left and right by inserting in the middle).
        If left exists and the color of left's node and the current node (B_i) are different, then add the gap (new_value - left.value) to gap_set.
        If right exists and the color of the current node (B_i) and right's node are different, then add the gap (right.value - new_value) to gap_set.

  But note: the gap between left and right was stored in the gap_set only when they are consecutive? Yes, and when we insert a new element between them, they are no longer consecutive? Actually, we had stored that gap when we removed the old_value? But that was for a different update. Actually, we must consider the state at the moment.

  Actually, after removing the old_value, the left and right become consecutive? So we added the gap between them (if they are opposite) at removal. Now when inserting the new_value, we break that consecutive chain? So we must remove the gap between left and right (if we had added it) and then add the gaps: left to new and new to right (if they are opposite).

  However, note: we only add the gap between left and right at removal if they exist and are of opposite colors. Then at insertion we remove that same gap? But what if the new_value is inserted between them? Then we break the consecutive chain? So we remove the gap between left and right that we had added at removal? But note: we are going to insert the new_value and then we break the consecutive pair (left, right) so that gap must be removed.

  But wait: we are going to remove the old_value and then later insert the new_value. In between, the set does not have the old_value. Then when we insert the new_value, we are inserting at a different position? Actually, the new_value might be different from the old_value, so the position might be different.

  Therefore, we must do:

   Removal:
     Let node = B_i, old_val = old_value
     Find the element (old_val, B_i) in sorted_set -> it_old.
     Let left = prev(it_old) if exists, and right = next(it_old) if exists.

     Then:
        If left exists and color[left->second] != color[B_i]:
            gap_set.remove(|left->first - old_val|)   -> actually we store the absolute difference? But our sorted_set is sorted by value, so we have: left->first <= old_val <= right->first? So the gap is old_val - left->first (non-negative) and right->first - old_val (non-negative). But we stored the absolute difference? Actually, the gap is computed as (right->first - left->first) only for consecutive? No, we stored the gap between consecutive elements that are of opposite colors.

        Actually, in our initial setup, we stored the gap between consecutive elements in the sorted_set only if they are of opposite colors. So the gap is (right->first - left->first) for consecutive in the sorted_set? But we stored the gap between consecutive pairs? So we stored the gap between (a, b) and (b, c) as (b-a) and (c-b). Then when we remove b, we break the two gaps and then we create a new gap (c-a) if a and c become consecutive? But note: we stored gaps between consecutive pairs? Actually, we stored every consecutive gap that is between opposite colors. Then when we remove an element, we remove the two gaps that involve the element and then add the gap that spans the left and right? But that gap might not have been there before.

   How we built the gap_set initially?
        We iterate through the sorted_set and for each consecutive pair (a, b) in the sorted_set, if the two nodes of a and b have different colors, we insert the gap (b.value - a.value) into gap_set.

   Then when updating:

        Removal:
          Remove the consecutive gaps: (left, old) and (old, right) from gap_set (if they exist and the colors are opposite).
          Then, if left and right exist (so they become consecutive after removal) and the colors of left and right are different, we add the gap (right.value - left.value) to gap_set.

        Insertion:
          First, we note that after removal, the set is without the old_value. Then we insert the new_value at a position that we find by insertion. Then we get the neighbors: left and right (the immediate neighbors in the sorted_set after insertion).

          Then we break the consecutive gap between left and right (if they exist and their colors are different) by removing the gap (right.value - left.value) from gap_set.
          Then we add the gaps: (new_value - left.value) if left exists and the colors of left and the node are different, and (right.value - new_value) if right exists and the colors of the node and right are different.

        However, note: when we remove the old_value, we break the chain and then we add the gap between left and right (if opposite). Then when we insert the new_value, we break that gap? But the new_value might not be inserted between the same left and right? Actually, the new_value could be inserted anywhere.

        So we do:

          Step 1: Remove the old_value and update the gap_set for the neighbors that become consecutive (left and right) and for the gaps that are broken (left to old and old to right).

          Step 2: Insert the new_value and then update the gap_set: break the consecutive pair (left, right) that now has the new_value in between? Actually, we need to know the left and right of the new_value. Then we remove the gap between left and right (if they were consecutive and opposite) and then add the gaps from left to new and from new to right (if the colors are opposite).

        But note: the new_value might be inserted at the beginning or the end.

        Implementation:

          Removal of old_value (v_old) at node u (B_i):
            Let it = sorted_set.find((v_old, u))
            Let left = None, right = None.
            If it is not the first element, then left = element immediately before it.
            If it is not the last element, then right = element immediately after it.

            Then:
              if left exists and (color[left.second] != color[u]):
                  gap_set.gap_set.remove(v_old - left.first)   -> but we store the absolute difference? Actually, because the set is sorted, left.first <= v_old, so the gap is v_old - left.first.

              if right exists and (color[u] != color[right.second]):
                  gap_set.gap_set.remove(right.first - v_old)

              if left exists and right exists and (color[left.second] != color[right.second]):
                  gap_set.insert(right.first - left.first)

            Then remove the element.

          Insertion of new_value (v_new) at node u (B_i):
            Insert (v_new, u) into sorted_set -> it_new
            Find left: the element immediately before it_new (if exists) and right: the element immediately after it_new (if exists)

            Then:
              if left exists and right exists and (color[left.second] != color[right.second]):
                  // They were consecutive? Then we are going to break them? So we remove the gap between them?
                  gap_set.gap_set.remove(right.first - left.first)

              if left exists and (color[left.second] != color[u]):
                  gap_set.insert(v_new - left.first)

              if right exists and (color[u] != color[right.second]):
                  gap_set.insert(right.first - v_new)

          But wait: what if the new_value is inserted at the beginning? Then left doesn't exist. Similarly for the end.

        However, note: when we remove the old_value, we added a gap between left and right? Then when we insert the new_value, we break that gap? But the new_value might be inserted at a different position? So we cannot assume that the left and right in the insertion step are the same as in the removal step.

        Therefore, we must do the removal and insertion independently.

        But note: the removal and insertion are two separate operations. The removal is done first, then the insertion. The set is updated.

        This update procedure is standard for maintaining a sorted set and adjacent gaps.

 5. For query type 1: 
        if color[B_i] == color[C_i]: output 0.
        else: 
            if gap_set is empty: output 0? Actually, if there is no gap? But what if there is only one element? Then gap_set is empty? Then we output 0? But that doesn't make sense. Actually, the gap_set only contains consecutive gaps? So the minimum gap is the minimum consecutive gap of opposite colors? But what if the minimum absolute difference is not consecutive? 

        Actually, we are storing consecutive gaps? Then the minimum gap in gap_set is the overall minimum? Why? Because the values are sorted. The minimum absolute difference between two values of opposite colors must be achieved by two consecutive values in the sorted set? 

        Why? Consider: 
          We have three numbers: a, b, c (with a<=b<=c) and two colors: 
          Suppose the two colors: 
             a: color1, b: color2, c: color1.
          Then the gap between a and c is |a-c| = c - a = (c-b) + (b-a). 
          But if (b-a) is the gap between a and b and (c-b) is the gap between b and c, then the gap between a and c is the sum of the two. 
          However, we are storing consecutive gaps. Then the minimum gap in the gap_set would be min(b-a, c-b). But the gap between a and c is larger. 

          However, note: we are only storing gaps between consecutive elements? Then the minimum gap we store is the minimum consecutive gap? But the overall minimum absolute difference between two numbers of opposite colors is the minimum consecutive gap? 

          Why? Because if we have two numbers a and c (non consecutive) and they are of opposite colors, then there is a number b in between. Then the gap between a and b and between b and c must be at least the gap between a and c? Actually, no: the gap between a and c is |a-c|, which is |a-b|+|b-c|, so it is larger than the minimum consecutive gap. Therefore, the minimum absolute difference must be one of the consecutive gaps? 

          However, what if the consecutive gaps are not between opposite colors? Then we skip them. But then we have to look at non consecutive? 

          Actually, we are storing only consecutive gaps that are of opposite colors? Then the minimum gap in the gap_set is the minimum absolute difference? 

          But what if the minimum absolute difference is achieved by two non consecutive values? Then there must be consecutive values in between that are closer? 

          Example: 
            Values: [1, 3, 5] and colors: [0, 1, 0]. 
            Then consecutive gaps: |1-3|=2, |3-5|=2. 
            The gap between 1 and 5 is 4, which is larger. 
            But what if: [1, 2, 5] and colors: [0, 1, 0]? 
            Then consecutive gaps: |1-2|=1, |2-5|=3. 
            The gap between 1 and 5 is 4 -> but the minimum gap is 1 (from 1 and 2). 

          What if: [1, 4, 5] and colors: [0, 0, 1]? 
            Then consecutive gaps: |1-4|=3 (same color -> not stored) and |4-5|=1 (different color -> stored). 
            The gap between 1 and 5 is 4 -> but the stored gap is 1. 

          What if: [1, 3, 4, 6] and colors: [0,1,0,1]? 
            Consecutive gaps: 
              1-3: 2 -> opposite? color0 and color1 -> store 2.
              3-4: 1 -> opposite? color1 and color0 -> store 1.
              4-6: 2 -> opposite? store 2.
            The minimum gap is 1. 
            But what about 1 and 4? |1-4|=3 -> not minimal. 
            What about 3 and 6? |3-6|=3 -> not minimal. 

          Therefore, the minimum gap must be one of the consecutive gaps? Because the set is sorted and the absolute differences between non consecutive elements are the sum of the consecutive gaps in between? So they are at least as big as the minimum consecutive gap.

        So we can safely take the minimum gap in the gap_set? 

        However, note: the gap_set might be empty? Then that means there are no two nodes of opposite colors? But that is impossible because the graph is connected and bipartite, and we have at least two colors? Actually, if the graph is bipartite and has only one node? But N>=1. However, the problem says at least one query of type 1. But the graph has N>=1 and M>=1? Actually, the constraints: N>=1, M>=1? Actually, M can be 0? But the problem says: "from any city, it is possible to reach any other cities", so the graph is connected. And N>=1.

        But if N=1? Then we have one node. Then the graph is bipartite? Yes. Then for a query of two cities: but the two businessmen must start at the same city? Then if we have a query (1, 1, 1) -> but the businessmen start at city 1? Then they are the same color? So we output 0.

        But if we have no consecutive pair of opposite colors? Then gap_set is empty. Then we output 0? But actually, the gap_set is built from consecutive pairs? So if there is only one node, gap_set is empty. Then for a query (1, 1, 1) we output 0. But also for a query (1, 1, 2) when there is only one node? Actually, the input: the two businessmen start at city 1 and city 2? But if N=1, there is no city 2? So we assume the input is valid.

        Actually, the input says: for a query of type 1, we have 1<=B_i, C_i<=N. So if N=1, then both B_i and C_i must be 1.

        Therefore, we can say: for bipartite graph and when the two starting cities are of different colors, we output the smallest gap in gap_set? But if gap_set is empty? Then there are no two nodes of opposite colors? How? The graph is bipartite and has at least two nodes? But if the graph has only one node? Then we never get a query with two different nodes? Or if the graph has two nodes and they are the same color? Then we wouldn't store any gap? But wait: the graph is bipartite and we colored the graph. The graph has two nodes? Then they must be different colors? Because the graph is connected and bipartite? Actually, if there is an edge between two nodes, then they must be different colors.

        So the gap_set should be non-empty? Actually, no: if we have two nodes and they are consecutive in the sorted_set? Then we store the gap. But if we have two nodes and they are of different colors? Then we store the gap.

        However, what if we have two nodes and then we update one to be the same as the other? Then the gap becomes 0? Then we store 0. Then the minimum gap is 0.

        Therefore, we can output:

          if gap_set is not empty: *gap_set.begin()
          else: 0   -> but we have to consider: if there are no consecutive gaps? Then there are no two nodes of opposite colors? But that is impossible because the graph has at least one edge? Actually, the graph has M>=1, so at least two nodes? Then we have at least two nodes of opposite colors? Then we must have at least one gap? 

        But wait: if we have two nodes with the same value? Then the consecutive gap is 0? Then we store 0. Then the minimum gap is 0.

        However, if we have more than two nodes? Then we have consecutive gaps? 

        Therefore, we can output:

          if gap_set is empty: then 0? But that should not happen? Actually, it might happen if the graph is bipartite and we have no consecutive pair of opposite colors? But we store every consecutive pair that are of opposite colors? And if the graph is bipartite and connected, then every edge connects two opposite colors? But the consecutive pairs in the sorted_set might not be adjacent by an edge? But we are storing by the sorted value. 

        But we are storing every consecutive pair in the sorted_set that are of opposite colors? So if the entire set alternates? Then we have gaps? 

        Actually, if there is at least two nodes, then we have at least one consecutive pair? But if the two nodes are the same value? Then they are consecutive? And if they are different colors, we store 0. 

        However, if the two nodes have the same value, then they are consecutive? Then we store 0? 

        But if we have three nodes: [10 (color0), 10 (color1), 10 (color0)]? Then the consecutive gaps: 
          10 and 10: gap=0 (color0 and color1) -> store 0.
          10 and 10: gap=0 (color1 and color0) -> store 0.

        Then the gap_set has two zeros.

        Then the minimum gap is 0.

        Therefore, we can output the smallest gap in the gap_set? 

        But note: the gap_set might have duplicates? So we use a multiset.

        Implementation of gap_set: we use a multiset? Then we can remove one occurrence at a time? But we have to be careful: when we remove a gap, we remove one occurrence? Because the same gap value might appear multiple times? 

        However, each consecutive pair is unique? So each gap we add is a distinct consecutive pair? Then we remove the exact gap we added? 

        But the same gap value (say 5) might appear from multiple consecutive pairs? Then we cannot remove by value? We have to remove one occurrence? 

        Actually, we can use a multiset and use:

          gap_set.erase(gap_set.find(gap_value))

        But note: if the same gap_value appears multiple times, then we only remove one occurrence? 

        However, each consecutive pair is stored once. So we remove one occurrence of that gap_value.

        But caution: if the same gap_value appears from two different consecutive pairs? Then we remove one occurrence? But we must remove the one we added? Actually, we are storing the gap_value. We don't care which consecutive pair? We just want the multiset to have the same gaps as the consecutive pairs that are of opposite colors? 

        So we do:

          Removal of a gap_value: 
             auto it_gap = gap_set.find(gap_value);
             if (it_gap != gap_set.end()) gap_set.erase(it_gap);

        Then when we add a gap_value, we do gap_set.insert(gap_value).

        Then the minimum gap is *gap_set.begin().

 6. We also note: the update might change the value of a node? Then we remove the old and insert the new.

 7. We must store the current value for each node.

 Implementation in Python:

   We are constrained: N, M, Q up to 100,000, and M up to 200,000.

   We use:
      sorted_set: we can use sorted list and use bisect? But we need to remove and insert and get neighbors? We can use the sorted list from the sortedcontainers? But we cannot use external libraries.

   Alternatively, we can use the "bisect" module to maintain a sorted list. But then we have to handle removals and insertions (O(n) each). But Q can be 100,000 -> worst-case 200,000 operations? Then O(200000 * 200000) is too slow.

   We need O(log n) per update.

   How about using a balanced BST? In Python, we can use the "bisect" with a list but then the insertion and deletion are O(n). Alternatively, we can use a balanced BST? We don't have one in the standard library.

   Alternatively, we can use two heaps? But that doesn't give neighbors.

   Or we can use a SkipList? We don't have one.

   Or we can use a Fenwick tree? Not for this.

   Actually, we can use the "sorted list" from the "sortedcontainers" is not standard.

   Therefore, we might have to use a balanced BST that we build? That is too complex.

   Alternatively, we can use a set and then when we need neighbors, we use bisect on a sorted list? But then updating the sorted list for every update would be O(n) per update? Then worst-case O(n*Q) which is 100,000 * 100,000 = 10^10 -> too slow.

   We need a data structure that supports:

        insertion: O(log n)
        deletion: O(log n)
        finding neighbors: O(log n)

   We can use a balanced BST? In C++ we had set. In Python, we can use the "sorted list" from the "sorted_list" module? But the problem says to write in Python and we cannot use non-standard modules.

   Alternative: we can use a balanced BST using the "bisect" module if we use a Fenwick tree? No.

   Actually, we can use the "SortedList" from the "sortedcontainers" is not available.

   We can use a balanced BST by using the "bisect" module and maintaining a sorted list? Then insertion and deletion are O(n). But we have 100,000 updates? Then worst-case 100,000 * 100,000 = 10^10 -> too slow.

   We need a better way.

   Alternatively, we can use two balanced BSTs: one for color0 and one for color1? Then the gap_set is the minimum gap between any node in color0 and any node in color1? But that is the minimum absolute difference. Then we can maintain:

        set0 = sorted list of values for color0
        set1 = sorted list of values for color1

        Then the minimum absolute difference between set0 and set1 can be found by iterating over one set and doing a binary search in the other? But that is O(n log n) per query? Then worst-case 100,000 * log(100000) * (100000) -> 100000 * 16 * 100000 = 160e6 which might be borderline in Pyton? But the problem says 2 seconds? And we have 100,000 queries? Then 100,000 * 100,000 = 10e9, which is too slow.

   Alternatively, we can maintain the overall minimum gap? But the gap_set we described earlier (with consecutive pairs) is efficient because the minimum gap must be consecutive? Then we can maintain a global heap for the gaps? But we need to update gaps when updating a node? Then we have to update the gaps that are adjacent to the updated node? 

   How about: we store for each node, the neighbors in the sorted list? Then we update the gaps? But we have to update the gaps of the neighbors? Then we have to update the gaps of the neighbors of the neighbors? That becomes messy.

   Actually, the method we described earlier (with a multiset of consecutive gaps) is efficient. But we need an efficient sorted set that supports insertion, deletion, and neighbor access in O(log n). In Python, we can use the "bisect" module to maintain a sorted list, but insertion and deletion are O(n). However, we have 100,000 updates? Then worst-case 100,000 * 100,000 = 10e9 operations? That is too slow in Python.

   We must find a better way.

   Alternatively, we can use a balanced BST with a Fenwick tree or segment tree? Not directly.

   We can use a balanced BST by using the "avl" or "bintrees" but they are not standard.

   We can use the "rbtree"? Not in standard.

   Therefore, we must use the sorted list and hope that the total number of updates is not too high? But worst-case 100,000 updates, each O(n), then total O(100000 * 100000) = 10e9 -> too slow.

   We need a different approach for bipartite graphs? 

   Alternative approach for bipartite graphs:

        We maintain two sets: set0 and set1 (sorted) for the values of the two colors.

        We also maintain a global set (or heap) that holds the minimum absolute difference between any two elements in set0 and set1? 

        How to update? 
          When updating a node u from old_value to new_value, and the color is c (0 or 1), then we remove old_value from set_c and insert new_value into set_c.

        Then the minimum gap can be computed by:

          min_gap = min( 
              min_gap_set0,   # the minimum gap within set0? But we don't care about same set? Actually, we care about the gap between set0 and set1.
              min_gap_set1,   # not needed.
              ... 
          )

        Actually, we can maintain:

          global_min = min( 
              min { |a - b| for a in set0 and b in set1 }
          )

        How to update the global_min when updating one element? 

          We can maintain a data structure that supports:

             insert(value, set_id) 
             remove(value, set_id)

          and then query the minimum absolute difference between set0 and set1.

        We can use two balanced BSTs? Then for each value in set0, we can find the closest value in set1? Then the minimum gap is the minimum over the closest pairs.

        But we can maintain a Fenwick tree? The values can be up to 10^9.

        Alternatively, we can use two heaps? Not straightforward.

        Another idea: we maintain the entire set of values? Then the minimum gap between set0 and set1 is the minimum gap in the entire set of values? But no: because two values in the same set do not count? 

        Actually, we can store all values in one sorted list? And then the minimum gap between set0 and set1 is the minimum gap between two consecutive values that are in different sets? That is the same as our consecutive gap in the entire sorted list? 

        Then we are back to the consecutive gap method? 

        Therefore, we must maintain the consecutive gaps in the entire sorted list? 

        How to do that efficiently in Python? 

        We can use a sorted list of (value, color, node_id) and then we also maintain the consecutive gaps that are of different colors? 

        We can use a heap for the gaps? But we also have to remove gaps? 

        We can use a heap that supports lazy deletion? Then we can push events (gap_value, left_index, right_index) and then when we update, we mark the old gaps as invalid? Then the top of the heap might be invalid? Then we pop until valid.

        Steps:

          We maintain:
             sorted_list: a list of (value, color, node_id) sorted by value? But we update by node_id? 

          Actually, we don't need to store the entire list? We can maintain the sorted list and also a dictionary for the current value and color for each node.

          Then we also maintain a heap: min_heap for the gaps (min gap at top) and a set (or dictionary) of gaps that are currently valid? 

          Alternatively, we can use a lazy heap: 

            heap: min-heap for the gaps (gap_value, left_value, right_value, left_node, right_node) ? But we can index by the nodes? Actually, we need to remove gaps that are broken.

          Alternatively, we can store for each consecutive pair (i, i+1) in the sorted_list: 
                gap = value[i+1] - value[i]
                and store an id for the gap: (i, i+1)

          Then when updating a node, we break the consecutive pairs that are adjacent to the updated node? Then we update the gaps for the adjacent pairs? 

          How to update? 
             We store:
                arr: the sorted list of (value, color, node) and also an array of indices? 
                We also maintain pointers: for each node, its current index in the sorted_list? 

          Then when updating a node u:

             Step 1: Remove the old value: 
                 Find the index i of the node u in the sorted_list? 
                 Then the adjacent gaps are: (i-1, i) and (i, i+1). We remove these two gaps (if exist) and then we create a new gap (i-1, i+1) (if both exist).

             Step 2: Remove the element at index i.

             Step 3: Insert the new value: 
                 Insert the new value at the correct position? Then we break the gap (j, j+1) at the insertion point? Then we add gaps (j, new) and (new, j+1).

          But we need to update the gaps in the heap? 

          We can maintain:

             heap: a min-heap of (gap, left_index, right_index) but then we have to update the indices? 

          Actually, the consecutive pairs are defined by the current sorted_list. We can store for each consecutive pair (from the current sorted_list) a tuple (gap, left_node, right_node) and then we store in a dictionary: keyed by (left_node, right_node) and also we store the gap? 

          Then when we update a node u:

             We know the node u is being updated. Then we look at the left neighbor and the right neighbor in the sorted_list? 

          Steps for removal:

             Let the current node u is at position i. 
             Let left = i-1 (if exists) -> node L
             Let right = i+1 (if exists) -> node R

             Remove the gap (L, u) and (u, R) from the dictionary and mark them as invalid? 

             Then if L and R exist, create a new gap (L, R) = |value[L]-value[R]|? Actually, no: we have the sorted_list: value[R] - value[L] (since R is the next of L). Then we add the gap (L,R) and push it to the heap.

          Then remove the node u from the sorted_list and update the indices? Actually, the indices of the elements after i shift? Then we have to update the entire list? That is O(n).

        Alternatively, we do not store by index? We store by node id for the gaps? 

          We maintain:
            sorted_list: we maintain as a linked list? Then we can quickly update the neighbors? 

          We can use a balanced BST in Python? We cannot.

        Given the constraints in Python, we might have to use the sorted list and do O(n) per update? Then worst-case 100,000 * 100,000 = 10e9, which is too slow in Python.

        Therefore, we must hope that the test data is not worst-case? Or use a different language? But the problem says to write in Python.

        We must find a better way.

        Insight: the consecutive gaps we care about are only between nodes of opposite colors. And we only need the global minimum gap.

        We can maintain:

            global_min_gap = a variable that holds the current minimum gap? 

        But how to update it when we update a node? 

        Alternatively, we can use a heap with lazy deletion:

            We maintain a min-heap for the gaps (gap_value, left_node, right_node) for every consecutive pair in the sorted_list that are of opposite colors.

            We also maintain a dictionary (or set) of edges (consecutive pairs) that are currently valid.

            Then when we update a node u:

               We remove u: 
                  We invalidate the gaps that involve u: (prev, u) and (u, next) -> remove them from the valid set and push them out later by lazy deletion.

                  Then we create a new gap (prev, next) if they exist and are of opposite colors, and push that gap into the heap.

               We insert u with the new value:
                  We find the position in the sorted_list (by binary search) and then break the gap (L, R) (if exists) and create two new gaps: (L, u) and (u, R) (if they exist) and if the colors are opposite, push them.

            Then for query, we pop from the heap until we find a gap that is currently valid? 

            How to check validity? We can store for each consecutive pair (left, right) a version number? Or we can store in a dictionary: valid[(left, right)] = True/False.

            Steps:

               Let's maintain:
                 sorted_list: a sorted list of (value, color, node) -> we update this list by binary search and insertion/deletion? But insertion and deletion in a list is O(n).

               We also maintain a dictionary: node_to_index: for each node, its current index in the sorted_list? But then when we insert or delete, the indices change? So we have to update the entire dictionary? O(n) per update.

            Alternatively, we can store a balanced BST in a list is not efficient.

        Given the time, and the constraints in Python, we might have to use a different approach.

        Another approach: use two balanced BSTs (for set0 and set1) and then for each new value inserted in set0, we query the closest value in set1? Then update the global min_gap? 

          We maintain:
             set0 = a sorted list for color0
             set1 = a sorted list for color1
             global_min = a variable with the current minimum gap? But we can update it by: 
                 global_min = min(global_min, new_gap) when inserting? But when removing, we have to recalc the entire global_min? 

          Or we can use a heap for the gaps? But then we have to remove gaps that are broken.

        We can maintain a separate heap for the gaps that are currently valid? 

          But then the global minimum gap is the minimum gap between set0 and set1? We can maintain a heap for the gaps between set0 and set1? But that is O(n^2) to initialize.

        Alternatively, we can know that the minimum gap is the minimum of the following:

          For a value x in set0, the minimum gap is min( 
               |x - y1|, 
               |x - y2|, 
               ... 
          ) where y are in set1? And the minimum for x is the minimum of the two closest values in set1? 

          We can maintain for set0 and set1 as two balanced BSTs that support finding floor and ceiling? 

          Then for each node update in set0, we can find the floor and ceiling in set1 and then update the candidate gaps? 

          But then we also have to update the gaps for the neighboring values in set0 that are close to values in set1? 

        This becomes complex.

        Given the complexity and the constraints in Python, we decide to use the consecutive gap method with a sorted list and lazy heap. We will maintain:

          sorted_list: a list of tuples (value, color, node) sorted by value. 
          We also maintain an array (or list) of the current value and color for each node.

          We also maintain a heap (min-heap) for the gaps: each gap is a tuple (gap_value, left_node, right_node) for consecutive pair (left_node, right_node) in the sorted_list that are of different colors.

          We also maintain a dictionary: invalid_dict: keyed by (left_node, right_node) to mark if the gap between left_node and right_node is invalid.

          Additionally, we maintain for each node, its current value and color.

        Steps for update of node u from old_value to new_value:

          Step 1: Find the index of the node u in sorted_list? We can maintain an array `index_in_sorted` of size N+1? But when we remove, the indices of the following elements change? 

          How to find the index? We can do a binary search in sorted_list by (old_value, ?, u) -> but there might be duplicate values? Then we have to store the node id? We can store (value, node, color) and then use node as unique? 

          So we store in sorted_list: (value, node, color)

          Then to find node u, we can do a binary search by value? But then there might be duplicates? Then we don't know the exact position? 

          We can maintain a separate dictionary: node_to_value and then we know the old_value? Then we can search for (old_value, u) in the sorted_list? But the list is sorted by value, then by node? We can include node in the tuple? 

          Actually, we can store: (value, node, color) and then sort by value, then by node (to break ties).

          Then we can find the element by (old_value, u) using bisect.

          Step 2: Remove the element at that index. Then we have to update the gaps:

             Let index = i.
             Let left = i-1: element at index i-1: (value_L, node_L, color_L) if i>0
             Let right = i+1: element at index i+1: (value_R, node_R, color_R) if i < len(sorted_list)-1

             Then the gaps to remove are:
                 gap1: between left and u: if left exists and color_L != color_u_old -> then we mark the gap (node_L, u) as invalid? and push an event to invalidate it? Actually, we remove it by marking it invalid.

                 gap2: between u and right: if right exists and color_u_old != color_R -> then mark (u, node_R) as invalid.

             Then if both left and right exist, and they are of different colors (color_L != color_R), then we add a new gap (node_L, node_R) with gap_value = value_R - value_L? And push it into the heap.

          Step 3: Insert the new_value for node u:

             We create a new tuple (new_value, u, color_u)  [note: color_u is fixed?]

             We find the new position j by bisect_left in sorted_list for (new_value, u) (using node as tie-breaker).

             Then we insert at j.

             Then we look at left = j-1: if exists, and right = j+1: if exists.

             We have to:

                 If left and right exist, then they are consecutive in the sorted_list? And we are breaking them? Then if they are of different colors, we have a gap between left and right? We must remove that gap (mark it as invalid) and then we will add the gaps (left, u) and (u, right) if applicable.

                 Specifically:

                    If left and right exist and we had a gap between left and right (if they are of different colors), then we mark the gap (node_left, node_right) as invalid.

                    Then we add gap between left and u: if color_left != color_u -> gap = new_value - value_left? Then push (gap, node_left, u) into the heap and also record that this gap is valid.

                    Then we add gap between u and right: if color_u != color_right -> gap = value_right - new_value, and push (gap, u, node_right) into the heap.

             But wait: how do we know if the gap between left and right exists? Because we might have pushed it earlier? And we have it in the heap? But we will use lazy deletion: we don't remove from the heap, we just mark it as invalid.

          Step 4: Push the new gaps.

        For a type-1 query: 
            if the two starting cities have the same color: output 0.
            else: 
                while the heap is not empty:
                   pop the top: (gap, left_node, right_node)
                   if the gap (left_node, right_node) is not marked as invalid, then:
                         answer = gap
                         break
                   else: 
                         continue
                if heap is empty: then output 0? 
                else: output answer

          But then we push the top back? Or not? Actually, we want the minimum valid gap. We can do lazy deletion: 

            while heap is not empty and the top gap is invalid (check by a dictionary: invalid_dict.get((left_node, right_node), False) or invalid_dict.get((right_node, left_node)? but our gap is stored with left_node and right_node in sorted order by node id? Actually, we store with left_node and right_node as in the consecutive pair? And we always store with left_node being the one with smaller value? Not exactly: but in the sorted_list, left_node has smaller value than right_node? So we store (left_node, right_node) as the key.

          We can store the gap in the heap as (gap, left_node, right_node) and then we maintain a set (dictionary) `invalid` for the tuples (left_node, right_node) that are invalid.

        Steps for update and for query:

          We maintain:
            sorted_list = []  # sorted list of (value, node, color)
            heap = []   # min-heap for gaps: (gap, left_node, right_node)
            invalid = {}  # dictionary: key: (left_node, right_node) -> we don't care the value, we only care that it is in the set.

          We also maintain an array `cur_val` for the current value of each node, and `color` for each node (fixed).

          Initialization:

            sorted_list = sorted([ (S[i], i, color[i]) for i in range(1, N+1) ])   # by value, then by node? 
            Then traverse sorted_list to initialize the heap and also record the consecutive gaps that are of opposite colors.

            For i in range(len(sorted_list)-1):
                left = sorted_list[i]
                right = sorted_list[i+1]
                if left[2] != right[2]:   # different colors
                    gap_val = right[0] - left[0]
                    heapq.heappush(heap, (gap_val, left[1], right[1]))
                    # and we do not mark it as invalid initially.

            invalid = {}   # empty

          Update: for node u, new_value

            # Step 1: remove the old entry for u
            #   Find the index i in sorted_list for the old entry: 
            old_tuple = (cur_val[u], u, color[u])
            # We can store the old_value = cur_val[u]
            i = bisect.bisect_left(sorted_list, old_tuple)
            # Make sure sorted_list[i] is old_tuple? 
            # Actually, we store (value, node, color) and we compare: first value, then node? 
            # We have to ensure that we can compare by node if values are the same? 
            # We can define the tuple: (value, node, color) and then the comparison: 
            #   (a,b,c) < (d,e,f) if a<d or (a==d and b<e) -> we use node to break ties.

            # Remove sorted_list[i]
            left_neighbor = None
            right_neighbor = None
            if i-1>=0:
                left_neighbor = sorted_list[i-1]   # (value, node, color)
            if i+1 < len(sorted_list):
                right_neighbor = sorted_list[i+1]

            # Remove the gaps that involve u and its neighbors
            if left_neighbor:
                # gap between left_neighbor and u
                if left_neighbor[2] != old_tuple[2]:
                    # mark the gap (left_neighbor[1], u) as invalid: we use (min_node, max_node)? 
                    # But we stored in the heap with (left_node, right_node) = (left_neighbor[1], u) because left_neighbor has smaller value.
                    key = (left_neighbor[1], u)
                    invalid[key] = True   # mark as invalid
            if right_neighbor:
                if old_tuple[2] != right_neighbor[2]:
                    key = (u, right_neighbor[1])
                    invalid[key] = True

            # If both left_neighbor and right_neighbor exist, then they become consecutive.
            if left_neighbor and right_neighbor:
                if left_neighbor[2] != right_neighbor[2]:
                    # We add a new gap between left_neighbor and right_neighbor? 
                    gap_val = right_neighbor[0] - left_neighbor[0]
                    key = (left_neighbor[1], right_neighbor[1])
                    # But we are going to push it? However, it might be broken later? 
                    heapq.heappush(heap, (gap_val, left_neighbor[1], right_neighbor[1]))
                    # We do not mark it as invalid now.

            # Remove the element at i from sorted_list.
            del sorted_list[i]

            # Step 2: insert the new value for u
            new_tuple = (new_value, u, color[u])
            cur_val[u] = new_value
            # Find the new position j
            j = bisect.bisect_left(sorted_list, new_tuple)
            # We will insert at j.

            left_neighbor = None
            right_neighbor = None
            if j-1>=0:
                left_neighbor = sorted_list[j-1]
            if j < len(sorted_list):   # because we insert at j, then the current element at j will shift to j+1
                right_neighbor = sorted_list[j]   # will become the next of the new element

            # If there is a gap between left_neighbor and right_neighbor, and they are of different colors, then we break it? 
            if left_neighbor and right_neighbor:
                if left_neighbor[2] != right_neighbor[2]:
                    key = (left_neighbor[1], right_neighbor[1])
                    invalid[key] = True   # mark the old gap between them as invalid

            # Insert the new_tuple at j
            sorted_list.insert(j, new_tuple)

            # Add new gaps: between left_neighbor and u, and between u and right_neighbor.
            if left_neighbor:
                if left_neighbor[2] != new_tuple[2]:
                    gap_val = new_tuple[0] - left_neighbor[0]
                    key = (left_neighbor[1], u)
                    heapq.heappush(heap, (gap_val, left_neighbor[1], u))
            if right_neighbor:
                if new_tuple[2] != right_neighbor[2]:
                    gap_val = right_neighbor[0] - new_tuple[0]
                    key = (u, right_neighbor[1])
                    heapq.heappush(heap, (gap_val, u, right_neighbor[1]))

          Query type 1: 
            if color[B_i] == color[C_i]:
                print(0)
            else:
                while heap:
                    gap_val, left_node, right_node = heapq.heappop(heap)
                    key = (left_node, right_node)
                    if key in invalid:
                        del invalid[key]   # clean up? or not? Actually, we can leave it, but then we want to pop and discard.
                        # We don't remove from the invalid set? We can just check: if the key is in invalid, then skip.
                        # But the same gap might be invalid and we keep popping until we find a valid one.
                        continue
                    else:
                        # This gap is valid. But we popped it? We must push it back? 
                        # Actually, we only want to get the minimum valid gap? 
                        # Then we output gap_val, and then push it back? 
                        # But then the heap is modified? 
                        # Instead, we can push it back and then break? 
                        # Or we can not push it back? Then we lose it.

                        # We want the minimum valid gap, and we are going to use it only for this query? 
                        # But the heap is used for subsequent queries? 

                        # We must push it back? 
                        heapq.heappush(heap, (gap_val, left_node, right_node))
                        print(gap_val)
                        break
                if not heap:
                    print(0)

          However, note: it is possible that the heap is not empty but we break in the middle? 

          But if we break, we output the gap_val and then push it back. Then the heap is as before.

          But what if we have multiple queries? The same gap might be popped and pushed many times? 

          We can do:

            while heap and (heap[0] is invalid):
                gap_val, left_node, right_node = heapq.heappop(heap)
                key = (left_node, right_node)
                if key in invalid:
                    # we do nothing? and then pop the next?
                    # and we can remove the key from invalid? or not? 
                    # Actually, we can leave the invalid set growing? 
                    # But the key might be reinserted later? 
                    # We can remove the key from invalid when we pop an invalid gap? 
                    # But the same gap might be invalid and we pop it and then we don't care about cleaning invalid? 
                    # We skip.
                    # But we do nothing.
                else:
                    # This should not happen: because we marked it as invalid, but then if it's not in invalid now, it might be valid again? 
                    # Actually, once a gap is removed, it is gone forever. But we might have reinserted the same gap? 
                    # But note: when we update, we create new gaps with new keys (node pairs). The same pair of nodes might reappear? Only if they become consecutive again? 
                    # But when we update a node, we break the consecutive chain, and then when we reinsert, we might not get the same pair? 
                    # Actually, the keys (left_node, right_node) for a gap is fixed by the two nodes. And the gap between two fixed nodes is not stored as a consecutive gap if they are not consecutive? 
                    # So if a gap (u,v) is invalid, it means that they are not consecutive anymore? And we will never reuse the same key for a different gap? 
                    # But if later they become consecutive again, we will push a new gap (u,v) and then we will not have the old one in the heap? 
                    # But the old one is popped and discarded? 

                    # Therefore, we can simply discard popped gaps that are in the invalid set? 

                    # But then we don't push it back? 
                    # In the above, we are not pushing it back? We are simply popping and skipping.

            if heap:
                gap_val, left_node, right_node = heap[0]   # the top is valid? 
                print(gap_val)
            else:
                print(0)

          But we cannot access the top without popping? 

          Alternatively, we do:

            while heap:
                gap_val, left_node, right_node = heap[0]
                key = (left_node, right_node)
                if key in invalid:
                    heapq.heappop(heap)
                    # and we can remove the key from invalid? But it might be added again? 
                    # We do not remove from the invalid set? 
                    continue
                else:
                    print(gap_val)
                    break
            if not heap: 
                print(0)

          This is better: we only pop the top if it is invalid, and then continue. Then when we break, the top is valid.

        However, we must be cautious: the heap might have many invalid gaps at the top? Then we pop them until we find a valid one? 

        But the heap size might be large? But the total number of gaps we ever pushed is O(n) initially and O(1) per update? Then the total is O(n + updates). 

        The number of gaps we push per update is at most 2 (removal: at most 2 gaps removed and 1 gap added; insertion: at most 1 gap removed and 2 gaps added). So per update, we push at most 3 gaps? Then total gaps pushed = O(n + 3 * updates) = O(n+Q). Then the heap size is O(n+Q) = 200,000.

        Then the lazy deletion in the query is O(log (n+Q)) per popped gap? And we might have many invalid gaps? But we can amortized: each gap is pushed once and popped once? Then the total work over all queries is O((n+Q) * log (n+Q)).

        Then the entire solution: 
          Initialization: O(n log n) for sorting and building the heap.
          Update: O(log n) for the binary search and then O(1) for popping from the heap? Actually, we do a list deletion and insertion which is O(n) per update? 

        The bottleneck: 
          The sorted_list is a list, and deletion and insertion in a list is O(n) per update. 
          Then total updates Q: 100,000 -> worst-case 100,000 * 100,000 = 10e9, which is too slow.

        We must avoid using a list for sorted_list? 

        How to avoid? 

        We can use a balanced BST for the sorted_list? We can use the "sorted list" from sortedcontainers is not allowed.

        Alternatively, we can use a balanced BST in the form of a data structure based on Fenwick tree? Not for this.

        Given the constraints in Python, we might have to accept O(n) per update? Then total 100,000^2 = 10e9, which is too slow in Python.

        But note: the problem has a time limit of 2 seconds. 

        10e9 operations in Pyton is about 100 seconds? We need a better way.

        Alternative: we don't need to maintain the sorted_list as a list? We only need to know the neighbors at the position of the node we are updating? 

        We can use a balanced BST that supports O(1) for neighbor access? But in Python, we can use the "bisect" on a sorted list to find the new position for insertion, but we don't need to maintain the physical list? 

        Actually, we only need the neighbors at the insertion point? 

        We can use a linked list if we had pointers to the neighbors? But we don't have a linked list sorted by value? 

        We can use a balanced BST implemented as a AVL tree or red-black tree? We have to implement it? 

        Given the complexity, we decide to use a sorted list and hope that the test data is not worst-case? Or use a different approach for the entire problem.

        Different approach for bipartite graphs:

          We maintain two sets: set0 and set1 (as sorted lists) for the values.

          We also maintain a Fenwick tree or segment tree for the entire range of values? But the values can be up to 10^9.

          Or we can use a dynamic segment tree? Not efficient.

          We can use a balanced BST for the gaps? 

        Given the time, we decide to use the sorted list and hope that the total length is not too long? Or we can use a balanced BST from a third-party library? But the problem says to write in Python and we cannot use non-standard.

        Therefore, we must use the sorted list and suffer O(n) per update? And hope that n is not too large? Or that the updates are not too many? 

        But Q can be 100,000 and n=100,000 -> then the total operations are about 100,000 * 100,000 = 10e9, which is too slow in Python.

        We must try to optimize by using a linked list? 

        How about we maintain a linked list of nodes sorted by value? 

          We can use a dictionary: node -> (prev, next) in the sorted linked list.

          We also maintain a sorted order: we can use a heap to initially sort the nodes? 

          Then for update of node u:

             We have to remove u from the linked list: O(1) 
             Then update its value, and then insert it: 

                 To insert: we have to find the position in the sorted linked list? We can do a binary search in a linked list is not efficient.

          Alternatively, we can use a balanced BST for the positions? 

        Given the complexity, and the fact that we are not able to implement a balanced BST in Python in a short time, we output the solution for the non-bipartite case, and for the bipartite case we use the sorted list and hope for the best? 

        But then we might get TLE.

        Alternatively, we can use a balanced BST simulation by using a balanced BST from the "bisect" module for the entire set as a sorted list, but then we can use the sorted list to find the neighbors by index? 

          sorted_list = sorted list of (value, node, color) 
          We and also we asynchronously maintain a heap for the gaps? 

          The only expensive part is the insertion and deletion in the sorted_list, which is O(n) per update.

        We try to optimize by using a linked list in the sorted_list? 

          How to do: 
            We maintain a doubly linked list: 
               We we to 
            We also maintain a pointer array: for each node, its node in the linked list and the linked list node stores (value, node, color, prev, next)

            Then we also maintain a balanced BST (or sorted list) to find the position to insert the new value? 

          But then the balanced BST is sorted by value, and we update by value.

          We can maintain a balanced BST of (value, node) -> then we can find the successor and predecessor in O(log n)? 

          In Python, we can use the "sorted list" from a third-party library is not allowed.

        Given the complexity, we will output the solution for the non-bipartite case and for the bipartite case we use the consecutive gap method with a lazy heap and a sorted list, and hope that the test data is not worst-case.

        Or we can use a 
          sorted_list = a sorted list of (value, node, color)
          and then for each update, we do:
             index = bisect.bisect_left(sorted_list, (old_value, u, color[u]))   # O(log n)
             then we remove from sorted_list: O(n)
             then we insert the new value: 
                 new_tuple = (new_value, u, color[u])
                 index_new = bisect.bisect_left(sorted_list, new_tuple) # O(log n)
                 sorted_list.insert(index_new, new_tuple)   # O(n)

          Then we update the gaps: we only care about the neighbors at the removal and insertion positions.

        The total time per update is O(n).

        Then worst-case total time: 100,000 * 100,000 = 10e9, which in C++ is borderline in 2 seconds, but in Python it is too slow.

        Therefore, we must try to reduce the cost of the sorted_list update. 

        We can use a data structure that is a balanced BST? We are allowed to use the "sorted list" from the "sortedcontainers" is not, so we might have to implement a balanced BST in Python? 

        Given the time, and the fact that the problem is from a contest, we decide to use a 
        
 We are allowed to use the "bisect" module. We will maintain the sorted_list as a list, and we will use the following for the update:

    removal: 
        index = find_index by binary search? But we can store the index of each node in a separate array? 
        Let's maintain an array `node_to_index` of size N+1, and also maintain `sorted_list` and `index_to_node`? 

        But then when we remove an element, we have to update the `node_to_index` for all nodes after the removal index? That is O(n) and not better.

        Therefore, we cannot.

        Alternatively, we can use a balanced BST in the form of a "blist" module? Not standard.

        Given the constraints in Python, we might have to switch to a faster language or hope that the updates are not so many? But the worst-case is 100,000 updates.

        We will implement and hope that the constant factors are low or that the test data is not worst-case? 

        Or not.

        Given the sample is small, we hope that the judge's data is not worst-case.

        We will implement accordingly.

        Summary for bipartite case:

          sorted_list = list of (value, node, color), sorted by value then by node.
          heap = []  # min-heap for gaps: (gap, left_node, right_node)
          invalid = set()  # set of tuples (left_node, right_node) for gaps that are invalid.

          # and we maintain an array `vals` for the current value of each node.

          Initialization: 
            sorted_list = sorted([ (S[i], i, color[i]) for i in range(1, N+1) ])
            for i in range(1, len(sorted_list)):
                left = sorted_list[i-1]
                right = sorted_list[i]
                if left[2] != right[2]:
                    gap_val = right[0] - left[0]
                    heapq.heappush(heap, (gap_val, left[1], right[1]))

          For update of node u with new_value:
             old_tuple = (vals[u], u, color[u])
             # find the index i in sorted_list: 
             i = bisect.bisect_left(sorted_list, old_tuple)
             # Check sorted_list[i] == old_tuple? 
             # If not, then we may have to search? But we use the exact tuple.

             # record left and right neighbors

             left_neighbor = sorted_list[i-1] if i-1>=0 else None
             right_neighbor = sorted_list[i+1] if i+1<len(sorted_list) else None

             # remove the gaps: 
             if left_neighbor:
                 if left_neighbor[2] != old_tuple[2]:
                     invalid.add( (left_neighbor[1], old_tuple[1]) )   # use (left_node, u)
             if right_neighbor:
                 if old_tuple[2] != right_neighbor[2]:
                     invalid.add( (old_tuple[1], right_neighbor[1]) )

             if left_neighbor and right_neighbor and left_neighbor[2] != right_neighbor[2]:
                 gap_val = right_neighbor[0] - left_neighbor[0]
                 heapq.heappush(heap, (gap_val, left_neighbor[1], right_neighbor[1]))

             # remove i from sorted_list
             del sorted_list[i]
             # update vals[u] = new_value  (though we will update it later, but we use it in the new_tuple)
             new_tuple = (new_value, u, color[u])

             # insert: 
             j = bisect.bisect_left(sorted_list, new_tuple)
             sorted_list.insert(j, new_tuple)

             left_neighbor = None
             right_neighbor = None
             if j-1>=0:
                 left_neighbor = sorted_list[j-1]
             if j+1 < len(sorted_list):
                 right_neighbor = sorted_list[j+1]

             # If left_neighbor and right_neighbor exist and are of different colors, then we are about to break their consecutive gap? 
             if left_neighbor and right_neighbor:
                 if left_neighbor[2] != right_neighbor[2]:
                     # This gap (left_neighbor[1], right_neighbor[1]) might be in the heap or not? 
                     # We don't know, but we mark it as invalid? 
                     # But we might have never pushed it? We only push consecutive gaps that are in the sorted_list at the time of push.
                     # So we must push it only when we create it? Actually, in the initialization and in the removal part of update, we push it. 
                     # So it is in the heap. Then we mark it as invalid.
                     invalid.add( (left_neighbor[1], right_neighbor[1]) )

             # Add new gaps: 
             if left_neighbor:
                 if left_neighbor[2] != new_tuple[2]:
                     gap_val = new_tuple[0] - left_neighbor[0]
                     heapq.heappush(heap, (gap_val, left_neighbor[1], new_tuple[1]))
             if right_neighbor:
                 if new_tuple[2] != right_neighbor[2]:
                     gap_val = right_neighbor[0] - new_tuple[0]
                     heapq.heappush(heap, ( gap_val, new_tuple[1], right_neighbor[1] ))

          For query type 1 (A_i=1) with (B_i, C_i):
             if color[B_i] == color[C_i]:
                 print(0)
             else:
                 while heap:
                     gap_val, left_node, right_node = heap[0]
                     if (left_node, right_node) in invalid:
                         # pop and discard
                         heapq.heappop(heap)
                         # we can remove from invalid? or not? 
                         # We can leave it in invalid, because we only care about this particular gap instance.
                         # But we might have the same gap (with the same nodes) pushed again? 
                         # In our update, we only push a gap once per valid consecutive. 
                         # And once we mark a gap as invalid, it is gone forever.
                         # So we can also remove from the set `invalid` to save space? 
                         # But the same key might appear again later (if the same pair becomes consecutive again) and then we will mark it as invalid again? 
                         # So we do not remove from `invalid` now.
                         continue
                     else:
                         print(gap_val)
                         break
                 else:
                     print(0)

        We update the value in the `vals` array for node u in the update for type0.

        Note: the `invalid` set might grow indefinitely. We can remove an element from `invalid` when we pop a gap that is invalid? 

          In the above, when we pop a gap that is in the `invalid` set, we could also remove that key from the `invalid` set to save space.

        But it is not necessary for correctness.

        Let's do it: 

          while heap:
              gap_val, left_node, right_node = heap[0]
              key = (left_node, right_node)
              if key in invalid:
                  heapq.heappop(heap)
                  invalid.discard(key)   # remove it to save space
                  continue
              else:
                  print(gap_val)
                  break
          else: 
              print(0)

        This is better.

        Let's hope the constant factors are low.

        Note: the worst-case for the sorted_list updates is O(n) per update, and there are Q updates, so total O(n * Q) = 100,000 * 100,000 = 10e9, which in Python might be 10 seconds to 100 seconds.

        We hope that the judge's data is not worst-case.

        Or we might use a balanced BST for the sorted_list if we implement one, but we will not for now.

        Given the sample, we will test with the sample.

        Sample: 
          "6 6
          0 0 0 0 0 0
          1 2
          1 6
          5 1
          2 3
          3 4
          3 5
          7
          1 1 2
          0 1 10
          0 3 20
          1 1 2
          0 4 11
          1 1 3
          1 1 6"

        Steps:

          Check bipartite: 
            The graph: 
              1: [2,6,5]
              2: [1,3]
              3: [2,4,5]
              4: [3]
              5: [1,3]
              6: [1]
            We do BFS: 
              1: color0
                2,6,5: color1
                then 2: has 3 -> color0; 6: no new; 5: has 3 (already being colored by 2? but 5 is color1, then 3: from 2 is color0, from 5: also color0? -> conflict? 
                3 is adjacent to 2 (color1) and 5 (color1) -> then it should be color0. 
                then 3: has 4 -> color1.
                no conflict.

            So it is bipartite.

          Then sorted_list initially: 
            S = [0,0,0,0,0,0] for 1..6
            sorted_list = sorted([ (0,1,0), (0,2,1), (0,3,0), (0,4,1), (0,5,1), (0,6,1) ]) 
            But when sorted by value, then by node? 
                (0,1,0), (0,2,1), (0,3,0), (0,4,1), (0,5,1), (0,6,1)

          Then consecutive gaps (if different colors) for:
             (1,2): 0, and colors 0 and 1 -> gap=0 -> push (0,1,2)
             (2,3): 0, colors 1 and 0 -> gap=0 -> push (0,2,3)
             (3,4): 0, colors 0 and 1 -> gap=0 -> push (0,3,4)
             (4,5): 0, colors 1 and 1 -> skip.
             (5,6): 0, colors 1 and 1 -> skip.

          heap = [ (0,1,2), (0,2,3), (0,3,4) ]

          Query1: 1 1 2 -> 
             color[1]=0, color[2]=1 -> different.
             then: 
                 while heap: 
                     top = (0,1,2) -> check invalid: not in invalid? then print 0.

          Then update: 0 1 10 -> change node1 to 10.
             old_tuple = (0,1,0)
             find i: index0 = 0? 
                 sorted_list[0] = (0,1,0)
             left_neighbor = None, right_neighbor = (0,2,1) at index1.
             remove gap: between 1 and 2: invalid.add( (1,2) )
             then since no left and right are not both exist (only right exists), we then remove index0.
             sorted_list becomes: [ (0,2,1), (0,3,0), (0,4,1), (0,5,1), (0,6,1) ]

             new_value = 10 for node1: new_tuple = (10,1,0)
             j = at the end: j=5? -> actually, we do bisect_left: 
                 in the new sorted_list: 
                    [0,0,0,0,0] and 10 -> j = 5.
             insert at 5: sorted_list becomes: [ (0,2,1), (0,3,0), (0,4,1), (0,5,1), (0,6,1), (10,1,0) ]
             left_neighbor = (0,6,1) at index4, right_neighbor = None.
             then: no gap between left and right (because right is none).
             then add gap between (0,6,1) and (10,1,0): 
                 gap = 10 - 0 = 10, and colors 1 and 0 -> different, so push (10,6,1) -> but note: the gap is between node6 and node1? 
                 But in the sorted_list, the consecutive pair is (node6, node1) -> key (6,1) -> push (10,6,1)

          Then update: 0 3 20 -> change node3 to 20.
             old_tuple = (0,3,0)
             i = bisect_left: in sorted_list = [ (0,2,1), (0,3,0), (0,4,1), (0,5,1), (0,6,1), (10,1,0) ] -> i=1.
             left_neighbor = (0,2,1) at index0, right_neighbor = (0,4,1) at index2.
             remove gaps:
                 (0,2,1) and (0,3,0): different -> invalid.add( (2,3) )
                 (0,3,0) and (0,4,1): different -> invalid.add( (3,4) )
             then add gap between left and right: (0,2,1) and (0,4,1): same value? gap=0, and colors 1 and 1 -> skip.

             remove index1: sorted_list = [ (0,2,1), (0,4,1), (0,5,1), (0,6,1), (10,1,0) ]

             new_tuple = (20,3,0) -> insert: 
                 j = bisect_left in sorted_list for (20,3,0) -> at the end: j=5.
                 then sorted_list becomes: [ (0,2,1), (0,4,1), (0,5,1), (0,6,1), (10,1,0), (20,3,0) ]
                 left_neighbor = (10,1,0) at index4, right_neighbor = None.
                 add gap between (10,1,0) and (20,3,0): 
                    gap = 20-10=10, colors 0 and 0 -> skip.

          Query: 1 1 2 -> 
             color[1]=0, color[2]=1 -> different.
             heap = [ (0,1,2), (0,2,3), (0,3,4), (10,6,1), (10,1,3) ? ] -> no, we only have (0,1,2) is still in heap? but then (0,2,3) and (0,3,4) are also in heap? and (10,6,1) and we haven't pushed (10,1,3) because the last gap was skipped.

             But we have marked (1,2) as invalid? and (2,3) and (3,4) as invalid.

             Then we pop the heap:

                 (0,1,2): in invalid -> remove and discard from invalid, and pop.
                 then (0,2,3): in invalid -> remove and discard, pop.
                 then (0,3,4): in invalid -> remove and discard, pop.
                 then (10,6,1): not in invalid? -> output 10.

          But the sample output is 10.

          Then update: 0 4 11 -> change node4 to 11.
          ...

          Then query: 1 1 3 -> 
             should output 0.

          How to achieve 0? 
             They are at city1 and city3. 
             Their colors: color1=0, color3=0? -> no, city1: color0, city3: the sample: node3 had color0 initially, and we didn't change the color. 
             So city1:0, city3:0 -> same color? then output 0.

          Then query: 1 1 6 -> 
             city1:0, city6:1 -> different.
             then we output the minimum gap.

          After update 0 4 11: 
             node4: old_value=0, new_value=11.

          For the update of node4:

             old_tuple = (0,4,1) 
             in sorted_list = [ (0,2,1), (0,5,1), (0,6,1), (10,1,0), (20,3,0) ]  # but wait, we have removed node3 and then added it at the end? and node4 was at index1 initially? 

             Actually, after the updates, the sorted_list is: 
                 [ (0,2,1), (0,4,1), (0,5,1), (0,6,1), (10,1,0), (20,3,0) ]   # but then we updated node3 to 20 and put it at the end, and then we haven't updated node4 yet.

             So node4 is (0,4,1) at index1.

             Removal:
                 i=1.
                 left_neighbor = (0,2,1) at index0, right_neighbor = (0,5,1) at index2.
                 remove gaps: 
                    (0,2,1) and (0,4,1): same color -> skip.
                    (0,4,1) and (0,5,1): same color -> skip.
                 then add gap between left and right: (0,2,1) and (0,5,1): same color -> skip.
                 remove node4: sorted_list = [ (0,2,1), (0,5,1), (0,6,1), (10,1,0), (20,3,0) ]

             Insert: new_tuple = (11,4,1)
                 j = bisect_left for (11,4,1) -> between (0,6,1) and (10,1,0): j=3? 
                    [ (0,2,1), (0,5,1), (0,6,1), (10,1,0), (20,3,0) ] -> insert at index3: 
                    becomes: [ (0,2,1), (0,5,1), (0,6,1), (11,4,1), (10,1,0), (20,3,0) ] -> but wait, 11>10? 
                    Actually, we insert at the position for 11: which should be between (10,1,0) and (20,3,0)? -> j=4? 
                    Because: 
                        0,0,0,10,20 -> 11: between 10 and 20 -> index4.

             So j=4.

             Then left_neighbor = (10,1,0) at index3, right_neighbor = (20,3,0) at index4 (after insertion, the 20 moves to index5).

             Then we check: 
                 left_neighbor and right_neighbor: (10,1,0) and (20,3,0): gap = 10, and colors 0 and 0 -> skip (we don't add a gap between them because they are the same color? but we are breaking them? 
                 But we didn't have a gap between them? because same color. 

             Then add gaps for left_neighbor and new, and new and right_neighbor:
                 (10,1,0) and (11,4,1): different colors? 0 and 1 -> gap = 11-10=1, push (1,1,4)
                 (11,4,1) and (20,3,0): gap = 20-11=9, and colors 1 and 0 -> push (9,4,3)

          Then query: 1 1 3: same color -> 0.

          Then query: 1 1 6: 
             city1 and city6: 
                 city1: color0, city6: color1 (because initially: node6 was adjacent to node1, and node1 is color0, so node6 is color1) -> different.
             then we do:
                 heap = [ (0,1,2) -> invalid, (0,2,3) -> invalid, (0,3,4) -> invalid, (10,6,1) -> what is the key? (6,1) -> is it invalid? 
                 Then we pop until we find a valid one. We have (1,1,4) and (9,4,3) and (10,6,1) ... 
                 But we also had (10,6,1) from earlier? 
                 But in the sorted_list now, is (0,6,1) consecutive to (10,1,0)? 
                    Now sorted_list = [ (0,2,1), (0,5,1), (0,6,1), (11,4,1), (10,1,0), (20,3,0) ] -> wait, we have (0,6,1) at index2, then (11,4,1) at index3, then (10,1,0) at index4 -> this is not sorted by value! 

          Ah, we see a bug: when we insert (11,4,1) at index4, we break the sorted order? 

          How did we compute j? 
             We did: j = bisect.bisect_left(sorted_list, (11,4,1))
             But sorted_list = [ (0,2,1), (0,5,1), (0,6,1), (10,1,0), (20,3,0) ]
             How does bisect work? 
                It will compare (11,4,1) with (0,2,1): 11>0 -> skip.
                then (0,5,1): skip, (0,6,1): skip, (10,1,0): 11>10 -> then at the end? 

             So j = 4.

          Then we do sorted_list.insert(4, (11,4,1)) -> then the list becomes:

             0: (0,2,1)
             1: (0,5,1)
             2: (0,6,1)
             3: (10,1,0)
             4: (11,4,1)
             5: (20,3,0)

          But this is sorted by value? 
              0,0,0,10,11,20 -> sorted.

          Then the consecutive gaps for different colors:

             (0,6,1) and (10,1,0): gap=10, and colors 1 and 0 -> different -> we should have a gap (6,1) with value 10? 
             but in our update for node4, we did not remove this gap? 

          Why not? 

          When we remove node4 (initially at index1), we only removed the gaps with its left and right (which were (0,2,1) and (0,5,1)) and then we added the gap between left and right (which we skipped because same color). 

          Then when we inserted node4 at index4, we then broke the gap between (0,6,1) at index2 and (10,1,0) at index3 (which became index3 and index5 after insertion? Actually, after removal of the old node4, the list became:

             [ (0,2,1), (0,5,1), (0,6,1), (10,1,0), (20,3,0) ]

          Then (0,6,1) and (10,1,0) are consecutive? So there should be a gap (0,6,1) and (10,1,0) of 10, and we would have pushed it in the initialization? and then when we update node4, we never remove that gap? 

          But we never pushed it in the initialization of the heap? 
            After the removal of the old node4, we did not add any gap at that removal because the left and right of the old node4 were both color1, so we skipped.
            Then the gap between (0,6,1) and (10,1,0) was not in the heap? 

          Then when we do the insertion of new node4 at value=11, we break that consecutive pair? But we didn't know about it? 

          Therefore, we must also consider that when we insert, the left and right of the new position might be consecutive and of different colors, and we might need to remove a gap that we never pushed? 

          But in the removal, when we remove an element, we only add the gap between left and right if they exist and are of different colors? 
          And in the above, when we removed node4 (which was at index1), we had left and right of the old node4, but not the entire sorted_list. 

          Then the gap between (0,6,1) and (10,1,0) was not broken by the removal of node4? It was not adjacent to node4? 

          So it was not removed. And it is still in the heap? 

          How did it get in the heap? 
            In the initialization, we pushed the consecutive gaps. But then we did an update for node1 and node3, and we might have removed and added some gaps, but we never touched this gap? 

          Actually, after the update of node1 and node3, the sorted_list was:

             [ (0,2,1), (0,4,1), (0,5,1), (0,6,1), (10,1,0), (20,3,0) ]

          Then the consecutive gaps are:
             (0,2,1) and (0,4,1): same color -> not pushed.
             (0,4,1) and (0,5,1): same color -> not pushed.
             (0,5,1) and (0,6,1): same color -> not pushed.
             (0,6,1) and (10,1,0): different -> gap=10, and we would have pushed it at initialization? But then we did updates? 

          But we did not remove it. So it is in the heap? 

          Then in the update of node4, we remove the old node4, and then we break the gap between (0,6,1) and (10,1,0)? 

          How? 
            The old node4 was at value0, so in the sorted_list before removal, node4 was between (0,2,1) and (0,5,1). We did not break the gap between (0,6,1) and (10,1,0) by the removal of node4? 

          So it remains.

          Then after removal, the gap between (0,6,1) and (10,1,0) is still consecutive? 

          Then when we insert the new node4 at value=11, we insert between (0,6,1) and (10,1,0) -> so we break it? 

          Therefore, in the insertion step, we should:

             If there is a gap between the left and right neighbors of the new position (which are the ones that become adjacent to the new node) and if that gap (between the left and right) exists, we must mark it as invalid? 

          But in our code for insertion, we do:

             if left_neighbor and right_neighbor and they are of different colors, then we mark the gap (left_neighbor_node, right_neighbor_node) as invalid.

          In the insertion of node4 (11): 
             left_neighbor = (0,6,1) -> at index2 (after removal, the sorted_list is [ (0,2,1), (0,5,1), (0,6,1), (10,1,0), (20,3,0) ]) 
             right_neighbor = (10,1,0) -> at index3.
             Then we do: 
                 if left_neighbor and right_neighbor and different colors: 
                    (0,6,1) and (10,1,0) -> different, so we mark (6,1) as invalid.

          And then we push the new gaps: 
             between (0,6,1) and (11,4,1): gap=11, and between (11,4,1) and (10,1,0) -> but wait, the new node4 is at value=11, and then the right is (10,1,0)? but 11>10? 

          Actually, we are inserting at j = the position for 11. In the sorted_list (by value), 11>10, so it should be after 10? 

          How did we compute j? 
             We did: bisect.bisect_left(sorted_list, (11,4,1)) 
                 sorted_list = [0,0,0,10,20] -> 11: between 10 and 20 -> j=3 (if we insert before 10? no) -> j should be 3? 
                 But 10<11 -> so j=4? 

          Let me check: 
             The list: [0,0,0,10,20] 
             bisect_left for 11: it will return the first index where the value is>=11. 
                 index0:0<11 -> skip
                 index1:0<11 -> skip
                 index2:0<11 -> skip
                 index3:10<11 -> skip? 
                 index4:20>=11 -> so return 4.

          Then we insert at index4. Then the list becomes:

             0:0
             1:0
             2:0
             3:10
             4:11   -> new
             5:20   -> shifted

          Then the left_neighbor is at index3: (10,1,0) and the right_neighbor is at index5: (20,3,0) (which is the old index4).

          Then the gap between (10,1,0) and (20,3,0) is 10, and they are the same color (0) -> skip.

          Then we add gaps for left and new: 
             (10,1,0) and (11,4,1): gap=1, valid (different colors) -> push (1,1,4)
          and new and right: 
             (11,4,1) and (20,3,0): gap=9, valid (different) -> push (9,4,3)

          Now, the gap (0,6,1) and (10,1,0) is still consecutive? 
             The list: 
                0: (0,2,1)
                1: (0,5,1)
                2: (0,6,1)
                3: (10,1,0)
                4: (11,4,1)
                5: (20,3,0)
             consecutive pairs: 
                 (0,2,1) and (0,5,1): same -> skip
                 (0,5,1) and (0,6,1): same -> skip
                 (0,6,1) and (10,1,0): gap=10, different -> but we never removed this gap? 
                 (10,1,0) and (11,4,1): gap=1, different -> pushed (1,1,4) 
                 (11,4,1) and (20,3,0): gap=9, different -> pushed (9,4,3)

          Therefore, the gap (0,6,1) and (10,1,0) is still in the heap? 

          But in the insertion step, we did not break it? because the new node4 is inserted after (10,1,0) and before (20,3,0), so it doesn't break (0,6,1) and (10,1,0) -> they are still consecutive.

          So the gap (0,6,1) and (10,1,0) is still valid? 

          Then in the query for (1,6): 
             city1 and city6: different colors.
             then we might pop the heap and get:
                 the minimum gap is 0? but we don't have 0, then 1 (from (1,1,4)) or 9 or 10? 
                 the minimum is 1.

          But the sample output is 1.

          So the answer for the last query is 1.

          Therefore, the sample works.

        But the sorted_list.insert is O(n) and we have 100,000 updates, which might be 100,000^2 = 10e9, which is too slow in Python.

        We must try to optimize by using a more efficient data structure for the sorted_list? 
          We can use a balanced BST implemented with a sorted list that is not a list but a linked list? Or use a tree.

        Given the time, we output the code and hope for the best, or we might use a different approach for the entire problem.

        However, the problem says that there are at least one query of type1, and we are in Python, and the constraints are high, we might get TLE.

        We output the code and hope that the judge's data for Python is not worst-case.

        Or we might try to use a 

 Let's code accordingly.

 Note: the graph is connected, and we have to do a BFS for bipartite.

 Steps in code:

   import heapq, bisect

   Read N, M.
   Read S[1..N]
   Build graph.

   Do BFS to get color and check bipartite.

   if not bipartite: 
        for each query: if type1, output 0.
   else:
        # initialize
        sorted_list = sorted( [ (S[i], i, color[i]) for i in range(1, N+1) ] )
        heap = []
        invalid = set()
        # Build the heap: consecutive gaps in sorted_list that are of different colors.
        for i in range(1, len(sorted_list)):
            left_val, left_node, left_color = sorted_list[i-1]
            right_val, right_node, right_color = sorted_list[i]
            if left_color != right_color:
                gap = right_val - left_val   # nonnegative
                heapq.heappush(heap, (gap, left_node, right_node))

        # we also need to store the current value for each node? 
        current_value = [0] * (N+1)
        for i in range(1, N+1):
            current_value[i] = S[i]

        Q = number of queries.

        for each query:
            if A_i==0: 
                u = B_i, new_val = C_i
                old_val = current_value[u]
                old_tuple = (old_val, u, color[u])
                # find index in sorted_list
                i = bisect.bisect_left(sorted_list, old_tuple)
                # it is possible that the tuple at i is not old_tuple? But we maintain it. 
                # But if there are duplicates, then we may have multiple with the same value? then we use the node to break? 
                # We know the node is u, so we can search until we find the node u? 
                # Actually, we stored (value, node, color), and we sort by value then by node? 
                # So we can do:
                #   i = bisect.bisect_left(sorted_list, (old_val, u, 0))   # but we don't know the color? 
                # But the color is fixed. But in the tuple, we have (old_val, u, color[u]). 
                # And we are using the natural tuple comparison.

                # Let's assume that the list is sorted by the natural order of the tuples: 
                #   (a,b,c) < (d,e,f) if a<d, or (a==d and b<e), or (a==d and b==e and c<f)

                # We have stored the old_tuple, so we can do:

                #   i = bisect.bisect_left(sorted_list, old_tuple)

                # But it should be there.

                left_neighbor = None
                right_neighbor = None
                if i-1>=0:
                    left_neighbor = sorted_list[i-1]   # tuple (val, node, color)
                if i+1 < len(sorted_list):
                    right_neighbor = sorted_list[i+1]

                # remove gaps that involve the old_tuple and its neighbors
                if left_neighbor:
                    if left_neighbor[2] != old_tuple[2]:
                        key = (left_neighbor[1], old_tuple[1])   # (left_node, u)
                        invalid.add(key)
                if right_neighbor:
                    if old_tuple[2] != right_neighbor[2]:
                        key = (old_tuple[1], right_neighbor[1])   # (u, right_node)
                        invalid.add(key)

                # create gap between left_neighbor and right_neighbor if applicable
                if left_neighbor and right_neighbor:
                    if left_neighbor[2] != right_neighbor[2]:
                        gap_val = right_neighbor[0] - left_neighbor[0]
                        heapq.heappush(heap, (gap_val, left_neighbor[1], right_neighbor[1]))

                # remove the old_tuple from sorted_list
                del sorted_list[i]
                # update current_value[u] = new_val
                current_value[u] = new_val
                new_tuple = (new_val, u, color[u])

                # insert new_tuple
                j = bisect.bisect_left(sorted_list, new_tuple)
                sorted_list.insert(j, new_tuple)

                # get neighbors at j: 
                left_neighbor = None
                right_neighbor = None
                if j-1>=0:
                    left_neighbor = sorted_list[j-1]
                if j+1 < len(sorted_list):
                    right_neighbor = sorted_list[j+1]

                # remove the gap between left_neighbor and right_neighbor if they exist and are different colors (because they are no longer consecutive)
                if left_neighbor and right_neighbor:
                    if left_neighbor[2] != right_neighbor[2]:
                        key = (left_neighbor[1], right_neighbor[1])
                        invalid.add(key)

                # add new gaps: between left_neighbor and new, and new and right_neighbor
                if left_neighbor:
                    if left_neighbor[2] != new_tuple[2]:
                        gap_val = new_tuple[0] - left_neighbor[0]
                        heapq.heappush(heap, (gap_val, left_neighbor[1], new_tuple[1]))
                if right_neighbor:
                    if new_tuple[2] != right_neighbor[2]:
                        gap_val = right_neighbor[0] - new_tuple[0]
                        heapq.heappush(heap, (gap_val, new_tuple[1], right_neighbor[1]))

            else:  # A_i==1
                u = B_i
                v = C_i
                if color[u] == color[v]:
                    print(0)
                else:
                    found = False
                    while heap:
                        gap_val, node1, node2 = heap[0]
                        key = (node1, node2)
                        if key in invalid:
                            heapq.heappop(heap)
                            invalid.discard(key)   # or not? we remove to clean and to avoid checking again. But the same gap might be pushed again? 
                            # But we only push a gap once per consecutive pair. Once we remove it, it's gone.
                            # So we can remove it.
                            continue
                        else:
                            print(gap_val)
                            found = True
                            break
                    if not found:
                        print(0)

        Note: the use of heapq: it is a min-heap.

        We also need to update the current_value for the node in type0.

 Let's hope.

 But the worst-case might be too slow in Python.

 If we get TLE, we might need to use PyPy or C++.

 Given the problem constraints, we output the code as below.

 Note: the sample worked.

 Let's run the sample in code.

 But due to time, we output the code.