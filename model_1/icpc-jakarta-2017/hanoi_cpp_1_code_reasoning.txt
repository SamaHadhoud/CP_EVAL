 Okay, we are going to solve the problem as follows:

 Steps:
 1. Parse input: N, M; the 3x3 cost matrix R; the initial configuration; and M goal configurations.

 2. Represent a state as a tuple of three sets (each set is a park) of bricks. However, note that the order in the park matters: the top brick must be the smallest. But the input gives the bricks from top to bottom (so the first brick in the list is the top). We can represent each park as a set? But note: we only care about the top brick (the smallest) for moves, and the entire set for state.

 However, note: the entire set is enough because the condition for moving a brick from park i to j is:
   - The brick we are moving (from park i) must be the smallest brick in park i (so we know the top).
   - The brick must be smaller than the smallest brick in park j (if park j is non-empty).

 But note: the entire set representation is sufficient because we can compute the min of the set (if non-empty) to know the top.

 Important: We must note that the sets form a partition of {1,...,N}.

 3. We have the following states of interest:
    - The initial state: S0
    - Each goal state: G0, G1, ..., G_{M-1}
    - The three final states: F0 = (all bricks, empty, empty), F1 = (empty, all bricks, empty), F2 = (empty, empty, all bricks)

    So total states of interest: 1 (initial) + M (goals) + 3 (finals) = M+4.

 4. We need to compute the minimum cost to go from any state A to state B (for all pairs of states of interest). However, note that the state space is huge: 3^N states. But N can be up to 40? We cannot traverse the entire state space.

 Alternative Insight: We note that M is at most 16, and we only care about a small set of states (M+4). We can use a state-space search (like Dijkstra) that starts from a state and explores moves until we have computed the cost to all states of interest? But the state space is too big.

 However, we can use a technique: we run Dijkstra from each state of interest, but we stop when we have reached all the other states of interest? But worst-case the entire state space is 3^N which is 3^40 (about 3.5e19) which is too big.

 We need a more efficient way to compute the distance between two states.

 Another Insight: The problem of moving from one configuration to another is similar to the Tower of Hanoi problem with three pegs and arbitrary costs, but with the constraint that we can only move the top brick and the move must preserve the increasing order (which is the same as the standard Tower of Hanoi condition: a brick can only be placed on a larger brick).

 However, note: in Tower of Hanoi, the goal is to move the entire tower from one peg to another. Here, we have arbitrary configurations.

 We can use iterative deepening? That won't work for N=40.

 Alternatively, we can use a bidirectional search? But the state space is too huge.

 Known fact: The problem of computing the minimum moves between two arbitrary states in the Tower of Hanoi with 3 pegs and N disks is known to be solvable in O(2^N) by dynamic programming? Actually, we have to consider the state of each disk (which peg it is on). The state is a vector of length N (each disk has a peg). The state space is 3^N, which is too big for N=40.

 We need a better approach.

 Observing constraints: M is at most 16, and N can be up to 40. But note: the states of interest are only M+4 (at most 20). We need to compute the cost between every pair of these states without exploring the entire state space.

 We can use the A* algorithm? But without a good heuristic and with state space 3^N, it's still too big.

 Alternatively, we can use a meet-in-middle? But N=40 is too big.

 Another idea: Represent the state by the location of each brick? Then the state is a vector of length N (each element in {0,1,2}). This state representation is an integer in [0, 3^N). We can use Dijkstra on the state space? But 3^N states: for N=40, 3^40 is astronomical.

 We must find a more efficient way.

 Insight: The moves are reversible? And the cost is not symmetric? So we cannot assume symmetry.

 However, note: the problem has been studied in the Tower of Hanoi literature. But our cost matrix R is arbitrary and not necessarily symmetric.

 But note: the problem constraints say N up to 40. This is too big for state-space search.

 We must use the fact that we only care about 20 states. We can run Dijkstra from each state of interest, but we need to avoid exploring the entire state space. We can set a bound? But worst-case the state space is 3^40.

 Alternatively, we can use iterative relaxation? Or we can use the fact that the moves only involve moving the top bricks. This is a state-space of the form: each state is determined by the location of each brick, but the state is constrained: in each park the bricks form a set that must be consecutive? Actually, no: the bricks can be arbitrary as long as they are in increasing order from top to bottom.

 Actually, the state is completely described by the location of each brick. The condition for a park is that the bricks in that park must form a decreasing sequence from bottom to top? Actually, the condition is that the top brick is the smallest in the park, then the next is the next smallest, etc. So the park is a set that can be represented as a sorted list (in increasing order of the brick indices) and the top is the smallest.

 How about we use state = (a, b, c) where a, b, c are the sets of bricks in parks 0,1,2. The state space is the set of partitions of the set {1,...,N} into three sets. The number of states is 3^N. For N=40, that's about 3.5e19, which is too many.

 Therefore, we must avoid full state-space exploration.

 Alternative approach: Use the known solution for Tower of Hanoi? But we have arbitrary initial and goal configurations.

 We can use recursion? Or we can use the idea of moving the largest brick? 

 Consider: The largest brick (brick N) must be moved only when it is exposed (i.e., the top of its stack). And when we move it, we have to move it to a park that does not have any brick smaller than it? Actually, it can only be placed in a park that is empty? Or if we place it in a park that already has bricks, then it must be placed at the bottom? But note: the condition is that we can only put a brick on top of a larger brick. So brick N must be placed in an empty park? Or in a park that has bricks all larger than N? But there is no brick larger than N. So brick N can only be placed in a park that is either empty or already has brick N? But brick N is unique. So brick N can only be placed in an empty park? Actually, no: it can be placed in a park that has bricks? But when we place it, it must be at the bottom? Because the existing bricks in the park are all smaller than N? Then condition: the existing bricks must be placed on top of brick N? But we are putting brick N on top of the existing stack? That would break the condition: we cannot put brick N (which is large) on top of a smaller brick. Therefore, brick N can only be moved to an empty park.

 So the standard Tower of Hanoi recursive step: to move bricks [1..n] from A to B, we move [1..n-1] to C, then move n from A to B, then move [1..n-1] from C to B.

 But here we have arbitrary configurations and arbitrary costs.

 However, we can use a recursive DP that uses the largest brick to break the problem. Let:

   dp[state][park] = minimum cost to move all bricks in the state to be in one park (park) from the current state.

 But state here is defined by the locations of all bricks? Still 3^N.

 But note: we have at most 20 states of interest. However, the problem is that we need the cost between two arbitrary states. How to compute the cost from state A to state B?

 We can use a recursive function that moves the largest brick that is misplaced? 

 Let state A and state B be two states. We can consider the largest brick (brick n). If in state A it is in park p, and in state B it is in park q, then we must eventually move it to park q. But to move brick n, we need to have park p having brick n on top (so no brick on top of it) and then we move it to park q which must be empty (because we cannot put brick n on top of a smaller brick? Actually, we can put brick n only in an empty park? Or in a park that has no bricks? Or if the park has bricks, then they must all be larger? But there are none. So only empty parks are acceptable for brick n.

 Therefore, to move brick n from park p to park q, we must first move all bricks that are currently on top of brick n (which in state A: the bricks in park p that are smaller than n) to the third park, say r. Then move brick n from p to q. Then move the bricks that were on top of brick n from r to q? But note: in the goal state B, brick n is in park q, and the bricks that were on top of it (which are smaller) must also be in park q? Actually, no: in state B, the bricks that were on top of brick n in state A might be in any park? They might not even be in park q? 

 Alternatively, we can use a known recursive algorithm for the generalized Tower of Hanoi between two arbitrary configurations? 

 Algorithm for moving from state A to state B:

   Let n = the largest brick that is misplaced (or if none, cost 0).

   If brick n is already in the correct park (as in state B), then we don't move it. But then the bricks on top of brick n must be moved to the configuration as in state B? Actually, we can recursively fix the configuration for the bricks [1..n-1] ignoring the park of brick n? 

   However, if brick n is not in the correct park, then:
      - Move all bricks in [1..n-1] that are currently in park p (the park of brick n in state A) to the third park (using the standard recursive procedure for moving a set of bricks from one park to another? but note: we don't care about the intermediate configuration as long as we free brick n). Then move brick n from p to q (the park it should be in state B). Then move the bricks [1..n-1] from the third park to park q? But wait: in state B, the bricks [1..n-1] that were originally in park p are not necessarily required to be in park q? They can be distributed arbitrarily.

   Actually, the goal state B has a fixed distribution of the bricks [1..n-1]. Therefore, we must not only free brick n but also then, after moving brick n, we must arrange the bricks [1..n-1] to match state B.

   How? We can break the problem into:

      Step 1: Move the bricks [1..n-1] from their current state (in state A) to an intermediate state: which is that they are distributed arbitrarily except that they are not on top of brick n? Actually, we need to move them off park p so that we can move brick n.

      Step 2: Move brick n from p to q.

      Step 3: Move the bricks [1..n-1] from the intermediate state (after step 1) to the state B (for bricks [1..n-1]).

   But the intermediate state in step 1 is arbitrary? How to compute the cost of step 1? And step 3 is the same problem for n-1.

   We can define a function: 

        f(S, A, B) = minimum cost to move the set of bricks S from configuration A to configuration B.

   But the state for S is the location of each brick in S? That is 3^(|S|). For |S| = 40, it's too big.

   Alternatively, we can use the following recursive idea for a single brick: but we have to account for the entire set.

   We are stuck? 

   But note: the problem says N up to 40 and M up to 16. However, the sample inputs are small (N=3). And the constraints for the state of interest are only 20. We might not need to solve for arbitrary N=40.

   Actually, the problem states that N can be up to 40. How did the sample inputs work? The first sample N=3, the second N=3.

   There must be a solution that works for N=40? Or maybe we can use iterative deepening with bound? That would be too slow.

   Known fact: The generalized Tower of Hanoi between two arbitrary configurations can be solved by recursion on the bricks from largest to smallest. The state for the recursion is the current park for the largest brick not yet fixed, and the current configuration of the smaller bricks? But then the state is the park of the largest brick and the configuration for the rest? Then we have 3 * (state for the rest) -> 3 * 3^(n-1) = 3^n. Again exponential.

   However, note: we only care about 20 states. We don't care about the entire state space. We want the cost between two fixed states: state A and state B.

   We can use recursion with memoization that uses the entire state (the vector of locations for bricks 1 to n) as the state? But the state space is 3^n which for n=40 is too big.

   Alternative: we can use recursion that only depends on the largest brick and the sets of bricks in each park? But then the state would be the current state of the entire set? We are back to 3^n.

   We need to break the problem differently.

   Insight: The moves are independent of the order of bricks below? Actually, once a brick is covered by a larger brick, it cannot be moved until the bricks above are moved away.

   We can use the following:

        Let F(n, p, q, r) = the minimum cost to move the bricks [1..n] from their current configuration (which is stored in a global variable) to a configuration where the bricks [1..n] are distributed arbitrarily, but the largest brick n is in a specific park? 

   This is not trivial.

   After reading known solutions for similar problems (like CodeForces problems), we find that for the classical Tower of Hanoi with arbitrary configurations and three pegs, there is a solution using state-space search for small n. But n=40 is too big.

   However, note: the problem constraints also have M up to 16, but the state space for the entire problem is 3^N which is too big. We must avoid full state-space search.

   Alternative plan: use iterative relaxation over the bricks from largest to smallest, keeping track of the location of the largest remaining brick and the "free" pegs? 

   Let dp[i][a][b] = minimum cost to have moved the bricks [i..N] to their target positions (as in state B) and currently the brick i is at park a, and the other two parks (say b and c) are free for bricks [1..i-1] (meaning they have no brick from [i..N] and can accept any brick smaller than i). But wait: the state B is fixed. We know for each brick j, the target park.

   How to design:

        We process the bricks from largest to smallest.

        State: 
            i: the current brick we are considering (starting from N down to 1)
            a: the park where brick i is currently located (in the current state we are simulating) -> but note: we are moving from state A to state B, so we know the initial park of brick i? Actually, we are building the cost from state A to state B.

        Actually, we can define:

            dp[i][p] = minimum cost to have moved bricks [i..N] to their target parks, and the topmost brick (among bricks [i..N]) that is currently in each park is stored? But we don't need that: we only care about the park of brick i and the fact that the parks that are holding bricks [i..N] are such that the next brick (i-1) can be moved without disturbing the already placed bricks? 

        Actually, the condition: we cannot put a brick on a smaller one. So if a park has a brick j (>=i) then we cannot put brick i-1 on top of it unless j is the bottom and we are putting i-1 above? But we are moving from state A to state B, and we are processing largest first. When we place brick i in its target park, then we can use the other two parks to move the smaller bricks.

        The standard recursion for the Tower of Hanoi for moving a tower from one peg to another:

            T(n, from, to, aux) = T(n-1, from, aux, to) + cost(from, to) + T(n-1, aux, to, from)

        Here, we have arbitrary initial and goal positions for each brick.

        We can define:

            dp[i][p0][p1][p2] = ...  -> too many states.

        Instead, we can use:

            dp[i][a][b] = minimum cost to move bricks [i..N] to their target parks, given that the parks that are holding bricks [i..N] are exactly the three parks, and the only thing that matters for moving brick i-1 is the park that has the smallest brick among [i..N] in each park? Actually, the top of each park is the smallest brick in that park among [i..N]. But note: the smallest brick in the park might be brick i? or even smaller? but we are processing from large to small, so we haven't placed bricks smaller than i yet.

        Actually, we can assume that the bricks [i..N] are already in their target parks, and they are fixed. Then the parks have some configuration: the top brick in each park for the set [i..N] is known. But the top brick in a park must be the smallest brick in that park in the set [i..N]. 

        Then for moving brick i-1, we care about the top of the parks in the set [i..N] because brick i-1 must be placed on a park that has a top brick > i-1? or on an empty park (which we can consider as having a top brick of infinity).

        Therefore, we can define state by the location of the bricks [i..N] and the top brick of each park. But the state space is 3^(N-i+1) which for i=1 is 3^N -> too big.

        However, we only care about the top brick of each park. And the top brick of a park is the smallest brick in that park in the set [i..N]. Therefore, the state can be represented as (t0, t1, t2) where t0 is the smallest brick in park0 in [i..N] (or INF if none), and similarly for t1, t2. The number of states: each t can be any brick in [i..N] or INF -> about (N-i+1+1)^3. Since i goes from N down to 1, the maximum state space per i is (N-i+2)^3. Then the total state space is sum_{i=1}^{N} (N-i+2)^3 = O(N^4) states? But we are iterating i from N down to 1, and for each i we have O((N-i+2)^3) states, and for each state we try moving brick i-1? 

        The recurrence:

            We are at brick i (initially i = N+1, then we go down to i=1) and state (t0, t1, t2) for the tops of the parks for bricks in [i..N]. 

            For i = N+1: no bricks, so state (INF, INF, INF). We start from the initial configuration of the bricks [1..N] for state A, and we want to achieve the configuration of state B.

            Actually, we start from state A and we want to go to state B. We process bricks from largest to smallest.

            Step: For brick i-1, we know:
                - In state A, it is initially in park p.
                - In state B, it should be in park q.

            Conditions:
                - To move it from its current park p, it must be the top of park p. In our state, the top of park p should be i-1? But wait: we have not moved the bricks above i-1? Actually, we are moving from large to small, so bricks larger than i-1 have been moved to their target and are now in the parks. And brick i-1 might be covered by bricks in [i..N] that are still in park p? Then we cannot move it until those are moved away.

            Therefore, the recursion must also account for the current location of brick i-1? And the fact that we might have to move the bricks above it.

        This becomes very complex.

 Given the complexity of the general solution and the constraints that M is small (<=16) but N can be up to 40, we must look for an alternative.

 However, note: the sample inputs have N=3. And the problem might be intended to be solved only for small N? But the problem statement says N up to 40.

 But then how to handle N=40? There must be a solution that works for N up to 40.

 Research: This problem is known as the "Tower of Hanoi with given initial and final configurations". There is a known solution that runs in O(N) time. How?

   Reference: "The Tower of Hanoi for Humans" by by which we mean, there is a greedy iterative method:

   - The largest brick that is not in its target position must be moved. But to move it, we must free it by moving all bricks above it to the spare peg. Then move it to its target. Then we don't move it again.

   Algorithm:

        while there is a brick that is not in its target position:
            find the largest such brick, say brick k
            let current_peg = current location of brick k
            let target_peg = target location of brick k
            if there is any brick on top of brick k in current_peg, then recursively move them to the spare peg (which is the one that is neither current_peg nor target_peg), but ensuring that when moving a brick we use the standard ToH recursion? But note: the spare peg might have bricks that are larger than the ones we are moving? But we are moving bricks that are smaller than k, and the spare peg might have bricks that are larger than these? But we can only put a brick on a larger one. So if the spare peg has a brick on top that is smaller than the brick we are moving, we cannot put it there? -> This is the same as the standard ToH.

        Actually, the algorithm is:

            Let spare_peg = the peg that is neither current_peg nor target_peg.
            Move all the bricks on top of brick k (which are bricks j < k that are in current_peg and above k) to the spare_peg. But to move these bricks, we have to move them as a group to the spare_peg, and we can use a standard ToH recursive move: move a tower of m bricks from current_peg to spare_peg using target_peg as temporary.

            However, the cost for moving a tower of m bricks from peg i to peg j is not fixed? It depends on the cost matrix R.

        In the standard ToH with three pegs and arbitrary costs, the minimum cost to move a tower of n disks from peg i to peg j is computed by:

            T(n, i, j) = 
                if n==0: 0
                else: 
                    min{ 
                        2 * T(n-1, i, k) + R[i][j]   # move n-1 to the spare peg k, then move the nth to j, then move the n-1 from k to j
                        T(n-1, i, j) + R[i][k] + T(n-1, j, i) + R[k][j] + T(n-1, i, j)  ? -> we have to consider the possibility of moving through intermediate.

                    }

        But with arbitrary costs, the optimal way to move a tower of n from i to j might be:

            Option1: 
                move top n-1 from i to spare k (using j as spare) -> cost = T(n-1, i, k, j)
                move the last disk from i to j -> cost = R[i][j]
                move top n-1 from k to j (using i as spare) -> cost = T(n-1, k, j, i)
                total = T(n-1, i, k, j) + R[i][j] + T(n-1, k, j, i)

            Option2:
                move top n-1 from i to j (using k) -> cost = T(n-1, i, j, k)
                move the last disk from i to k -> cost = R[i][k]
                move top n-1 from j to i (using k) -> cost = T(n-1, j, i, k)
                move the last disk from k to j -> cost = R[k][j]
                move top n-1 from i to j (using k) -> cost = T(n-1, i, j, k)
                total = T(n-1, i, j, k) + R[i][k] + T(n-1, j, i, k) + R[k][j] + T(n-1, i, j, k)

        We would take the minimum over the two options and also over the choice of spare peg (but there is only one spare).

        However, we have three pegs, and the spare is fixed as the third one.

        Therefore, we can define:

            Let f(n, a, b, c) = minimum cost to move a tower of n disks from peg a to peg b, using peg c as the spare.

            Then:
                f(0, a, b, c) = 0
                f(n, a, b, c) = min(
                    f(n-1, a, c, b) + R[a][b] + f(n-1, c, b, a),
                    f(n-1, a, b, c) + R[a][c] + f(n-1, b, a, c) + R[c][b] + f(n-1, a, b, c)
                )

        But wait, the second option uses two moves of the entire n-1 tower. And the recurrence is:

            f(n, a, b, c) = min(
                f(n-1, a, c, b) + R[a][b] + f(n-1, c, b, a),   # option1: spare is c, but then we use c as intermediate for the n-1 tower twice? 
                f(n-1, a, b, c) + R[a][c] + f(n-1, b, a, c) + R[c][b] + f(n-1, a, b, c)  # option2: move n-1 from a to b, then move the last to c, then move n-1 from b to a, then move the last from c to b, then move n-1 from a to b.
            )

        This has a term f(n-1, a, b, c) twice in the second option? Actually, the second option is:

            move n-1 from a to b -> cost1 = f(n-1, a, b, c)
            move last from a to c -> cost2 = R[a][c]
            move n-1 from b to a -> cost3 = f(n-1, b, a, c)
            move last from c to b -> cost4 = R[c][b]
            move n-1 from a to b -> cost5 = f(n-1, a, b, c)

            total = cost1+cost2+cost3+cost4+cost5

        And then we take the minimum of option1 and option2.

        But is option2 always more expensive? Usually in the classical ToH with constant cost, option1 is cheaper. But here costs are arbitrary.

        We might also consider: move the n-1 tower from a to c, then move the last from a to b, then move the n-1 tower from c to b. This is option1.

        option2 is: move the n-1 from a to b, then last from a to c, then move the n-1 from b to a, then last from c to b, then move the n-1 from a to b.

        There is also: 
            option3: move the n-1 from a to c, then last from a to b, then move the n-1 from c to a, then last from b to c, then ... -> this is not necessary.

        Actually, we only need these two options? 

        But note: the recurrence might be defined as:

            f(n, a, b, c) = min(
                f(n-1, a, c, b) + R[a][b] + f(n-1, c, b, a),
                f(n-1, a, b, c) + R[a][c] + f(n-1, b, a, c) + R[c][b] + f(n-1, a, b, c),
                ... over the two possible spares? but there is only one spare (c)
            )

        And then we have to try which one is cheaper.

        This recurrence has overlapping subproblems? Yes, and the state is (n, a, b, c) but note that a, b, c are in {0,1,2} and there are 3 choices for a, 2 for b, 1 for c? Actually, c is determined as the spare: c = 3 - a - b? So state: (n, a, b) and a and b in {0,1,2} with a!=b, and then c=3-a-b.

        Therefore, the state space is O(n * 3 * 2) = O(6n) states. This is O(N) per state and O(N) in total.

        So we can precompute a table for all n in [0, N] and all a, b in {0,1,2} (a!=b) of the cost to move a tower of n disks from a to b using the spare.

        Then, for the given initial and goal configurations, we can do:

            Let A = initial configuration (a list of parks for each brick, with brick 1 to N)
            Let B = goal configuration (a list of parks for each brick)

            We process from brick N down to brick 1:

                Let current_peg = A[i] for brick i
                Let goal_peg = B[i] for brick i

                If current_peg == goal_peg, then we may not need to move it, but we have to check: are there any bricks j>i in the same park that are below it? But note: we are moving from large to small, so the larger bricks have been moved. This brick i might be covered by bricks that are not yet moved? -> Actually, we are moving from large to small, so when we are at brick i, the only bricks that are not yet fixed are the ones < i. The bricks > i have been fixed in their target parks.

                Therefore, if current_peg == goal_peg, then we only need to worry about the bricks on top of i in the current state? But wait, the state for the larger bricks has been fixed. The bricks on top of i in the current state are bricks j < i that are in the same park. We are about to move them. So if brick i is in the right park, then we can leave it there and move the smaller ones.

                But if there is a brick j>i in the same park, then we have already moved it? So the park should have only bricks <= i? No: we haven't moved the smaller ones. 

                Actually, we are free to move the smaller ones arbitrarily. So if brick i is in the right park, then we don't move it, and the only effect is that the park goal_peg has a new base at brick i, and the spare for moving the tower of bricks [1..i-1] might be affected.

                Otherwise, if current_peg != goal_peg, then we must move it. To move it, we must first move all bricks that are on top of it (bricks in the range [1..i-1] that are in current_peg) to the spare peg. Then move brick i to goal_peg. Then move the tower of bricks [1..i-1] from the spare peg to the goal_peg.

                How to compute the cost for moving the tower of bricks [1..i-1] from current_peg to the spare peg? We can use the function f(i-1, current_peg, spare, other) that we precomputed.

                Then the cost for this brick i is:
                    cost1 = f(i-1, current_peg, spare, other)   [ move the smaller ones from current_peg to spare ]
                    cost2 = R[current_peg][goal_peg]             [ move brick i ]
                    cost3 = f(i-1, spare, goal_peg, current_peg) [ move the smaller ones from spare to goal_peg ]

                total = cost1 + cost2 + cost3

                And then we update the location of bricks [1..i-1]: they are now in goal_peg? And we have moved them from spare to goal_peg.

                But note: the function f(i-1, spare, goal_peg, current_peg) is precomputed for a full tower. But our tower of bricks [1..i-1] might not be contiguous in the spare peg? We moved them from current_peg to spare peg using the standard move, so they should be in spare peg in one stack? 

                However, the catch: the initial configuration of the bricks [1..i-1] in the spare peg might be arbitrary? But in our recursion, we are moving them as a contiguous tower from current_peg to spare peg, and then from spare peg to goal_peg. This assumes that the move for the tower is done in the standard way. But the smaller bricks might be distributed arbitrarily in the initial configuration? 

                This is the issue: the initial configuration for the entire set of bricks is arbitrary. The above recursion (moving a tower) only works if the tower is contiguous and in increasing order. In our state, after moving the bricks [1..i-1] from current_peg to spare peg, they will be in one stack in the spare peg, and then we move them to goal_peg. 

                But initially, the bricks [1..i-1] might be distributed in all three pegs? 

                Therefore, this recursion only works if the entire set of bricks [1..i-1] is in the current_peg and in sorted order? That is not true in an arbitrary configuration.

        So we cannot use the standard tower move for a group of bricks that are not forming a contiguous tower.

 Given the above, we must use a state-space search for the entire state for the set of states of interest. But the states of interest are only 20. We can hope that the cost between two states of interest can be computed by a Dijkstra that is optimized to stop when we reached the target state? And use a priority queue.

        Since N=40, the state space is 3^40, which is too big for Dijkstra.

        We need to hope that the cost between two states is not too high and we can meet in the middle? But the cost might be exponential.

        Alternatively, we can use the fact that the only states we care about are the states of interest (20 states). We can run a Dijkstra from each state of interest, but we prune states that have a cost already exceeding the best known cost to the states of interest? We can stop the Dijkstra when we have reached all states of interest from the start state.

        Specifically, for a given start state S, we want the cost to each state in the set T (the other states of interest). We can run Dijkstra from S and stop when we have extracted all states in T.

        The number of states in the entire graph is 3^N, which is too big for N=40.

        But note: we only care about states that are on the path from S to the states in T. The branching factor is 6 (from a state, we can move the top brick from any of the 3 parks to any of the other 2). So the out-degree is 6. The shortest path in terms of number of moves might be bounded by (number of moves needed to move each brick) and the cost might be bounded, but the state space is 3^N which is astronomical.

        Therefore, we must use a different approach for large N.

        Given the complexity and the fact that M is at most 16 and the states of interest are only 20, we can use the following: 

          We precompute the cost between state i and state j (for the 20 states) using a bidirectional search? Or using A* with a heuristic. The heuristic could be the number of bricks that are not in their target park? But cost is arbitrary.

        But without a good heuristic, bidirectional search: the state space from one state might have to explore 3^N states in the forward and backward direction, which is 2 * 3^(N/2) states. For N=40, 3^20 is about 3.5e9 which is borderline in C++ in terms of memory and time.

        Alternatively, use iterative deepening DFS? Not for cost minimization.

 Given the time constraints, and since the sample inputs are small (N=3), and the problem might be intended for small N (even though the statement says N up to 40), we must reconsider the constraints.

        But the problem statement says: time limit 1.0 second, memory limit 256 MB.

        We also note: the sample input has N=3.

        After re‐examining the constraints: M <= 16, and N<=40. But the states of interest are only 20. Maybe the actual number of states visited in the Dijkstra between two states of interest is not the entire state space? The moves are only moving the top brick, and the state space is the partition of the bricks. The state is defined by the sets in the three parks. We can represent a state by the sorted tuple of the three sets. We can use a hash of the set representation.

        But 3^40 states is too many to store.

        Alternative: use the following for small N and hope that for large N we have a more efficient method? But the problem does not specify that N is small in practice.

        Insight: the initial, goals, and final states might be very close in terms of move distance? Then Dijkstra might terminate early.

        But worst-case, the state space is 3^40, which is too big.

        However, note that the sample input has N=3, so we can try to solve for small N (<=10) using Dijkstra over the state space, and for large N (>=11) use the recursive method for the Tower of Hanoi for the entire move between states, but how?

        There is a known efficient method for the Tower of Hanoi with three pegs and arbitrary initial and final configurations that runs in O(2^N) time. We can try to use:

            For a state, the only information we need to move a brick is: for each brick, its current park and its target park. Then the cost to move from state A to state B can be computed by a recursion on the bricks from largest to smallest, and we only care about the current "free" status of the pegs. The state in the recursion is the current park of the largest not-yet-moved brick and the set of pegs that are "free" (i.e., have no bricks that haven't been moved and are therefore available to place the brick on). 

            Specifically, let:

                dp[i][a][mask] = minimum cost to have moved the bricks [i..N] to their target parks, where the largest brick not yet moved is i (and all larger are moved), and it is currently in park a, and mask is the set of pegs that are free (free means that the park has no bricks that have not been moved to their target).

            How to design the mask? The mask has 3 pegs, so 8 states.

            Then the state space is: O(N * 3 * 8) = O(24N) = O(N), which is feasible for N<=40.

            How does it work?

                We process the bricks from largest to smallest.

                For brick i, if it is already in its target park, then we simply mark it as moved, and the park a might become free? But wait, if there are smaller bricks in the same park, then it is not free. So we have to consider: after moving a brick, the park might become free only if there are no smaller bricks in that park that haven't been moved? 

                Actually, the state should be: after moving bricks [i+1..N] to their target, we have a configuration where the only bricks left are [1..i] and they are in some parks. For each park, we know the smallest brick in that park (the top) for the set [1..i]. Then to move brick i, we care about the top of its current park and the top of the target park.

                Alternatively, we can use the following recurrence from a known solution for the "Tower of Hanoi with random initial and final configuration" in O(N) time and constant in the number of pegs (for 3 pegs, constant factors in 3^3=27 per state):

                Let F(i, a, b, c) = minimum cost to move the first i smallest bricks to their target positions, and the current pegs for the bottom of the stacks (or the largest moved brick in each peg) are a, b, c for the three pegs. But this state space is i^3.

                But i can be up to 40, and 40^3 = 64000, which is acceptable.

                Specifically, known solution from [ a specific code ]:

                    Let a0, a1, a2 = the largest (bottom) brick in each park for the already moved bricks that form the base of the stack in that park. If a park has no moved brick, then we can consider it as having a brick of size N+1 (infinity).

                Then for brick i (the next smallest), we know its current park and its target park.

                To move brick i to its target park, we must:
                    - If it is already in its target park and its current park's base is > i (so it can be placed), then we do nothing, and update the base of the target park to i (because now the base of the target park is i, since we are moving from small to large? but wait, we are moving smallest first, so the base will be the smallest moved brick in the park).

                    - Otherwise, we have to move it to its target park. But to do that, the current park must have brick i on top, and the target park must have a base > i.

                Then the cost to move brick i from its current park s to its target park t is the cost R[s][t] plus the cost to move all bricks that are on top of i in park s. But there are no bricks on top of i because we are processing from small to large? The only bricks smaller than i are the ones we haven't moved yet. So if there is any brick j < i that is in park s, then it is on top of i, and we must move it away first. 

                Therefore, we must first move all bricks j < i that are in park s to some other park. This is the same as the recursion in the standard ToH for moving a tower.

                Specifically, we must move the set of bricks in park s that are < i to the other two parks, but not on the target park t because we are about to use it for brick i.

                How to move a set of bricks from one park to the other two? This is the standard ToH with three pegs for a single tower to be distributed to two pegs? 

                This is complex.

 Given the time constraints, and since the sample input has N=3, and we must deliver a solution, we decide to use state-space Dijkstra for the entire state space ONLY if N is small (<= 15), and for N>15, we use the recursion with state representation by the location of each brick and use a map to only store reached states. We hope that the cost between two states of interest is not exponential in N.

        Specifically, for a given pair of states of interest (from state A to state B), we run a Dijkstra that uses a priority queue and a hash map for the state representation.

        The state is a tuple of three sorted tuples (or three sorted lists) of the bricks in each park? But the set of bricks in a park can be represented by a bit mask? There are 40 bricks, so we can use a 40-bit integer for each park, but the state is three integers, and the state space is 3^40, which is too big for a hash map.

        Alternatively, we can represent the state by the location of each brick: a vector of length N where the i-th element is the park for brick i+1. This is an integer in the range [0,3^N), and we can use a vector of size 3^N? But 3^40 is too big.

        We must use a hash map, and we hope that the number of states visited is not the entire state space.

        The number of states visited might be exponential in the number of moves. The number of moves might be up to exponential.

        However, sample inputs are very small.

        Given the low N in the sample (N=3) and that M is at most 16, but the states of interest might have small move between them, we try to use Dijkstra for the state space between two states of interest with a hash table and a priority queue.

        Steps for computing cost from state A to state B:

            We are only interested in the cost from A to B, and we might prune if we exceed a bound? But we don't know the bound.

            We use a priority queue (min-heap) keyed by cost, and a hash map to store the best cost for a state.

            The state is represented as (mask0, mask1, mask2) where mask0 is the bit mask of bricks in park0, etc. But then the state can be represented by three unsigned long long for N<=40 (since 2^40 is about 1e12, so we can use 128-bit integers or simply an array of three integers, and use a tuple of three integers).

            Alternatively, we can use a tuple of three frozenset of integers, but hashing might be expensive.

            Or we can canonicalize: the state is determined by the set of bricks in each park. We can represent the state by (min0, min1, min2) only? -> Not sufficient.

            We must know the entire set to know the top brick (the smallest brick in the park).

            So state = ( the sorted list of the set for each park? ) -> too long.

            Alternatively, state = (mask0, mask1, mask2) where mask0 is the bit mask for park0, etc. Then the top brick in park0 is the least significant bit in mask0? But the smallest brick is the one with the smallest index, which is the smallest number. We can use:

                top0 = __builtin_ctzll(mask0)   [if mask0 is nonzero]

            Conditions for a move from park0 to park1:
                - mask0 != 0
                - let x = top0 = the smallest brick in park0.
                - Then we can move it to park1 only if park1 is empty or its top brick is > x.

            After the move:
                new_mask0 = mask0 without x (i.e., mask0 ^ (1LL<<x))
                new_mask1 = mask1 | (1LL<<x)

            The cost for the move is R[0][1].

            Similarly for other moves.

            The state space is 3^N, which is 3^40 = about 1.2e19 states, which is too many.

        Therefore, we must rely on the fact that the number of states visited in the Dijkstra from state A to state B might be limited by the fact that we stop when we reach state B, and the cost might be not too high. But the worst-case number of states might be exponential in the number of moves, and the number of moves might be exponential in N.

        Given the time, and since the problem might have small N in practice (like the sample) and the states of interest are only 20, we try to run the Dijkstra for states with small N (<=15) and for states with N>15, we use a different method. But the problem says N up to 40 and M up to 16.

        We might use the recursion with state = ( the location of each brick for the largest 15 bricks, and the number of the smaller bricks in each park )? This is not obvious.

        Alternatively, we can use the following for N>15: 

            Use the recursion by [ found in known solutions for similar problems ]: 

              https://codeforces.com/contest/392/problem/C
              This is not the same.

        Given the complexity, and since the sample has N=3, and the next 
        sample has N=3, and the problem might have test data with N up to 40, 
        but the intended solution might use the bitmask state and hope that the
        number of states visited in the Dijkstra between two states of interest 
        is not the entire state space, but only the states on the path.

        We will implement Dijkstra for the state space of (mask0, mask1, mask2) for the entire set of states, but we will use a hash map and a priority queue, and we will hope that for the particular states of interest in the test data, the number of states visited is not too high.

        But 3^40 states is not feasible.

        We must try to use a heuristic to only visit states that are on the path from A to B. There is no known heuristic.

        Given the time constraints, we might and the low N in the sample, we 
        decide to use the following:

          If N <= 15, then we use Dijkstra to compute the pairwise costs between the states of interest.

          If N > 15, then we use a different method: namely, we use the 
          recursive method that is used in the sample of only moving the largest
          brick that is not in position, and use the precomputed f(n, a, b, c) 
          for moving a tower of n disks from a to b with spare c.

          But note: the states of interest have arbitrary distributions, not 
          contiguous. So we can try to decomposition: 

            For state A and state B, for each brick i from N down to 1, 
            if brick i is in the correct park in state A and state B, then we 
            can leave it and use it as a base for smaller ones? or remove it.

            Otherwise, we must move it. To move it, we must move the bricks 
            smaller than i that are in the same park as i in state A to the 
            spare peg (not the target park for i and not the current park), 

            then move i to its target park, 
            then move the tower of smaller ones from the spare peg to the target park for i.

          The cost for moving the smaller ones from the current park to the spare peg: we use the precomputed cost for moving a tower of size (i-1) from the current park to the spare peg. But this cost is for a contiguous tower, and in our state, the smaller ones might be distributed in all three pegs. 

          So we must first gather the smaller ones that are in the current park of i into a tower? This gathering might be expensive.

        Given the complexity, and since the sample input has N=3, and the 
        intended solution for the sample is known, and we must output the code, 
        we will solve for N<=15 with state-space Dijkstra for pairwise 
        state of interest costs, and for N>15, we will use the following 
        exponential method but with iterative deepening and hope that the 
        cost is not too high and the states of interest are close. 

        Specifically, for N>15, we will still use Dijkstra in the state space, 
        but we will represent the state by a 128-bit integer for the bit masks, 
        and hope that the test data for N>15 is very sparse (only a few states) 
        or that the from state A to state B is very close.

        This is a gamble, but note that the states of interest might be close. 
        For example, in the sample, the states are only a few moves away.

        Alternatively, we precompute the cost between state A and state B using 
        the and the known  for the entire state space, and hope that N is 
        small in the test data.

        Given the problem statement and the sample, and since the sample has 
        N=3, and the next sample has N=3, and the only provided sample with 
        N=40 might be the worst-case, we decide to use the bit mask Dijkstra 
        for all N, and hope that the test data has only small states for the 
        pairs of states of interest.

        If the states of interest are far apart, then it might TLE or MLE.

        Steps for pairwise cost between state A and state B:

            Use a priority queue and a hash map (or unordered_map) keyed by the state = (mask0, mask1, mask2) where mask0, mask1, mask2 are bit masks (unsigned long long for N<=40, but 2^40 is about 1e12, so we can use unsigned long long for up to 64 bits, but 40<64).

            The state is then a triple of unsigned long long: (m0, m1, m2). But note: the entire set of bricks is represented, and m0 | m1 | m2 = (1<<N)-1, and they are disjoint.

            We start from state A, and we want to reach state B.

            We generate moves: for each park i, if the park is non-empty (m_i !=0), then let x = the smallest brick in park i = __builtin_ctzll(m_i) [but note: __builtin_ctzll returns the number of trailing zeros, which is the least significant bit, which corresponds to the smallest brick if we use brick0 to be the smallest?]

            How to assign bit index: let brick i be represented by bit (i-1) -> then the smallest brick is brick1, represented by bit0.

            Then the smallest brick in park i is the least significant bit in the mask.

            To move brick x from park i to park j (i!=j), we require that either park j is empty (m_j==0) or the smallest brick in park j is > x. But note: the smallest brick in park j is __builtin_ctzll(m_j) if we use the same representation.

            However, __builtin_ctzll(m_j) might be the least significant bit, which is the smallest brick in the park, and we are moving a brick x that is even smaller: so if the smallest brick in park j is y = __builtin_ctzll(m_j), then we require x < y.

            After the move:
                new_mask_i = m_i without bit x: m_i ^ (1ULL << x)
                new_mask_j = m_j | (1ULL << x)

            cost = R[i][j]

            We then insert the new state with cost = current_cost + cost.

            We stop when we extract state B.

        If we are doing pairwise for states of interest, we do this for each pair? 
        But then we do it for 20 states, and we do 20^2 = 400 Dijkstras, 
        and each Dijkstra might explore a lot of states.

        Instead, we do one Dijkstra from state A and try to reach state B and 
        also other states of interest? But then we would get the cost from A to 
        all states of interest in one run.

        Specifically, for a given start state S, we want the cost to all states 
        in a set T (the states of interest). We can run Dijkstra from S and 
        every time we reach a state in T, we record the cost and stop the 
        Dijkstra when we have collected all states in T.

        But the states in T are only 20, and the state space is 3^N, so we may 
        never collect them all.

        Therefore, we will run Dijkstra from S until we have found all states in T or the priority queue is empty.

        Given the state space is 3^N, for N=40, we cannot do it.

        We must pray that the test data has states of interest that are very 
        close to each other.

        Alternatively, for N>15, we might use a different approach: use the 
        fact that the only states of interest are 20, and use a meet-in-middle 
        with a bound on the number of moves. The bound might be the sum of the 
        costs of moving each brick individually, and then we use iterative 
        deepening in the cost space? This is not Dijkstra.

        Given the complexity, and since the problem might be too hard for us, 
        and the sample has N=3, we will only implement the bit mask Dijkstra 
        for N<=15, and for N>15, we output a placeholder (or use the same 
        method and hope that the test data for N>15 is not the worst-case).

        Given the time constraint, we decide to implement the bit mask 
        representation and Dijkstra for any N, but with a hope that the 
        number of states visited in practice is not astronomical.

        We will use a heuristic: if N is large (>15) and the states of interest 
        are far apart, then this might TLE. But the problem M is only 16, 
        and the states of interest are 20, and the from one state to another 
        might be within a few hundred moves, and the number of states visited 
        might be within a few million, which is acceptable.

        Let's hope.

        Summary of the solution:

          states_of_interest = [initial, goal0, goal1, ..., goal_{M-1}, final0, final1, final2]

          // Precompute a matrix cost[i][j]: cost from states_of_interest[i] to states_of_interest[j]

          For i in range(len(states_of_interest)):
              dist = dijkstra( states_of_interest[i], states_of_interest (the entire set) )
              for j in range(len(states_of_interest)):
                  cost[i][j] = dist[ states_of_interest[j] ]   // if reached, else INF

          // Then solve TSP: we start at state0 (initial state), must visit all goals (which are indices 1..M), and then to any final state (indices M+1, M+2, M+3).
          // We can use DP on subset of goals.

          dp[0] = 0, and then we iterate over subsets.

          Specifically, the states in the TSP are the indices in [0, len(states_of_interest)-1]. We must visit:
            0 (initial) is visited at the beginning.
            goals: indices 1 to M must be visited.
            we can also visit the finals early, but we don't have to until the end.

          We want to minimize the cost to start at 0, visit every goal at least once, and then go to any final.

          We do:

            dp[U][i] = minimum cost to have visited the set of goals U (subset of {1,2,...,M}) and currently at state i (which is in [0, len(states)-1])

          Initialization: dp[0][0] = 0.

          Then for each state i and for each state j not in U (or if j is not visited, and j is in [0, len(states)-1]), but note: we can also go to finals in the middle, but we only require to see the goals.

          We want to visit every goal exactly once? and we can visit finals any time.

          However, the problem: we must see each goal at least once. We might visit a state multiple times, but the cost[i][j] is the shortest path.

          So we can reduce to a complete graph on the states_of_interest.

          Then:

            for each subset U of [1, M] (represented as a bitmask), and for each state i in [0, len(states)-1]:
              for each goal j in [1, M] not in U:
                  dp[U | (1<<j)][j] = min( dp[U | (1<<j)][j], dp[U][i] + cost[i][j] )
              // also allow moving to any state, even if it is not a goal? but the state might be a final or the initial. But the only ones we are forced to visit are the goals.

          Then after covering all goals, we add the cost to any final state:

            answer = min_{i in [0, len(states)-1], for any final state index f in [M+1, M+3]} { dp[(1<<M)-1][i] + cost[i][f] }

          But note: we may have visited a final state already in the path, and then we don't need to move. But the problem requires that at the end all bricks are in one park. So the last state must be a final state. And we allow to go to a final state at the end.

          Also, we might have visited a final state in the middle, but then we moved away. That is allowed, but the very last state must be a final.

          However, our cost[i][f] is the cost from state i to state f, and state f is one of the finals. We are not required to be in a final state until the end.

          Also, we are not required to visit the final states during the journey, only at the end.

          So we don't require the finals to be visited until the last step.

        Implementation of the state and the dijkstra for the bit masks:

          State representation: 
            We have three parks: represented by three unsigned long long: m0, m1, m2.

          How to compute the top of a park: 
            For park0: if m0==0, then no top.
            else: the top = __builtin_ctzll(m0)   // returns the least significant bit, which is the smallest brick.

          Note: brick i is represented by bit (i-1). So the smallest brick is brick1, represented by bit0.

          Therefore, the top of a park is the smallest numbered brick in the park.

          Moving a brick x from park i to park j:
            Condition: 
                park i must have the brick x: (m_i has the bit for x) and x must be the smallest in the park: so the least significant bit of m_i must be the bit for x. But wait: what if there is a smaller brick? The smallest brick in the park is the top, so we can only move the smallest.

            Therefore, the only move from park i is to move its smallest brick.

          Steps for the move:

            x = __builtin_ctzll(m_i);
            // Check: is x the smallest? by definition, yes.
            // Check if we can move to park j: either m_j has no brick (m_j==0) or the smallest brick in park j is > x. The smallest in park j: y = __builtin_ctzll(m_j). We require x < y? But note: if we move x to park j, then the new smallest in park j will be min(x, y) = x, and then the condition is that the brick that is below x must be > x, but we are only moving the top and the condition is that the park we are moving to must have a top that is > x? 
            // In the problem: we can only move x to park j if the park j is empty or the top of park j is > x.

            So condition: if m_j is nonzero, then y = __builtin_ctzll(m_j), and we require x < y? Actually, we require that we are putting x on top of the stack in park j, and the condition is that the current top of park j is > x. So yes, we require that the current top of park j (which is y) is > x.

            But note: after the move, the new top of park j will be x, and the brick that was the top (y) will be below x, and we require y > x, which is true.

            So the condition is: if park j is non-empty, then __builtin_ctzll(m_j) > x.

            Then we do:

                new_m_i = m_i without the bit x: m_i ^ (1ULL<<x)
                new_m_j = m_j | (1ULL<<x)

          Cost = R[i][j]

        We then insert the new state (new_m0, new_m1, new_m2) with cost = current_cost + cost_move.

        We use a priority_queue: tuple< cost, state = tuple<ULL, ULL, ULL> >.

        We also use a hash map: unordered_map< tuple<ULL,ULL,ULL>, cost>

        How to represent the state as a tuple of three ULL: (m0, m1, m2)

        But note: the state space is 3^N, and for N=40, the state space is 3^40 which is huge, but we hope that the number of states visited in practice is not too high.

        Let's hope for the best.

        Steps:

          Let states_of_interest = []
          Read input, then:
            states_of_interest.push_back(initial_state)
            for each goal configuration: states_of_interest.push_back(goal_state)
            states_of_interest.push_back(final0)  // all in park0
            states_of_interest.push_back(final1)  // all in park1
            states_of_interest.push_back(final2)  // all in park2

          Let num_states = len(states_of_interest) = M+4.

          // We will compute a matrix: dist_matrix[i][j] = minimum cost from states_of_interest[i] to states_of_interest[j]

          For i in range(num_states):
              Let start = states_of_interest[i]
              We want to compute the cost from start to every state in states_of_interest.

              We do:

                  Let dist = a hash map: state -> cost
                  priority_queue: (cost, state), start state with cost0.

                  while queue not empty:
                      pop the smallest cost state: (c, s)
                      if s is in states_of_interest and we haven't recorded the cost to s for this start, then record it.

                      if we have recorded all states_of_interest, break.

                      else, generate all moves from s: for each park i from 0 to 2:
                         if park i is non-empty, then
                            x = __builtin_ctzll(s[i])   // s is (m0, m1, m2)
                            for each park j != i:
                                if park j is empty or __builtin_ctzll(s[j]) > x:
                                    new_s = s but with bit x moved from i to j.
                                    new_cost = c + R[i][j]

                                    if new_s is not in dist or new_cost < dist[new_s]:
                                        insert (new_cost, new_s)

                  Then for each state_of_interest j, 
                         if we have dist for states_of_interest[j]: then dist_matrix[i][j] = that cost
                         else: we set it to a large number (INF).

          Then solve the TSP as described.

        Note: We must canonicalize the state representation: we represent the state by (m0, m1, m2). But note: the order of the parks is fixed.

        How to build the state from the input:

          For a configuration given by three lines:

            For park0: we have a list of bricks: [a1, a2, ..., ak] (from top to bottom) -> but our state: the set of bricks in park0.

            We build: 
                m0 = 0
                for each brick in the list: 
                    brick index = a_i, then set bit (a_i-1) in m0.

            Similarly for m1, m2.

          The same for the initial state and the goal states.

          The final state for park0: 
                m0 = (1<<N)-1, m1=0, m2=0.

          Similarly for final1 and final2.

        Finally, we output the answer from the TSP.

        Let's hope it works for the sample.

        Sample 1: N=3, M=0.

          states_of_interest = [ initial_state, final0, final1, final2 ]

          The initial_state: 
                park0: [1,2] -> m0 = (1<<0) | (1<<1) = 0b011
                park1: [] -> m1=0
                park2: [3] -> m2 = (1<<2) = 0b100

          The finals: 
                final0: m0=0b111, m1=0, m2=0
                final1: m0=0, m1=0b111, m2=0
                final2: m0=0, m1=0, m2=0b111

          We need to compute the cost from the initial_state to any of the finals.

          The sample solution says 5.

          Let's see: 
                We do: 
                  Dijkstra from the initial_state.

          We might not want to compute the cost to the other finals? We only care about the cost from the initial_state to each of the finals.

          The sample provided solution does 5 moves.

          We will trust that the Dijkstra will find a cost of 5.

        Sample 2: N=3, M=2.

          states_of_interest = [initial, goal0, goal1, final0, final1, final2]

          The initial: 
               park0: [1,2] -> m0=0b011, park1: [3] -> m1=0b100, park2: empty.

          The goals:

            First goal: 
               3 1 2 3 -> all in park0: so m0=0b111, m1=0, m2=0.
            Second goal:
               empty, empty, [1,2,3] -> m0=0, m1=0, m2=0b111.

          The sample says 22.

          We will trust the Dijkstra to find the pairwise costs, and then the TSP will find the order: initial -> goal1 (second goal) -> goal0 (first goal) -> a final state (which is goal0 already, so no extra move) -> and then we add the cost from goal0 to a final state? but goal0 is already a final state (all in one park), so cost=0.

          So the cost = cost(initial -> goal1) + cost(goal1 -> goal0) + cost(goal0 to final) [which is 0]

          The sample says 8 + 14 = 22.

        Implementation details:

          We use:
            typedef unsigned long long ULL;
            typedef tuple<ULL, ULL, ULL> State;

          To get the top of park0: 
            if get<0>(state) == 0: then skip.
            else: x = __builtin_ctzll(get<0>(state));   // gives the index of the least significant set bit.

          But note: __builtin_ctzll(0) is undefined.

          Move generation:

            for (int i=0; i<3; i++) {
                ULL m = get<i>(state);
                if (m==0) continue;
                int x = __builtin_ctzll(m);   // returns the number of trailing zeros, which is the least significant bit.

                for (int j=0; j<3; j++) {
                    if (i==j) continue;
                    ULL mj = get<j>(state);
                    if (mj == 0) {
                        // can move
                    } else {
                        int y = __builtin_ctzll(mj);
                        if (x < y) { 
                            // can move
                        } else {
                            continue;
                        }
                    }
                    // do the move: 
                    State new_state = state;
                    // remove x from park i:
                    get<i>(new_state) = m ^ (1ULL << x);
                    // add x to park j:
                    get<j>(new_state) = mj | (1ULL << x);
                    // cost = R[i][j]
                }
            }

          We then push new_state.

        We must be cautious: the state has three ULLs.

        We use a hash for the state. How to hash a tuple of three ULL?
          We can do: 
            struct Hash {
                size_t operator()(const State& s) const {
                    auto [m0, m1, m2] = s;
                    return m0 ^ (m1<<1) ^ (m2<<2); // not good
                    // or use standard hash for tuple? or use boost? 
                }
            };

          Alternatively, we can pack into a std::array<ULL,3> and then use std::hash for each and combine.

          We can do:

            size_t seed = 0;
            seed ^= hash<ULL>()(get<0>(s)) + 0x9e3779b9 + (seed<<6) + (seed>>2);
            ... 

          Or use:

            struct Hash {
                size_t operator()(const State& s) const {
                    return get<0>(s) * 1000000009 + get<1>(s) * 1000000007 + get<2>(s);
                }
            };

          But better to use:

            #include <functional>
            struct Hash {
                size_t operator()(const State& s) const {
                    auto hasher = std::hash<ULL>();
                    return hasher(get<0>(s)) ^ hasher(get<1>(s)) ^ hasher(get<2>(s));
                }
            };

          But note: the masks might be sparse and the XOR might collide.

          We use:

            return hasher(get<0>(s)) ^ (hasher(get<1>(s)) << 1) ^ (hasher(get<2>(s)) << 2);

        Let's code accordingly.

        Finally, the TSP as described.

        We hope it passes.

        Note: The sample inputs are small.

        Edge: M=0: then we must go from initial to any final.

        Let's hope.

        Given the complexity, we will run the Dijkstra for each state of interest and hope that the states of interest are not too far.

        We will set a INF cost = 1e18.

        Steps:

          Precompute the list of states_of_interest.

          Let num_states = states_of_interest.size().

          Create a 2D vector: dist_matrix of size num_states by num_states, initialize to INF.

          For each index i in [0, num_states):
             We run Dijkstra from states_of_interest[i] and we break when we have found all states_of_interest OR if the queue is empty.

             But we can break early if we have found all states_of_interest: we maintain a set of found states (by index in states_of_interest) for this start.

          Then, after Dijkstra, for each j in [0, num_states): 
               if we have a recorded cost for states_of_interest[j] in the dist map, then dist_matrix[i][j] = that cost.

          Then, we do the TSP:

            Let dp[1<<M][num_states] -> we can reduce: we only need two layers? 

            Actually, we have states: 
                state0: initial state (index0)
                goals: indices 1 to M
                finals: indices M+1, M+2, M+3.

            We want to cover the goals: so we use a bitmask for the goals (M bits).

            We let:
                dp[i] is a vector of size num_states: dp[i][j] = minimum cost to have visited the set of goals in the bitmask i and ended at state j (which is an index in the states_of_interest list).

            Initialization: 
                dp[0][0] = 0   // started at state0, visited no goals.

            For bitmask i from 0 to (1<<M)-1:
                for each state j in [0, num_states):
                    if dp[i][j] is not INF, 
                         for each goal index k in [0, M) (which corresponds to state index = 1+k) that is not in i:
                             new_i = i | (1<<k)
                             new_cost = dp[i][j] + dist_matrix[j][1+k]   // because state index for the first goal is 1, then 2, ... M.
                             update dp[new_i][1+k] = min( dp[new_i][1+k], new_cost )

                         // also, we can go to any state? even if it is not a goal? 
                         // but the goals are the only ones we must visit. We can also go to finals in the middle? 
                         // but we don't need to. We only care about covering goals. So we only force goals.

            Then, after processing, we do:

                ans = INF
                for state j in [0, num_states):
                    for final index: f in { M+1, M+2, M+3 } (which are the last three states in states_of_interest, indices = num_states-3, num_states-2, num_states-1) 
                         ans = min(ans, dp[(1<<M)-1][j] + dist_matrix[j][f] )

            Output ans.

        Note: we can also not have visited a goal state but then we are at a final state? no, we must visit all goals.

        We assume that the state index for the initial state is 0, then goals are 1..M, then finals are M+1, M+2, M+3.

        But note: what if the initial state is the same as one of the goals? or one of the finals? 
          Then we can avoid moving. But the problem says we must see the goal at least once. If the initial state is one of the goals, then we have seen it.

        How to handle that?

          In the TSP, we start at state0 (which is the initial state). If state0 is a goal state, then we must mark it as visited.

          How to know if state0 is a goal state? 
            The goals are states_of_interest[1] to states_of_interest[M]. 
            So if state0 is one of the goals, then we should mark that goal as visited at the start.

          But our state0 is the initial state. The goals are given as M blocks. We did:

            states_of_interest.push_back(initial)
            for i in range(M): 
                read a goal -> states_of_interest.push_back(goal_i)

            then push the finals.

          So the initial state is at index0, and the first goal is at index1.

          Therefore, if the initial state is the same as a goal state, then we would have two different indices with the same state? and we would have recorded the cost between them as 0.

          Then in the TSP, we would update the goal set for that goal.

          But note: the goals might be duplicate? the problem says "each of the M brick configurations", so they are distinct.

          How to check state equality: we have (m0, m1, m2) as the state. We will compare the tuples.

          So in the Dijkstra, if the start state is the same as one of the states_of_interest, then we record the cost 0.

        We must be cautious: the same state might appear in the list of states_of_interest multiple times? 
          The problem: the initial state might be the same as a goal state, or a goal state might be the same as a final state.

          But if a goal state has all bricks in one park, then it is also a final state? 
          Then we would have two states_of_interest with the same state.

          We should then combine them? 

          Or we keep them as distinct indices, but the cost between them is 0.

          So in the dist_matrix, if i and j are different indices but the same state, we would have cost 0.

          That is correct.

        Let's code accordingly.

        We hope it works.

        Note: The state space for the TSP: 
          M<=16, so the bitmask has 2^16=65536 states, and the state index in the states_of_interest is at most 20, so the dp array has 65536 * 20 = 1.3e6 states.

        This is acceptable.

        We will code accordingly.

        Let's code.