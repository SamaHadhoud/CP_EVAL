 We are given R (rows) up to 14 and C (columns) up to 1000.
 The grid has R rows and C columns. Each cell is either '.' (empty) or 'v' (rice-planted).

 Conditions for sacred arrangement:
  1. Each row must have at least one scarecrow.
  2. Every two consecutive columns must have at least one scarecrow.

 We use inclusion-exclusion to handle the condition that every row has at least one scarecrow.

 Let F(T) be the number of arrangements that avoid placing any scarecrow in the rows in set T (and are allowed only in rows not in T) and that satisfy the consecutive column condition (every two consecutive columns have at least one scarecrow).

 Then by inclusion-exclusion, the answer is:
   sum_{T subset of [R]} (-1)^{|T|} * F(T)

 How to compute F(T) for a fixed subset T?
   We note that for each column j, we can only place scarecrows in the rows that are:
        - available (i.e., the cell is '.') 
        - and not in T.

   Let A_j = set of rows in column j that are available and not in T.

   Condition: For the consecutive column condition, we require that for any two consecutive columns j and j+1, at least one of them has at least one scarecrow.

   However, note that the condition is: "each consecutive two columns contain at least one scarecrow" meaning that for every consecutive pair (j, j+1), there must be at least one scarecrow in column j OR column j+1.

   We can model this with a DP over columns with state indicating whether the current column has at least one scarecrow and also considering the previous column's state? Actually, we can design:

   Let:
      dp[j][0] = number of ways to arrange the first j columns such that the j-th column has NO scarecrow, but the consecutive condition is maintained up to j (so note: then the previous column (j-1) must have had a scarecrow? because the pair (j-1, j) must have at least one? But if j=0 then we have no previous?).

   However, note the condition applies to consecutive pairs: 
        for j from 0 to C-2: the pair (j, j+1) must have at least one.

   We can design the state as:
        state0: the current column has at least one scarecrow? Not exactly: we need to ensure that the consecutive condition is maintained. We can let:

        Let:
          dp[j][0] = the number of ways for the first j+1 columns such that the j-th column has no scarecrow, but the consecutive condition for the last pair (if any) is satisfied. However, if the j-th column is empty, then the previous column must have had at least one to cover the pair (j-1, j). But then we also have to worry about the next column?

   Alternatively, we can break the condition by having a state that indicates the last column that had a scarecrow? But note the condition is only for consecutive pairs.

   We can use a state that indicates the last column that had a scarecrow? But that might be too heavy.

   Actually, note: the condition is local: we only require that for each consecutive pair (j, j+1), at least one column has a scarecrow. This is similar to: we cannot have two consecutive zeros (if we let 0 represent a column with no scarecrow and 1 with at least one). But note: we are allowed to have two consecutive ones? Yes.

   Therefore, we can do:

        dp[j][state] where state in {0, 1} meaning:
          state=0: the j-th column has no scarecrow -> then the previous column (j-1) must have had a scarecrow (to satisfy the pair (j-1,j)).
          state=1: the j-th column has at least one scarecrow.

        However, what about the pair (j, j+1)? We haven't processed the next column. Instead, we can enforce at each step that the consecutive condition for the current and next hasn't been broken? Actually, we can do:

        Conditions:
          - We cannot have two consecutive zeros.

        Therefore, we design the state as:
          dp[j][0]: the number of ways for the first j+1 columns such that the j-th column is empty (so we require that the previous column was non-empty) and the entire sequence so far is valid (including the consecutive condition for the last two).
          dp[j][1]: the number of ways for the first j+1 columns such that the j-th column is non-empty.

        But note: if the j-th column is empty, then the previous must be non-empty. So the transition:

          For the first column (j=0):
            dp0[0] = 0   -> because if the first column is empty, then we have no previous to cover? But the consecutive condition hasn't been applied? Actually, condition for consecutive columns starts from column0 and column1. However, the first column alone? There is no consecutive pair including it? So the first column can be empty? But wait: condition says "each consecutive two columns", so the consecutive pairs are (0,1), (1,2), ... , (C-2, C-1). The first column by itself is not constrained by the consecutive condition? Then we can have the first column empty? However, if the first column is empty, then when we get to the second column we must have the second column non-empty? But then the state for the second column would be non-empty, and the consecutive pair (0,1) would be satisfied by the second column.

          However, note: if the entire grid has only one column? Then condition "every consecutive two columns" is vacuously true? So we only require that each row has at least one? But that is handled by inclusion-exclusion.

        Therefore, for the first column:
          dp0[0] = 0   # we cannot have the first column empty? Actually we can, because there's no consecutive pair ending at the first column? But the consecutive condition doesn't require anything for the first column alone. However, if we have only one column, then the consecutive condition doesn't apply. But the row condition is taken care of by inclusion-exclusion? Actually, the row condition is independent: we are computing F(T) which doesn't require each row to have a scarecrow? Actually, F(T) counts arrangements that avoid rows in T and satisfy the consecutive column condition. And the consecutive column condition for a single column: no consecutive pair, so it's automatically satisfied.

        But note: the consecutive condition applies only to consecutive two columns. So if there is only one column, then no constraint? 

        Therefore, for the first column:
          state0: no scarecrow -> then we have 1 way? But wait: we must also consider that we are not putting any scarecrow. However, the non_empty_arr[0] is the number of ways to have at least one scarecrow in the first column (for rows not in T). So the ways for having no scarecrow in the first column is 1? But actually, we have two choices per row? However, we are counting: for the first column, we can choose any subset of the available rows? But then having no scarecrow is one way.

        However, note: in F(T) we do not require the row condition? The row condition is handled by inclusion-exclusion. In F(T), we are only avoiding rows in T. And the consecutive condition: for a single column, it's satisfied. So for the first column:

          Option 1: put no scarecrow -> that is allowed? Then we have 1 way? But wait: we also have the possibility of having scarecrows? Actually, we are going to use:

          Let non_empty_arr[j] = number of non-empty ways for column j? Actually, non_empty_arr[j] counts the ways that the column j has at least one scarecrow. The total ways for column j is 2^(a_j) (each row independently chosen) and we subtract the empty case: so non_empty_arr[j] = 2^(a_j) - 1.

          Then the entire arrangement for the columns can be:

            Option for column j: either we put at least one (non_empty_arr[j] ways) or we put none (1 way).

          But then we have the consecutive condition: we cannot have two consecutive zeros.

        Therefore, we design:

          Let:
            dp[0][0] = 1   # meaning: we choose to have no scarecrow in column0 -> but note: this is one way? However, we have to account for the fact that we could have chosen any subset? Actually, no: if we choose to have no scarecrow, then we are forced to choose the empty set. So that is 1 way.

            dp[0][1] = non_empty_arr[0]   # meaning: we choose to have at least one scarecrow.

          Then for j>=1:

            If we want the current column j to be empty (state0), then the previous column must have been non-empty? because we cannot have two consecutive zeros. So:
                dp[j][0] = dp[j-1][1] * 1   [because we are forced to choose the empty set for column j: one way?]

            But wait: the state0 for column j: we are forced to choose the empty set -> that is 1 way? However, what if the column j has no available rows? Then we cannot put a scarecrow, but also we are forced to choose the empty set. So the 1 way is always available? Actually, if the column j has no available row (so non_empty_arr[j] = 0) then we cannot put any scarecrow? Then the only possibility for column j is the empty set. But then if we choose state0, then we require that the previous column was non-empty.

            Similarly, for state1 (current column non-empty), we can come from any state of the previous column? However, we don't require the previous column to be non-empty? Because if the previous column was empty, then the consecutive pair (j-1, j) is covered by the current column? So:

                dp[j][1] = (dp[j-1][0] + dp[j-1][1]) * non_empty_arr[j]

          However, note: if non_empty_arr[j] is 0 (i.e., no way to put a scarecrow in column j), then we cannot have state1 for column j.

        But then what about the consecutive condition? The consecutive condition for (j-1, j) is already enforced by the state: 
          - If the current column j is state0, then the previous must be state1 -> so the pair (j-1,j) is covered by the previous column (which is non-empty).
          - If the current column j is state1, then the pair (j-1,j) is covered by either the previous column (if it was non-empty) or the current column (if the previous was empty). But if the previous was empty, then the consecutive pair (j-1,j) is covered by the current column? Yes.

        However, what about the consecutive pair (j-2, j-1)? That was already taken care of in the previous state.

        Therefore, recurrence:

          dp[0][0] = 1   [if column0 is empty]
          dp[0][1] = non_empty_arr[0]

          For j from 1 to C-1:
            dp[j][0] = dp[j-1][1]   # because we require the previous column was non-empty, and then we choose the empty set for column j (1 way)
            dp[j][1] = (dp[j-1][0] + dp[j-1][1]) * non_empty_arr[j]

          Then F(T) = dp[C-1][0] + dp[C-1][1]   ? 

        But wait: what about the consecutive condition for the last pair? 
          The consecutive condition for (C-2, C-1) is enforced in the state at j=C-1? 
          However, note: if the last column is state0, then we require that the previous (column C-2) was state1 (which is enforced by the recurrence: because we set dp[C-1][0] = dp[C-2][1]). So that pair is covered.

        However, the consecutive condition for the entire grid is satisfied? Because we enforce at every step.

        But note: the consecutive condition for the entire grid is: for every pair (j, j+1) for j=0 to C-2. And our recurrence ensures that for every j from 1 to C-1, if the current column j is state0 then the previous (j-1) was state1. And if the current column j is state1, then the consecutive pair (j-1, j) is satisfied because either the previous column was state1 (so covered) or the previous was state0? But wait, if the previous column was state0, then we required the column j-2 was state1? But that is already taken care of in the state at j-1? Actually, the state at j-1 being state0 requires that j-2 was state1. Then for the pair (j-1, j): 
          - j-1 is state0: then we require j-2 is state1 -> that covers the pair (j-2, j-1). 
          - But the pair (j-1, j) is covered by j (which is state1).

        So the recurrence is correct.

        However, what if the entire grid has only one column? Then we have:
            F(T) = dp0[0] + dp0[1] = 1 + non_empty_arr[0]

        But is that correct? 
          Condition: no consecutive pair -> so valid. 
          The arrangements: 
            Option0: no scarecrow in the only column -> 1 way.
            Option1: at least one scarecrow -> non_empty_arr[0] ways.

        So total = 1 + non_empty_arr[0] ways.

        But wait: the row condition is handled by inclusion-exclusion? So this F(T) counts arrangements that avoid rows in T, and in the one column we can have any subset of the available rows? Then the total arrangements for the column is 2^(a_0) = (1 + non_empty_arr[0])? Actually, because non_empty_arr[0] = 2^(a_0) - 1, so total = 1 + (2^(a_0)-1) = 2^(a_0). 

        So that is correct: for one column, the consecutive condition is vacuous, and we count all subsets? 

        However, note: the consecutive condition is satisfied for one column? Yes.

        But then why in the sample input: "1 3\n..." -> output 5? 

        For a grid of 1 row and 3 columns: 
          R=1, C=3, and grid = "..."

        We are going to compute the total arrangements that satisfy the consecutive condition? And then use inclusion-exclusion to ensure that the one row has at least one scarecrow? 

        How does inclusion-exclusion work for the row condition? 
          We iterate over subsets T of the rows. Since there's only one row, T can be either {} or {0}.
          F({}) = count of arrangements that avoid no row -> so all rows are available. And we count arrangements for 3 columns satisfying consecutive condition? 
          F({0}) = count of arrangements that avoid the row0 -> then we have no available row? Then non_empty_arr[j] = 0 for every j. Then:
              dp0[0] = 1, dp0[1] = 0 -> then for j=1: 
                 dp1[0] = dp0[1] = 0
                 dp1[1] = (dp0[0]+dp0[1])*0 = 0
              then for j=2: 
                 dp2[0] = dp1[1] = 0
                 dp2[1] = (dp1[0]+dp1[1])*0 = 0
              so F({0}) = 0+0 = 0.

          Then total = F({}) - F({0}) = F({}).

        How do we compute F({})? 
          non_empty_arr[j] for each j: since the row is available, a_j=1 -> non_empty_arr[j] = 2^1-1 = 1.

          Then:
            j0: dp0[0]=1, dp0[1]=1.
            j1: dp1[0] = dp0[1] = 1
                 dp1[1] = (dp0[0]+dp0[1])*1 = (1+1)=2
            j2: dp2[0] = dp1[1] = 2
                 dp2[1] = (dp1[0]+dp1[1])*1 = (1+2)=3
            total = 2+3 = 5.

        So that matches.

        However, what if a column has no available row? Then non_empty_arr[j] = 0. Then:
          For j0: 
            dp0[0] = 1, dp0[1] = 0.
          Then j1: 
            dp1[0] = dp0[1] = 0
            dp1[1] = (dp0[0]+dp0[1]) * non_empty_arr[1] = (1+0)*0 = 0
          Then j2: 0.

        Then total ways = 0.

        This matches the third sample: 
          "2 3\nvvv\n..." 
          First row: "vvv" -> so base[0] = base[1]=base[2] for the first row: 0? Then for the second row: the second row is available? 
          But note: we are going to iterate over T (subsets of rows). The inclusion-exclusion:

          We require that both rows must be covered. So T can be:
            T0: {} -> then for column0: available rows = second row -> a0=1 -> non_empty_arr0=1.
                   column1: available rows = second row -> a1=1 -> non_empty_arr1=1.
                   column2: available rows = second row -> a2=1 -> non_empty_arr2=1.

                   Then F({}) = computed as above for 3 columns: 5? 

            T1: {0} -> then we avoid row0: so available rows = row1. Then same as above: 5.
            T2: {1} -> then we avoid row1: then for column0: only row0 is available? But row0 is all 'v'? So column0: base[0] = 0? Then non_empty_arr0 = 0. Then F({1}) = 0.
            T3: {0,1} -> then we avoid both rows: then non_empty_arr0=0, non_empty_arr1=0, non_empty_arr2=0 -> F=0.

          Then total = F({}) - F({0}) - F({1}) + F({0,1}) = 5 - 5 - 0 + 0 = 0.

        So that matches.

        But wait: the third sample: the first row is all 'v', so we cannot put any scarecrow in the first row. Therefore, to satisfy the condition that the first row has at least one scarecrow, we must have at least one scarecrow in the first row? But we cannot. So the answer should be 0.

        However, in our inclusion-exclusion, we are counting arrangements that cover all rows. The inclusion-exclusion formula:

          total = sum_{T} (-1)^(|T|) * F(T)

          where F(T) counts arrangements that avoid rows in T (and satisfy the consecutive condition).

          Then if we let U be the set of all rows, then the arrangements that cover all rows are:

          = F(âˆ…) - F({0}) - F({1}) + F({0,1})

          = 5 - 5 - 0 + 0 = 0.

        So it works.

 Implementation details:

   Steps:

     1. Precompute base masks for each column: base[j] is a bitmask of R bits: bit i is 1 if grid[i][j]=='.' (available), 0 otherwise.

     2. Precompute power2: for exponents from 0 to R (max exponent R).

     3. Precompute popcount_arr: for all masks in [0, 1<<R).

     4. For each subset T in [0, 1<<R):
            For each column j:
                available_mask = base[j] & ~T   [so we remove the rows in T]
                a_j = popcount_arr[available_mask]   [if the mask has more than R bits? we mask to R bits? Actually, we only consider the lower R bits]

                non_empty_arr[j] = (power2[a_j] - 1) % MOD   [if a_j>0; if a_j==0, then non_empty_arr[j]=0]

            Then, if C==0: 
                    F(T) = 0? Actually, if C==0 then no consecutive pairs, and we have an empty arrangement? But we have no column -> then we don't put any scarecrow. Then the row condition is not satisfied? But note: inclusion-exclusion is over the row condition? However, the problem: if there are no columns, then we cannot put any scarecrow -> then no row has a scarecrow? So we would not count this? Actually, the problem states: R>=1, C>=1? The constraints: R>=1, C>=1? Actually: 1<=R, 1<=C.

            Then we do:

                dp0 = 1   # for state0 of column0: meaning we choose no scarecrow in column0 -> 1 way
                dp1 = non_empty_arr[0]   # for state1: meaning we choose at least one in column0

                Then for j from 1 to C-1:
                    new_dp0 = dp1   # state0 for column j: we require that the previous column (j-1) was state1, and we choose empty set for column j -> 1 way
                    new_dp1 = (dp0 + dp1) * non_empty_arr[j] % MOD

                Then F(T) = (dp0 + dp1) for the last state? But note: after the loop, we have the states for the last column.

                Actually, we did:
                    j=0: state0 = 1, state1 = non_empty_arr[0]
                    then for j=1: 
                         state0 = state1_prev = non_empty_arr[0]
                         state1 = (1 + non_empty_arr[0]) * non_empty_arr[1]

                Then for j=1, total = state0 + state1 = non_empty_arr[0] + (1+non_empty_arr[0])*non_empty_arr[1]

                But we can also have: 
                    column0: empty -> then column1 must be non-empty? and column0: non-empty -> then column1 can be either? But no: our state for column1: 
                      state0: column1 is empty -> then we require column0 was non-empty? so that's non_empty_arr[0] ways? 
                      state1: column1 is non-empty -> then we don't care about column0? but we do: we have (dp0_prev+dp1_prev) * non_empty_arr[1] = (1 + non_empty_arr[0]) * non_empty_arr[1]

                So total = non_empty_arr[0] + (1+non_empty_arr[0])*non_empty_arr[1]

          Then we store F(T) = (state0 + state1) for the last column? Actually, at each step we only keep the last column. So at the end, we have the last column's state0 and state1, and we add them.

     5. Then apply inclusion-exclusion: 
            total = 0
            for T in range(1<<R):
                if popcount_arr[T] % 2 == 0:
                    total = (total + F(T)) % MOD
                else:
                    total = (total - F(T)) % MOD

     6. Adjust total to be non-negative modulo.

   However, note: the above recurrence for the DP uses two variables that we update for each column. We can use two variables and update them in a loop for columns.

   But note: what if the column j has no available row? Then non_empty_arr[j]=0. Then:
        new_dp0 = dp1   [which is the state1 from the previous column]
        new_dp1 = (dp0+dp1)*0 = 0

   Then for the next column, we have state0 = new_dp0 = dp1, state1 = 0.

   Example: 
        Column0: non_empty_arr[0] = 0 -> then dp0=1, dp1=0.
        Column1: 
            state0 = dp1_prev = 0
            state1 = (1+0)*non_empty_arr[1]   [if non_empty_arr[1] is non-zero?]

        Then if non_empty_arr[1] is non-zero, then state1 = (1+0)*x = x? 

   But wait: if column0 has no available row, then we must choose the empty set? So state0=1, state1=0. Then for column1: 
        state0 = previous state1 = 0
        state1 = (previous state0 + state1) * non_empty_arr[1] = (1+0)*x = x.

        Then total for column1 = 0+x = x.

   Then if we have column2: 
        state0 = state1_prev = x
        state1 = (state0_prev + state1_prev) * non_empty_arr[2] = (0 + x) * non_empty_arr[2] = x * non_empty_arr[2]

   This seems correct.

   However, what if we have two consecutive columns that are forced to be empty? 
        Column0: non_empty_arr[0]=0 -> state0=1, state1=0.
        Column1: non_empty_arr[1]=0 -> then:
            state0 = state1_prev = 0
            state1 = (state0_prev+state1_prev)*0 = (1+0)*0 = 0 -> so total=0.

        Then the consecutive condition for (0,1): we have two consecutive zeros? That is invalid? But our recurrence: 
            Column0: state0 -> we have no scarecrow -> then we require that the previous column? But column0 is the first column -> so no previous? Then it's allowed? But then column1: state0 -> then we require that column0 was non-empty? But column0 was state0 (empty) -> so we cannot assign state0 for column1? 

        Therefore, if column1 is forced to be empty, then we must have state0 for column1? But then we require that column0 was non-empty? which it wasn't -> so state0 for column1 is 0.

        And state1 for column1 is 0 because non_empty_arr[1]=0. So total=0.

        This is correct: we have two consecutive zeros (column0 and column1) -> invalid.

   Therefore, the recurrence is correct.

   Let's test on the sample: 
        "2 2\nv.\n.."

        Rows: 2, Columns: 2.

        Grid:
          row0: "v." -> available: only column1? Actually, column0: row0: 'v' -> not available; row1: '.' -> available? 
          row1: ".." -> both available.

        So base[0]: column0: row0: not available, row1: available -> mask = 0b10 (if we index rows from 0 to R-1: row0 is bit0, row1 is bit1) -> so base[0] = 2 (binary 10).
        base[1]: column1: row0: '.' -> available -> bit0=1; row1: '.' -> available -> bit1=1 -> base[1]= 3 (binary 11).

        Inclusion-exclusion: T in {0, 1, 2, 3} (for 2 rows, subsets: 0:00, 1:01, 2:10, 3:11).

        We need F(T) for each T.

        T=0: avoid no rows -> available = base[j] for each column.

            Column0: base[0]=2 -> available_mask = 2 -> a0 = popcount(2)=1 -> non_empty_arr0 = 2^1-1 = 1.
            Column1: base[1]=3 -> available_mask=3 -> a1=2 -> non_empty_arr1 = 2^2-1=3.

            Then:
                j0: state0=1, state1=1.
                j1: state0 = state1_prev = 1
                     state1 = (state0_prev+state1_prev)*3 = (1+1)*3 = 6
                total = 1+6 = 7.

        T=1: avoid row0 (which is bit0) -> so mask T=1 (binary 01) -> then:
            Column0: base[0]=2 (10) -> ~T= ...1110? Then base[0] & ~T = 10 & 10? -> 2 -> a0=1 -> non_empty_arr0=1.
            Column1: base[1]=3 (11) -> base[1] & ~T = 11 & 10 = 10 -> a1=1 -> non_empty_arr1=1.
            Then:
                j0: state0=1, state1=1.
                j1: state0=1, state1=(1+1)*1=2 -> total=3.

        T=2: avoid row1 (bit1) -> T=2 (binary 10) -> then:
            Column0: base[0]=10 -> & ~T (which is 01) -> 00 -> so a0=0 -> non_empty_arr0=0 -> state0=1, state1=0.
            Column1: base[1]=11 -> & ~T (01) -> 01 -> a1=1 -> non_empty_arr1=1.
            Then:
                j1: state0 = state1_prev = 0
                     state1 = (state0_prev+state1_prev)*1 = (1+0)=1 -> total=0+1=1.

        T=3: avoid both rows -> 
            Column0: base[0] & ~3 = 0 -> non_empty_arr0=0 -> state0=1, state1=0.
            Column1: base[1] & ~3 = 0 -> non_empty_arr1=0 -> state0=0, state1=0 -> total=0.

        Then total = 
            T0: 7 -> sign: |T0|=0 -> even -> +7
            T1: 3 -> sign: |T1|=1 -> odd -> -3
            T2: 1 -> sign: |T2|=1 -> odd -> -1
            T3: 0 -> sign: |T3|=2 -> even -> +0
            = 7-3-1 = 3.

        Matches the sample output: 3.

   Therefore, we code accordingly.

   However, note: the state for the first column: 
        state0 = 1   [meaning: we choose the empty set for the first column?]
        state1 = non_empty_arr[0]   [meaning: we choose a non-empty set for the first column]

   But what if non_empty_arr[0] is 0? Then state1=0. Then we have state0=1 and state1=0.

   Then for the next column, we use:
        state0_next = state1_prev = 0
        state1_next = (state0_prev+state1_prev)*non_empty_arr[1] = (1+0)*non_empty_arr[1] = non_empty_arr[1]

   That is correct.

   We code accordingly.

   Note: The problem states: R>=1, C>=1.

   Let's code accordingly.

   Steps in code:

        Read R, C and grid.

        Precompute:
            nT = 1 << R

            base = [0] * C
            for j in range(C):
                mask = 0
                for i in range(R):
                    if grid[i][j] == '.':
                        mask |= (1 << i)
                base[j] = mask

            Precompute power2: for exponents from 0 to R (inclusive) -> size R+1.
            Precompute popcount_arr for all masks in [0, nT): 
                popcount_arr[x] = bin(x).count('1')   [for x in range(nT)]

        F_values = [0] * nT   # F(T) for each T

        For T in range(nT):
            non_empty_arr = [0] * C
            for j in range(C):
                avail_mask = base[j] & (~T)   # but note: ~T is in infinite bits? We only care about the lower R bits? So we can mask by (nT-1) to get R bits?
                # Actually, base[j] is in the range [0, nT-1]. Then ~T is in the range of integers? We can mask by (nT-1) to get the lower R bits? 
                # Because: base[j] has R bits? So we do:
                avail_mask &= (nT - 1)
                a_j = popcount_arr[avail_mask]
                if a_j == 0:
                    non_empty_arr[j] = 0
                else:
                    non_empty_arr[j] = (power2[a_j] - 1) % MOD

            if C == 0:
                F_values[T] = 0
            else:
                # For column0:
                dp0 = 1
                dp1 = non_empty_arr[0]

                # Process from column1 to last column (if any)
                for j in range(1, C):
                    # state0 for column j: we choose the empty set -> then the previous column must have been non-empty? so we take state1 from the previous column.
                    new_dp0 = dp1   # because we require the previous column was non-empty? and we have 1 way to choose the empty set?
                    # state1 for column j: we choose at least one -> then we can come from any state of the previous column? and we multiply by non_empty_arr[j]
                    new_dp1 = (dp0 + dp1) % MOD
                    new_dp1 = (new_dp1 * non_empty_arr[j]) % MOD
                    dp0, dp1 = new_dp0, new_dp1

                F_values[T] = (dp0 + dp1) % MOD

        total = 0
        for T in range(nT):
            if popcount_arr[T] % 2 == 0:
                total = (total + F_values[T]) % MOD
            else:
                total = (total - F_values[T]) % MOD

        total %= MOD
        if total < 0:
            total += MOD
        print(total)

   Let's test with the one column case: 
        R=1, C=1, grid = ['.']
        T in [0,1]:
        T=0: 
            base[0] = 1 (if row0 is the first row, then bit0 set) -> a0=1 -> non_empty_arr[0]=1.
            Then: 
                dp0=1, dp1=1 -> F(0)=1+1=2.
        T=1:
            base[0] & ~1 = 0 -> non_empty_arr[0]=0 -> dp0=1, dp1=0 -> F(1)=1.
        Then total = F(0) (sign +) - F(1) (sign -) = 2 - 1 = 1? 

        But expected? 
          The grid: one row and one column: we can put the scarecrow? Or not? 
          The row condition: we require at least one scarecrow in the row? So we cannot have the empty set. 
          How does inclusion-exclusion work?
            T=0: F(0) counts arrangements that avoid no row? So we can choose any subset? 
                  subsets: empty -> 0; non-empty -> 1 -> total arrangements? 2? But then we subtract arrangements that avoid row0? 
            T=1: F(1) counts arrangements that avoid row0? Then we have no row? then the arrangements: only the empty set? 1 way.

            Then total = F(0) - F(1) = 2 - 1 = 1.

          But wait: the row condition requires the row to have at least one scarecrow. So the valid arrangements are only the non-empty set? which is 1 way.

        However, our F(0) counts the entire arrangements: both empty and non-empty? That's 2? Then we subtract the arrangements that avoid row0? which is 1? Then we get 1? which is the non-empty arrangement? 

        But note: the row condition is enforced by inclusion-exclusion: we are counting arrangements that cover all rows? So that is the non-empty arrangement? 

        So the answer is 1? 

        But the grid has one row and one column: the scarecrow is either present or not? But we require the row to have at least one? so only one way.

        Therefore, the code for one column is correct.

   However, the sample input "1 3\n..." -> we computed above as 5? and that was correct.

   So we run the code for the samples.

   Sample 1: "2 2\nv.\n.." -> we computed 3? and the code above for T=0:7, T=1:3, T=2:1, T=3:0 -> total=7-3-1=3 -> correct.

   Sample 2: "1 3\n..." -> 
        R=1, C=3, grid = ['...']
        base[0]=1, base[1]=1, base[2]=1.

        T in [0,1] (since nT=2)

        T=0: 
            non_empty_arr = [ (2^1-1)=1, 1, 1]
            Then:
                j0: dp0=1, dp1=1
                j1: dp0 = dp1_prev=1, dp1 = (1+1)*1=2 -> then for j1: total state=1+2=3
                j2: dp0 = dp1_prev=2, dp1 = (1+2)*1=3 -> total = 2+3=5 -> F(0)=5.

        T=1: 
            non_empty_arr = [0,0,0]
            j0: dp0=1, dp1=0
            j1: dp0=0, dp1=(1+0)*0=0 -> then j1: 0
            j2: dp0=0, dp1=(0+0)*0=0 -> total=0.
        Then total = F(0) - F(1) = 5 - 0 = 5.

        Correct.

   Sample 3: "2 3\nvvv\n..." -> 
        R=2, C=3.

        Grid:
          row0: "vvv" -> base[0]=0, base[1]=0, base[2]=0? 
          row1: "..." -> so base[0]= (0 for row0, 1 for row1 -> 2 (binary 10)), base[1]=2, base[2]=2.

        Then:
          T=0: 
            non_empty_arr[0] = popcount( base[0] & ~0 ) = popcount(2)=1 -> 1
            non_empty_arr[1] = 1
            non_empty_arr[2] = 1
            Then F(0) = 5? (as in the 1x3 case) -> 5.

          T=1: avoid row0 -> then available rows: row1 -> same as above? 
            base[0] & ~1 = 2 & ~1 (which is 111..0 in bits? then mask to 2 bits: 10 & 10 = 2 -> popcount=1 -> non_empty_arr[0]=1, similarly for others -> F(1)=5.

          T=2: avoid row1 -> then 
            base[0] & ~2 = 2 & 1 = 0 -> non_empty_arr[0]=0
            base[1] & ~2 = 0 -> non_empty_arr[1]=0
            base[2] & ~2 = 0 -> non_empty_arr[2]=0
            Then F(2)=0? (because: 
                j0: dp0=1, dp1=0
                j1: dp0=0, dp1=(1+0)*0=0
                j2: dp0=0, dp1= (0+0)*0=0 -> total=0)

          T=3: avoid both -> non_empty_arr[0]=0, non_empty_arr[1]=0, non_empty_arr[2]=0 -> F(3)=0.

          Then total = F(0) - F(1) - F(2) + F(3) = 5 - 5 - 0 + 0 = 0.

        Correct.

   Sample 4: "3 3\n...\n.v.\n..." -> 
        We are not going to compute by hand, but the sample output is 145.

   We code accordingly.

   One note: the grid has 3 rows and 3 columns.

   We trust the algorithm.

   However, note: the state0 and state1 for each column: we are using two variables and updating for each column. This is O(C) per subset T, and there are 2^R subsets -> R up to 14 -> 2^14=16384, and C up to 1000 -> 16384 * 1000 = 16.384e6, which is acceptable in Pyton? We need to optimize the inner loop.

   We write the code accordingly.

   Let's run the code for the sample 4: 
        Input: 3 3
                ...
                .v.
                ...

        We must get 145.

   We don't do by hand, but we run the code.

   We code accordingly.

   One more note: the base mask for each column:

        Column0: 
            row0: '.' -> bit0=1
            row1: '.' -> bit1=1
            row2: '.' -> bit2=1 -> mask = 0b111 = 7.

        Column1:
            row0: '.' -> 1
            row1: 'v' -> 0
            row2: '.' -> 1 -> mask = 0b101 = 5.

        Column2: same as column0: 7.

        Then we iterate over T in [0,8) (since 2^3=8).

        We'll compute F(T) for each T.

        Then total = inclusion-exclusion sum.

        We hope to get 145.

   We run the code in mind? It's long. We trust.

   We code accordingly.

   We write the code below.

   Note: We must do mod arithmetic appropriately.

   We precompute power2 for exponents up to R (max R=14, so up to 14).

   Precomputation of popcount_arr: for x in range(nT) (nT=8 for R=3) -> we can compute by bin(x).count('1').

   Then for each T in range(8):

        For each column j in [0,2]:
            avail_mask = base[j] & ~T, then mask to (nT-1) bits? Actually, base[j] is already in the lower R bits. Then ~T is an integer with infinite ones? We do: 
                avail_mask = base[j] & (~T) 
                Then we mask with (nT-1) to get the lower R bits? Because base[j] is in [0, nT-1]. But ~T might have more bits? 
                We can do: avail_mask = base[j] & (~T) & (nT-1)

        Then a_j = popcount_arr[avail_mask]

        Then non_empty_arr[j] = (power2[a_j] - 1) % MOD.

        Then DP for the columns.

   Then combine.

   We hope the code runs within the constraints.

   Since R<=14, C<=1000, and 2^R * C = 16384 * 1000 = 16.384e6 iterations, which is acceptable in Pyton? But note: in the inner loop we also do R (to compute base masks initially) and for each subset T we iterate over C columns and do a DP that is O(C). The base masks precomputation is O(R*C) = 14*1000 = 14000, which is acceptable.

   We code accordingly.

   Let me run the sample 4 in the code: 
        R=3, C=3, grid = ["...", ".v.", "..."]

        base = [7, 5, 7]   (for columns 0,1,2)

        nT = 8.

        Precomputation for power2: [1,2,4,8,...] for exponents 0 to 3: 
            power2[0]=1, power2[1]=2, power2[2]=4, power2[3]=8.

        popcount_arr for 0..7: 
            0:0, 1:1, 2:1, 3:2, 4:1, 5:2, 6:2, 7:3.

        Then for T from 0 to 7:

        T=0: 
            col0: avail_mask = 7 & ~0 = 7 -> a0=popcount_arr[7]=3 -> non_empty_arr0=8-1=7
            col1: avail_mask = 5 & ~0 = 5 -> a1=popcount_arr[5]=2 -> non_empty_arr1=4-1=3
            col2: avail_mask = 7 -> non_empty_arr2=7

            Then DP:
                j0: state0=1, state1=7
                j1: state0 = state1_prev = 7
                     state1 = (1+7)*3 = 8*3=24
                j2: state0 = 24
                     state1 = (7+24)*7 = 31*7=217
                F(0)=24+217=241.

        T=1: (binary 001) 
            col0: 7 & ~1 = 7 & 6 = 6 -> popcount(6)=2 -> non_empty_arr0=4-1=3
            col1: 5 & ~1 = 5 & 6 = 4 -> popcount(4)=1 -> non_empty_arr1=1
            col2: 7 & ~1=6 -> non_empty_arr2=3
            DP:
                j0: s0=1, s1=3
                j1: s0=3, s1=(1+3)*1=4
                j2: s0=4, s1=(3+4)*3=21 -> total=4+21=25.

        T=2: (binary 010) 
            col0: 7 & ~2 = 7 & 5 = 5 -> popcount=2 -> non_empty_arr0=3
            col1: 5 & ~2 = 5 & 5 = 5 -> popcount=2 -> non_empty_arr1=3
            col2: 7 & ~2 = 5 -> non_empty_arr2=3
            DP:
                j0: s0=1, s1=3
                j1: s0=3, s1=(1+3)*3=12
                j2: s0=12, s1=(3+12)*3=45 -> total=12+45=57.

        T=3: (011) 
            col0: 7 & ~3 = 7 & 4 = 4 -> popcount=1 -> non_empty_arr0=1
            col1: 5 & ~3 = 5 & 4 = 4 -> non_empty_arr1=1
            col2: 7 & ~3=4 -> non_empty_arr2=1
            DP:
                j0: s0=1, s1=1
                j1: s0=1, s1=(1+1)*1=2
                j2: s0=2, s1=(1+2)*1=3 -> total=5.

        T=4: (100) 
            col0: 7 & ~4 = 7 & 3 = 3 -> popcount=2 -> non_empty_arr0=3
            col1: 5 & ~4 = 5 & 3 = 1 -> popcount=1 -> non_empty_arr1=1
            col2: 7 & ~4=3 -> non_empty_arr2=3
            DP: same as T=1? 
                j0: 1,3
                j1: s0=3, s1=(1+3)*1=4
                j2: s0=4, s1=(3+4)*3=21 -> total=25.

        T=5: (101) 
            col0: 7 & ~5 = 2 -> popcount=1 -> non_empty_arr0=1
            col1: 5 & ~5 = 0 -> non_empty_arr1=0
            col2: 7 & ~5=2 -> non_empty_arr2=1
            DP:
                j0: s0=1, s1=1
                j1: s0=1, s1=(1+1)*0=0 -> then s0=1, s1=0
                j2: s0=0, s1=(1+0)*1=1 -> total=1.

        T=6: (110) 
            col0: 7 & ~6 = 1 -> non_empty_arr0=1
            col1: 5 & ~6 = 5 & 1 = 1 -> non_empty_arr1=1
            col2: 7 & ~6=1 -> non_empty_arr2=1
            DP: same as T=3? -> total=5.

        T=7: (111) 
            col0: 7 & ~7=0 -> non_empty_arr0=0
            col1: 0
            col2: 0
            DP: 
                j0: s0=1, s1=0
                j1: s0=0, s1=(1+0)*0=0
                j2: s0=0, s1=0 -> total=0.

        Then total = 
            T0: 241 -> +241
            T1: 25 -> -25
            T2: 57 -> -57
            T3: 5 -> +5   (because |T3|=2 -> even? no: |T3|=2 -> even? in inclusion-exclusion: sign = (-1)^|T| -> for |T| even: positive; odd: negative. 
            T4: 25 -> |T4|=1? T4=4 -> binary 100: popcount=1 -> odd? so negative -> -25
            T5: 1 -> popcount=2? T5=101 -> popcount=2 -> even? then positive -> +1
            T6: 5 -> popcount=2 -> even? +5
            T7: 0 -> popcount=3 -> odd? then negative? but 0 -> doesn't matter.

        So: 
            241 -25 -57 +5 -25 +1 +5 = 
            241 -25 = 216; 216-57=159; 159+5=164; 164-25=139; 139+1=140; 140+5=145.

        Therefore, we get 145.

   So the code is correct.

   We write the code accordingly.

   One last note: we must mask the ~T to nT-1? because the base mask only has R bits. 

   We do: 
        avail_mask = base[j] & (~T) 
        Then we do: avail_mask &= (nT - 1)   # to get the lower R bits.

   But note: base[j] is already in the range [0, nT-1]. Then ~T in Python is a big integer? But when we & with base[j], we get the bits that are set in base[j] and not set in T? But base[j] is R bits. Then we can also do: 
        avail_mask = base[j] & (~T) 
        and then use the popcount_arr[avail_mask]? But if avail_mask has more than R bits? Then our popcount_arr is only for the lower nT numbers? 

   We precomputed popcount_arr for indices from 0 to nT-1. But if avail_mask is greater than nT-1? Then we masked the base[j] to R bits? Actually, base[j] is at most nT-1. Then base[j] & (~T) might be greater than nT-1? 

   Example: R=2, nT=4, base[j]=3 (binary 11), T=0: ~T = ...11111111 (in binary, infinite ones) -> then base[j] & ~T = 3? which is in [0,3]. 
        T=1: ~T = ...11111110 -> base[j] & ~T = 3 & ...10 = 2? which is in [0,3].

   So we don't need to mask? But to be safe, we can mask: avail_mask = base[j] & (~T) & (nT-1)

   However, note: base[j] is already in [0, nT-1]. Then base[j] & (nT-1) is base[j]. But ~T is not bounded? Then base[j] & ~T might have bits beyond R? 

   But we only care about the R bits? So we mask with (nT-1) (which is a mask of R ones).

   We do: 
        avail_mask = base[j] & (~T)
        avail_mask &= (nT - 1)

   Then we get the lower R bits.

   Alternatively, we can do: 
        avail_mask = base[j] & (~T) 
        and then use popcount_arr[avail_mask] only if avail_mask < nT? But actually, if avail_mask >= nT, then we mask? 

   But we know that base[j] < nT, so base[j] & (nT-1) = base[j]. Then base[j] & ~T: the ~T has all higher bits set? So base[j] & ~T = base[j] & ( (nT-1) | (high_mask) ) = base[j] & (nT-1) because base[j] is in [0, nT-1]. 

   Therefore, we can skip the masking? 

   But to be safe, we do: 
        avail_mask = base[j] & (~T) 
        # Since base[j] is in the range [0, nT-1], we can use the lower R bits, so we take:
        avail_mask = avail_mask & (nT-1)

   Actually, it is the same as base[j] & (~T & (nT-1))? 

   We do: 
        avail_mask = base[j] & ( (nT-1) & ~T ) 
        But note: (nT-1) & ~T is the same as ~T in the lower R bits? 

   Alternatively, we can compute the mask for ~T within R bits: 
        mask_T = nT - 1
        avail_mask = base[j] & (mask_T & ~T) 

   But that is the same as: base[j] & (mask_T) & ~T = base[j] & ~T   (since base[j] is in mask_T). 

   So we can skip the masking? 

   We'll do without masking? But we precomputed popcount_arr only for indices in [0, nT-1]. Then we must ensure that avail_mask is in [0, nT-1]. 

   Since base[j] is in [0, nT-1] and ~T is an integer, then base[j] & ~T might be larger than nT-1? 

   Example: R=2, nT=4, base[j]=3, T=0: ~T is a big integer? Then base[j] & ~T = 3? which is <4.

   But if we have R=2, base[j]=3, and T=0, then ~T has all ones? Then base[j] & ~T = 3.

   How about base[j]=3, T=1: 
        ~T = ...11111110 (binary) -> base[j] & ~T = 3 & ...11111110 = 2? which is in [0,3].

   So it is safe? 

   We'll rely on the fact that base[j] has only the lower R bits set? Then base[j] & ~T will only have bits in the lower R bits? 

   Therefore, we can use popcount_arr[avail_mask] without masking? 

   But we precomputed popcount_arr for indices from 0 to nT-1. Then if avail_mask is in [0, nT-1]? It is, because base[j] is in [0, nT-1] and ~T is an integer? Then the result has bits only in the lower R bits? 

   So we can skip masking? 

   We'll do without masking? 

   But note: the base[j] is computed as an integer that has bits only in the lower R bits. Then base[j] & ~T will have bits only in the lower R bits? 

   Therefore, we can do without masking.

   We code accordingly.

   Let's run the sample with R=1, T=1: 
        base[0]=1 (binary 01)
        T=1: ~T is ...11111110 (in bits) -> then base[0] & ~T = 1 & ...11111110 = 0? 
        But wait: we want to remove row0? Then the available rows should be none? So 0.

        But if we mask with nT-1 (which is 1 for R=1) then we get 0? 

        Without masking: we get 0? 

        So it is the same.

   Therefore, we don't mask.

   We output the code.