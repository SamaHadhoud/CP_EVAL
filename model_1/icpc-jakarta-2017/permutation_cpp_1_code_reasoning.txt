 Okay, we are given N (up to 100) and Q (up to 300,000). We need to:
  1. Decompose the permutation into cycles.
  2. Compute the order k (which is the LCM of the cycle lengths) - note that M = k+1, but we only need exponents from 1 to k (since we want i from 1 to M-1).
  3. Generate k permutations: for exponent i in [1, k], compute P^i by rotating each cycle by i positions.
  4. Sort the k permutations (each permutation is an array of n integers) lexicographically (as defined: the first index where they differ determines the order).
  5. For each query K_i (which is an integer from 1 to k), we output the exponent T such that the permutation P^T is at position K_i in the sorted list.

 However, note that k (the order) might be large? The LCM of numbers (cycle lengths) that are at most 100. The worst-case cycle lengths are when we have cycles of distinct prime lengths? The maximum LCM for numbers <=100 is about 44100 (which is the LCM of numbers 1 to 100? Actually, it's the LCM of the set of cycle lengths we have). Since N is only 100, the worst-case LCM is about 44100 (which is acceptable because 44100 is about 44k, and we have to generate 44k permutations, each of size 100 -> 44k * 100 = 4.4e6 integers, which is acceptable in memory and time? But note we have Q up to 300,000, which we can answer by storing an array of exponents for the sorted list and then just indexing).

 But worst-case k might be as large as 44100? Actually, the LCM of all integers from 1 to 100 is around 69720375229712477164533808... but that is huge. However, note that the cycle lengths must sum to N (100). So the cycle lengths are a partition of 100. The maximum LCM for partitions of 100 is known to be around 44100 (for example, cycles of lengths 100? then LCM=100; cycles of 97 and 3? LCM=291; but worst-case is when we have the highest LCM for a partition of 100). Actually, the maximum LCM for a partition of 100 is 44100 (which is LCM(100,99) won't work because they don't partition 100, but the known maximum for partitions of 100 is achieved by the partition: 100 = 84 + 12 + 4 -> LCM(84,12,4)=84? Actually, we can compute the maximum LCM for partitions of N=100? It's known to be 44100: the partition [44,45]? 44+45=89 -> not 100. Actually, the known maximum LCM for partitions of 100 is achieved by [100] (LCM=100), [99,1] (LCM=99), ... but actually, the maximum LCM for partitions of 100 is 44100? Let me check: 100 = 100 -> LCM=100; 100=50+50 -> LCM=50; 100=25+25+25+25 -> LCM=25; 100= 96+4 -> LCM=96? ... Actually, the maximum LCM for any partition of 100 is 44100? 

 But note: the cycle lengths must be positive integers that sum to 100. The maximum LCM for partitions of 100 is achieved by the partition: 100 = 100? 100 -> LCM=100; but if we take 100= 99+1 -> LCM=99; 100=98+2 -> LCM=98? ... Actually, the maximum LCM for partitions of 100 is 44100? Why? Because 100 = 100, but we can also have 100 = 84 + 12 + 4? -> LCM(84,12,4)=84? Not 44100.

 Actually, the maximum LCM for partitions of 100 is 44100? Because 44100 = LCM(100, 99) but 100+99=199>100. How about 100 = 100? -> LCM=100. How about 100= 99+1 -> LCM=99. How about 100=96+4 -> LCM=96? How about 100= 90+10 -> LCM=90? How about 100= 84+16 -> LCM=336? How about 100= 60+40 -> LCM=120? How about 100= 50+30+20 -> LCM=100? How about 100= 44+45+9+2? -> 44+45+9+2=100 -> LCM(44,45,9,2)=LCM(44,45,9)=44*45*9 / gcd(44,45)=1, gcd(44,9)=1, gcd(45,9)=9 -> so LCM(44,45,9)=44*5*9=1980? 

 Actually, the maximum LCM for partitions of 100 is known to be 44100? I recall that the maximum LCM for partitions of 100 is 44100? But how? 44100 = 100 * 441? Or 44100 = 100 * 441? Actually, 44100 = 100 * 441? Not exactly. But note: the LCM of the set {100, 99, 98, ...} isn't the issue. We are taking the LCM of a set of numbers that sum to 100. The maximum LCM for a partition of 100 is 44100? I think it is achieved by the partition: [44,45,4,7]? 44+45+4+7=100? Then LCM(44,45,4,7)=LCM(44,45,28)= let's compute: 44=2^2*11, 45=3^2*5, 28=2^2*7 -> LCM = 2^2 * 3^2 * 5 * 7 * 11 = 4*9*5*7*11 = 13860? 

 Actually, after checking known sequences: the maximum LCM for a partition of 100 is 44100. How? Partition: 100 = 84 + 12 + 4? 84+12+4=100 -> LCM(84,12,4)=84? Not 44100. 

 Alternatively, 100 = 100? LCM=100. 

 Actually, I recall that the maximum LCM for partitions of 100 is 44100, achieved by the partition [44,45,10,1]? 44+45+10+1=100 -> LCM(44,45,10,1)= LCM(44,45,10)= LCM(44, LCM(45,10)) = LCM(44,90) = 44*90 / gcd(44,90)= (44*90)/2 = 1980? 

 How about [100]? LCM=100. [99,1] -> 99. [98,2] -> 98. [97,3] -> 291. ... 

 Actually, I found a reference: the maximum LCM for a partition of 100 is 44100. The partition that achieves this is: 100 = 100? No. Actually, 100 = 84 + 12 + 4? Not. Then how? 

 But note: we are decomposing the permutation into cycles, and the cycle lengths must be a partition of N (100). The maximum LCM for a partition of 100 is indeed 44100? How? 

 I found: the maximum LCM for a partition of 100 is 44100, and it is achieved by the partition: [100] has LCM 100, but the partition [50, 30, 20] has LCM 100? Actually, the partition that gives 44100 is: [44,45,9,2]? 44+45+9+2=100, and LCM(44,45,9,2)= LCM(44,45,9) = 44*5*9 = 1980? 

 Alternatively, [50, 49, 1] -> 50*49=2450? 

 Actually, after checking: the maximum LCM for a partition of 100 is 44100, achieved by the partition: [84,12,4]? That doesn't add up. 

 Alternatively, [63, 35, 2]? 63+35+2=100 -> LCM(63,35,2)= LCM(63,70)=630? 

 How about [100] -> 100, [99,1] -> 99, ... [90,10] -> 90, ... [80,20] -> 80? 

 Actually, the known maximum LCM for partitions of 100 is 44100? I think I recall that the maximum LCM for partitions of 100 is 44100, achieved by the partition: 100 = 100? No. Actually, 100= 99+1 -> 99, 100=98+2 -> 98, ... 100=96+4 -> 96, ... 100= 84+12+4 -> 84? 

 But wait: 100 = 100 -> LCM=100, which is less than 44100? 

 How can we get 44100? 44100 is the LCM of the set {100, 99, 98, ...} ? But we cannot use all numbers from 1 to 100 because they add to more than 100. 

 Actually, the partition that gives 44100 is: [100] doesn't. How about [99,1]? 99. 

 I think I made a mistake: the LCM of a set of numbers that sum to 100 cannot exceed 44100? But 44100 is the LCM of numbers 1 to 100? That is huge. However, we cannot have a partition of 100 that includes numbers that are large enough to have LCM 44100? 

 Actually, the LCM of a partition is the LCM of the parts. The maximum LCM for any partition of 100 is known to be 44100? 

 After a quick search in my mind: actually, the maximum LCM for a partition of 100 is 44100? 

 But note: 44100 = 100 * 441? Actually, 44100 = 100 * 441? 100*441=44100. But we cannot have a cycle of length 44100? because the sum of the cycle lengths is only 100. 

 So what is the maximum LCM for a partition of 100? 

 We can compute it by generating all partitions of 100 and computing the LCM? But that is too expensive? Alternatively, we can use known results: the maximum LCM for a partition of 100 is 44100? 

 Actually, I found that the maximum LCM for partitions of 100 is 44100, achieved by the partition: 100 = 100? No, because 100 is less than 44100. 

 How about: the LCM of a set of numbers that are at most 100 and that sum to 100 can be at most 100? Actually, no: if we have two cycles of length 50, the LCM is 50. If we have cycles of lengths 40 and 60, then LCM(40,60)=120. So 120>100. 

 So the LCM can be larger than 100? 

 Then what is the maximum LCM? 

 Consider: we want to maximize the LCM of a set of integers that sum to 100. We can use numbers that are not necessarily divisors of 100. 

 The known maximum LCM for a partition of 100 is 44100? Actually, I found a reference: the maximum LCM for a partition of 100 is 44100? 

 How? 44100 = LCM(100, 99, 98) is 100*99*49? But 100+99+98=297>100. 

 Alternatively, we can use the prime factorization: we want to assign exponents to primes such that the sum of the primes raised to exponents (with multiplicities) is <=100? And then maximize the product of primes raised to exponents? Actually, the LCM is the product of the highest powers of primes in the factorization of the numbers? 

 Actually, the problem is equivalent to: choose a set of numbers a1, a2, ..., ak such that a1+a2+...+ak=100 and maximize LCM(a1,...,ak). 

 Known: the maximum LCM for partitions of 100 is 44100? 

 Actually, I recall that the maximum LCM for a partition of 100 is 44100, achieved by the partition: [100] -> 100, [99,1] -> 99, ... [90,10] -> 90, ... [80,20] -> 80, ... [60,40] -> 120, [60,30,10] -> 60, [50,30,20] -> 100, [44,45,10,1] -> 1980, [42,30,28] -> 420? 

 But 420 is less than 44100. 

 Actually, after research, I recall that the maximum LCM for a partition of 100 is 44100, achieved by the partition: [84,12,4]? 84+12+4=100 -> LCM(84,12,4)=84? 

 Then how 44100? 

 Alternatively, [100] is 100, and 100 is less than 44100. 

 Actually, I think there is a misunderstanding: the LCM of the cycle lengths is the order of the permutation. The maximum order of a permutation of size 100 is the maximum LCM of a partition of 100. And the maximum LCM for a partition of 100 is known to be 44100? 

 How? Let me check: the partition [4,3,5] has LCM 60. The partition [25,75] has LCM 75? But 25+75=100 -> LCM=75? 

 Actually, the maximum LCM for a partition of 100 is 44100? I found that the maximum LCM for a partition of 100 is 44100? 

 But how? 44100 = 100 * 441? 

 Actually, the partition that achieves 44100 is: [44,45,11]? 44+45+11=100? Then LCM(44,45,11)= 44*45*11 / gcd(44,11)=11 -> so LCM(44,45,11)=44*45=1980? 

 Then how 44100? 

 Alternatively, [50, 49, 1] -> LCM(50,49)=2450? 

 Or [50, 48, 2] -> LCM(50,48,2)= LCM(50,48)=1200? 

 How about [100] -> 100? 

 Actually, I found that the maximum LCM for a partition of 100 is 44100, and it is achieved by the partition: [100] -> 100? 

 But wait, 44100 is the LCM of the entire set {1,2,...,100}? That is not a partition. 

 I think the confusion: the LCM of the cycle lengths (which are a partition of 100) can be as large as 44100? 

 Actually, the known maximum LCM for a partition of 100 is 44100? 

 I recall that the maximum LCM for a permutation of size 100 is 44100? 

 How? The permutation is decomposed into cycles. The cycle lengths must be positive integers that add to 100. The maximum LCM of such a set is 44100? 

 Actually, I found that the maximum LCM for a partition of 100 is 44100? 

 The partition that achieves it: [100] -> LCM=100? 
 [99,1] -> 99? 
 ... 
 [90,10] -> 90? 
 ... 
 [84,12,4] -> 84? 
 [75,25] -> 75? 
 [72,18,10] -> 360? 
 [60,40] -> 120? 
 [60,30,10] -> 60? 
 [50,30,20] -> 100? 
 [48,32,20] -> 480? 
 [45,30,15,10] -> 90? 
 [44,33,22,1] -> 132? 
 [42,35,15,8] -> 840? 
 [40,30,15,10,5] -> 120? 
 [36,24,24,16] -> 144? 
 [30,30,20,20] -> 60? 
 [25,25,25,25] -> 25? 

 Then how 44100? 

 Actually, after research, I recall that the maximum LCM for a partition of 100 is 44100? 

 But I also found: 
  The maximum order of an element in S_100 (the symmetric group on 100 elements) is 44100? 

 And the partition that achieves it: 
  The prime factorization of 44100 is 2^2 * 3^2 * 5^2 * 7^2 -> so the partition would be the primes with exponents: 
  We break 100 as the sum of the prime powers? 

  2^2 = 4, 3^2=9, 5^2=25, 7^2=49 -> total = 4+9+25+49 = 87. Then we have 100-87=13 left? Then we break 13 into 1's? 

 But adding ones doesn't change the LCM. So the LCM is 4*9*25*49 = 44100? 

 So the partition: [49,25,9,4,1,1,...,1] (with 13 ones) -> then LCM(49,25,9,4,1,...,1)= LCM(49,25,9,4)= 49*25*9*4 / gcd? Since they are coprime? Actually, 49 and 25 and 9 and 4: they are pairwise coprime? So LCM=49*25*9*4 = 44100.

 So the maximum k (the order) is 44100? 

 Therefore, worst-case k is 44100? 

 Now, we have to generate 44100 permutations, each of size 100 -> total integers: 44100 * 100 = 4,410,000 which is acceptable in C++ (about 4.4e6 integers) in terms of memory (each integer is 4 bytes -> 4.4e6 * 4 = 17.6 MB) and also in time? 

 How long does it take to generate? 
   For each exponent (from 1 to k=44100) and for each cycle (number of cycles is at most 100) and for each element in the cycle (cycle length L), we compute the new position: (current_index + exponent) mod L -> so for one permutation, the work is O(n). Total work: O(k * n) = 44100 * 100 = 4.4e6 operations? That is acceptable.

 Then we have to sort 44100 permutations (each permutation is an array of 100 integers). The comparison of two permutations of size 100: worst-case 100 comparisons (if they differ at the last element). So each comparison is O(n). The total cost of sorting is O(k * n * log(k)) = 44100 * log2(44100) * 100.

 log2(44100) is about 16, so 44100 * 16 * 100 = 44100*1600 = 70,560,000 comparisons? Each comparison in the worst-case might require 100 element comparisons? Then 70,560,000 * 100 = 7,056,000,000 comparisons? That is 7e9 comparisons, which might be borderline in C++ in 3 seconds? 

 Alternatively, we can avoid storing the entire permutation? Or we can avoid the expensive sort? 

 Note: the problem constraints: N=100, and k up to 44100, and Q up to 300000.

 But worst-case k=44100 is about 44k, so the sorting step might be heavy: 44k * log(44k) * 100 = about 44k * 16 * 100 = 70.4 million * 100 = 7.04e9 comparisons? That might be too slow in C++.

 We need to optimize the sorting.

 Alternative idea:

 Instead of generating the entire permutation for every exponent, we can generate a "key" for the permutation that we can compare lexicographically without storing the entire array? 

 But note: we have to compare two permutations lexicographically: that is, we need to compare two arrays of 100 integers. 

 Alternatively, we can precompute the entire permutation for each exponent? But then we have 44k * 100 integers (4.4e6 integers) which is acceptable in memory, but the sorting time is the issue.

 How about we use a Schwartzian transform: store the exponent and the permutation, but then when we sort, we only compare the permutations. But the comparisons are expensive.

 We can try to generate the permutation as a tuple of 100 integers and then use the standard tuple comparison? That is efficient in C++? 

 But worst-case, the sort might do O(k log k) comparisons and each comparison O(n) in the worst-case (if they are identical until the last element). 

 Total operations: O(k * n * log k) = 44100 * 100 * 16 = 70,560,000 comparisons? Actually, 70 million comparisons? Because each comparison of two permutations might take 100 comparisons of integers? Then total integer comparisons: 70,560,000 * 100 = 7,056,000,000 which is 7e9? 

 In C++, one integer comparison is one operation? On a modern machine, 1e9 operations per second? Then 7e9 operations would take 7 seconds? But the time limit is 3 seconds? 

 So we need to optimize.

 Alternative approach:

 We don't need to store the entire permutation? We can compute the permutation on the fly? But we cannot avoid storing the entire permutation for each exponent? Because we need to compare lexicographically.

 Alternatively, we can avoid storing the entire permutation for each exponent by generating a key that is the permutation itself as a tuple? But then we still have the same storage and same comparison cost.

 How about we generate the permutations and then use radix sort? 

 But radix sort on 100-digit numbers with base 100? The total number of digits is 100, and the base is 100? Then the radix sort would be 100 passes, each pass counting sort for 100 buckets. The counting sort is O(k + base) per pass. So total: 100 * (44100 + 100) = 100 * 44200 = 4,420,000 operations? That is acceptable.

 However, the counting sort for each digit: we have to sort by the first element, then by the second, etc. But note: the permutations are arrays of 100 integers (each integer from 0 to n-1, so base=100). 

 Steps for radix sort (from least significant digit to most? but lexicographic order: we want to sort by the first element, then the second, ... so we should sort by the last digit first? Actually, lexicographic: we start from the first element. So we should sort by the first element (most significant) then the second, etc. 

 So we do:

   We have an array of k (44100) permutations, each permutation is an array of 100 integers.

   We do a stable sort by the 100th element? No, we want the first element to be the most significant. So we do:

     for d from 99 down to 0:  (because the 0-th index is the first element, the most significant)
        stable_sort the array of permutations by the d-th element? 

 But that would be 100 passes of stable sort? And stable sort (like counting sort) would be O(k + base). 

 Total time: 100 * (44100 + 100) = 100 * 44200 = 4,420,000? That is acceptable.

 However, note: we have k=44100, and base=100. Each counting sort: we create an array of 100 buckets, then we traverse the list and put each permutation into the bucket corresponding to the d-th element. Then we traverse the buckets in increasing order to get the sorted order for that digit. Then we do that for d from the last (least significant) to the first? 

 But lexicographic order: we care first about the first element, then the second, etc. So we should sort by the first element first? But then when we sort by the second element, we break ties? Actually, we do:

   We want to sort by the first element (index0) first, then by index1, then by index2, etc.

   So we do:

      sort by the last element (index99) with a stable sort -> then the array is sorted by index99, but then if we do index98, then the index98 becomes more significant? Actually, no: we want the first element to be the most significant. So we should start with the first element? 

   However, if we do:

      sort by the last element (least significant) first, then by the next, ... and then by the first element (most significant) last? Then the last sort (on the first element) will dominate? And the previous sorts will break ties? 

   Actually, that's the standard: radix sort from least significant to most significant, and then the last sort (most significant) is the one that dominates. But lexicographic order is from the first element (most significant) to the last. 

   Therefore, we should do:

      for d from 99 down to 0:   # d from the last element (least significant) to the first element (most significant) -> but that doesn't work? 

   Alternatively, we can reverse the order: we want the first element to be the most significant. So we sort by the last element first (using a stable sort) and then by the next last, ... and then by the first element last. Then the array will be sorted by the entire permutation? 

   Example: two permutations: [1,2] and [1,1]. We want [1,1] < [1,2]. 
        First we sort by the second element: we get [1,1] then [1,2] -> then we sort by the first element? But we don't change the order because the first element is 1 for both? So we get [1,1] then [1,2] -> which is correct.

   But if we have [2,1] and [1,2]: 
        First sort by the second element: 
           [2,1]: second element=1
           [1,2]: second element=2 -> so we put [2,1] then [1,2]?
        Then sort by the first element: 
           we see [2,1] has first element=2, [1,2] has first element=1 -> then we put [1,2] then [2,1] -> which is correct.

   However, note: when we do the first sort (by the last element) we break ties arbitrarily? Actually, we don't have to break ties because we then sort by the next. 

   So we do:

        for d from n-1 down to 0:   # d from the last index to the first index (so the first index is the last sort)
            stable_sort the array of permutations by the d-th element.

   But that would be:

        We start with the last element (index n-1) and do a stable sort. Then we do index n-2, ... and finally index0.

   This is because the index0 is the most significant and we do it last? Actually, we do the least significant (last element) first, and the most significant (first element) last. Then the last sort (index0) is the one that dominates? 

   But stable sort preserves the relative order for elements with the same key. So when we sort by index0, if two permutations have the same value at index0, then the next thing that breaks the tie is the order from the previous sorts. But the previous sorts were by index1, index2, ...? Actually, no: we did the last element first and then index1? 

   Actually, the tie-breaking order is the reverse: the last element was the first sort, then the next last, ... and the first element was the last sort. So when we compare two permutations that have the same value at index0, the next significant element is index1? 

   But lexicographic order: if two permutations have the same first element, we look at the second element. So we want the second element to have been sorted in increasing order? And we did sort by the second element? But we did it before the first element? And then we did the first element? So when we then sort by the first element (index0), if two are equal, the order from the previous sort (by index1) remains? 

   Exactly: stable sort by the second element (index1) then by the first element (index0) will give: 
        First, the array is sorted by index1. Then when we sort by index0, we rearrange only by index0, but if two have the same index0, we leave the relative order (which is the order by index1) unchanged? 

   But we want: first by index0, then by index1. 

   So we must do the most significant digit last? 

   Therefore, we do:

        sort by the least significant digit (last element) first, and then by the next least significant, and so on, and the most significant (first element) last.

        Then the final array is sorted: 
            if two permutations have the same first element, then the relative order from the previous sort (which was by the entire rest) remains? 

        But the previous sort was by the entire rest? Actually, no: we did the last element first, then the second last, ... then the first element last.

        And when two permutations have the same first element, the relative order from the previous passes (which sorted by the rest) is the lexicographic order for the rest? 

        Actually, yes: because we have stably sorted by the entire array from the last element to the second element? So the array is already sorted by the entire array from the second element to the last? Then when we sort by the first element, we break ties by the entire rest? which is already sorted? 

        So the entire array becomes sorted lexicographically? 

   Therefore, we can do:

        for d from n-1 down to 0:   # d is the index in the permutation array (from last to first)
            stable sort the list of permutations by the d-th component.

   We can use counting sort for each digit because the range of each integer is [0, n-1] (n<=100).

   Steps for counting sort for one digit d:

        Create an array (or vector) of buckets: buckets[0..n] (size n+1) as empty lists.

        For each permutation in the current list (in the current order):
            x = permutation[d]
            append the permutation to buckets[x]

        Then clear the list and traverse x from 0 to n-1, and for each x, append all the permutations in buckets[x] to the list.

        This is stable.

   Total for one digit: O(k + n) -> about 44100 + 100 = 44200 per digit.

   Then for 100 digits: 100 * 44200 = 4,420,000 operations? (each operation is moving a pointer to a permutation? Actually, we are moving the entire permutation? But we have k=44100 permutations, each of size 100? Then moving one permutation is moving 100 integers? So the entire radix sort would be 100 * 44200 * (cost of moving a permutation)? 

   Actually, we can avoid moving the entire permutation by using pointers. We can store an array of pointers to the permutations? Then we sort the pointers? 

   Alternatively, we can store the permutations in a fixed array and then for each counting sort, we create an array of buckets of indices? 

   But note: we are storing k permutations, each as an array of n integers. Total memory: k * n * sizeof(int) = 44100*100*4 = 17.6 MB.

   We want to do radix sort without moving the entire permutation? We can use an array of indices and then rearrange the indices.

   Steps:

        Let A[0..k-1] be the array of permutations (each permutation is a vector of n integers, or an array of n integers? Actually, we can store them in a vector of vectors? Or we can store them in a 2D array?).

        We create an array of indices: index[0..k-1] = [0,1,...,k-1]

        Then we do:

            for d from n-1 down to 0:
                // count the frequency for the d-th element of the permutation at position index[i]
                Create an array count of n+1 zeros, and an output array for indices.

                For each i in the current index array:
                    x = perm[ index[i] ][d]
                    count[x]++

                Then do prefix sums: so that count[x] becomes the last index for bucket x.

                Then traverse the current index array backwards (to preserve stability) and place each index in the output array.

        Then set the current index array to the output array.

        After all digits, the index array is sorted.

   But note: we are doing from the last digit to the first? Actually, we are doing from the least significant to the most significant? And we are using a standard LSD radix sort? 

   Alternatively, we can use:

        for d from n-1 down to 0:
            // do counting sort on the d-th element

            vector<int> count(n, 0);
            // count frequencies
            for each index i in the current list of indices:
                x = perm[i][d]
                count[x]++

            // prefix sum: so that count[x] becomes the starting index for bucket x? Actually, we want the positions in the output.

            We can do:

                vector<int> pos(n,0);
                pos[0]=0;
                for i from 1 to n-1:
                    pos[i] = pos[i-1] + count[i-1]

                Then create a new_index array of size k.

                for each index i in the current index array (in order):
                    x = perm[i][d]
                    new_index[ pos[x] ] = i
                    pos[x]++

            Then set current index array = new_index.

   But note: we are traversing the current index array in the original order? Then we are preserving the relative order for the same x? Then it is stable.

   However, we want to traverse from the last element? Actually, we are doing the last digit first? 

   This is standard LSD radix sort.

   Total operations per digit: O(k + n) -> 44100+100 per digit, and 100 digits -> 100*(44100+100)=4,420,000.

   Then we have an array of indices (size k) that points to the permutations in lexicographic order.

   Then we can build an array: 
        sorted_exponents = [ exponent for the permutation at index[0], exponent for the permutation at index[1], ... ]

   Then for each query K_i, we output sorted_exponents[K_i-1]? 

   But note: our list of permutations for exponents 1 to k? We stored the permutation for exponent i in an array? and we also stored the exponent? 

   Actually, we stored the permutations in an array: 
        perm[i] for i in [0, k-1] is the permutation for exponent = i+1? 

   But wait: we generated for exponent in range(1, k+1). Then we stored in an array: 
        perms[0] = P^1, perms[1]=P^2, ... perms[k-1]=P^k.

   Then we want to sort the array perms (which has k elements) lexicographically? 

   Then after radix sort, the array of indices (let's call it idx) is such that:
        perms[ idx[0] ] is the smallest permutation? and perms[ idx[k-1] ] is the largest.

   Then the exponent for the permutation at position j in the sorted list is: 
        original exponent = idx[j] + 1? 

   Why? Because perms[i] was generated for exponent i+1? 

   Actually, we stored perms[0] for exponent1, perms[1] for exponent2, ... so perms[i] corresponds to exponent = i+1.

   So the exponent for the permutation at perms[ idx[j] ] is: idx[j] + 1.

   Then we build an array ans_sorted of size k: 
        ans_sorted[j] = idx[j] + 1

   Then for each query K_i (which is 1-indexed: the K_i-th smallest permutation) we output ans_sorted[K_i-1].

   Steps:

        Step 1: Read n, q, permutation P.

        Step 2: Convert P to 0-indexed.

        Step 3: Cycle decomposition.

        Step 4: Compute k = LCM(cycle_lengths)

        Step 5: Generate k permutations: 
                 perms = array of k permutations, where perms[i] (for i from 0 to k-1) is the permutation for exponent = i+1.

                 How to generate? 
                    For exponent = i+1 (let t = i+1) and for each cycle of length L, 
                    for each element at position j in the cycle (0-indexed position in the cycle), 
                         the new position of the element at the j-th position in the cycle is the element at the (j+t) mod L-th position in the cycle.

                    Then we build the permutation: for each element in the cycle, we assign:
                         perm_arr[cycle[j]] = cycle[ (j+t) % L ]

        Step 6: Radix sort the array perms (which is an array of k arrays of n integers) using LSD radix sort for base n (digits from 0 to n-1) and with n digits (each permutation has n elements). 

                 We create an array idx of [0,1,...,k-1] for the initial indices.

                 Then for d from n-1 down to 0:
                     sort the array idx by the d-th element of perms[i] (for the permutation at index i).

                 How to sort: we do counting sort.

        Step 7: Build an array result_exponent of size k: 
                 for j in range(k):
                     result_exponent[j] = idx[j] + 1   (because the permutation at idx[j] was generated for exponent = idx[j]+1)

        Step 8: For each query K_i (from input), output result_exponent[K_i-1].

   Note: k might be as large as 44100? and n=100, so the radix sort should be efficient.

   Let's test with the sample: n=5, P = [2,3,1,5,4] -> [1,2,0,4,3] (0-indexed). 
        Cycles: 
            start at 0: 0->2->0? 
                0: P0[0]=1 -> index1? 
                Actually: P0 = [1,2,0,4,3] -> 
                  index0: P0[0]=1 -> go to index1
                  index1: P0[1]=2 -> go to index2
                  index2: P0[2]=0 -> back to 0: so cycle: [0,1,2]
            then index3: P0[3]=4 -> go to index4, P0[4]=3 -> cycle: [3,4]

        Cycle_lengths = [3,2] -> LCM(3,2)=6.

        Then we generate 6 permutations: for exponent from 1 to 6.

        Then we sort them and build the result_exponent.

        Then for queries: 1 to 6, we output the exponent for the sorted list.

        The sample output: 6,3,4,1,2,5.

   We have to check: the permutation for exponent6: it is the identity? 
        For the cycle [0,1,2]: 
            exponent6: 
                0 -> (0+6)%3=0 -> element0: so element0 maps to element0 -> 0
                1 -> (1+6)%3=1 -> element1 -> 1
                2 -> (2+6)%3=2 -> element2 -> 2
            For cycle [3,4]:
                3 -> (0+6)%2=0 -> element0 in the cycle? which is 3 -> so 3 maps to 3
                4 -> (1+6)%2=1 -> element1 in the cycle? which is 4 -> so 4 maps to 4.
            So the permutation is [0,1,2,3,4] -> which is the identity.

        And the sample says the smallest permutation is P^6.

        Then the next: P^3: 
            [0,1,2]: 
                0: (0+3)%3=0 -> element0:0 -> maps to 0? but the element at 0 should be the element that is at position (0+3 mod3) in the cycle? 
                Actually, we have the cycle: [0,1,2]. 
                The element originally at position0 (which is 0) is mapped to: we take the element at position (0+3)%3=0 -> which is 0? -> so at index0 we put 0.
                Similarly, index1: element1 -> (1+3)%3=1 -> element1=1 -> so at index1 we put 1.
                index2: (2+3)%3=2 -> element2=2 -> at index2 we put 2.
                [3,4]:
                3: (0+3)%2=1 -> element1 in the cycle? which is 4 -> so at index3 we put 4.
                4: (1+3)%2=0 -> element0=3 -> at index4 we put 3.

            So the permutation is [0,1,2,4,3] -> which in 1-indexed is [1,2,3,5,4]? but the sample says P^3 = [1,2,3,5,4] -> matches.

        Then we have to sort the permutations? The identity [0,1,2,3,4] is the smallest? Then [0,1,2,4,3] is the next? 

        Then P^4: 
            [0,1,2]: 
                0: (0+4)%3=1 -> element1=1 -> so at index0 we put 1.
                1: (1+4)%3=2 -> element2=2 -> at index1 we put 2.
                2: (2+4)%3=0 -> element0=0 -> at index2 we put 0.
            [3,4]:
                3: (0+4)%2=0 -> element0=3 -> at index3 we put 3.
                4: (1+4)%2=1 -> element1=4 -> at index4 we put 4.
            So permutation: [1,2,0,3,4] -> 1-indexed: [2,3,1,4,5] -> which is P^4.

        Then we have the list:

            exponent1: [1,2,0,4,3] -> [2,3,1,5,4] -> 0-indexed: [1,2,0,4,3]
            exponent2: [2,0,1,3,4] -> [3,1,2,4,5] -> 0-indexed: [2,0,1,3,4]?
            exponent3: [0,1,2,4,3] -> [1,2,3,5,4] -> 0-indexed: [0,1,2,4,3]
            exponent4: [1,2,0,3,4] -> [2,3,1,4,5] -> 0-indexed: [1,2,0,3,4]
            exponent5: [2,0,1,4,3] -> [3,1,2,5,4] -> 0-indexed: [2,0,1,4,3]
            exponent6: [0,1,2,3,4] -> identity.

        Now we sort the 0-indexed permutations lexicographically:

            [0,1,2,3,4] -> exponent6
            [0,1,2,4,3] -> exponent3
            [1,2,0,3,4] -> exponent4
            [1,2,0,4,3] -> exponent1
            [2,0,1,3,4] -> exponent2
            [2,0,1,4,3] -> exponent5

        Then the sorted list: 
            A[0] = exponent6 -> T=6
            A[1] = exponent3 -> T=3
            A[2] = exponent4 -> T=4
            A[3] = exponent1 -> T=1
            A[4] = exponent2 -> T=2
            A[5] = exponent5 -> T=5

        But the sample output is: 6,3,4,1,2,5 -> which matches.

        However, the sample says: A = [P^6, P^3, P^4, P^1, P^2, P^5] -> which is the same.

   Therefore, we code accordingly.

   Important: We have to be cautious about the cycle representation: when we decompose, we get the cycles. Then for each cycle, we have a list of indices: the cycle as we traverse.

   How we generate the permutation for exponent t:

        We create an array res of n integers (initialized to 0?).

        For each cycle: 
            L = len(cycle)
            For each index j in the cycle (j from 0 to L-1), the element at the original index = cycle[j] 
            will be mapped to the element at the cycle[ (j + t) % L ]

        Then we set: res[ cycle[j] ] = cycle[ (j+t) % L ]

   Then we have the permutation.

   Then we store perms[i] = res (for exponent t = i+1).

   Then we do radix sort on perms (which is a vector of k vectors of n integers).

   Steps for radix sort (using LSD):

        vector<int> idx(k);
        for (int i=0; i<k; i++) idx[i]=i;

        for (int d = n-1; d>=0; d--) {
            // We'll do counting sort for the d-th element of the permutations.

            // Create an array of counts for 0..n-1 (size n) and initialize to 0.
            vector<int> count(n,0);
            for (int i=0; i<k; i++) {
                int perm_index = idx[i];
                int x = perms[perm_index][d];   // the d-th element of the permutation at index = perm_index
                count[x]++;
            }

            // Compute prefix sums: we want the starting positions? But we are going to do stable sort, so we can do:
            vector<int> pos(n,0);
            if (n>0) {
                pos[0] = 0;
                for (int i=1; i<n; i++) {
                    pos[i] = pos[i-1] + count[i-1];
                }
            }

            // Now create a new index array
            vector<int> new_idx(k);
            for (int i=0; i<k; i++) {
                int perm_index = idx[i];
                int x = perms[perm_index][d];
                new_idx[ pos[x] ] = perm_index;
                pos[x]++;
            }

            idx = new_idx;
        }

        Then build result_exponent: for j in range(k): result_exponent[j] = idx[j] + 1

   Then process the queries.

   Let's test with the sample at exponent1: 
        perms[0] = [1,2,0,4,3] -> d from 4 down to 0:

        d=4: 
            element: perms[0][4]=3 -> then we put it in bucket3? 
            ... we do for all, but we have 6 permutations.

        We are doing LSD so we start with the last element? 

        We'll simulate the radix sort for the sample? 

        But note: the identity permutation [0,1,2,3,4] has last element=4? and the others: 
            exponent3: [0,1,2,4,3] -> last element=3
            exponent4: [1,2,0,3,4] -> last element=4
            exponent1: [1,2,0,4,3] -> last element=3
            exponent2: [2,0,1,3,4] -> last element=4
            exponent5: [2,0,1,4,3] -> last element=3
            exponent6: [0,1,2,3,4] -> last element=4 -> wait, no: the last element of exponent6 is 4? 
            Actually, the last element of exponent6: at index4 is 4? 

        So after the first pass (d=4): we sort by the last element (values: 3 or 4). 

        Bucket3: [exponent3, exponent1, exponent5] -> in the order of the original idx? 
        Bucket4: [exponent4, exponent2, exponent6] 

        Then we create new_idx: [3,1,5,4,2,6]? 

        Then d=3: we look at the element at index3.

        For exponent3: permutation [0,1,2,4,3] -> element at index3=4? 
        exponent1: [1,2,0,4,3] -> element at index3=4
        exponent5: [2,0,1,4,3] -> element at index3=4
        exponent4: [1,2,0,3,4] -> element at index3=3
        exponent2: [2,0,1,3,4] -> element at index3=3
        exponent6: [0,1,2,3,4] -> element at index3=3

        Then we sort by the third element? Actually, index3? 

        Then for the first three (exponent3,1,5): they all have 4? -> so we keep the relative order: [3,1,5]?
        Then for the next three: [4,2,6] have 3? -> so we keep the relative order: [4,2,6]? 

        Then new_idx = [3,1,5,4,2,6]

        Then d=2: we look at index2.

        exponent3: [0,1,2,4,3] -> index2=2
        exponent1: [1,2,0,4,3] -> index2=0
        exponent5: [2,0,1,4,3] -> index2=1
        exponent4: [1,2,0,3,4] -> index2=0
        exponent2: [2,0,1,3,4] -> index2=1
        exponent6: [0,1,2,3,4] -> index2=2

        Then we sort:

            For each element, we look at the value at index2:

            exponent3: 2 -> bucket2
            exponent1: 0 -> bucket0
            exponent5: 1 -> bucket1
            exponent4: 0 -> bucket0
            exponent2: 1 -> bucket1
            exponent6: 2 -> bucket2

            Then new_idx: 
                bucket0: [1,4]  -> exponent1, exponent4
                bucket1: [5,2]  -> exponent5, exponent2
                bucket2: [3,6]  -> exponent3, exponent6

            Then new_idx = [1,4,5,2,3,6]

        Then d=1: index1:

            exponent1: [1,2,0,4,3] -> index1=2
            exponent4: [1,2,0,3,4] -> index1=2
            exponent5: [2,0,1,4,3] -> index1=0
            exponent2: [2,0,1,3,4] -> index1=0
            exponent3: [0,1,2,4,3] -> index1=1
            exponent6: [0,1,2,3,4] -> index1=1

        Then:

            bucket0: [5,2] -> exponent5, exponent2
            bucket1: [3,6] -> exponent3, exponent6
            bucket2: [1,4] -> exponent1, exponent4

            Then new_idx = [5,2,3,6,1,4]

        Then d=0: index0:

            exponent5: [2,0,1,4,3] -> index0=2
            exponent2: [2,0,1,3,4] -> index0=2
            exponent3: [0,1,2,4,3] -> index0=0
            exponent6: [0,1,2,3,4] -> index0=0
            exponent1: [1,2,0,4,3] -> index0=1
            exponent4: [1,2,0,3,4] -> index0=1

        Then:

            bucket0: [3,6] -> exponent3, exponent6
            bucket1: [1,4] -> exponent1, exponent4
            bucket2: [5,2] -> exponent5, exponent2

            Then new_idx = [3,6,1,4,5,2]

        Then the sorted list: 
            [3,6,1,4,5,2] -> meaning the exponents: 
                position0: exponent3+1? no: 
                Actually, we stored perms[0] for exponent1, perms[1] for exponent2, ... perms[5] for exponent6.

                The sorted list: 
                  first: idx[0]=3 -> perms[3] -> exponent4? because index3 -> exponent=3+1=4? 
                But we expected: [6,3,4,1,2,5] -> the exponents in sorted order: [6,3,4,1,2,5]

        What went wrong? 

        Our radix sort produced: [3,6,1,4,5,2] -> meaning the permutation at index3 is the smallest? 
        perms[3] is the permutation for exponent4? -> [1,2,0,3,4] -> but the identity (exponent6) is the smallest? 

        We see: we did the radix sort from the last element to the first? and the identity is [0,1,2,3,4] -> which has the smallest first element? 

        Why did we get exponent4 first? 

        Actually, we did:

            We started with the last element (d=4) and then d=3, then d=2, then d=1, then d=0.

            But lexicographic order: the first element (d=0) is the most significant. 

            Our radix sort does the least significant digit first? and the last digit (d=4) is the least significant? and d=0 is the most significant? 

            Then we did the last pass on d=0? and then the entire array is sorted by d=0? 

            But we expected the identity to be first? 

        How did we get [3,6,1,4,5,2]? 

            The first element (d=0) of the permutations:

                exponent1: [1, ...] -> d0=1
                exponent2: [2, ...] -> d0=2
                exponent3: [0, ...] -> d0=0
                exponent4: [1, ...] -> d0=1
                exponent5: [2, ...] -> d0=2
                exponent6: [0, ...] -> d0=0

            Then we put the ones with d0=0 first: exponent3 and exponent6? Then d0=1: exponent1 and exponent4? Then d0=2: exponent5 and exponent2.

            Then in each bucket, the relative order from the previous pass? 

            In the bucket0 (d0=0): we had [3,6] -> which came from the previous pass? In the previous pass (d1) we had: 
                exponent3: d1=1 -> bucket1? 
                exponent6: d1=1 -> bucket1? 
                Then we had bucket1: [3,6] -> meaning exponent3 then exponent6? 

            Then we put exponent3 then exponent6? 

            Then the sorted list: 
                exponent3: [0,1,2,4,3] -> in 1-indexed: [1,2,3,5,4]
                exponent6: [0,1,2,3,4] -> identity

            But the identity is smaller than [0,1,2,4,3]? 

            Actually, no: because [0,1,2,3,4] is smaller than [0,1,2,4,3]? 

            Why? Because at the first element: both 0, then second element: both 1, then third: both 2, then fourth: 3<4? 

            So identity should be first? 

            But we put exponent3 first? 

            How did we get [3,6]? 

            From the previous pass (d1) we had: 
                After d1 (index1) we had: 
                   new_idx = [5,2,3,6,1,4] -> then we are going to d0? 

            But then we traverse the current index array in order? 

            For d0: we have the current index array = [5,2,3,6,1,4] -> which corresponds to the permutations:

                idx[0]=5: exponent6? no: our perms: 
                   perms[0]: exponent1
                   perms[1]: exponent2
                   perms[2]: exponent3
                   perms[3]: exponent4
                   perms[4]: exponent5
                   perms[5]: exponent6

                So:
                   5: perms[5] -> exponent6? 
                   2: perms[2] -> exponent3
                   3: perms[3] -> exponent4
                   6: invalid? we only have k=6, so indices 0..5.

            This is a bug: we did:

                vector<int> idx(k); initially: [0,1,2,3,4,5]

            Then after each pass we reassign idx to new_idx? which is the permutation indices (0..5) in the new order.

            But in the code above, in the inner loop:

                for (int i=0; i<k; i++) {
                    int perm_index = idx[i];
                    ... 
                }

            Then we create new_idx: which is a permutation of the same perm_index.

            Then we set idx = new_idx.

            Then in the next pass, we use the new_idx as the current order.

            Then at the last pass (d=0) we have:

                idx = [3,6,1,4,5,2] -> but 6 is out of bounds? 

        Correction: I see: we did:

            vector<int> new_idx(k);
            for (int i=0; i<k; i++) {
                int perm_index = idx[i];
                int x = perms[perm_index][d];
                new_idx[ pos[x] ] = perm_index;
                pos[x]++;
            }

        Then the new_idx contains the perm_index? which is from 0 to k-1? 

        But in the sample, k=6, so indices 0 to 5. How did we get 6? 

        Actually, the sample simulation had a mistake: we used exponent numbers (1..6) as indices? but the perm_index is the original index in the perms array (0..5). 

        In the last pass (d=0) we started with idx = [5,2,3,6,1,4] -> but 6 is not in [0..5]? 

        How did we get 6? 

        Actually, in the previous step (d=1) we had:

            new_idx = [5,2,3,6,1,4] -> but wait, we have k=6, so we should have indices 0..5? 

            How did we get 6? 

        I see: in the step for d=1, we had:

            We started with idx = [3,1,5,4,2,0]? -> no, actually we started with the result of the previous pass (d=2): which was [1,4,5,2,3,0]? 

        Let me do the entire radix sort step by step for the sample:

            k=6, n=5.

            Step0: idx = [0,1,2,3,4,5]   (the original indices: 0->exp1, 1->exp2, 2->exp3, 3->exp4, 4->exp5, 5->exp6)

            d=4: last element (index4) of each permutation:

                perms[0] = [1,2,0,4,3] -> d4=3
                perms[1] = [2,0,1,3,4] -> d4=4
                perms[2] = [0,1,2,4,3] -> d4=3
                perms[3] = [1,2,0,3,4] -> d4=4
                perms[4] = [2,0,1,4,3] -> d4=3
                perms[5] = [0,1,2,3,4] -> d4=4

                Count: 
                   3: 3 times -> count[3]=3
                   4: 3 times -> count[4]=3

                Then pos: 
                   pos[0]=0, pos[1]=0, pos[2]=0, pos[3]=0, then for i>=4? we only care for 0..4? 
                   Actually, we have n=5: indices 0..4.

                We do:
                   pos[0]=0
                   pos[1]=0
                   pos[2]=0
                   pos[3]=0
                   pos[4]=3   (because count[0]=0, count[1]=0, count[2]=0, count[3]=3, then we set pos[0]=0, then pos[1]=0, pos[2]=0, pos[3]=0, and then pos[4]=3? 
                Actually, we did:

                   vector<int> pos(n,0);   // n=5: [0,0,0,0,0]
                   if (n>0) {
                      pos[0]=0;
                      for i=1 to 4: 
                         pos[i] = pos[i-1] + count[i-1]
                   }

                So:
                   i=1: pos[1] = pos[0] + count[0] = 0+0=0
                   i=2: pos[2]=0+0=0
                   i=3: pos[3]=0+0=0
                   i=4: pos[4]=0+count[3]=3? 

                Then for each element in the current idx (0,1,2,3,4,5):

                    i=0: perm_index=0 -> x=3 -> new_idx[0] = 0? then pos[3] becomes 1? 
                    i=1: perm_index=1 -> x=4 -> new_idx[3] = 1? then pos[4] becomes 4? 
                    i=2: perm_index=2 -> x=3 -> new_idx[1] = 2? then pos[3]=1 -> then becomes 2? 
                    i=3: perm_index=3 -> x=4 -> new_idx[4] = 3? 
                    i=4: perm_index=4 -> x=3 -> new_idx[2] = 4? 
                    i=5: perm_index=5 -> x=4 -> new_idx[5] = 5? 

                Then new_idx = [0,2,4,1,3,5]   (because: 
                    index0:0, index1:2, index2:4, index3:1, index4:3, index5:5)

                Then we set idx = [0,2,4,1,3,5]

            Then d=3: 
                perms[0][3]=4, perms[2][3]=4, perms[4][3]=4, perms[1][3]=3, perms[3][3]=3, perms[5][3]=3

                Count: 
                  3: 3
                  4: 3

                Then pos: 
                  pos[0]=0, pos[1]=0, pos[2]=0, pos[3]=0, pos[4]=3? 

                Then:
                   i=0: perm_index=0 -> x=4 -> new_idx[3] =0 -> then pos[4]=4
                   i=1: perm_index=2 -> x=4 -> new_idx[4]=2 -> pos[4]=5
                   i=2: perm_index=4 -> x=4 -> new_idx[5]=4 -> pos[4]=6 -> out of bounds? 

            Correction: our array new_idx has size 6? so index0..5.

            Actually, we do:

               for i=0 to 5:
                   x = perms[ idx[i] ][3]   // d=3

                Then we update new_idx at the position given by pos[x] and then increment pos[x].

            How we computed pos: 
                pos[0]=0
                pos[1]=0
                pos[2]=0
                pos[3]=0
                pos[4]=3   (because count[0]=0, count[1]=0, count[2]=0, count[3]=3 -> so pos[4]=0+count[0]+count[1]+count[2]+count[3]? no: our loop:

                  pos[0]=0
                  pos[1]=pos[0]+count[0]=0+0=0
                  pos[2]=pos[1]+count[1]=0+0=0
                  pos[3]=pos[2]+count[2]=0+0=0
                  pos[4]=pos[3]+count[3]=0+3=3

            Then for x=4, we start at pos[4]=3.

            Then:

                i=0: perm_index=0 -> x=4 -> new_idx[3]=0, then pos[4]=4
                i=1: perm_index=2 -> x=4 -> new_idx[4]=2, then pos[4]=5
                i=2: perm_index=4 -> x=4 -> new_idx[5]=4, then pos[4]=6
                i=3: perm_index=1 -> x=3 -> new_idx[0]=1, then pos[3]=1
                i=4: perm_index=3 -> x=3 -> new_idx[1]=3, then pos[3]=2
                i=5: perm_index=5 -> x=3 -> new_idx[2]=5, then pos[3]=3

            Then new_idx = [1,3,5,0,2,4]

            Then idx = [1,3,5,0,2,4]

            Then d=2: 
                perms[1]: exponent2 -> [2,0,1,3,4] -> index2=1
                perms[3]: exponent4 -> [1,2,0,3,4] -> index2=0
                perms[5]: exponent6 -> [0,1,2,3,4] -> index2=2
                perms[0]: exponent1 -> [1,2,0,4,3] -> index2=0
                perms[2]: exponent3 -> [0,1,2,4,3] -> index2=2
                perms[4]: exponent5 -> [2,0,1,4,3] -> index2=1

                Count: 
                  0: 2
                  1: 2
                  2: 2

                pos: 
                   pos[0]=0
                   pos[1]=0+count[0]=2
                   pos[2]=2+count[1]=4
                   pos[3]=? we don't use, but we only have 0..2.

                Then:

                   i=0: perm_index=1 -> x=1 -> new_idx[2] =1, then pos[1]=3
                   i=1: perm_index=3 -> x=0 -> new_idx[0]=3, then pos[0]=1
                   i=2: perm_index=5 -> x=2 -> new_idx[4]=5, then pos[2]=5
                   i=3: perm_index=0 -> x=0 -> new_idx[1]=0, then pos[0]=2
                   i=4: perm_index=2 -> x=2 -> new_idx[5]=2, then pos[2]=6 -> out of bounds? 
                   i=5: perm_index=4 -> x=1 -> new_idx[3]=4, then pos[1]=4

                Then new_idx = [3,0,1,4,5,2]   -> because:
                    index0: 3
                    index1: 0
                    index2: 1
                    index3: 4
                    index4: 5
                    index5: 2

            Then d=1: 
                perms[3]: exponent4: [1,2,0,3,4] -> index1=2
                perms[0]: exponent1: [1,2,0,4,3] -> index1=2
                perms[1]: exponent2: [2,0,1,3,4] -> index1=0
                perms[4]: exponent5: [2,0,1,4,3] -> index1=0
                perms[5]: exponent6: [0,1,2,3,4] -> index1=1
                perms[2]: exponent3: [0,1,2,4,3] -> index1=1

                Count: 
                    0:2, 1:2, 2:2

                Then:

                   i=0: perm_index=3 -> x=2 -> new_idx[ pos[2] ] = new_idx[4] = 3, then pos[2]=5
                   i=1: perm_index=0 -> x=2 -> new_idx[5]=0, then pos[2]=6
                   i=2: perm_index=1 -> x=0 -> new_idx[0]=1, then pos[0]=1
                   i=3: perm_index=4 -> x=0 -> new_idx[1]=4, then pos[0]=2
                   i=4: perm_index=5 -> x=1 -> new_idx[2]=5, then pos[1]=3
                   i=5: perm_index=2 -> x=1 -> new_idx[3]=2, then pos[1]=4

                new_idx = [1,4,5,2,3,0]

            Then d=0: 
                perms[1]: exponent2: [2,0,1,3,4] -> d0=2
                perms[4]: exponent5: [2,0,1,4,3] -> d0=2
                perms[5]: exponent6: [0,1,2,3,4] -> d0=0
                perms[2]: exponent3: [0,1,2,4,3] -> d0=0
                perms[3]: exponent4: [1,2,0,3,4] -> d0=1
                perms[0]: exponent1: [1,2,0,4,3] -> d0=1

                Count: 
                   0:2, 1:2, 2:2

                Then:

                   i=0: perm_index=1 -> x=2 -> new_idx[ pos[2] ] = new_idx[4] = 1, then pos[2]=5
                   i=1: perm_index=4 -> x=2 -> new_idx[5]=4, then pos[2]=6
                   i=2: perm_index=5 -> x=0 -> new_idx[0]=5, then pos[0]=1
                   i=3: perm_index=2 -> x=0 -> new_idx[1]=2, then pos[0]=2
                   i=4: perm_index=3 -> x=1 -> new_idx[2]=3, then pos[1]=3
                   i=5: perm_index=0 -> x=1 -> new_idx[3]=0, then pos[1]=4

                new_idx = [5,2,3,0,1,4]

            Then the sorted list of exponents: 
                index0:5 -> exponent6
                index1:2 -> exponent3
                index2:3 -> exponent4
                index3:0 -> exponent1
                index4:1 -> exponent2
                index5:4 -> exponent5

            Then the result_exponent = [6,3,4,1,2,5] -> which matches.

        So the code for radix sort is correct.

   We code accordingly.

   Note: we assume n>=1? but the problem says n>=1.

   Let's code.

   Important: We have to compute the LCM? We have to use math.gcd? 

   Steps for LCM:

        k = 1
        for each cycle length L in cycle_lengths:
            k = k * L / gcd(k, L)

        But we want integer? 

        We can do:

            k = 1
            for L in cycle_lengths:
                g = gcd(k, L)
                k = k * (L // g)

   We use from math import gcd? But in C++: __gcd or std::gcd? 

   We'll use:

        long long gcd(long long a, long long b) {
            if (b==0) return a;
            return gcd(b, a%b);
        }

        Then LCM: a / gcd(a,b) * b   (to avoid overflow? but k is at most 44100? and L<=100, so we can do in long long? but k might be 44100, and then 44100 * 100 / gcd = 4410000? which is acceptable.

   However, worst-case: the LCM for the partition of 100 we described: 4,9,25,49 -> 4*9*25*49=44100? then multiplied by the ones? but we have 13 ones? then we do: 
        k = 1
        k = 1 * 4 -> 4
        k = 4 * 9 / gcd(4,9)=1 -> 36
        k = 36 * 25 / gcd(36,25)=1 -> 900
        k = 900 * 49 / gcd(900,49)=1 -> 44100
        then for each one (13 times): 
            k = 44100 * 1 / gcd(44100,1)=1 -> 44100

        So we can do:

            k = 1;
            for (int L : cycle_lengths) {
                k = k / gcd(k, L) * L;
            }

        But note: k * L / gcd might be the same? 

        However, to avoid overflow: we do division first? 

        Since k and L are integers and k is divisible by gcd(k,L), we can do: k = (k / gcd(k,L)) * L;

        But we have to use long long? because k might be 44100? and then 44100 * 100? but no: we are dividing by the gcd.

        Actually, the maximum k is 44100? which is within int? but 44100 * 100 = 4,410,000 which is within int? 

        However, the LCM for the worst-case partition of 100 is 44100, which is 44100, so we can use int.

        But let me check: the maximum LCM for a partition of 100 is 44100? 

        Actually, we have one more: the LCM of (96,4) is 96? 
        But 44100 is the maximum.

        So we can use int.

   Summary of code:

        #include <iostream>
        #include <vector>
        #include <cstring>
        #include <algorithm>
        #include <cmath>
        #include <queue>
        #include <stack>
        #include <map>
        #include <set>
        #include <climits>
        using namespace std;

        long long gcd(long long a, long long b) {
            if (b == 0) return a;
            return gcd(b, a % b);
        }

        int main() {
            int n, q;
            cin >> n >> q;
            vector<int> P(n);
            for (int i=0; i<n; i++) {
                cin >> P[i];
                P[i]--; // 0-indexed
            }

            // Cycle decomposition
            vector<bool> visited(n, false);
            vector<vector<int>> cycles;
            for (int i=0; i<n; i++) {
                if (!visited[i]) {
                    vector<int> cycle;
                    int cur = i;
                    while (!visited[cur]) {
                        visited[cur] = true;
                        cycle.push_back(cur);
                        cur = P[cur];
                    }
                    cycles.push_back(cycle);
                }
            }

            // Compute k = LCM of cycle lengths
            vector<int> cycle_lengths;
            for (auto &cycle : cycles) {
                cycle_lengths.push_back(cycle.size());
            }
            long long k = 1;
            for (int L : cycle_lengths) {
                long long g = gcd(k, L);
                k = (k / g) * L;
            }
            // Now k is the order (exponent from 1 to k)

            // Generate k permutations: perms[i] for i in [0, k-1] (for exponent = i+1)
            vector<vector<int>> perms;
            perms.resize(k, vector<int>(n)); // k vectors of n integers

            // For exponent t (from 1 to k): t = i+1 -> i from 0 to k-1
            for (long long i=0; i<k; i++) {
                long long exponent = i+1;   // we are generating P^(i+1)
                // We'll create a permutation array: res of n integers
                // For each cycle:
                for (auto &cycle : cycles) {
                    int L = cycle.size();
                    // The shift: exponent mod L? but we can do exponent mod L? 
                    long long shift = exponent % L;
                    if (shift == 0) shift = L;   // then we do a full cycle? but modulo L: (j+shift) mod L = (j) mod L? 
                    // Actually, we can do: (j + exponent) % L, but note: we can also do: 
                    //   We want: for the j-th element in the cycle, the new position is (j+exponent) mod L?
                    //   But exponent mod L is the same as shift? and if shift==0, then (j+0) mod L = j, so we don't need to set shift=L? 
                    //   Because (j+exponent) % L = (j + (exponent mod L)) % L, and if exponent mod L is 0, then it's j.
                    //   So we can just do: shift = exponent % L; then use shift.

                    // But note: exponent mod L might be 0? then we use 0? 
                    //   Then the element at cycle[j] goes to cycle[(j+0) % L] = cycle[j] -> identity? 
                    //   But if we use shift=L: then (j+L) mod L = j -> same.
                    //   So we can just do: shift = exponent % L.

                    // Then we do:
                    for (int j=0; j<L; j++) {
                        int new_index_in_cycle = (j + exponent) % L;
                        if (new_index_in_cycle >= L) new_index_in_cycle -= L; // not needed, because mod is in [0,L-1]
                        perms[i][ cycle[j] ] = cycle[new_index_in_cycle];
                    }
                }
            }

            // Now, we have perms: a vector of k vectors of n integers (each integer in [0, n-1])
            // We want to sort the k permutations lexicographically (by the array perms[i] from index0 to index n-1) 
            // using LSD radix sort.

            vector<long long> idx(k);
            for (long long i=0; i<k; i++) {
                idx[i] = i;
            }

            // We'll do for d from n-1 down to 0
            // But note: k can be 0? but k>=1 (since M>1 -> k>=1)

            for (int d = n-1; d>=0; d--) {
                // We'll do counting sort for the digit d

                vector<long long> count(n,0);   // frequencies for 0..n-1
                for (long long i=0; i<k; i++) {
                    // the permutation index = idx[i]
                    int x = perms[ idx[i] ][d];
                    count[x]++;
                }

                // Compute the starting positions: 
                vector<long long> pos(n,0);   // starting position for bucket x
                if (n>0) {
                    for (int x=1; x<n; x++) {
                        pos[x] = pos[x-1] + count[x-1];
                    }
                }

                // Create new_idx
                vector<long long> new_idx(k);
                for (long long i=0; i<k; i++) {
                    int perm_index = idx[i];
                    int x = perms[perm_index][d];
                    new_idx[ pos[x] ] = perm_index;
                    pos[x]++;
                }

                idx = new_idx;
            }

            // Now idx is the sorted order: the i-th smallest permutation is perms[ idx[i] ]
            // And the exponent for that permutation is: idx[i] + 1
            vector<long long> result_exponent(k);
            for (long long i=0; i<k; i++) {
                result_exponent[i] = idx[i] + 1;
            }

            // Process queries
            for (int i=0; i<q; i++) {
                long long K;
                cin >> K;   // K_i: 1-indexed position in the sorted list
                // We have result_exponent: the j-th element (0-indexed) is the exponent for the j+1-th smallest permutation?
                // So for the K-th smallest permutation (K from 1 to k), we want result_exponent[K-1]
                cout << result_exponent[K-1] << endl;
            }

            return 0;
        }

   But note: k might be large? but k is at most 44100? and we are storing idx and new_idx as vector<long long> of size k? which is 44100, which is acceptable.

   However, the problem says Q can be 300,000, but we are storing only k elements for result_exponent? and k is at most 44100? 

        But note: the problem says: "each query contains an integer K_i" and "1<=K_i < M", and M=k+1, so K_i is in [1, k]. 

        So we have to store result_exponent of size k (44100) and then for each query, we do a lookup: result_exponent[K_i-1].

   But if K_i is 100000? then K_i-1 = 99999? which is beyond k-1? 

        But the problem states: "1<=K_i < M", and M=k+1, so K_i is at most k? 

        So K_i in [1, k] -> then K_i-1 in [0, k-1] -> valid.

   However, note: we generated k = LCM(cycle_lengths) and we stored result_exponent[0..k-1].

   So we are safe.

   Let me test with the sample: k=6, and then we have result_exponent = [6,3,4,1,2,5] for indices0..5.

   Query: 
        1 -> output 6
        2 -> output 3
        3 -> output 4
        4 -> output 1
        5 -> output 2
        6 -> output 5

   which matches.

   But note: the problem says: the next line: the integer on the i-th line is K_i.

   We read q queries.

   We are done.

   However, note: the exponent in the generation: (j+exponent) % L -> we use exponent = i+1, which can be large? but modulo L, it is exponent % L.

   But we did: 
        new_index_in_cycle = (j + exponent) % L;

   But exponent can be as large as k (44100) and j is at most L (<=100). Then j+exponent might be 44100+100=44200? which is within int? 

   But we do modulo L, which is at most 100? 

        (j+exponent) % L = (j + (exponent % L)) % L? 

        Actually, (a+b) mod L = (a mod L + b mod L) mod L? 

        But we don't need to worry: integer is 32-bit, and 44200 is safe.

   But in the inner loop: we are doing for each cycle and for each element in the cycle? and the total over all cycles is n? so generating one permutation is O(n). Then total for k permutations: O(k*n) = 44100*100 = 4.4e6, which is acceptable.

   Let me run the worst-case: n=100, k=44100: 
        perms: 44100 * 100 * 4 bytes per integer = 4410000 * 4 = 17.6 MB? 

   Memory: 
        perms: 44100 * 100 integers = 4.41e6 integers -> about 17.64 MB.
        Also, we have idx and new_idx: each is k (44100) long longs? 8 bytes per element -> 44100*8 = 352800 bytes -> 0.35 MB.

        Then the radix sort: we have count: n (100) integers -> 100*4=400 bytes, and pos: 100 integers -> 400 bytes? and new_idx: 44100 long longs -> 0.35 MB.

        Total memory: about 18 MB? which is under 256 MB.

   Time: 
        Generating perms: 44100 * 100 = 4.41e6 operations (each operation is a few arithmetic) -> fast.

        Radix sort: 100 (passes) * (2 * k + n) = 100 * (2*44100 + 100) = 100 * (88200+100) = 100 * 88300 = 8.83e6 operations? -> fast.

        Then we process queries: 300000 -> just 300000 lookups? 

        Total: acceptable.

   But note: the problem says memory limit: 256MB.

   We'll code accordingly.

   However, we used long long for idx? but k is at most 44100, so we can use int for idx? 

        But: k=44100, which is within int.

        But note: the exponent i (from 0 to k-1) is at most 44100? so we can use int for the exponent? 

        But in the generation: exponent = i+1 (int) is enough.

        However, in the radix sort: we stored idx as vector<long long>? we can change to int.

        Actually, we can use int for everything? 

        But k is at most 44100? which is 44100, which is less than 2^16.

        So we change to int.

   Revised:

        vector<int> idx(k);
        for (int i=0; i<k; i++) idx[i]=i;

        Then in the counting sort:

            vector<int> count(n,0);
            vector<int> pos(n,0);
            vector<int> new_idx(k);

        And the exponent for the permutation is int? 

        But note: k is the LCM, which is at most 44100? 

        And the queries: K_i is at most k, which is 44100? 

        So we can output as int.

   But the problem: the exponent T_i might be as large as 44100? which is within int (int is at least 2^31).

   So we change to int.

   Code:

        #include <iostream>
        #include <vector>
        #include <cmath>
        using namespace std;

        int gcd(int a, int b) {
            if (b == 0) return a;
            return gcd(b, a % b);
        }

        int main() {
            int n, q;
            cin >> n >> q;
            vector<int> P(n);
            for (int i=0; i<n; i++) {
                cin >> P[i];
                P[i]--; // 0-indexed
            }

            // Cycle decomposition
            vector<bool> visited(n, false);
            vector<vector<int>> cycles;
            for (int i=0; i<n; i++) {
                if (!visited[i]) {
                    vector<int> cycle;
                    int cur = i;
                    while (!visited[cur]) {
                        visited[cur] = true;
                        cycle.push_back(cur);
                        cur = P[cur];
                    }
                    cycles.push_back(cycle);
                }
            }

            // Compute k = LCM of cycle lengths
            vector<int> cycle_lengths;
            for (auto &cycle : cycles) {
                cycle_lengths.push_back(cycle.size());
            }
            int k = 1;
            for (int L : cycle_lengths) {
                int g = gcd(k, L);
                k = (k / g) * L;
            }

            // Generate k permutations: perms[i] for i in [0, k-1] (for exponent = i+1)
            vector<vector<int>> perms(k, vector<int>(n)); // k vectors of n integers

            for (int i=0; i<k; i++) {
                int exponent = i+1;   // we are generating P^(i+1)
                for (auto &cycle : cycles) {
                    int L = cycle.size();
                    for (int j=0; j<L; j++) {
                        int new_index_in_cycle = (j + exponent) % L;
                        perms[i][ cycle[j] ] = cycle[new_index_in_cycle];
                    }
                }
            }

            // LSD radix sort
            vector<int> idx(k);
            for (int i=0; i<k; i++) {
                idx[i] = i;
            }

            for (int d = n-1; d>=0; d--) {
                vector<int> count(n,0);   // frequencies for 0..n-1
                for (int i=0; i<k; i++) {
                    int x = perms[ idx[i] ][d];
                    if (x < n) {
                        count[x]++;
                    }
                }

                // Compute the starting positions: 
                vector<int> pos(n,0);
                if (n>0) {
                    for (int x=1; x<n; x++) {
                        pos[x] = pos[x-1] + count[x-1];
                    }
                }

                vector<int> new_idx(k);
                for (int i=0; i<k; i++) {
                    int perm_index = idx[i];
                    int x = perms[perm_index][d];
                    new_idx[ pos[x] ] = perm_index;
                    pos[x]++;
                }

                idx = new_idx;
            }

            vector<int> result_exponent(k);
            for (int i=0; i<k; i++) {
                result_exponent[i] = idx[i] + 1;
            }

            for (int i=0; i<q; i++) {
                int K;
                cin >> K;
                // K is between 1 and k (inclusive)
                cout << result_exponent[K-1] << endl;
            }

            return 0;
        }

   Let me test with the sample.

   We already did a simulation for the radix sort and it worked.

   But note: in the counting sort, we have:

        for (int x=1; x<n; x++) {
            pos[x] = pos[x-1] + count[x-1];
        }

        Then when we place an element with value x, we put it at pos[x] and then increment pos[x]? 

        This is standard.

   But note: the count array is for values in [0, n-1]? and our perms[i][d] is in [0, n-1]? so we are safe.

   We run the sample: it should output 6,3,4,1,2,5.

   We'll run the sample:

        n=5, q=6, P=[2,3,1,5,4] -> 0-indexed: [1,2,0,4,3]

        ... we know the cycles: [0,1,2] and [3,4] -> k=LCM(3,2)=6.

        Then perms generation: we did above.

        Then radix sort: we did a simulation and it produced result_exponent = [6,3,4,1,2,5]? 

        Actually, after the radix sort, the sorted indices idx = [5,2,3,0,1,4] -> then result_exponent = [5+1=6, 2+1=3, 3+1=4, 0+1=1, 1+1=2, 4+1=5] -> [6,3,4,1,2,5] -> which is the expected output.

   So we output:

        6
        3
        4
        1
        2
        5

   for the queries 1,2,3,4,5,6.

   We are done.

   Note: The problem states: "It is guaranteed that P_i ≠ P_j for all i ≠ j." so the input is a permutation.

   We'll submit.

   However, note: the gcd function: we used int. Also, k is computed as an int? but what if k overflows int? 

        The maximum k is 44100? which is about 4e4, which is within int.

   But worst-case: the LCM for a partition of 100? we know it is 44100? so we are safe.

   But what if n=1? then k = LCM(1)=1? 

        Then we generate perms: one permutation? then we do radix sort? 

        Then the queries: q? and we output for each query K_i (which must be 1, because 1<=K_i<M, and M=2? so K_i=1) -> then output result_exponent[0] = 0+1 = 1.

        So for n=1: 
            P = [1] -> 0-indexed: [0]
            cycles: [0] -> k=1.
            Then we generate one permutation: exponent1: for the cycle [0]: 
                j=0: (0+1) %1 = 0? -> so perms[0][0]=0 -> the permutation [0] (identity) -> but what is P^1? it should be P? which is [0]? so correct.

            Then we build result_exponent[0] = 0+1 = 1.

            Then for any query: output 1.

   So it works.

   We write the code accordingly.

   Note: the modulo operation: (j+exponent) % L: if L=1, then (j+exponent)%1 is 0? and then we use cycle[0]? which is the only element.

   So it's safe.

   Final code.