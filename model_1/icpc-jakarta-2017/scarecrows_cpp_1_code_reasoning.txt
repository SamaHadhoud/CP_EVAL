 We are given R (rows) and C (columns) with R <= 14 and C up to 1000.
 We have a grid of R lines, each of length C, containing '.' for empty and 'v' for rice.

 Conditions:
 1. Each row must have at least one scarecrow.
 2. Every two consecutive columns must have at least one scarecrow.

 We can only place scarecrows on '.'.

 Approach:
 We use inclusion-exclusion over the rows: we consider subsets T of rows that we are going to "forget" the constraint (i.e., we allow these rows to have no scarecrow). Then we count the arrangements that avoid T (so we don't put scarecrows in T) and that satisfy the consecutive column constraint.

 For a fixed subset T, we define:
   For each column j, let A_j be the set of rows not in T that are available (i.e., grid[i][j]=='.').

 Condition 2: Every two consecutive columns must have at least one scarecrow. This can be interpreted as: 
   In the entire arrangement, there should be no two consecutive columns that are both "empty" (meaning: no scarecrow in any row of that column? Actually note: condition says "each consecutive two columns contain at least one scarecrow". So if we let x_j be the event that column j has at least one scarecrow, then we require that for every j from 0 to C-2, at least one of column j or column j+1 has a scarecrow.

 However, note: condition 2 does not require each column to have a scarecrow? But condition 1 requires each row to have at least one, but that doesn't force every column to have one. However, condition 2 forces that in every pair of consecutive columns, at least one column has a scarecrow.

 How to count for fixed T?
   We design a DP for columns j=0 to C-1.

   State for column j:
     We need to know if column j has at least one scarecrow? But also condition 2 involves consecutive pairs.

   We can let:
     dp[j][0] = number of ways for columns 0 to j such that column j does NOT have any scarecrow and the arrangement for columns [0:j] satisfies condition 2 for all consecutive pairs within [0:j] (but note: if j==0, condition 2 doesn't apply? Actually condition 2 applies for consecutive columns, so for j=0 we have no consecutive pair?).
     dp[j][1] = number of ways for columns 0 to j such that column j has at least one scarecrow.

   However, condition 2: we require that for every consecutive pair (j, j+1), at least one of j or j+1 has a scarecrow. This condition must hold for j from 0 to C-2.

   How about we enforce condition at the transition? Actually, condition (j-1, j) is enforced at step j.

   But note: if at column j we do not put any scarecrow, then column j-1 must have had a scarecrow? Actually condition (j-1, j) requires that at least one of j-1 and j has a scarecrow. So if j has none, then j-1 must have one.

   Therefore, our state can be:

     Let state at j be:
        state = 0: column j is empty -> then we require column j-1 must be non-empty (so condition (j-1, j) holds).
        state = 1: column j is non-empty -> then condition (j-1, j) holds regardless of column j-1.

   However, what about the condition for (j, j+1)? That will be taken care of at j+1.

   But note: we cannot have two consecutive empty columns.

   Therefore, we design:

     Let:
        dp0[j] = number of ways for columns 0 to j such that column j is empty and the conditions for consecutive pairs in [0, j] are satisfied. 
        dp1[j] = number of ways for columns 0 to j such that column j is non-empty and the conditions for consecutive pairs in [0, j] are satisfied.

     However, note: if j=0, then we cannot have state0 (empty) if condition 1 requires each row to have at least one? Actually condition 1 is not enforced in this fixed T? Actually we are avoiding T. Condition 1 is enforced by inclusion-exclusion. Here we are only counting arrangements that avoid T and satisfy condition 2.

     But condition 2: for the first column, there is no consecutive pair. So the first column can be either empty or non-empty? However, if the first column is empty, then when we come to the next column (if exists) we must have the next column non-empty? But what if the entire arrangement has only one column? Then condition 2 does not apply? So for one column, we can have the first column empty? However, condition 2 applies for consecutive columns. If there is only one column, condition 2 is trivially satisfied.

     However, condition 2 says "each consecutive two columns", meaning for every j from 0 to C-2, the pair (j, j+1) must have at least one scarecrow. So if C==1, condition 2 is vacuous.

     So for j=0:
        If we put an empty column: then we set dp0[0] = 1? But wait: how do we put an empty column? We choose 0 scarecrows from the available rows? That is 1 way? However, note: we are not forced to put anything? But condition 2 is satisfied.

        But note: condition 1 is not our concern at this fixed T? Actually condition 1 is being handled by inclusion-exclusion: we are counting arrangements that avoid T and satisfy condition 2. Condition 1 is the row condition which we enforce via inclusion-exclusion: at the end we require that no row is missing (so T=0 and inclusion-exclusion). Here we are just counting for a fixed T (so we are ignoring the rows in T).

        However, condition 2 only constrains consecutive columns. So for j=0, we can have:
          dp0[0] = 1   (if we choose 0 scarecrows in column0) 
          dp1[0] = (# of non-empty ways for column0) = (2^(a0) - 1)  [where a0 is the number of available rows in column0]

        But wait: condition 2 for the first column: none? so both are valid.

     Then for j>=1:
        To have column j empty (state0):
          Then condition (j-1, j) requires that column j-1 must be non-empty. So:
             dp0[j] = dp1[j-1]   (because we are forced to have j-1 non-empty and j empty)

        To have column j non-empty (state1):
          Then condition (j-1, j) is satisfied regardless of j-1. So:
             dp1[j] = (dp0[j-1] + dp1[j-1]) * (non_empty_ways for column j)

        However, note: the non_empty_ways for column j is the number of ways to put at least one scarecrow in column j: which is (2^(a_j) - 1, where a_j is the number of available rows in column j (that are not in T and are available '.').

     But wait: what if a_j==0? Then we cannot put any scarecrow in column j? Then non_empty_ways = 0. Then state1 would be 0.

     Also, if a_j==0, then state0: we can have column j empty? But condition 2: if we choose column j empty, then we require column j-1 non-empty? But condition 2 is satisfied? However, we cannot put a scarecrow in column j? So state0 is forced to be the same as above? Actually we can have column j empty? But we don't put any scarecrow. So:
        dp0[j] = dp1[j-1]   (if a_j==0, then we have no choice: we must leave it empty, but then we require j-1 non-empty)
        dp1[j] = 0

     Alternatively, we can precompute for each column j and each T, the non_empty_ways = 
        if there is at least one available row: (2^(a_j) - 1 mod MOD, else 0.

     Then the recurrence is:
        dp0[0] = 1   [if we leave column0 empty] 
        dp1[0] = non_empty_ways[0]

        For j from 1 to C-1:
            dp0[j] = dp1[j-1]   [because if we leave j empty, then j-1 must be non-empty to satisfy (j-1,j)]
            dp1[j] = (dp0[j-1] + dp1[j-1]) * non_empty_ways[j] % MOD

        Then the total for T is (dp0[C-1] + dp1[C-1])? 

     However, note: condition 2 must hold for every consecutive pair. This recurrence ensures that the pair (j-1, j) is satisfied? But what about pairs beyond? Actually, our recurrence builds step by step and condition (j-1, j) is enforced at step j. The condition for (j-2, j-1) was already enforced at step j-1.

     But wait: what about the last pair? When j = C-1, we have built up to the last column. The condition for (C-2, C-1) is enforced at j=C-1? Yes.

     However, note: the state dp0[C-1] means the last column is empty. Is that acceptable? Condition 2 does not require the last column to be non-empty? It only requires consecutive pairs. The pair (C-1, C) doesn't exist. So it's okay.

     But what if the entire arrangement ends with an empty column? Condition 2 is still satisfied because the last pair (C-2, C-1) is satisfied by the recurrence: if the last column is empty, then the second last must be non-empty (because we set dp0[C-1] = dp1[C-2]).

     However, what about the first column? We have two states: empty and non-empty. The recurrence for the first column is independent? Actually condition 2 for the first two columns: if the first column is empty, then the second column must be non-empty? But in our recurrence for j=1:
          dp0[1] = dp1[0]   -> so if the first column was non-empty then we can have the second column empty? Actually condition (0,1) is satisfied because the first column is non-empty? Then if the second column is empty, that's okay? Then condition (1,2) becomes: we require the third column to be non-empty? and so on.

     So the recurrence is correct.

     But note: what if the entire arrangement has two columns? 
        If the first column is empty: then we require the second column to be non-empty? Actually condition (0,1) requires at least one scarecrow in columns0 or columns1. If columns0 is empty, then columns1 must have one? So we have:
          state for column0: 
             empty: then column1 must be non-empty -> one way? Actually no: the non_empty_ways for column1 is the number of ways to put at least one in column1? So:
          dp0[0] = 1
          dp1[0] = non_empty_ways[0]
          Then for j=1:
             dp0[1] = dp1[0]   -> so if column0 was non-empty, then we can have column1 empty? But condition (0,1) is satisfied because column0 is non-empty? Yes. 
             dp1[1] = (dp0[0] + dp1[0]) * non_empty_ways[1]

          Then total ways for T = dp0[1] + dp1[1]

     However, note: we also have the possibility that the first column is non-empty and the second column is non-empty? That is included in dp1[1].

     But if the first column is empty, then the second column must be non-empty? That is included in dp0[1]? Actually dp0[1] = dp1[0] -> which counts the ways that the first column is non-empty and the second column is empty? That's the opposite.

     Actually our recurrence for state0 at j=1: 
        state0 at j=1: column1 is empty -> then condition (0,1): we require column0 to be non-empty -> so we must have had state1 at j=0. Therefore, dp0[1] = dp1[0] -> which is the number of ways that column0 is non-empty and column1 is empty.

     How about the case: column0 empty and column1 non-empty? 
        Then condition (0,1) is satisfied? because column1 is non-empty.
        But how do we count that?
          For j=0: we have state0: column0 empty -> that's 1 way.
          Then for j=1: we want state1: non-empty. 
          dp1[1] = (dp0[0] + dp1[0]) * non_empty_ways[1] 
          = (1 + dp1[0]) * non_empty_ways[1]

          So that includes the case: column0 empty and column1 non-empty? Yes: the term dp0[0] (which is 1) multiplied by non_empty_ways[1] is exactly that.

     Therefore, the recurrence is correct.

     However, note: we are not explicitly tracking the state of the entire column? We are aggregating the entire arrangement for the prefix.

     But there is a problem: what if the first column is non-empty and the second column is non-empty? That is included in dp1[1] (via the term (dp0[0] + dp1[0]) * non_empty_ways[1] -> and then we multiply by non_empty_ways[1] and then we have two independent choices? Actually the choices in the columns are independent? 

     Actually, the recurrence does not overcount? It counts every valid arrangement that satisfies condition 2 for consecutive pairs.

     Therefore, for fixed T, we compute:
        non_empty_ways[j] = (# of ways to put at least one scarecrow in column j) for j in [0, C-1]

        dp0[0] = 1
        dp1[0] = non_empty_ways[0]

        for j from 1 to C-1:
            dp0[j] = dp1[j-1]   # j-th column empty -> then j-1 must be non-empty
            dp1[j] = (dp0[j-1] + dp1[j-1]) * non_empty_ways[j] % MOD

        total_T = (dp0[C-1] + dp1[C-1]) % MOD

     However, note: condition 2 is satisfied for every consecutive pair? Yes.

     But what if we have a column j that is forced to be empty because there are no available rows? Then we set non_empty_ways[j]=0. Then:
        dp1[j] = 0
        dp0[j] = dp1[j-1]   -> which might be nonzero? That means we can have column j empty only if the previous column is non-empty.

     This matches: we have no choice for column j: we must leave it empty, and then we require the previous column to be non-empty.

     However, if the previous column is forced to be non-empty? But what if the previous column also had non_empty_ways[j-1]=0? Then dp1[j-1]=0, so dp0[j]=0 -> which is correct: we cannot have column j empty because then we require column j-1 to be non-empty, but column j-1 cannot be non-empty? Actually we cannot put a scarecrow in j-1? So then we break.

     Therefore, the recurrence naturally handles unavailable columns.

 3. Inclusion-Exclusion:

     We are counting arrangements that avoid T (so we do not put any scarecrow in rows of T). However, we have not enforced condition 1: each row must have at least one scarecrow. Condition 1 says: each row (that is not in T) must have at least one scarecrow? Actually condition 1 says "each row", meaning every row must have at least one. But if we avoid T, we are not putting any scarecrows in T, so we are not covering the rows in T? Therefore, we want to count arrangements that cover all rows? So we must have T = empty set? 

     How inclusion-exclusion works:

        Let F(T) = number of arrangements that avoid T (so they do not put scarecrows in rows of T) and that satisfy condition 2.

        Then, the arrangements that cover all rows (so every row has at least one scarecrow) is:
           Sum_{T subset of [0, R-1]} (-1)^{|T|} * F(T)

        Why? 
          Let U be the universe of arrangements that satisfy condition 2 and avoid no row? Actually we are not avoiding any row? But we are only avoiding T? Actually we are counting without the row condition? Then we use inclusion-exclusion to enforce that each row has at least one.

        Alternatively, we can think: 
          For a row i, let A_i be the event that row i has no scarecrow. We want none of the events to occur.

          Then by inclusion-exclusion:
             |∩_i A_i^c| = Sum_{T} (-1)^{|T|} * |∩_{i in T} A_i|

          But note: ∩_{i in T} A_i is the event that for each i in T, row i has no scarecrow. That is exactly the arrangement that avoids T? And we count F(T) = arrangements that avoid T and satisfy condition 2.

        Therefore, the answer is:
           ans = Sum_{T} (-1)^{|T|} * F(T)   [mod MOD]

 Implementation:

        Precompute for each T (subset of rows) the value F(T) as described above.

        Steps:
          Precompute base masks for each column: base[j] = bitmask of available rows (ignoring T for now).

          Precompute power2: for numbers up to R (since a_j <= R).

          Precompute popcount for all masks in [0, (1<<R)-1]? Or we can use bin(T).count('1')? But we have to do it for each T.

          For each T (from 0 to (1<<R)-1):
             For each column j:
                 available_rows_mask = base[j] & ~T   -> this gives the rows available for this column that are not in T and that are originally available ('.').
                 a_j = popcount(available_rows_mask)
                 non_empty_ways_j = (power2[a_j] - 1) % MOD   if a_j>0, else 0.

             Then run the DP for columns:

                 dp0 = 1   [for the first column: state0 = empty]
                 dp1 = non_empty_ways[0]

                 for j from 1 to C-1:
                    new_dp0 = dp1   # because to have j empty, we require j-1 non-empty
                    new_dp1 = (dp0 + dp1) * non_empty_ways_j % MOD
                    dp0, dp1 = new_dp0, new_dp1

                 F(T) = (dp0 + dp1) % MOD

          Then:
             ans = 0
             for T in [0, 1<<R):
                 sign = -1 if (popcount(T) % 2 == 1) else 1
                 ans = (ans + sign * F(T)) % MOD

          Then adjust ans to be non-negative modulo MOD.

 4. Corner: C=0? But C>=1 per constraints.

 5. Example: 2nd sample: R=1, C=3, grid: "..."
        T: subsets of rows of size 1: T can be 0 (empty) or 1 (the only row).

        For T=0: 
            base[0] = base[1]=base[2] = 1 (since the only row is available).
            non_empty_ways[0] = non_empty_ways[1] = non_empty_ways[2] = 2^1-1 = 1.

            DP:
               j0: dp0=1, dp1=1 -> total for j0: 2? Actually we have two states? But note: condition 2 doesn't apply for the first column? So we have two possibilities: leave it empty or put the scarecrow? But condition 2: we have consecutive columns? We must consider the entire arrangement.

            Actually we run:
               j0: dp0=1, dp1=1.
               j1: 
                  dp0 = dp1 (from j0) = 1
                  dp1 = (dp0 + dp1) * non_empty_ways[1] = (1+1)*1 = 2
                  -> so states: j1: (1,2)
               j2:
                  dp0 = dp1 (from j1) = 2
                  dp1 = (dp0 + dp1) * non_empty_ways[2] = (1+2)*1 = 3
                  total = dp0+dp1 = 2+3 = 5.

            F(0)=5.

        For T=1 (the only row is excluded):
            Then base[j] & ~T = 0 -> so non_empty_ways[j]=0 for each j.
            Then:
               j0: dp0=1, dp1=0 -> total=1
               j1: dp0 = dp1 (from j0)=0, dp1=(1+0)*0=0 -> total=0
               j2: dp0=0, dp1=(0+0)*0=0 -> total=0.

            F(1)=0.

        Then ans = (-1)^0 * F(0) + (-1)^1 * F(1) = 5 - 0 = 5.

        Matches sample.

 6. Third sample: R=2, C=3, grid:
        "vvv"
        "..."

        base[0]: 
            row0: 'v' -> not available -> mask: row1: '.' -> so mask = 1<<1 = 2 -> base[0]=2.
            base[1]: row0: 'v', row1: '.' -> base[1]=2.
            base[2]: row0: 'v', row1: '.' -> base[2]=2.

        Now, condition: each row must have at least one scarecrow? But row0 is not available in any column? So no matter what, we cannot put a scarecrow in row0? Therefore, the arrangement cannot cover row0? So we expect 0.

        How inclusion-exclusion?
          We iterate T. We want the arrangements that cover all rows? But row0 must be covered? But we cannot cover it? So the answer must be 0.

        Let's compute F(T) for T that does not include row0? Actually note: if T does not include row0, then we are required to put a scarecrow in row0? But we cannot? So for any T that does not contain row0, the non_empty_ways for each column: 
            We are avoiding T? But if T does not contain row0, then we are still forced to consider row0? But row0 is not available? So base[j] has row1 available? and row0 is not available? Then base[j] & ~T: 
                T might be 0: then base[j] & ~T = base[j] = 2 -> which does not include row0? So we are not forced to put in row0? Actually condition 1 is enforced by inclusion-exclusion: we are avoiding T, so we are not putting in T, but we are allowed to not put in row0? However, we cannot put in row0? So we are only putting in row1? 

            Then non_empty_ways[j] = (2^(popcount(2)) - 1) = (2^1-1)=1.

            Then F(0) = 5? But then we have to subtract F(T) for T that contain row0? 

        However, note: the inclusion-exclusion formula counts arrangements that cover all rows? So if we do not cover row0, then we don't count? Actually we are going to subtract the arrangements that avoid T? Then we use inclusion-exclusion to force that every row not in T is covered? But if T does not contain row0, then we require row0 to be covered? But we cannot cover row0? So F(T) for T that does not contain row0 must be 0? 

        Actually: when T does not contain row0, then we require row0 to be covered? But we cannot put a scarecrow in row0? Therefore, the arrangement that avoids T and covers all rows not in T? Actually no: the definition of F(T) is: arrangements that avoid T (so no scarecrows in T) and satisfy condition2. There is no requirement to cover the rows not in T? 

        But wait: condition1: each row must have at least one scarecrow? That condition is not enforced in F(T)? Actually condition1 is the one we are enforcing by inclusion-exclusion? And F(T) does not enforce condition1? It only enforces condition2 and the avoidance of T.

        Therefore, in F(T) for T=0, we count arrangements that avoid no row? But condition1 (each row has at least one) is not enforced? So we count arrangements that satisfy condition2? and that do not use any row in T (which is none) -> so they can use any row? But condition1 is not enforced? So we count arrangements that might not cover row0? 

        Actually: condition1 is the row condition: each row must have at least one scarecrow. We are using inclusion-exclusion to enforce condition1? So F(T) counts arrangements that avoid T and satisfy condition2, but they might not cover the rows not in T? 

        Therefore, we must compute F(T) as described: without condition1? Then inclusion-exclusion will subtract the ones that miss row0? 

        How to fix? Actually our F(T) counts arrangements that avoid T (so they don't put scarecrows in T) and satisfy condition2. It does not enforce that the rows not in T must be covered? So condition1 is not enforced? 

        Then the inclusion-exclusion formula:

           ans = Sum_{T} (-1)^{|T|} * F(T)

        counts the arrangements that cover all rows? because:

          Let U be the set of arrangements that avoid T and satisfy condition2. Then the inclusion-exclusion formula for the covering of all rows is:

             ans = Sum_{T} (-1)^{|T|} * |U_T|

          where U_T is the set of arrangements that avoid T and satisfy condition2? and that do not cover the rows in T? Actually no: avoiding T means we don't put scarecrows in T? so we are not covering T? Then the formula:

          |∩_{i} A_i^c| = Sum_{T} (-1)^{|T|} * |∩_{i in T} A_i|

          Here, A_i is the event that row i has no scarecrow? Then ∩_{i in T} A_i is the event that for every row i in T, there is no scarecrow? and also there might be no scarecrow in rows not in T? Actually no: the arrangement is free to cover or not cover rows not in T? 

          But note: condition1 requires that every row has at least one scarecrow? So the event A_i^c is that row i has at least one scarecrow.

          Then the formula says: the number of arrangements that cover every row (so every row has at least one scarecrow) and satisfy condition2 is:

             ans = Sum_{T} (-1)^{|T|} * F(T)

          where F(T) is the number of arrangements that avoid T (so they do not put any scarecrow in T) and satisfy condition2? and they might or might not cover the rows not in T? 

          But note: avoiding T means we are not putting scarecrows in T? so we are not covering T? Then condition1 requires covering T? So we cannot cover T? Therefore, the arrangement must not cover T? which contradicts condition1? 

          Actually, condition1 requires every row to be covered? So if we avoid T, we are not covering T? Then the arrangement cannot satisfy condition1? 

          Therefore, we must reinterpret: 

          We are counting arrangements that satisfy condition2 and that do not use any row in T? and we don't care about condition1? Then we use inclusion-exclusion to enforce that the rows not in T are covered? Actually condition1 requires that every row is covered? So if T is non-empty, then we are not covering T? So condition1 fails? Therefore, the formula counts:

             F(T) = arrangements that avoid T (so they do not use any row in T) and satisfy condition2? and they must cover the rows not in T? 

          But wait: condition1 requires every row to be covered? So if we avoid T, then we cannot cover T? Then condition1 fails? Therefore, the only T for which condition1 can be satisfied is T=empty? And then we require that the arrangement covers all rows? 

          How do we enforce that the arrangement covers all rows? We have to use inclusion-exclusion? 

          Actually, we can break condition1 into two parts:

            Condition1: for every row i, there is at least one scarecrow in row i.

          We can use inclusion-exclusion to subtract the arrangements that miss at least one row? 

          So:

            Let U = set of arrangements that satisfy condition2? (without condition1).

            For a row i, let A_i = {arrangements that have no scarecrow in row i}.

            Then we want | U ∩ (∩_{i} A_i^c) | = ?

            By inclusion-exclusion:

              = Sum_{T subset of [0, R-1]} (-1)^{|T|} * | U ∩ (∩_{i in T} A_i) |

          But note: ∩_{i in T} A_i = arrangements that have no scarecrow in any row i in T? and satisfy condition2? 

          This is exactly F(T) as we defined? 

          Therefore, the answer is:

            ans = Sum_{T} (-1)^{|T|} * F(T)

          And note: we do not require that the arrangement covers the rows in T? Actually we require the opposite: we avoid T? So the arrangement does not cover T? and we do not require that? Then how does condition1 get satisfied? 

          Condition1 requires that every row is covered? So the arrangement must cover T? but we are avoiding T? Then the arrangement cannot cover T? Therefore, the only way condition1 is satisfied is when T is empty? 

          But wait: the inclusion-exclusion formula counts:

             When T is empty: we count all arrangements that avoid no row? (so they might cover any row) and satisfy condition2? Then we subtract arrangements that avoid one row? then add back ...? 

          Actually, the formula counts:

             F(empty): arrangements that avoid no row? meaning they can use any row? and condition2? -> but they might miss some row? 
             Then we subtract F({i}) for each i: which are arrangements that avoid row i? and condition2? -> then we subtract arrangements that miss row i? but we also subtract arrangements that miss row i and also miss row j? 

          Then the inclusion-exclusion formula gives the number of arrangements that cover every row? 

          However, note: our F(T) does not enforce condition1? It only enforces condition2 and avoiding T? Then the formula is correct? 

          Example: second sample: R=1, C=3, grid "..."
            T=empty: F(empty)=5 -> arrangements that satisfy condition2? and avoid no row? (so they can use the row? but they might not? Actually condition1 is not enforced? So F(empty) counts arrangements that have condition2 satisfied? and avoid no row? meaning they can put scarecrows arbitrarily? but without condition1? 

            How many arrangements are there without condition1? 
               Condition2: consecutive columns must have at least one? 
               We have 3 columns? and 1 row? 
               Each column: either put a scarecrow or not? 
               Condition2: 
                 (0,1): at least one of col0 or col1 has a scarecrow? 
                 (1,2): at least one of col1 or col2 has a scarecrow? 

               Total without condition1: 
                 Condition2: 
                   We cannot have two consecutive zeros? 
                   We have 3 columns: states: 
                     (0,0,0): invalid: because (0,1) fails? 
                     (0,0,1): invalid: (0,1) fails? 
                     (0,1,0): invalid: (1,2) fails? 
                     (0,1,1): valid? 
                     (1,0,0): invalid: (1,2) fails? 
                     (1,0,1): valid? 
                     (1,1,0): valid? 
                     (1,1,1): valid? 
                 So valid: 4? 

            But we computed F(empty)=5? 

            Why 5? 
               Our DP for T=empty:
                 non_empty_ways for each column: 2^1-1=1? 
                 Then:
                    j0: dp0=1, dp1=1 -> total=2
                    j1: dp0 = dp1(j0)=1, dp1=(1+1)*1=2 -> total=3
                    j2: dp0=2, dp1=(1+2)*1=3 -> total=5.

            What is wrong? 

            Our DP counts:
              Condition2: we require every consecutive two columns to have at least one? 
              But our DP state:
                 state0: column j is empty? -> then condition (j-1,j): we require j-1 non-empty? 
                 state1: column j non-empty? -> condition (j-1,j) satisfied? 

            However, note: condition2 does not require that a column that is non-empty has to be in a row that is available? Actually we are forced: we can only put scarecrows in available cells? But we precomputed non_empty_ways: which is the number of non-empty ways to put scarecrows in the available rows? 

            And in the sample, every column is available? so non_empty_ways=1? meaning we have exactly one way to put at least one scarecrow? But wait: there is only one row? so we have two possibilities: put a scarecrow or not? But non_empty_ways=1: which means we have one way to put at least one? that is: put the scarecrow? 

            Then the arrangements we count:

               state0: column j empty? -> then we don't put any scarecrow? that is 1 way? 
               state1: column j non-empty? -> we put the scarecrow? that is 1 way? 

            So the states:

               j0: state0: 1 (empty), state1: 1 (non-empty) -> total 2.

            j1: 
               state0: column1 empty? then we require column0 non-empty? -> state0 = state1 of j0? = 1 -> meaning: column0 non-empty and column1 empty: one arrangement: [1,0]?
               state1: (state0 of j0 + state1 of j0) * 1 = (1+1)*1=2 -> arrangements: 
                   [0,1]: column0 empty? but then condition (0,1) requires column0 or column1 to have one? column1 has one? so that's allowed? 
                   But wait: we have state0 at j0=1 and state1 at j1=2: that includes [0,1]? 
                   Also [1,1]: column0 non-empty and column1 non-empty? 
                   So state1=2: [0,1] and [1,1]? 

            Then j1 total = 1 (state0) + 2 (state1) = 3.

            j2: 
               state0: column2 empty? then we require column1 non-empty? = state1 of j1 = 2 -> so arrangements: 
                   [0,1,0] and [1,1,0]? 
               state1: (state0 of j1 + state1 of j1) * 1 = (1+2)=3 -> arrangements: 
                   [0,1,1]: from [0,1] then put in column2 -> (0,1,1)
                   [1,1,1]: from [1,1] then put in column2 -> (1,1,1)
                   [1,0,1]: from [1,0] (state0 at j1) then put in column2? -> but wait: state0 at j1=1? so that's the arrangement [1,0]? then we add 1 in column2 -> (1,0,1) -> which is valid? 
                   Actually condition (1,2): column1 is empty? but column2 is non-empty? so condition (1,2) is satisfied? 
                   So we have 3 arrangements: (0,1,1), (1,1,1), (1,0,1)

            Then total = 2 (state0) + 3 (state1) = 5.

            But we only found 4 valid arrangements? 

            What is the fifth? 
               The arrangements we have:
                 j0: [0] and [1] -> two.
                 j1: [1,0] (state0: from [1] then 0), [0,1] and [1,1] (state1) -> three.
                 j2: 
                    state0: 
                       [0,1,0] -> condition (0,1): column0=0, column1=1 -> satisfied? condition (1,2): column1=1, column2=0 -> satisfied? because at least one in (1,2) is 1? -> actually condition (1,2): column1 is 1 -> satisfied? 
                       [1,1,0] -> condition (1,2): column1=1, column2=0 -> satisfied? 
                    state1: 
                       [0,1,1]: condition (0,1): satisfied? (1,2): satisfied?
                       [1,1,1]: satisfied?
                       [1,0,1]: condition (0,1): column0=1 -> satisfied? (1,2): column1=0, column2=1 -> satisfied? 

            So we have 5 arrangements? But earlier I thought 4? 

            Why did I think 4? 
               I missed [0,1,0]? 

            Condition2: 
               (0,1): column0=0, column1=1 -> 1 present -> satisfied.
               (1,2): column1=1, column2=0 -> 1 present -> satisfied.

            So [0,1,0] is valid? 

            Therefore, F(empty)=5? 

            Then the answer for the second sample is 5? 

            But condition1: each row must have at least one scarecrow? 
               In the second sample, R=1: so the row must have at least one scarecrow? 
               In which arrangements is the row covered? 
                  [0] -> row0 has 0? -> invalid.
                  [1] -> valid.
                  [1,0] -> the row0 has scarecrow in column0? -> valid.
                  [0,1] -> valid? 
                  [1,1] -> valid.
                  [0,1,0] -> the row0 has scarecrow in column1? -> valid.
                  [1,1,0] -> valid.
                  [0,1,1] -> valid.
                  [1,1,1] -> valid.
                  [1,0,1] -> valid.

               Actually, the only arrangement that does not cover the row is [0,0,0]? but we don't have that? 

            But note: our F(empty) counts arrangements that avoid no row? and satisfy condition2? and we have 5 arrangements? 

            Then why the sample output is 5? 

            However, condition1 is enforced by inclusion-exclusion? 

            But in the inclusion-exclusion formula: 
               T=0: F(0)=5, T=1: F(1)=0 -> then ans = 5 - 0 = 5.

            So it matches.

            But wait: condition1: we require the row to be covered? How does inclusion-exclusion ensure that? 

            Actually: F(0) counts all arrangements that avoid no row? and condition2? -> 5 arrangements? 
            F(1) counts arrangements that avoid row0? -> which means we cannot put any scarecrow? Then non_empty_ways=0? so F(1)=0? 

            Then the formula: 5 - 0 = 5.

            And in the 5 arrangements, the row is covered? 

            Why? 
               Because in every arrangement we have at least one scarecrow? 

            Actually: condition2 requires that consecutive columns have at least one scarecrow? Then in an arrangement that satisfies condition2, we must have at least one scarecrow? because if there are 3 columns, condition2 requires (0,1) and (1,2) to have at least one? so at least one column must be non-empty? But what if there is only one row? then the entire arrangement has at least one scarecrow? so the row is covered? 

            Therefore, condition1 is automatically satisfied? 

            But what if we have two rows? and we have an arrangement that covers only one row? and the other row has no scarecrow? 

            Example: R=2, C=1, grid: 
                row0: '.' 
                row1: 'v'

            Then condition1: row0 must be covered? 
            Condition2: none? 

            Then the arrangements for T=empty:
                base[0]: row0 available, row1 not -> mask = 1.
                non_empty_ways[0] = 2^1-1 = 1? 
                Then:
                   j0: dp0=1, dp1=1 -> total=2.

                But condition1: we require row0 to be covered? 
                The arrangements:
                   state0: column0 empty? -> then we put nothing? -> row0 is not covered? -> invalid for condition1? 
                   state1: we put a scarecrow in row0? -> then row0 is covered? -> valid.

                So we should count only state1? 

            How does inclusion-exclusion handle? 
               F(empty)=2? 
               F(T) for T that contains row0: 
                 T={0}: then base[0] & ~T = 0? -> non_empty_ways=0? -> F({0})=1? (dp0=1 for j0, dp1=0 -> total=1) 
               F(T) for T that does not contain row0? 
                 T={1}: then base[0] & ~T = 1? -> non_empty_ways=1? -> F({1})=2? 
                 T={0,1}: F=1? 

               Then ans = F(0) - [F({0}) + F({1})] + F({0,1}) = 2 - (1+2) + 1 = 0.

            But expected? 
               We want arrangements that cover row0? and condition2 is vacuous? 
               There is only one arrangement: put a scarecrow in row0? 

               So ans should be 1.

            Why 0? 

            What is the problem? 

            Our F(T) counts arrangements that avoid T? and condition2? but we do not require that the rows not in T are covered? 

            Therefore, in F(empty) we count both: 
                state0: no scarecrow? -> which does not cover row0? 
                state1: one scarecrow? -> which covers row0? 

            Then inclusion-exclusion: we want to subtract the arrangements that do not cover row0? 

            The arrangements that do not cover row0? are the ones that avoid row0? (T={0})? but then F({0}) counts arrangements that avoid row0? -> which is only the empty arrangement? -> 1? 

            Then the arrangements that cover row0? = F(empty) - F({0}) = 2 - 1 = 1? 

            But the inclusion-exclusion formula is:

               ans = F(0) - F({0}) - F({1}) + F({0,1}) 

            Why do we subtract F({1})? 

            The inclusion-exclusion formula is:

               ans = Sum_{T} (-1)^{|T|} * F(T)

            Here: 
               T=0: +2
               T={0}: -1
               T={1}: -2
               T={0,1}: +1

            Then ans = 2 - 1 - 2 + 1 = 0.

            Why do we subtract T={1}? 

            T={1}: arrangements that avoid row1? meaning we can put in row0? and condition2? 
                Condition2: none? 
                Then arrangements: 
                   state0: 1 (no scarecrow) -> row0 is not covered? 
                   state1: 1 (put in row0) -> row0 covered? 
                So F({1})=2.

            But why do we subtract this? 

            The event A_0: arrangements that have no scarecrow in row0? 
            The event A_1: arrangements that have no scarecrow in row1? 

            Then ∩_{i in T} A_i = A_{T}? 

            For T={1}: we are counting arrangements that avoid row1? and condition2? -> which is the same as arrangements that satisfy A_{1}? (because avoiding row1 means no scarecrow in row1, which is the condition for A_1) and also we don't care about row0? 

            But the inclusion-exclusion formula counts:

               |∩_{i} A_i^c| = ... 

            Actually, the event we are counting for T={1} is A_1? (arrangements that avoid row1, so they have no scarecrow in row1) but they might or might not have a scarecrow in row0? 

            Then we subtract F({1})? 

            But we want to subtract arrangements that have no scarecrow in row0? 

            How do we express the event A_0? 

            The inclusion-exclusion over T: 
               T is a set of rows? and we count F(T)= arrangements that avoid T? 

            But avoiding T means: no scarecrow in any row in T? 

            Therefore, for T={0}, we are avoiding row0? -> so no scarecrow in row0? -> then the arrangement is in A_0? 
            For T={1}, we are avoiding row1? -> no scarecrow in row1? -> then the arrangement is in A_1? 

            Then the formula:

               ans = F(0) - [F({0}) + F({1})] + F({0,1})

            subtracts both the arrangements that miss row0 and the arrangements that miss row1? 

            But we only care about missing row0? 

            Actually, condition1 requires both row0 and row1 to be covered? 

            So we want to subtract arrangements that miss at least one row? and then add back those that miss two? 

            Therefore, the formula is correct? 

            Why then in the example R=2, C=1, grid: 
                row0: '.', row1: 'v'

            The valid arrangement: put a scarecrow in row0? -> which covers row0? and row1 is not available? so we don't require to cover row1? 

            Condition1: each row must have at least one scarecrow? 
               row0: covered? 
               row1: not covered? -> but the problem: the field has rice-planted soil? so we cannot put a scarecrow in row1? 

            Therefore, condition1: each row must have at least one scarecrow? -> row1 must have at least one? but we cannot? -> so no arrangement? 

            Then the answer should be 0? 

            And we computed 0? 

            So it matches.

            Therefore, the third sample: 
                R=2, C=3, grid:
                    "vvv"
                    "..."

                Condition1: row0 must be covered? but row0 is all 'v'? -> we cannot put a scarecrow in row0? -> then condition1 fails? -> no arrangement? 

                How does the program compute?
                  We iterate T? 
                  For T that does not contain row0? (i.e., T=0, T={1})? 
                  For T that contains row0? (T={0}, T={0,1})? 

                  For T that does not contain row0? (T=0 or T={1}?):
                     Then we require row0 to be covered? but we cannot put a scarecrow in row0? so in F(T) we will have for every column: 
                         base[j] = mask for available rows: 
                            row0: 'v' -> not available? 
                            row1: '.' -> available? 
                         Then base[j] = 2 (for row1) -> and then base[j] & ~T: 
                            If T=0: then mask = 2 -> a_j=1 -> non_empty_ways=1? 
                            If T={1}: then mask = 2 & ~(2) = 0 -> non_empty_ways=0? 

                  Then for T=0: 
                     non_empty_ways = [1,1,1]? 
                     Then F(0)=5? 
                  For T={1}: non_empty_ways = [0,0,0]? then F({1})=? 
                         j0: dp0=1, dp1=0 -> total=1
                         j1: dp0=0, dp1=(1+0)*0=0 -> total=0
                         j2: dp0=0, dp1=0 -> total=0? 

                  For T={0}: 
                     base[j] & ~T = base[j] & ~1 = 2? (because T=1) -> so mask=2? -> non_empty_ways=1? 
                     Then F({0})=5? 

                  For T={0,1}:
                     base[j] & ~T = 0? -> non_empty_ways=0? -> F({0,1})=1 (at j0) then becomes 0? 

                  Then ans = F(0) - F({0}) - F({1}) - F({0,1})? 
                         = 5 - 5 - 0 - 0? = 0? 

            So we output 0? 

            Matches sample.

 7. Therefore, we code as described.

 8. Optimizations:
        We have 2^R (<= 2^14 = 16384) subsets T.
        For each T, we do a DP over C (<=1000) columns? 
        Total operations: 16384 * 1000 = 16,384,000 -> acceptable.

        Precomputation: 
          base[j] for each column j: once for all T? 
          power2: precomputed for exponents 0..R? 
          popcount: we can precompute an array popcount_arr for all masks in [0, nT) where nT=1<<R.

        Steps:

          Read R, C and grid.

          nT = 1<<R

          Precompute base[0..C-1]:
             for j in range(C):
                 mask = 0
                 for i in range(R):
                     if grid[i][j]=='.':
                         mask |= (1<<i)
                 base[j] = mask

          Precompute power2[0..R]: 
             power2[0]=1
             for i in range(1, R+1): power2[i] = (power2[i-1]*2) % MOD

          Precompute popcount_arr for all masks in [0, nT):
             for x in range(nT):
                 popcount_arr[x] = bin(x).count('1')   # or we can use bit_count if using Python 3.10+? but we are writing in C++? 

          Then:
             F = [0] * nT   # F[T] for each T

             for T in range(nT):
                 # For each column j, compute available_rows = base[j] & ~T, then a_j = popcount_arr[available_rows]
                 non_empty_ways = [0] * C
                 for j in range(C):
                     avail = base[j] & (~T)   # but note: T is an integer, and we are in the range [0, nT-1]? so we mask? 
                     avail &= (nT-1)   # to clear any higher bits? 
                     a = popcount_arr[avail]
                     if a==0:
                         non_empty_ways[j] = 0
                     else:
                         non_empty_ways[j] = (power2[a] - 1) % MOD

                 # Now run DP for columns
                 if C==0:
                     total_val = 0
                 else:
                     dp0 = 1
                     dp1 = non_empty_ways[0]
                     for j in range(1, C):
                         # new state: 
                         new_dp0 = dp1   # j-th column empty -> then j-1 must be non-empty? so we take state1 from j-1
                         new_dp1 = (dp0 + dp1) % MOD
                         new_dp1 = (new_dp1 * non_empty_ways[j]) % MOD
                         dp0, dp1 = new_dp0, new_dp1
                     total_val = (dp0 + dp1) % MOD
                 F[T] = total_val

             ans = 0
             for T in range(nT):
                 cnt = popcount_arr[T]
                 if cnt % 2 == 0:
                     ans = (ans + F[T]) % MOD
                 else:
                     ans = (ans - F[T]) % MOD

             ans %= MOD
             if ans < 0: ans += MOD
             print(ans)

 9. In C++:

        We note: 
          R up to 14 -> nT = 1<<14 = 16384.
          C up to 1000.

        Steps:

          Precompute base: for each column, a bitmask of R bits.

          Precompute power2: array of size R+1.

          Precompute popcount for all masks from 0 to nT-1: we can do with a vector and a loop.

          Then iterate T from 0 to nT-1.

          For each T, we compute non_empty_ways for each column.

          Then run a simple DP of length C.

        We use modulo arithmetic.

        We note: negative modulo: 
          ans = (ans - F[T]) % MOD; 
          Then we adjust: if (ans < 0) ans += MOD.

 10. Edge: C=0? then the grid has no columns? 
        Condition1: each row must have at least one scarecrow? -> impossible? so answer=0? 
        Condition2: vacuous? 
        Then F(0)=0? and for T non-empty? F(T)=0? -> ans=0? 

        But the problem says C>=1.

 11. Let's test with the first sample: 
        Input: 
          2 2
          "v."
          ".."

        base[0]: 
            row0: 'v' -> not available? 
            row1: '.' -> available? -> mask = (1<<1) = 2.
        base[1]:
            row0: '.' -> available? -> mask |= (1<<0) = 1.
            row1: '.' -> available? -> mask |= (1<<1) = 1|2 = 3.

        Precomputation for T=0:
            column0: avail = base[0] & ~0 = 2 -> a0 = 1 -> non_empty_ways[0] = 1.
            column1: avail = 3 -> a1=2 -> non_empty_ways[1] = 2^2-1=3.

            DP:
               j0: dp0=1, dp1=1 -> total for j0: 2.
               j1: 
                  dp0 = dp1 (from j0) = 1
                  dp1 = (dp0+j0 + dp1+j0) * non_empty_ways[1] = (1+1)*3 = 6
                  total = 1+6=7.

            F(0)=7.

        T=1 (binary 01): 
            base[0] & ~1 = 2 & ~1 = 2 -> a0=1 -> non_empty_ways[0]=1.
            base[1] & ~1 = 3 & ~1 = 2 -> a1=1 -> non_empty_ways[1]=1.
            DP:
               j0: dp0=1, dp1=1 -> total=2.
               j1: dp0=1, dp1=(1+1)*1=2 -> total=3.

            F(1)=3.

        T=2 (binary 10):
            base[0] & ~2 = 2 & ~2 = 0 -> a0=0 -> non_empty_ways[0]=0.
            base[1] & ~2 = 3 & ~2 = 1 -> a1=1 -> non_empty_ways[1]=1.
            DP:
               j0: dp0=1, dp1=0 -> total=1.
               j1: dp0 = dp1 (from j0)=0, dp1=(1+0)*1=1 -> total=1.

            F(2)=1.

        T=3 (binary 11):
            base[0] & ~3 = 0 -> non_empty_ways[0]=0.
            base[1] & ~3 = 0 -> non_empty_ways[1]=0.
            DP:
               j0: dp0=1, dp1=0 -> total=1.
               j1: dp0=0, dp1= (1+0)*0=0 -> total=0.
            F(3)=0? But actually j0: state0=1, j1: state0=0, state1=0 -> total=0? 

            Then F(3)=0.

        Then ans = F(0) - F(1) - F(2) + F(3) = 7 - 3 - 1 + 0 = 3.

        Matches sample.

 12. Code accordingly.

 13. Note: in C++, when we compute base[j] & ~T, note that T is an integer of the subset. We can do:

        int avail = base[j] & ~T;

        But note: T is an int, and base[j] is an int that only has R bits? so we can mask with (nT-1) if needed? Actually the bit representation of base[j] is in [0, nT-1]. And T is in [0, nT-1]. So we can just do:

        avail = base[j] & ~T;

        However, in C++ we might have issues with the sign? Since ~T is a bitwise complement that might extend to more bits? So we do:

        avail = base[j] & (~T) & (nT-1);

        Or we use unsigned? 

        Alternatively, we can do:

        avail = base[j] & (~T);
        Then we know that base[j] has bits only in [0, R-1], so we don't care about higher bits? 

        But then popcount: we are using a precomputed popcount for numbers in [0, nT-1]? 

        We precomputed popcount_arr for indices 0 to nT-1? So we do:

        int idx = avail & (nT-1);   // to get the lower R bits? but if R=14, then nT-1 = (1<<14)-1.

        Actually, base[j] is built from R bits? so we can do:

        avail = base[j] & ~T;
        Then a = popcount_arr[avail];   // because avail is in the range [0, nT-1]? 

        But note: base[j] is at most (1<<R)-1? and T is in [0, nT-1]? then ~T (as an int) might have higher bits set? 

        To be safe, we do:

        avail = base[j] & (~T);
        avail = avail & ((1<<R)-1);   // mask the lower R bits.

        Or we can use an unsigned type? 

        Alternatively, precompute popcount for the value (base[j] & ~T) without masking? but the value might be negative? 

        How about we use:

        a = __builtin_popcount(avail);   // but note: avail might be negative? and __builtin_popcount is for unsigned? 

        Actually, we can use:

        a = __builtin_popcount( base[j] & ~T & ((1<<R)-1) )

        But we precomputed popcount_arr for all numbers in [0, nT-1]? So we can do:

        int idx = base[j] & ~T;
        idx = idx & ((1<<R)-1);
        a = popcount_arr[idx];

        Or we can avoid the mask if we precomputed popcount_arr for numbers up to (1<<R)-1? and base[j] & ~T might be negative? 

        Actually, we can do:

        unsigned int uT = T;
        unsigned int ubase = base[j];
        unsigned int avail = ubase & ~uT;

        Then we can mask with (1<<R)-1? 

        But easier: we know that the number we care about has at most R bits? so we do:

        avail = base[j] & ~T;
        avail &= (nT - 1);   // because nT = 1<<R, so nT-1 is a mask for R bits.

        Then a = popcount_arr[avail];

 14. Alternatively, we can use the built-in popcount for integers? But note: R<=14, and we are iterating 16384 * 1000 = 16.3e6, and __builtin_popcount is fast? 

        We can avoid precomputation of popcount_arr? and use:

        a = __builtin_popcount( base[j] & ~T & (nT-1) );

        But note: the mask (nT-1) is necessary to clear higher bits? 

        Actually, base[j] is already in [0, nT-1]? and T is in [0, nT-1]? then base[j] & ~T might set higher bits? 

        Example: on a 32-bit machine, ~T for T=0x0000 is 0xFFFFFFFF? then base[j] & ~T = base[j]? which is in [0, nT-1]? so we don't need to mask? 

        But then __builtin_popcount(base[j] & ~T) will count the bits in base[j]? which is what we want? 

        However, the problem: if base[j] has a value that has more than R bits? no, because base[j] is built from R bits? 

        But ~T: if T is an int and we are on 32 bits, then ~T is 32 bits? then base[j] (which has R bits) is extended to 32 bits? and we want the popcount of the lower R bits? 

        Actually, base[j] & ~T: the bits beyond R are not set in base[j]? so it is the same as base[j] & ( (1<<R)-1 ) & ~T? 

        Therefore, we can do:

        a = __builtin_popcount( base[j] & ~T );

        without masking? 

        But note: if R is 14, then base[j] is at most 16383? which fits in 16 bits? and __builtin_popcount counts the number of bits set in the entire integer? which for an unsigned number is what we want? 

        However, in C++, for negative numbers, __builtin_popcount might give the number of bits in the two's complement? 

        We can avoid negative by converting to unsigned? 

        Alternatively, we can use:

        a = __builtin_popcount( (base[j] & ~T) & ((1<<R)-1) );

        But to be safe, we do:

        a = __builtin_popcount( base[j] & ~T & (nT-1) );

        Actually, base[j] is stored as an integer and we built it with R bits? so base[j] is in [0, nT-1]. Similarly, T is in [0, nT-1]. Then ~T in the integer type will have all higher bits set? but then base[j] has 0 in higher bits? so base[j] & ~T = base[j] & ( (nT-1) & ~T )? 

        Actually, base[j] has bits only in the low R bits? so we can mask:

        unsigned int avail = (unsigned int)(base[j]) & (unsigned int)(~T);
        a = __builtin_popcount(avail);

        But note: this counts the bits in the entire unsigned int? which for a number that has only low R bits set is the same as the popcount in the low R bits? 

        However, we want the popcount in the low R bits? 

        Actually, base[j] has only low R bits set? and ~T has all bits set above R? so base[j] & ~T: the bits above R are 0? because base[j] has 0 above R? 

        Therefore, we can do:

        a = __builtin_popcount( base[j] & ~T );

        without masking? 

        But let's test: 
          base[j] = 3 (binary ...00011) for R=2? 
          T=0: ~T = all ones? -> base[j] & ~T = 3 -> popcount=2? 
          T=1: ~T = ...11111110 -> base[j] & ~T = ...00000010 -> popcount=1? 

        Correct.

        However, if base[j] has a value that is negative? we built base[j] as an integer from R bits? so it is nonnegative? 

        So we can do:

        int avail = base[j] & ~T;
        a = __builtin_popcount(avail);

        But note: __builtin_popcount is for unsigned? Actually, it's for unsigned integers? 

        We can use:

        a = __builtin_popcount( (unsigned int)(base[j] & ~T) );

        But base[j] and T are integers? 

        Alternatively, we can use bitset? but that is slower? 

        Since we are in C++ and we have to do 16384*1000 = 16e6 popcounts? and __builtin_popcount is fast? 

        However, we precomputed popcount_arr for all masks? which is 16384? then we can do:

          int idx = base[j] & ~T;
          a = popcount_arr[idx & (nT-1)];

        This is one memory access? which is also fast.

        We'll precompute popcount_arr for all numbers in [0, nT) (which is 16384) -> small.

        Steps:

          vector<int> popcount_arr(nT, 0);
          for (int i=0; i<nT; i++) {
              popcount_arr[i] = __builtin_popcount(i);   // i is in [0, nT-1]? 
          }

        Then for each T and j:

          int avail = base[j] & ~T;
          avail &= (nT-1);
          a = popcount_arr[avail];

        Or we can do:

          int a = popcount_arr[ (base[j] & ~T) & (nT-1) ];

 15. We code accordingly.

 16. Also note: the modulus is 1000000007.

 Let's code in C++.