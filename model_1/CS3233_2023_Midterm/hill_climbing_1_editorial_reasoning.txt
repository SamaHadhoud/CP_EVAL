We are given multiple test cases. The constraints are that the sum of n and m over test cases is at most 300,000. However, note that the problem states that the total sum of n and m (each test case contributes its n and m) is at most 300,000? Actually, the problem says: "The sum of n and m over all test cases does not exceed 300,000". But note: each test case has n and m, and the sum of all n and all m (separately? or together?) is not clear. Actually, the problem says: "the sum of n and m over all test cases does not exceed 300000". This likely means that if we let T be the total number of test cases, then the sum (n_i + m_i) for each test case i is at most 300,000. But wait, the problem says "the sum of n and m over all test cases", meaning we add up all the n_i and all the m_i? Actually, the sample input has 4 test cases, and the first one: n=5, m=4 -> 9, the next two: n=6, m=11 -> 17 each, and the last: n=5, m=10 -> 15. Then total is 9+17+17+15=58, which is <=300000. Also, the problem says "the sum of n and m over all test cases does not exceed 300000", meaning the total of (n_i + m_i) for i from 1 to C is <=300000.

However, note that the next constraint: the graph has n-1<=m<=300000, and the total of (n_i+m_i) is bounded by 300000. But wait: if the total of (n_i+m_i) is 300000, then the maximum m in one test case is 300000? But then the total over test cases would be 300000? Actually, the problem says: the total (over test cases) of n and m (meaning we add up every n_i and every m_i) is <=300000. This is a very tight constraint. For example, if we have one test case, then n+m<=300000. But if we have 300000 test cases? Then each test case must have n+m=1? However, n>=2 and m>=n-1>=1, so n+m>=3. So the maximum number of test cases C is bounded by 300000/(minimum n+m) = 300000/3 = 100000. But the problem says C<=300000 and the total of n and m (meaning the sum of all n and all m) is <=300000. This implies that the test cases are very small on average.

Actually, the problem says: "the sum of n and m over all test cases does not exceed 300000". This is ambiguous. In competitive programming, it usually means: 
  Sum_{test cases} (n_i + m_i) <= 300000.

But note: the sample input has 4 test cases: 
  test1: n1=5, m1=4 -> 9
  test2: n2=6, m2=11 -> 17
  test3: n3=6, m3=11 -> 17
  test4: n4=5, m4=10 -> 15
Total = 9+17+17+15 = 58.

Therefore, we can assume that the total of (n_i + m_i) for all test cases is at most 300000.

This is a key insight: the total input size is bounded. Therefore, we can design an algorithm that runs in O(n_i + m_i) per test case? But note: the constraint on the total is 300000, so we can iterate over each test case and do O(n_i + m_i) work.

However, note that the problem also says: 
  "The first line contains two integers n and m ... (2 <= n <= 300000; n-1 <= m <= 300000)."
and then the total of (n_i+m_i) over test cases is <=300000.

Wait: if the total of (n_i+m_i) is 300000, then the maximum n in any test case is at most 300000, but the minimum n is 2, and the total over test cases of n and m is 300000. This implies that the number of test cases C cannot be too large. In fact, the smallest possible n_i+m_i is 2+1=3 (for a tree with 2 nodes: 1 edge). Then the maximum number of test cases is 300000/3 = 100000. But the problem says C (the number of test cases) is at most 300000? That seems contradictory.

Let me reread: "the sum of n and m over all test cases does not exceed 300000". This must mean that if we add up all the n's and all the m's (so we have two big sums: total_n and total_m) then total_n + total_m <= 300000? That would make sense because then the entire input size is bounded by 300000.

But note: in the input, each test case has:
  - a line with two integers n and m
  - a line with m integers (the a_i's)
  - m lines, each with two integers (the edges)

So the total number of integers in the input is:
  C (for the number of test cases)
  + 2*C (for the n and m in each test case)
  + sum_{test cases} m_i   (for the a_i array)
  + 2 * sum_{test cases} m_i   (for the edges)

But the problem says: "the sum of n and m over all test cases" does not exceed 300000. This is ambiguous. However, the constraints on the sample are consistent with: 
  total_n = 5+6+6+5 = 22
  total_m = 4+11+11+10 = 36
  total_n + total_m = 22+36 = 58.

But the problem says "the sum of n and m" meaning we are adding the n's and m's together? Then it would be 5+4+6+11+6+11+5+10 = 58.

Therefore, the total input integers for the edges would be 2 * (4+11+11+10) = 72, and for the a_i array: 4+11+11+10=36, and the initial lines: 1 (for C) + 4*2 (for the n and m of each test case) = 9. Total integers: 1+8+36+72 = 117.

But the problem states: "the sum of n and m over all test cases does not exceed 300000". This is the key constraint for our algorithm.

So we have:
  Let T = total of (n_i + m_i) for all test cases (i.e., for each test case we add n_i and m_i) and T<=300000.

But note: the total number of edges we have to read is the sum of m_i over test cases. And the total of m_i is at most T (because T = sum(n_i+m_i) and each m_i is at least n_i-1, so m_i >= n_i-1, so m_i <= T). Actually, the total m_i is bounded by T (because T = sum(n_i+m_i) and each n_i>=2, so m_i <= T).

Therefore, the entire input size is O(T) which is 300000.

So we can read the entire input without any problem.

Now, how to solve the problem?

We are required to color at least ceil(n/2) edges such that:
  For each color c (from 1 to m):
      - The number of edges colored with c is at most a_c.
      - The edges of each color c form a connected subgraph (meaning the subgraph induced by color c is connected).

Note: we have m colors (from 1 to m), and each color c has a capacity a_c. Also, we can leave edges uncolored (color 0).

The problem: does there exist a coloring with at least ceil(n/2) colored edges? And if yes, output one.

Observations:

1. Since the graph is connected, we know that we have at least n-1 edges.

2. We are only required to color at least ceil(n/2) edges. This is at least (n+1)//2.

3. The condition for each color: the set of edges with color c must form a connected subgraph. This implies that the edges of the same color must form a connected forest (in fact, a connected subgraph, which might have cycles? but the condition is connectivity: the entire set of edges of color c must form a connected component). However, note: the condition says "every pair of edges with color c is reachable from each other by only using edges with color c". This is equivalent to: the subgraph (V_c, E_c) is connected. So if we have two edges that are not connected by a path of edges of color c, then it is invalid.

This is a very strong condition. It means that each color class must form a connected subgraph. Therefore, each color class must be contained in a single connected component? Actually, the condition is that the edges of the same color form a connected graph. But note: the entire set of edges of that color must form a connected graph. So the edges of one color form a connected subgraph.

How can we use the capacities a_c? Note that the a_c are given for each color c, and the sum of a_c is <= m.

We are allowed to leave edges uncolored. So we can choose a subset of edges to color, and then assign colors to them such that for each color c, the edges of color c form a connected subgraph and the number of edges of color c is at most a_c.

We need at least ceil(n/2) edges colored.

How to approach?

Note: the problem does not require to maximize the number of colored edges. We only need to color at least ceil(n/2) edges.

Idea: We can try to use only one color? But the condition for one color: the entire set of edges we color with that color must form a connected subgraph. And we cannot exceed a_c for that color.

But we are allowed to use multiple colors. However, the condition for each color is independent: each color must form a connected subgraph.

But note: we are free to assign any subset of edges to any color as long as the connected condition per color holds and the capacities are not exceeded.

Another idea: we can use the entire graph? But the capacities a_c might be too small.

However, note that the sum of a_c is <= m. This means that the total number of edges we can color (if we use all colors) is at most m. But we have m edges? So we can color at most m edges, which is the entire graph. But we don't need to color the entire graph, only ceil(n/2) edges.

But the problem: we have to satisfy the connectivity condition per color.

Key insight: if we can form a spanning tree, then we can color the entire spanning tree with one color? But the capacity a_c for that color must be at least n-1. But we don't know if we have a color with a_c >= n-1.

But note: we have multiple colors. We can break the spanning tree into several connected subtrees? However, the condition requires each color class to be connected. So if we use two colors, we must break the spanning tree into two connected subtrees. How? We can remove an edge and then assign each connected component to a different color? But then each color class is connected? Actually, if we break the tree into two trees, then each tree is connected. So we can assign one color to the edges in the first tree and another to the edges in the second tree.

But how to break the spanning tree? We can choose a partition of the edges of the spanning tree into k connected components? Actually, we can remove k-1 edges to get k connected components. Then we can assign each component to a color. However, we are free to assign any set of edges, not necessarily a spanning tree.

But note: we are not limited to the spanning tree. We can use any set of edges.

However, the graph is connected, so we can always form a spanning tree. But we are allowed to use non-tree edges too. The condition: the set of edges of a color must form a connected subgraph. So if we assign a non-tree edge to a color, then we must also assign all the edges that connect the two endpoints? Actually, no: the condition is that the entire set of edges of that color must form a connected graph. So if we assign a non-tree edge, then we can also assign the entire path between the two endpoints? But that might force us to assign many edges.

Alternative approach:

We note that the condition for a color c is that the edges of that color form a connected subgraph. This is equivalent to: the edges of color c form a connected spanning subgraph of the vertices they cover. So the set of edges of one color must form a connected graph (which may not be the entire graph, but a connected subgraph).

Therefore, each color class is a connected subgraph (a connected graph on a subset of vertices).

We need to cover at least ceil(n/2) edges. But note: the edges we color must form a forest? Not necessarily: they can have cycles? The condition does not forbid cycles. However, the condition is connectivity: if we have a cycle, then the entire cycle is connected. But we can have a connected graph that is not a tree.

But note: if we use multiple colors, the entire set of colored edges does not have to be connected. Only the edges of the same color must be connected.

Therefore, we can think of the problem as: we want to partition a subset of edges (of size at least ceil(n/2)) into groups (each group is a color) such that:
  - Each group forms a connected subgraph.
  - The size of group c is at most a_c.

And we have m groups (colors) available.

But the groups are independent. We can assign arbitrarily? However, the capacities a_c are given.

How to assign? We are free to choose which edges to color and which color to assign.

We can try to use as few colors as possible? Or we can try to use the colors with large a_c.

But note: the sum of a_c is <= m. And we need at least ceil(n/2) edges. Therefore, if the maximum a_c is at least ceil(n/2), then we can try to assign a connected set of ceil(n/2) edges to that color. How?

So the problem reduces to: does the graph have a connected subgraph with at least ceil(n/2) edges? If we find one, then we can assign it to a color c that has a_c >= ceil(n/2). Then we leave the rest uncolored. That would be a valid solution.

But what if no color has capacity >= ceil(n/2)? Then we must use at least two colors. For example, if the maximum a_c is 3, but ceil(n/2)=10, then we need at least 4 colors (if each color can do at most 3, then 3*3=9 < 10, so we need 4 colors: 3+3+3+1). But note: we have m colors, so we can use multiple colors. However, each color class must form a connected subgraph. And we need to cover at least ceil(n/2) edges.

But now the problem becomes: can we cover at least ceil(n/2) edges by a set of connected subgraphs (each of size at most a_c) such that each connected subgraph is assigned to a distinct color and the capacities are not exceeded?

But note: the colors are distinct, and each color c can be used only once (with at most a_c edges). Also, the connected subgraphs might share edges? No, each edge is colored at most once.

So we need to partition a subset of edges (of size at least ceil(n/2)) into k groups (k is at most m) such that each group is connected and the size of group c (if we assign it to color c) is at most a_c.

But how to do that? It seems difficult.

Alternative Insight:

We are constrained by the total capacity (sum a_c <= m) and we only need ceil(n/2) edges. But note that the capacities a_c are given arbitrarily. However, we can use the colors in any order? Actually, we have fixed colors 1..m with capacities a_1, a_2, ... a_m.

We can sort the capacities in descending order. Then we try to assign the largest available color to the largest connected component we can form? But we are forced to use the capacities as given.

But note: the problem does not require to use the colors in any particular order? We can assign the connected components arbitrarily to any color as long as the capacity of the color is at least the size of the connected component.

Therefore, we can do:

Step 1: Find a set of connected edge-disjoint subgraphs (each connected) such that the total number of edges in these subgraphs is at least ceil(n/2). And we must be able to assign each subgraph to a distinct color c such that the size of the subgraph is <= a_c.

But note: we are allowed to leave edges uncolored even within the chosen connected subgraphs? Actually, no: each connected subgraph we choose must be entirely assigned to one color. And we can only assign one color per edge. And we are free to choose which edges to color.

So we can choose an edge partition of a subset of edges into connected subgraphs. And then we assign each connected subgraph to a color that has capacity at least the size of the subgraph.

But we are free to choose the partition arbitrarily? How to form connected subgraphs? 

Note: the entire graph is connected. We can use a spanning tree. Then we break the spanning tree into several connected components? How? 

We can remove some edges to break the tree into connected components. Then each connected component (a subtree) is a connected subgraph. But then we have partitioned the tree edges. Then we can also include non-tree edges? But if we include a non-tree edge, then we must assign it to a color by itself? Because if we assign it to a color, then we must assign the entire path connecting the endpoints? Actually, no: the condition only requires that the set of edges of the same color is connected. So if we assign a non-tree edge to a color, then we can assign it alone? Because a single edge is connected? Yes: the subgraph (V_c, E_c) for that color: V_c has the two endpoints and E_c has the one edge -> connected.

So we have two types of connected subgraphs: 
   Type 1: a single edge (which is connected).
   Type 2: a connected subgraph with multiple edges.

But we can mix and match.

However, the problem: we need to cover at least ceil(n/2) edges. And we must assign each connected subgraph to a color that can take it (i.e., the size of the subgraph <= a_c).

So we can formulate:

We have a set of connected subgraphs (which are edge-disjoint) that together cover at least ceil(n/2) edges. And we have a set of capacities a_1, a_2, ..., a_m. We want to assign each connected subgraph to one color (each color can take at most one connected subgraph? Actually, no: we can assign multiple connected subgraphs to the same color? 

Wait: the condition for a color c: the set of edges with color c must form a connected subgraph. If we assign two disjoint connected subgraphs to the same color, then the entire set of edges of color c is not connected. Therefore, each color can only be assigned to exactly one connected subgraph.

Therefore, we need to partition the set of edges we choose to color into connected subgraphs, and then assign each connected subgraph to a distinct color. The constraint is: for the connected subgraph of size s assigned to color c, we require s <= a_c.

But note: the same color cannot be reused. So the number of connected subgraphs we form must be at most the number of colors (which is m). But m is the total number of edges? Actually, the number of colors is m (from 1 to m). So we have m colors.

Therefore, we can form up to m connected subgraphs. But we don't need to use all colors: we can leave a color unused.

So the problem reduces to:

Find a set of edge-disjoint connected subgraphs (each is connected) such that the total number of edges is at least ceil(n/2). Then we need to assign each subgraph to a distinct color c such that the size of the subgraph is <= a_c.

But note: we are free to choose which edges to include. We don't have to cover the entire graph.

How to find such a partition? 

We can use a greedy approach:

1. Start by including as many edges as possible? But we have to form connected subgraphs.

2. Alternatively, we can use the entire graph? But we don't have to. We only need ceil(n/2) edges.

But note: we are constrained by the capacities: we cannot use a connected subgraph of size s if we don't have a color c with a_c >= s.

Therefore, we must form connected subgraphs that are not too large. Specifically, if we have no color with capacity at least s, then we cannot use a connected subgraph of size s.

So the maximum size of a connected subgraph we can use is bounded by the maximum capacity available. Let M = max(a_c). Then each connected subgraph must have at most M edges.

But we also have the constraint that the total number of edges we cover is at least ceil(n/2).

How to form the connected subgraphs? 

We can use a DFS/BFS to traverse the graph and form connected subgraphs. But note: we want to cover as many edges as possible? Actually, we only need ceil(n/2). So we can be greedy: we can start with small connected subgraphs (like single edges) and then merge if necessary? But we cannot merge two connected subgraphs arbitrarily because then they become one.

Alternatively, we can try to form connected subgraphs by starting from a root and then traversing the graph? 

But note: the problem is NP-hard? But the constraints: the total n and m over test cases is 300000. So we need an efficient solution.

Another idea: 

We know that if we have a color c with a_c >= ceil(n/2), then we can try to find a connected subgraph with exactly ceil(n/2) edges? Or at least ceil(n/2) edges? Actually, we can use a connected subgraph with at least ceil(n/2) edges and at most a_c edges. How to find such a connected subgraph? 

We can use a BFS/DFS to traverse the graph and we can use the following: 

  We want a connected subgraph with at least ceil(n/2) edges. But note: the entire graph has m>=n-1 edges, so such a subgraph exists? Actually, we can take the entire graph? But then we need a_c>=m. If we don't have a color with a_c>=m, then we cannot take the entire graph. But we don't need the entire graph: we only need ceil(n/2) edges.

So we can try to find a connected subgraph with exactly ceil(n/2) edges? How? 

We can start from any vertex and do a BFS until we have collected ceil(n/2) edges? But note: the set of edges we collect must form a connected subgraph. Actually, if we start at a vertex and do a BFS, we grow a tree. We can stop when we have collected k = ceil(n/2) edges. But the BFS tree we build will cover a set of vertices. The number of edges in the tree is the number of vertices minus one. So if we want k edges, we need k+1 vertices. But we only need k edges, so we can stop when the tree has k edges, which covers k+1 vertices.

But note: we are not limited to trees. We can include non-tree edges? However, if we include a non-tree edge, then we are not increasing the number of vertices. So if we have a tree on x vertices (with x-1 edges), we can add one non-tree edge to get x edges. But we are free to choose.

But we want at least ceil(n/2) edges. So if we can form a connected subgraph with at least ceil(n/2) edges and at most M (the maximum capacity) edges, then we can assign it to a color that has capacity at least the size of the subgraph.

Therefore, algorithm for one test case:

Step 0: Let k = ceil(n/2).

Step 1: Find the maximum capacity M = max_{c} a_c.

If M >= k, then we can try to find a connected subgraph with at least k edges (and at most M edges). Then we assign that entire subgraph to a color that has capacity at least the size of the subgraph (and we can choose one with M>=k, so we can use that color).

But note: we might have multiple colors with capacity>=k, so we can choose any.

So the problem reduces to: does the graph contain a connected subgraph with at least k = ceil(n/2) edges? And we know the entire graph is connected and has at least n-1 edges, which is at least ceil(n/2) for n>=2? 
  For n=2: ceil(2/2)=1, and n-1=1 -> yes.
  For n=3: ceil(3/2)=2, and n-1=2 -> yes.
  For n=4: ceil(4/2)=2, and n-1=3 -> yes.

So the entire graph has at least ceil(n/2) edges. But we cannot take the entire graph if the entire graph has more than M edges? Then we need a connected subgraph that has at least k edges and at most M edges? Actually, we can take a connected subgraph that is a subgraph of the entire graph. 

But note: we can always take a connected subgraph that has exactly k edges? How? 

We can start from the entire graph and remove edges until we have k edges? But we must maintain connectivity. So we can remove edges arbitrarily? Actually, we can do: 

  Start with the entire graph (which is connected). Then we remove edges one by one until the remaining subgraph has k edges. But we must ensure that the subgraph remains connected. How? 

  We can remove leaves? But if we remove a leaf edge, we disconnect a vertex. Alternatively, we can remove an edge that is not a bridge? But we don't know.

But note: we are not limited to trees. We can have cycles. So we can remove an edge that is part of a cycle without disconnecting the graph.

Therefore, we can do:

  We know the entire graph is connected and has m>=n-1 edges. We want to remove (m - k) edges and still leave the graph connected? But we don't need the entire graph to be connected? We only need the subgraph we choose to be connected. Actually, we can take any connected subgraph. We can take a spanning tree? That has n-1 edges. Then if k <= n-1, we can remove (n-1 - k) edges from the spanning tree? But then the tree becomes disconnected. 

Alternatively, we can take a BFS tree and then stop when we have k edges? But the BFS tree has exactly n-1 edges. We cannot have more? Unless we include non-tree edges.

So we can do:

  We can form a connected subgraph with exactly k edges by starting from a spanning tree (which has n-1 edges) and then if n-1 < k, we have to add non-tree edges? But k = ceil(n/2) and n-1 >= ceil(n/2) for n>=2? 
      n=2: ceil(2/2)=1, n-1=1 -> equal.
      n=3: ceil(3/2)=2, n-1=2 -> equal.
      n=4: ceil(4/2)=2, n-1=3 -> n-1>=ceil(n/2).

  Actually, for n>=2: 
        ceil(n/2) <= n-1   [since ceil(n/2) <= (n+1)/2, and (n+1)/2 <= n-1 for n>=3? 
          n=3: (3+1)/2=2, n-1=2 -> equal.
          n=4: (4+1)/2=2.5 -> ceil=3? Actually, ceil(4/2)=2. 
          But: ceil(4/2)=2, and 2<=3 (which is n-1) -> holds.

  So for any n>=2, we have n-1 >= ceil(n/2). Therefore, we can take a spanning tree? But the spanning tree has n-1 edges, which is at least k. But if k = ceil(n/2) is less than n-1, then we can remove (n-1 - k) edges arbitrarily? But we must leave the spanning tree connected? 

  Actually, we don't need the entire tree: we can take any connected subgraph. We can take a subtree that has k edges? How? 

  We can root the tree arbitrarily. Then we do a DFS and keep a counter. We traverse the tree and when we have collected k edges, we stop. But note: the edges we collect must form a connected subgraph. Since we start from the root and we traverse the tree, the set of edges we traverse forms a connected subtree. But we can get a connected subtree with k edges? 

  How many edges can we get? We can get at most n-1. We want k. We can do:

      Let T be a spanning tree. We can choose a root and then order the edges arbitrarily. We can do a DFS and include edges until we have k edges? Then we stop. Then the set of edges we have is connected? Yes, because we started from the root and we have a contiguous part.

  But note: if we stop in the middle of the DFS, we might leave a node half-visited? But we can take the entire DFS tree of the first k edges? Actually, we can use a BFS: we traverse the tree in BFS order and collect edges until we have k edges. Then we have a connected subtree that covers a contiguous BFS layer? 

  However, we must cover a set of vertices: the subtree will cover a set of vertices and the edges we traverse. The number of edges is k, so the number of vertices is k+1. Then we have a connected subtree with k edges.

  Therefore, we can always find a connected subgraph with exactly k edges? 

  Algorithm for one test case when M>=k:

      Step 1: k = ceil(n/2)
      Step 2: Find a connected subgraph with exactly k edges. (We can do by BFS: start from any node, and collect edges until we have k edges. But note: we must not break the connectivity. We can use BFS on the entire graph? But we are not limited to a tree? We can include non-tree edges? 

      Actually, we can use the entire graph. But we want exactly k edges? And connected. We can do:

          Use BFS to traverse the graph: we start at a node and then we traverse edges. We mark edges as we traverse. We stop when we have traversed k edges. But note: we might traverse a non-tree edge that doesn't lead to a new vertex? Then the set of edges we have might not be connected? 

      Alternatively, we can build a spanning tree first. Then we can traverse the tree (using BFS or DFS) and pick the first k edges. Then the set of edges we pick is a connected subtree.

      How to pick the first k edges? We can do:

          We build an arbitrary spanning tree (using BFS or DFS). Then we do a BFS starting from the root and we collect edges in BFS order. We stop when we have k edges.

      Then we have a connected subgraph (a tree) with k edges.

      Then we assign this entire set of k edges to a color c that has a_c >= k (which exists by our assumption M>=k). Then we leave all other edges uncolored.

      Then we output:
          For each edge in the graph: 
             if the edge is in the chosen set, then assign it the color c (we choose one color c that has a_c>=k; we can choose the one with the largest capacity? But any will do).
             else, assign 0.

      Then we output the coloring.

      But note: we have multiple colors. We are using only one color. And we are leaving the rest uncolored. This satisfies the condition: the set of edges of color c is the chosen tree? which is connected. And we have at least k edges.

      Therefore, this works.

But what if M < k? Then we cannot use one color to cover k edges. Then we must use multiple colors.

How to cover k edges with multiple colors? 

We need to partition a subset of at least k edges into several connected subgraphs, each of size at most M, and then assign each subgraph to a distinct color such that the size of the subgraph does not exceed the capacity of the color.

But note: the capacities a_c are arbitrary. However, we have sorted the capacities? We can sort the capacities in descending order. Then we want to assign the largest connected subgraph we form to the largest capacity, and so on.

But we are free to choose the connected subgraphs arbitrarily. How to form them? 

We can use the following:

  We want to cover as many edges as possible? Actually, we only need k. So we can be greedy: we form as many connected subgraphs as we can, each of size at most M, and we stop when we have collected at least k edges.

  How to form connected subgraphs? 

      We can use the entire graph? But we cannot assign a connected subgraph that is too big (if it is bigger than M, we cannot assign it). So we break the graph into connected subgraphs of size at most M. 

      But note: we are not forced to use the entire graph. We only need k edges.

      We can do:

          Traverse the graph and form connected subgraphs greedily: 

          Start with an arbitrary edge: that's a connected subgraph of size 1. Then we can add adjacent edges? But we want to form a connected subgraph. 

          Actually, we can do a BFS and when we have collected s edges (s<=M) for the current subgraph, we break and start a new one? But the problem: if we break arbitrarily, the next edge we pick might not be adjacent to any edge we haven't colored? But we are free to skip edges? 

      Alternatively, we can use a DFS and assign edges to the current subgraph until we hit M edges, then start a new one. But the subgraph must be connected. 

      However, there is a known technique: we can use an Euler Tour? But we are dealing with an undirected graph.

      Another idea: we can use a spanning tree and then break the tree into subtrees? But the non-tree edges? 

      We know: the entire graph has m edges. We can break the graph into connected components? But we only need k edges.

      We can try to form connected subgraphs of size 1? Then we have as many as we want. But then the total number of connected subgraphs we need is k (each of size 1). Then we require that we have k colors with capacity at least 1. But what if we have a color with capacity 0? Then we cannot use it. 

      But note: the capacities a_c: we are given m integers a_1,...,a_m. And the sum of a_c is <= m. And we need k edges. But if we use single edges, we need k colors with a_c>=1. 

      How many colors have a_c>=1? Let x = number of colors with a_c>=1. Then if x>=k, we can assign k single edges to k distinct colors (each with capacity>=1). 

      But is that valid? Each single edge is a connected subgraph. Then we assign each single edge to a distinct color. Then we have covered k edges. 

      Therefore, if x>=k, we can do that.

      But what if x<k? Then we cannot use k single edges. We have to use some larger connected subgraphs. 

      However, we can use a mix: some connected subgraphs of size more than 1. 

      But note: we have the constraint that the entire set of capacities: the sum of a_c is <= m. And we need k edges. 

      Also, the number of connected subgraphs we form must be at least the number of colors we use. And the number of colors we use is the number of connected subgraphs. 

      We are free to choose which edges to color. We only require the colored edges to be partitioned into connected subgraphs, each of size at most M (which is the maximum capacity, but note: we have capacities that are small).

      Actually, we don't need to form large connected subgraphs: we can form as large as the capacity allows. 

      How to assign? 

          We are going to assign the connected subgraphs to the colors. We can assign a connected subgraph of size s to a color c if a_c >= s.

          We want the total number of edges covered to be at least k.

          We can sort the capacities in descending order: let b[0] >= b[1] >= ... >= b[m-1]. 

          Then we want to form a set of connected subgraphs (edge-disjoint) such that the total size is at least k and the i-th largest connected subgraph has size at most b[i] (or we can assign arbitrarily? we can assign the largest subgraph to the largest capacity). 

          Actually, we can assign arbitrarily: we are free to assign any subgraph to any color as long as the capacity is sufficient.

          Therefore, we need to form a set of connected subgraphs (each size at most M) such that the total size is at least k and the multiset of sizes {s1, s2, ...} can be assigned to the capacities: that is, we can assign each subgraph to a distinct color c such that s_i <= a_c.

          This is equivalent to: the multiset of sizes {s1, s2, ...} is dominated by the multiset of capacities (if we sort both in non-decreasing order, then for each i, s_i <= a_i)? Actually, we can assign arbitrarily: we can assign the smallest subgraph to the smallest capacity that can take it? But it's easier: we can sort the subgraph sizes in descending order and the capacities in descending order, and then for each i, we require that the i-th largest subgraph has size <= the i-th largest capacity.

          Why? Because we want to assign the largest subgraph to a capacity that is at least as large, then the next largest to the next largest capacity, etc. This is the greedy assignment: it is necessary and sufficient that the largest capacity is at least the largest subgraph, the second largest capacity is at least the second largest subgraph, and so on.

      Therefore, we need to form a set of connected subgraphs (edge-disjoint) such that if we sort the sizes (s1>=s2>=...) and we sort the capacities (b0>=b1>=...), then for every i, s_i <= b_i.

      And the total sum of s_i is at least k.

      How to form such subgraphs? 

          We want to maximize the total number of edges we cover? Actually, we only need at least k. But we also have to satisfy the domination condition.

          We can try to form the set of connected subgraphs as follows:

            We know that the entire graph is connected. We can break it into connected subgraphs by a DFS/BFS that collects edges until the current subgraph has reached the maximum allowed by the next available capacity? But we don't know the capacities in advance? 

          Alternatively, we can use the entire set of edges? But then we have one connected subgraph of size m, and we require the largest capacity to be at least m. But that is not the case (M < k, and k <= ceil(n/2) <= n-1, but m can be large).

      Actually, we can form the connected subgraphs arbitrarily. We can use the following greedy:

          Sort the capacities in descending order: b[0], b[1], ... , b[t-1] (we only consider colors that we use? actually, we can ignore colors with capacity 0). But note: we are going to form subgraphs only for the non-zero capacities? 

          However, we can also skip some colors: we don't have to use all colors. We only need to form a set of subgraphs that can be assigned to the capacities (with the domination condition) and the total edges is at least k.

          How to form the connected subgraphs? 

          We can traverse the edges in any order? But we need the subgraphs to be connected. 

          Idea: we can start by building a spanning tree. Then we break the tree into subtrees? 

          Specifically, we can use the following known fact: a tree can be partitioned into subtrees such that the sizes of the subtrees are at least 1 and at most M, and the number of subtrees is minimized? Actually, we want to control the sizes so that the multiset of sizes is dominated by the capacities.

          Alternatively, we can use the entire graph? But we can break the graph arbitrarily? 

          However, note: we are free to skip edges. We only need k edges. So we can be greedy: 

            We start with an empty set of subgraphs.
            We traverse the edges in an arbitrary order. For each edge, if we can add it to the current subgraph without exceeding the capacity limit (which we haven't fixed yet) and maintaining connectivity, we do. But we don't know the capacity for the current subgraph? 

          Actually, we are forming the subgraphs arbitrarily. We want the sizes of the subgraphs to be as large as possible? To minimize the number? But we have to satisfy the domination condition: the i-th largest subgraph must be <= the i-th largest capacity.

          Therefore, we should form the largest possible connected subgraph that does not exceed the largest capacity? Then the next largest that does not exceed the next largest capacity, etc.

          But note: we are constrained by the graph structure: we can only use edges that are connected.

          How? 

            Step 1: sort the capacities in descending order: b[0] >= b[1] >= ... >= b[p] (we ignore zeros). Let p = number of non-zero capacities? Actually, we can include zeros? But we cannot use a color with capacity 0. So we ignore them.

            Step 2: We want to form connected subgraphs: 
                Let i=0.
                While we haven't covered k edges and i < p (number of non-zero capacities) and there are edges left:
                    We form a connected subgraph of size at most b[i] (the current capacity) and as large as possible (but at most b[i]). We take a connected subgraph that is as large as possible but not exceeding b[i]. 

                How to form a connected subgraph of size at most X? 

                    We can start from an arbitrary unused edge. Then we do a BFS from that edge? But we are constrained to at most X edges. We can do a BFS that collects up to X edges? But we want to maximize the size? Then we can take a connected component of the remaining graph? But we are allowed to skip edges arbitrarily? 

                    Actually, we are free to choose any connected subgraph from the remaining edges? But we want one that is as large as possible and at most X. 

                    However, the entire remaining graph might be disconnected? 

                    We can do:

                       Pick an unused edge. Then we start a BFS from that edge: we consider the entire graph (only unused edges) and we traverse the graph until we have collected X edges? Then we stop. 

                    Then we assign that set of edges to the current capacity. 

                Step 3: Then we mark those edges as used and move to the next capacity.

            Step 4: If we have collected at least k edges, then we output Yes and the coloring. Otherwise, we output No.

          But is this optimal? We are forming the largest possible connected subgraph for the current capacity. Then we use the next capacity for the next largest. This will minimize the number of edges we cover? Actually, we are covering as many as we can per subgraph.

          However, we might cover more edges if we use a different strategy? But note: we are constrained by the capacities: the largest capacity can take at most b[0] edges. Then the next at most b[1] edges, etc. 

          But the problem: we are not forced to use the largest capacity first? We can assign a small subgraph to a large capacity? But that would be wasteful. So we should use the large capacities for large subgraphs.

          Therefore, the greedy of forming the largest possible connected subgraph for the largest capacity is natural.

          But how to form a connected subgraph of size at most X that is as large as possible? 

            We can do a BFS starting from an arbitrary unused edge. Then we traverse the graph (using only unused edges) and we stop when we have collected X edges. Then we have a connected subgraph? But note: we start from one edge and then we add adjacent edges. Then the set of edges we collect is connected? 

            However, if we start from an edge and then we add an adjacent edge, then the two edges share a vertex -> connected. Then we add an edge adjacent to any edge we already have? Then it remains connected. 

            But we can also use edges that are not adjacent? Then we break connectivity. So we must only add edges that are adjacent to the current subgraph? 

            We maintain a set of vertices that are in the current subgraph. Initially, the edge (u,v) gives us vertices u and v. Then we look for an unused edge that has at least one endpoint in the current vertex set? Then we add that edge. Then we update the vertex set. 

            This is the typical BFS for graph traversal. 

            Algorithm for one subgraph for capacity X:

                Let Q be a queue of vertices (initially empty).
                We pick an arbitrary unused edge (u0, v0). We mark it as used. We add both u0 and v0 to the set and also to the queue? Actually, we can start by adding one vertex? 

                Alternatively, we can do:

                    Let S = set of edges (initially empty).
                    We need to start: pick an unused edge e0 = (u0, v0). Add e0 to S. Then mark e0 as used. Then add u0 and v0 to the queue.

                    Then while the queue is not empty and |S| < X:
                         Pop a vertex w from the queue.
                         For each neighbor x of w such that the edge (w,x) is unused and |S| < X:
                             Mark the edge (w,x) as used and add it to S.
                             If x is not in the vertex set, add x to the queue and to the vertex set.

                    Then we have a connected subgraph S.

                But note: this might not be maximal? Because we are doing BFS from the initial vertex set. But we are constrained to X edges. We stop at X.

          Then we move to the next capacity.

          Then we do this for each capacity in descending order.

          Then we count the total number of edges covered. If it is at least k, we output Yes. Otherwise, No.

          Then we output the coloring: for each connected subgraph we formed for capacity b_i, we assign all edges in that subgraph to the color corresponding to b_i. But note: there might be multiple colors with the same capacity? Then we must assign to a distinct color. 

          How to assign the color index? 

              We have the list of capacities: a_1, a_2, ..., a_m. We ignore the ones with 0. 

              Then we sort the non-zero capacities in descending order. Then we form the subgraphs in that order. Then we assign the i-th largest capacity (which we used) to a specific color index that has that capacity? But note: there might be multiple colors with the same capacity. 

              We can do:

                  Precompute: for each distinct capacity, we keep a list of color indices that have that capacity.

                  Then when we form a subgraph of size s, we pick a color index from the list of capacities that are >= s? But we want to use the largest capacities first? 

                  Actually, we are processing the capacities in descending order. So for the current capacity b_i, we have a list of colors that have capacity b_i. We can pick any color from that list. Then we remove that color from the list.

              Then for the output: for each edge, we know which subgraph it belongs to. Then we know the color index we assigned to that subgraph. Then we output that color index for the edge, and 0 for edges that are not colored.

          But note: we might form a subgraph of size s that is less than or equal to b_i, but we are using a color that has capacity b_i (which is >= s). 

          However, we are using the largest capacities first. We form a subgraph as large as possible (up to b_i). 

          Therefore, the algorithm for the case M<k is:

            Step 1: k = ceil(n/2)
            Step 2: Let M = max(a_c). If M>=k, then we use the one-color method above.

            Step 3: Otherwise, M < k.

                Step 3.1: Create a list of non-zero capacities, and sort in descending order. Let this list be B = [b0, b1, ... , b_{p-1}], where p is the number of non-zero capacities.

                Step 3.2: Initialize:
                    total_edges_covered = 0
                    used = array of booleans for edges (initially false)

                Step 3.3: We also maintain a queue for BFS (for the current subgraph) and a set of vertices that are in the current subgraph? Actually, for each subgraph we start fresh.

                Step 3.4: For each capacity b in B (in descending order) and while total_edges_covered < k and there are unused edges:

                    If b==0, skip.

                    Start a new subgraph for this capacity b:

                      Find an unused edge to start: we can iterate over the edges until we find an unused one? But the total n+m is 300000, so we can do.

                      Then do a BFS (as described) to form a connected subgraph of at most b edges. We stop when we have collected b edges OR we run out of adjacent unused edges? Actually, we stop when we have collected b edges, because we don't want to exceed b.

                      Let s = number of edges in the current subgraph.

                      Then total_edges_covered += s.

                      Then we assign this subgraph to a color that has capacity at least s. But we are processing capacities in descending order. We are at capacity b, and s<=b. We can pick any color that has capacity b? But note: we might have a color with capacity greater than b? But we are processing from largest to smallest. We want to assign the current subgraph to a color that has capacity at least s. But we have a list of capacities. How to assign the color index?

                      We can do: we maintain for each distinct capacity value, a list of color indices that have that capacity and haven't been used.

                      Then we pick a color index from the list of capacities that are at least s? But we want to use the one with capacity as small as possible? Actually, we can use any. But we are processing the large capacities first. We have already used some large capacities. 

                      Alternatively, we can assign the current subgraph to a color that has capacity exactly b? Because we are processing b. But note: we might have multiple colors with the same b. So we can pick one of them.

                      Then we remove that color index from the list for capacity b.

                Step 3.5: After processing all capacities in B (or we have covered k edges), check: if total_edges_covered >= k, then output Yes and the coloring. Otherwise, output No.

          But note: we might run out of unused edges before we cover k edges? Then we output No.

          Also, we might use all capacities (all non-zero) and still not cover k edges? Then output No.

          Therefore, we have:

            if M>=k: 
                find a connected subgraph with k edges (by building a spanning tree and taking the first k edges in BFS order)
                assign it to a color with capacity>=k (pick one)
                output the coloring: the chosen edges get that color, others 0.

            else: // M < k
                Sort non-zero capacities in descending order: B
                total = 0
                used[] = {false} for each edge
                color_assignment = array of 0's for each edge (meaning uncolored)

                // Precompute: for each capacity value, the list of color indices that have that capacity and haven't been used.
                capacity_map: a map from capacity value to list of color indices.

                For each capacity b in B (in descending order) and while total < k and there exists an unused edge:
                    // Start a new subgraph for capacity b
                    s = 0
                    // Find the first unused edge to start
                    start_edge = any unused edge? We can maintain an index for the next unused edge? But we are going to traverse arbitrarily.

                    Actually, we can iterate over all edges to find an unused edge? But the total m is bounded (by the total m over test cases is bounded by 300000) so we can do:

                    But we need to do BFS on the unused edges. We maintain:

                         a queue for vertices? Actually, we start with an edge, then we have two vertices.

                    We do:

                         Pick an unused edge (u0, v0). Mark it as used and add to the current subgraph. s = 1.
                         Let Q = deque([u0, v0])
                         Let visited_vertices = set([u0, v0])

                         While s < b and Q is not empty and total < k? (actually, we are only building one subgraph of at most b edges) and we haven't exceeded b:
                              pop a vertex u from Q.
                              For each neighbor v of u (in the entire graph) such that the edge (u,v) is unused and s < b:
                                  Mark edge (u,v) as used, add it to the current subgraph, s++.
                                  If v is not in visited_vertices, then add v to visited_vertices and push v to Q.

                    But note: we are traversing the entire graph? And we are checking all neighbors? 

                    However, we are only concerned with unused edges. We can precompute the graph structure? 

                    But the graph is fixed. We have the entire graph stored.

                    But note: the total over test cases of n and m is 300000. So we can store the graph per test case? But the constraint: the sum of n and m over test cases is 300000. So we can store the graph for each test case? 

                    Actually, the problem says: the sum of (n_i + m_i) for all test cases is <=300000. So the total number of vertices and edges we have to store is 300000. Therefore, we can store the entire graph for each test case? 

                    But note: the input also has the array a of size m. The total m over test cases is the sum of m_i, which is part of the 300000? 

                    Since the total of (n_i+m_i) is 300000, then the total m_i over test cases is at most 300000. Similarly, the total n_i is at most 300000.

                    Therefore, we can do:

                      Precompute for the current test case: 
                         n, m, the graph (adjacency list) for the n vertices? But note: we have m edges. We can build an array for the edges? and an adjacency list: for each vertex, a list of edges (or just the neighbor and the edge index).

                    Then in the BFS for one subgraph, we traverse the neighbors of a vertex. The total work over the entire test case is O(n_i+m_i). 

                    Then we assign the current subgraph (of size s) to a color:

                         We pick a color index from the list capacity_map[b] (but note: we are using capacity b, but we might have multiple colors with capacity b). However, we want to use one of them. But what if the current subgraph has size s, and we have a color with capacity b (which is >= s). Then we can assign it.

                         But we are processing the capacity b. We have a list for capacity b: we pop a color index from that list.

                         Then for every edge in the current subgraph, we set color_assignment[edge_index] = that color index.

                    Then total += s.

                Then, if total>=k: output Yes and the color_assignment for each edge (for edge i, output the color_assignment[i] or 0 if not assigned? Actually, we only assigned the edges we colored. The rest are 0? 

                But note: we did not assign an edge that we did not pick? Then they are 0.

                Otherwise, output No.

          However, there is a catch: we might have skipped some edges? But that is fine.

          But note: we are forming the subgraphs one by one. We stop when we have covered k edges? Actually, we break the loop when total>=k? Or we continue until we use all capacities? 

          We can break early: if we have already covered k edges, we can stop. 

          Also, we might have more capacities: we can skip them.

          Therefore, the algorithm for the case M<k.

But note: the worst-case: we have to iterate over all edges? The total m per test case can be up to 300000? But the total over test cases is 300000, so the entire algorithm runs in O(300000). 

But what if we have many test cases? The total (n_i+m_i) is 300000, so the worst-case number of test cases is 100000? But each test case has at least n_i>=2 and m_i>=n_i-1, so n_i+m_i>=3. Then the maximum number of test cases is 100000.

But the algorithm for the case M<k: we are going to iterate over the capacities (which are at most m_i per test case? but the total over test cases of m_i is bounded by 300000) and for each capacity we do a BFS that collects at most b edges? 

However, the total work per test case: we traverse each edge at most once (because we mark them as used). So the entire BFS for all subgraphs in one test case is O(m_i). 

Therefore, the total work over all test cases is O(300000).

But note: the capacities for one test case: we have m_i capacities. We only consider non-zero capacities. Then we sort them: but the total m_i over test cases is 300000, so the total time for sorting over all test cases is O( sum(m_i * log(m_i)) )? But the sum of m_i is 300000. The worst-case is one test case: m_i=300000, then sorting takes O(300000*log(300000)) which is acceptable? But the problem says the total n_i+m_i is 300000. But note: the problem says "the sum of n and m over all test cases" is 300000. So the total m_i is at most 300000. Therefore, the total time for sorting over all test cases is O(300000*log(300000))? But worst-case we have 100000 test cases? Then each test case has m_i=3? Then we sort 100000 arrays of size 3? Then total time is 100000 * O(3*log(3)) = O(300000). 

Therefore, the entire algorithm is efficient.

But what if we have no non-zero capacities? Then we cannot color any edge. Then if k>0, we output No.

Therefore, we have:

  k = ceil(n/2)
  M = max(a_c)

  if M>=k:
      // Case 1: use one color
      Build a spanning tree (BFS tree) of the graph.
      Then traverse the tree in BFS order and pick the first k edges. 
      Then assign all these k edges to a color c that has a_c>=k (choose one arbitrarily, say the first color index with a_c>=k).
      For each edge i:
          if the edge is in the set of k edges, then output the chosen color index for this edge.
          else, output 0.

  else:
      // Case 2: M < k
      Let B = sorted list of non-zero capacities in descending order.

      If the length of B is 0: then we have no color to assign -> if k>0 then output No.

      total_edges = 0
      used = boolean array of size m (edges) -> false
      color_assignment = array of m zeros.

      // Precompute an array for the next unused edge? We can iterate by index? But we have to start BFS from an edge. We can have a pointer to the next unused edge? 

      Let next_edge_index = 0   (we have edges indexed 0 to m-1)

      // Precompute the graph: we need an adjacency list for each vertex: for each vertex, a list of (neighbor, edge_index)

      adj = array of lists of size n+1
      For i from 0 to m-1:
          edge i: (u, v)
          add (v, i) to adj[u]
          add (u, i) to adj[v]

      // We also precompute a map: capacity_map: for each capacity value, the list of color indices that have that capacity and are not used.
      cap_map = {}
      For color_index from 1 to m:
          c = a[color_index-1]   // because the a array is 0-indexed for the m colors? 
          if c>0:
              if c not in cap_map, cap_map[c] = []
              cap_map[c].append(color_index)

      But note: we are going to process the capacities in descending order. And we might have multiple colors with the same capacity. Then we can use a list for each capacity.

      However, we sorted B in descending order. Then we iterate over B:

          For a capacity b in B:
              // Check if there is any color left for capacity b? 
              But note: we might have used all colors of capacity b? Then we skip? Actually, we have cap_map: we can check if cap_map has b and the list for b is non-empty.

          So:

          For each b in B (in descending order) and while total_edges < k and there exists at least one unused edge:

              // If there is no color left for capacity b, skip to next b? 
              if b not in cap_map or cap_map[b] is empty, skip.

              // Else, pick a color from cap_map[b]: 
                  color_index = cap_map[b].pop()

              // Now, we want to form a connected subgraph of at most b edges.

              // Find an unused edge: we can start from the next_edge_index. 
                  while next_edge_index < m and used[next_edge_index] is True:
                      next_edge_index++

                  if next_edge_index == m: break   // no more edges

              Let start_edge = next_edge_index, and the edge (u0, v0) = the edge at index next_edge_index.

              Mark used[start_edge] = True.

              We initialize:
                 Q = deque([u0, v0])
                 visited_vertices = set([u0, v0])
                 current_edges = [start_edge]   // we don't really need the list, we just assign the color_index to the edge and count.
                 s = 1

              Then we assign color_assignment[start_edge] = color_index.

              Then while s < b and Q is not empty:
                  u = Q.popleft()
                  For each (v, edge_id) in adj[u]:
                      if used[edge_id]: continue
                      if s == b: break the inner loop   // we cannot take more than b
                      // Else, we use this edge.
                      used[edge_id] = True
                      color_assignment[edge_id] = color_index
                      s++ 
                      total_edges++   // but note: we count this edge
                      if v not in visited_vertices:
                         visited_vertices.add(v)
                         Q.append(v)

              Then we set total_edges += s? Actually, we already incremented total_edges by 1 for the start_edge and then for each additional edge we did s++ and total_edges++. 

              Actually, we did: 
                  start_edge: s=1, then we set color_assignment, and we set used, and then we did not increment total_edges? 

              Correction: we did not increment total_edges for the start_edge? 

              We should do:

                  total_edges starts at 0.

                  When we pick the start_edge: we set used, and we set color_assignment, then we do s=1, and then we set total_edges += 1.

                  Then for each additional edge: we do total_edges++ when we assign it.

              But then we are counting each edge as we assign.

          Then we move to the next capacity.

      After the loop, if total_edges >= k: output "Yes" and the color_assignment array (for each edge, output the color_index assigned or 0 if not assigned? Actually, we only assigned edges that we colored. The others are 0? But we initialized color_assignment to 0, and we assigned only the ones we colored. So we output the list of color_assignment for each edge.

      Else: output "No".

But note: we did not account for the start_edge in the total_edges? We did:

      total_edges starts at 0.
      We pick the start_edge: we set total_edges += 1? Actually, we did not. 

      We should set: 
          total_edges++ when we assign the start_edge.

      Then for each additional edge in the BFS, we do total_edges++.

      Therefore, the total_edges is the number of edges we colored.

But wait: we break the BFS when we have collected b edges? Then we set s= number of edges in the subgraph. Then we can do total_edges += s? 

Actually, we can avoid incrementing total_edges in the inner loop: we can set total_edges += s at the end? 

Alternatively, we can do:

      s = 1   (for the start_edge) -> then we set total_edges += 1 at the start.

      Then for each new edge we add: we do s++ and total_edges++.

      Then we break when s==b.

But then we break the inner BFS when s==b.

But note: we also break when the queue is empty? Then we have collected all connected edges? Then we break.

      Then we move to the next capacity.

This algorithm for the BFS for one subgraph: we start at the start_edge, then we traverse the graph from the two endpoints. We traverse the unused edges adjacent to the current vertex set. We stop when we have collected b edges.

But note: we are only traversing edges that are incident to the current vertex set. This is standard BFS.

But what if the start_edge is isolated? Then we have no adjacent edges? Then we get a subgraph of size 1.

This is acceptable.

Therefore, the entire solution:

  Read C.
  For each test case:
      Read n, m.
      k = ceil(n/2) = (n+1)//2   (if n is even: n/2, if odd: (n+1)//2)

      Read list a[1..m]  (we will index from 0 to m-1 for the array)

      Read m edges.

      M = max(a)   (if the array is empty, then M=0)

      if M>=k:
          // Case 1
          Build a graph (for the entire graph) and then build a spanning tree (using BFS). We get a tree with n-1 edges.

          Then we do a BFS on the tree: we want to collect the first k edges. How? 
              We start at a root (say vertex 0). 
              We create an array for the tree: parent and children? Actually, we can do a BFS and record the order of edges.

          Actually, we can do:

              Build an array for the tree: we know the edges of the tree. Then we build an adjacency list for the tree.

              Then we do a BFS starting from an arbitrary vertex (say 0). We maintain:

                  order_edges = []   // the list of edges in BFS order
                  Q = deque([0])
                  visited = [False]*n, visited[0]=True.

                  Then while Q:
                      u = Q.popleft()
                      For each neighbor v of u in the tree:
                         if not visited[v]:
                            visited[v]=True
                            add the edge (u,v) to order_edges
                            Q.append(v)

              Then we take the first k edges from order_edges.

          But note: the input edges are given arbitrarily. We need to know the index of the edge? 

          How to assign the color? 

              We need to assign the same color to these k edges. We choose a color c that has a_c>=k. We can choose the first color index i (from 0 to m-1) such that a[i]>=k.

          Then we create an array res of length m (for the m edges) initially 0.

          For each edge index j in the set of k edges (we have to know the index j of the edge in the input), we set res[j] = i+1? (because color indices are 1..m, and we chose the color index = i+1? But we have the array a: the i-th color is a_i. We want the color index = the position? Actually, the problem: the i-th edge in the input should be assigned c_i.

          We are going to output m integers: for the j-th edge (0-indexed) we output the color we assign.

          How do we know the index of the edge? 

             In the BFS tree, we recorded the edge (u,v). But we don't know the input index. 

          We can do: when building the graph, for each edge, we store the input index.

          Steps:

            graph = [[] for _ in range(n)]
            For i in range(m):
                u, v = edge i (0-indexed vertices? the input vertices are 1-indexed, so subtract 1)
                graph[u-1].append((v-1, i))
                graph[v-1].append((u-1, i))

            Then when building the spanning tree, we use a BFS that records the edge index.

          Alternatively, we can build the spanning tree and then for each edge in the tree, we know the index? 

          We do:

            tree_edges = []   # the list of edge indices that are in the spanning tree? Actually, we don't need the entire tree? We only need k edges.

            We do a BFS that collects edges until we have k edges? But we need to form a connected subgraph? We can do:

                visited = [False]*n
                Q = deque()
                start = 0
                visited[0]=True
                Q.append(0)
                edges_used = []   # list of edge indices we use
                while Q and len(edges_used) < k:
                    u = Q.popleft()
                    for (v, idx) in graph[u]:
                        if not visited[v]:
                            visited[v]=True
                            edges_used.append(idx)
                            Q.append(v)
                            if len(edges_used)==k:
                                break
                    # end for
                # end while

            Then we have k edges: edges_used.

            Then we choose a color: 
                for i in range(m):
                    if a[i] >= k:
                        chosen_color = i+1
                        break

            Then we create res = [0]*m
            for idx in edges_used:
                res[idx] = chosen_color

            Then output:
                "Yes"
                then the list res (m integers)

      else:   // M < k
          // Case 2: use multiple colors

          Step 1: Precompute the graph (adjacency list with edge indices) as above.

          Step 2: Create an array used of m booleans, all False.
          Step 3: Precompute cap_map: 
                cap_map = {}
                for i in range(m):   # i from 0 to m-1, color index i+1
                    cap = a[i]
                    if cap>0:
                         if cap not in cap_map: cap_map[cap]=[]
                         cap_map[cap].append(i+1)   # store the color index (which is i+1)

          Step 4: Sort the non-zero capacities in descending order: 
                B = sorted([cap for cap in cap_map.keys()], reverse=True)

          Step 5: total_edges = 0
          Step 6: next_edge_index = 0   (to find the next unused edge)
          Step 7: res = [0] * m   # for each edge, the color (0 by default)

          Step 8: We create a queue for the BFS (for one subgraph) and a set for visited vertices? Actually, we do BFS per subgraph.

          For each b in B:
                if total_edges>=k: break

                if b not in cap_map or len(cap_map[b])==0: 
                    continue

                # Get a color for this capacity b:
                color_index = cap_map[b].pop()

                # Find the next unused edge:
                while next_edge_index < m and used[next_edge_index]:
                    next_edge_index += 1
                if next_edge_index == m: 
                    break   # no more edges

                start_edge_index = next_edge_index
                u0, v0 = edges[start_edge_index]   # note: edges[i] = (u_i, v_i) in the input? we stored the raw edges? 

                # We need the vertex indices? and we have stored the graph? Actually, we have the graph, but we can also store the edges as an array: edges[i] = (u, v) (0-indexed)

                # Mark the start edge as used and assign the color.
                used[start_edge_index] = True
                res[start_edge_index] = color_index
                total_edges += 1

                # Initialize the BFS for the current subgraph: 
                Q = deque()
                # We start at the two vertices of the start edge
                Q.append(u0)
                Q.append(v0)
                visited_vertices = set([u0, v0])

                s = 1   # we have one edge

                while s < b and Q:
                    u = Q.popleft()
                    for (v, edge_id) in graph[u]:
                        if used[edge_id]:
                            continue
                        # We found an unused edge incident to u? 
                        # But we are limited by b: we cannot exceed b edges in the subgraph.
                        if s == b:
                            break
                        # Use this edge
                        used[edge_id] = True
                        res[edge_id] = color_index
                        total_edges += 1
                        s += 1
                        # If we haven't visited v, then we add it to the BFS
                        if v not in visited_vertices:
                            visited_vertices.add(v)
                            Q.append(v)
                # End while for BFS for this subgraph

          # End for each b in B

          if total_edges >= k:
              Output "Yes"
              Output the list res (m integers)
          else:
              Output "No"

But note: the above BFS for the multiple-colors case: we are traversing the entire graph? But we are constrained by the capacity b: we break when we have collected b edges. Also, we break when the queue is empty.

  However, we are only traversing edges that are incident to the current vertex set. This is standard.

But what about an edge that is incident to the current vertex set but we have already used? We skip.

Therefore, the solution.

Let's test with the sample:

Sample Input 1:

4
5 4
4 0 0 0
2 3
2 1
4 5
4 3

n=5, m=4, k=ceil(5/2)=3.
a = [4,0,0,0] -> M=4>=3 -> Case 1.

Then we build a spanning tree? The graph has 4 edges. We build a spanning tree (which is the entire graph? since n=5, the tree has 4 edges). Then we do a BFS:

   Start at vertex 0 (if we map: 
        vertices: 1->0, 2->1, 3->2, 4->3, 5->4.

   Edges:
        edge0: (2,3) -> (1,2) -> in 0-indexed: (1,2)
        edge1: (2,1) -> (1,0)   [because 2->1, 1->0?] 
        edge2: (4,5) -> (3,4)
        edge3: (4,3) -> (3,2)

   We build the graph:

        graph[0]: [(1,1)]   # because edge1: (1,0) -> vertex0 (which is 1) to vertex1 (which is 2) -> but wait: the input vertex 1 is 0-indexed 0? 

        Actually, the input: 
            edge0: 2 3 -> u=2->1, v=3->2? 
            edge1: 2 1 -> u=2->1, v=1->0
            edge2: 4 5 -> u=4->3, v=5->4
            edge3: 4 3 -> u=4->3, v=3->2

        Then:

            vertex0: 1 -> has edge1: to vertex1 (which is 2) -> but wait: 
            vertex1: 2 -> has edges: edge0: to vertex2 (3), edge1: to vertex0 (1), edge3: to vertex3 (4) -> no, edge3 is (4,3) -> vertex3 (4) to vertex2 (3) -> so vertex2: 3 is connected to vertex1 (2) and vertex3 (4) and vertex4 (5) to vertex3 (4).

        Actually, the graph:

            vertex0 (1): connected to vertex1 (2) via edge1.
            vertex1 (2): connected to vertex0 (1) via edge1, to vertex2 (3) via edge0, to vertex3 (4) via edge3? 
            But edge3: (4,3) -> vertex3 (4) to vertex2 (3) -> so vertex2 (3): connected to vertex1 (2) via edge0, and to vertex3 (4) via edge3? 
            vertex3 (4): connected to vertex2 (3) via edge3, and to vertex4 (5) via edge2.
            vertex4 (5): connected to vertex3 (4) via edge2.

        Then the graph is connected.

        We build a spanning tree: we can choose any tree. For example, we choose:

            root=0 (vertex0:1)
            Then we add edge1: (0,1) -> so we have vertices 0 and 1.
            Then from vertex1, we add edge0: (1,2) -> so we have vertex2.
            Then from vertex1, we add edge3: (1,3) -> so we have vertex3.
            Then from vertex3, we add edge2: (3,4) -> so we have vertex4.

        Then the BFS order of edges: 
            edge1, edge0, edge3, edge2.

        We want k=3 edges: so we take the first 3: edge1, edge0, edge3.

        Then we assign them to a color with capacity>=3: we have a[0]=4, so we choose color1.

        Then the output for the edges:

            edge0: color1? -> but the first edge in the input is edge0: so the first output is 1.
            edge1: color1 -> second output: 1.
            edge2: not taken -> 0.
            edge3: color1 -> fourth output: 1? 

        But the sample output: "1 1 0 1"

        That is: 
            edge0: 1
            edge1: 1
            edge2: 0
            edge3: 1

        But we took edge0, edge1, edge3. The edge3 is the last edge? In the input, the edges are:

            edge0: (2,3)
            edge1: (2,1)
            edge2: (4,5)
            edge3: (4,3)

        So the output: 
            edge0: 1
            edge1: 1
            edge2: 0
            edge3: 1   -> "1 1 0 1"

        Matches.

Sample Input 2:

6 11
0 0 0 0 0 0 0 3 2 3 3
1 2
2 3
3 4
4 5
5 6
6 1
1 4
4 2
2 5
5 3
4 6

n=6, k=ceil(6/2)=3.

a = [0,0,0,0,0,0,0,3,2,3,3] -> M=3, which is >=3? So Case 1? 

But then we can use one color to cover 3 edges.

But the sample output: 
    "Yes"
    "8 11 10 10 9 8 8 11 9 10 11"

This uses multiple colors. Why?

Note: the problem: we only require to color at least ceil(n/2) edges. But the sample output uses 11 edges? Actually, no: the output has 11 numbers: 
    [8, 11, 10, 10, 9, 8, 8, 11, 9, 10, 11]

Which edges are colored? All of them? 

But the condition: for color 8: the edges colored 8: the first edge (index0) is 8, the sixth (index5) is 8, the seventh (index6) is 8 -> three edges. And they must form a connected subgraph? 

The edges: 
    edge0: (1,2)
    edge5: (6,1) -> vertex6 and vertex1
    edge6: (1,4) 

    The vertices: 1,2,6,4 -> connected? 
        edge0: 1-2
        edge5: 1-6
        edge6: 1-4 -> so all are connected to vertex1 -> connected.

For color 9: 
    edge4: 9? -> edge4: (5,6) -> but wait: 
    edge8: 9 -> edge8: (2,5) -> then we have two edges: (5,6) and (2,5) -> connected? 
        They share vertex5 -> connected.

For color 10:
    edge2:10, edge3:10, edge9:10 -> 
        edge2: (3,4)
        edge3: (4,5)
        edge9: (5,3) -> 
        vertices: 3,4,5 -> connected? 
            3-4, 4-5, 5-3 -> connected.

For color 11:
    edge1:11, edge7:11, edge10:11 -> 
        edge1: (2,3)
        edge7: (4,6) -> but wait, the edge7: the input edge7: (4,2) -> actually, the 8th edge? 
        The edges: 
            edge1: (2,3)
            edge7: (4,2) -> which is (2,4)? 
            edge10: (4,6) -> 
        Then vertices: 2,3,4,6 -> connected: 
            2-3, 2-4, 4-6.

So the coloring is valid.

But why did we not use Case 1? Because M=3>=3? Then we could have used one color to cover 3 edges? Then why the sample output used 11 edges? 

The problem: we are only required to color at least ceil(n/2)=3 edges. We can do with 3. But the problem does not require to maximize. 

However, the problem says: "if the answer is Yes, output a line containing m space-separated integers ...". And it says "if there are multiple possible answers, output any one of them".

So we can output a solution that colors only 3 edges? 

But the sample output colors 11 edges. Why? 

Because the sample input: 
    "6 11
     0 0 0 0 0 0 0 3 2 3 3"

Note: the capacities: 
    color8: a_8=3
    color9: a_9=2
    color10: a_10=3
    color11: a_11=3

and the others are 0.

But if we use Case 1: we only use one color (say color8) to color 3 edges. Then we leave the rest uncolored. That would be a valid solution: we have 3>=ceil(6/2)=3, and the set of edges of color8 is connected. 

But the sample output colored all edges? 

Why? The problem does not require to color as many as possible. It only requires at least 3. 

But the sample output: 
    "Yes
     8 11 10 10 9 8 8 11 9 10 11"

This uses 11 edges. 

So we can do either solution. The problem says "output any".

But our algorithm for Case 1 would output a solution with 3 edges. The sample output has 11. Both are valid.

However, the problem sample output is provided. So we must output a solution that matches? 

But the problem says "output any", so both are acceptable.

But the next sample input:

6 11
0 0 0 0 0 0 0 3 2 3 3
... same edges ...

and the output:

    "Yes
     11 11 11 0 0 0 0 0 0 0 0"

This uses color11 for the first three edges? 

But the condition: the three edges of color11 must be connected. The first three edges:

    edge0: (1,2)
    edge1: (2,3)
    edge2: (3,4)

They form a path: connected. 

So it is valid.

Therefore, our algorithm for Case 1 would work for the second and third sample? 

But the third sample input:

5 10
1 0 0 0 0 0 0 0 0 1
... edges ...

n=5, k=ceil(5/2)=3.

a = [1,0,0,0,0,0,0,0,0,1] -> M=1, which is <3 -> Case 2.

Then we sort non-zero capacities: [1,1] (descending: [1,1])

Then we form two subgraphs: 

   First capacity=1: we pick an unused edge (say the first one: (1,2)). Then we assign it to a color (say the first color with capacity1: which is color1? or the last? we have two: the first non-zero is at index0 and the last at index9.

   Then we form a subgraph of size 1: just that edge.

   Then we pick the next capacity=1: pick the next unused edge (say the second one: (2,3)). Then we assign it to a color (the other color with capacity1, say color10?).

   Then we have covered 2 edges, which is <3. Then we try to pick the next capacity? There are no more non-zero capacities. Then we output No.

But the sample output: "No"

Therefore, the solution.

But note: the sample input 2 and 3: both have the same graph and capacities? 

Sample input 2: 
    "6 11
     0 0 0 0 0 0 0 3 2 3 3"

Sample input 3:
    "6 11
     0 0 0 0 0 0 0 3 2 3 3"

But the outputs are different.

In the second sample input, our algorithm: 
   M=3>=3 -> Case 1: we can output a solution with 3 edges.

But the sample output for the second sample input is a solution with 11 edges. 

In the third sample input, the sample output: 
    "Yes
     11 11 11 0 0 0 0 0 0 0 0"

Which is a solution with 3 edges? Then why didn't we do Case 1 for the third sample input? 

But the third sample input is:

    "5 10
     1 0 0 0 0 0 0 0 0 1"

Then we did Case 2.

But the second and third sample inputs are different: one has n=6, m=11, and the other has n=5, m=10.

Therefore, our algorithm should work.

But note: the second sample input: 
    n=6, m=11, k=3, M=3 -> Case 1.

    Then we build a spanning tree (which has 5 edges) and then we take the first 3 edges in BFS order.

    Then we assign them to a color with capacity>=3: we have colors 8,10,11 with capacity>=3. We choose the first one: color8.

    Then we output: 
        For the first 3 edges in the BFS tree: what are they? 

        We build the graph: 
            vertices 0..5: 
            edges: 
                edge0: (0,1)  [1,2] -> 0,1
                edge1: (1,2)   [2,3] -> 1,2
                edge2: (2,3)   [3,4] -> 2,3
                edge3: (3,4)   [4,5] -> 3,4
                edge4: (4,5)   [5,6] -> 4,5
                edge5: (5,0)   [6,1] -> 5,0
                edge6: (0,3)   [1,4] -> 0,3
                edge7: (3,1)   [4,2] -> 3,1
                edge8: (1,4)   [2,5] -> 1,4
                edge9: (4,2)   [5,3] -> 4,2
                edge10: (3,5)  [4,6] -> 3,5

        We build a spanning tree: we choose arbitrarily. 

        Let's start from vertex0.

        Then we might pick:
            edge0: (0,1) -> add vertex1.
            edge5: (0,5) -> add vertex5.
            edge6: (0,3) -> add vertex3.

        Then from vertex1: 
            edge1: (1,2) -> add vertex2.
            edge7: (1,3) -> but vertex3 already visited? skip.
            edge8: (1,4) -> add vertex4.

        Then we have 5 edges: [edge0, edge5, edge6, edge1, edge8] in the tree.

        Then we take the first 3: edge0, edge5, edge6.

        Then the output: 
            edge0: color8? 
            edge5: color8
            edge6: color8
            the rest: 0.

        Then we output: 
            color8: 8, for the edges: edge0, edge5, edge6 -> the rest 0.

        But the sample output for the second sample is: 
            "8 11 10 10 9 8 8 11 9 10 11"

        But we output a different solution. 

        The problem: any valid solution is acceptable.

        We can output: 
            "8 8 8 0 0 0 0 0 0 0 0"   for the 11 edges? 

        Actually, we have 11 edges. We assign:
            edge0: 8
            edge1: 0
            edge2: 0
            edge3: 0
            edge4: 0
            edge5: 8
            edge6: 8
            edge7: 0
            edge8: 0
            edge9:0
            edge10:0

        But is the set of edges of color8 connected? 
            edge0: (0,1)
            edge5: (0,5)
            edge6: (0,3)
            The vertices: 0,1,5,3 -> connected? 
                They are all incident to vertex0 -> connected.

        Therefore, it is valid.

        So we can output either.

        However, the sample output is more complex. 

        But the problem says "any".

Therefore, we can output the simpler solution.

But note: the constraints: the total n+m over test cases is 300000. We have to be efficient.

We must code carefully.

But the problem: in Case 1, we build a spanning tree and then take the first k edges. 

But what if the graph has multiple connected components? The problem says the graph is connected.

Therefore, the solution.

Let me run the third sample input:

    "5 10
     1 0 0 0 0 0 0 0 0 1"

    n=5, k=3, M=1 -> Case 2.

    Then we form two subgraphs: 
        We have two non-zero capacities: [1,1] (sorted descending: [1,1])

        Start with capacity=1: pick an unused edge (say edge0). Then we form a subgraph: just that edge. Assign to a color (say the first color with capacity1: color1). Then total_edges=1.

        Then next capacity=1: pick an unused edge (say edge1). Then we form a subgraph: just that edge. Assign to a color (the next color with capacity1: color10). Then total_edges=2.

        Then we break the loop: but 2<3 -> then we output "No".

    The sample output: "No", so it matches.

Therefore, the solution.

But note: the sample input 2 and 3 are different: the second sample input has n=6, m=11, and the third has n=5, m=10.

We have to be cautious: the total n+m over test cases is 300000, so we can run.

One more: the first sample input: 
    "5 4
     4 0 0 0
     2 3
     2 1
     4 5
     4 3"

    We did: Case1 -> output "1 1 0 1"

    But the sample output: "Yes" and "1 1 0 1"

    So it matches.

Therefore, we output:

  For each test case:
      k = (n+1)//2
      M = max(a)  [if the list is empty, M=0]

      if M>=k:
          Build graph (with edge indices) for n nodes and m edges.
          Do a BFS to build a spanning tree and collect the first k edges (by BFS order) -> we get a list of edge indices: chosen_edges (size k)
          Choose a color index c such that a[c-1]>=k? Actually, we have the array a[0..m-1] for the m colors. We choose the smallest index i (0-indexed) such that a[i]>=k. Then the color is i+1.

          Then create an array res of m zeros.
          For each edge index in chosen_edges: set res[edge_index]= (i+1)

          Output "Yes"
          Output the list res (m integers)

      else:   # M<k
          Build graph (adjacency list with (neighbor, edge_index)) for n nodes and m edges.

          Precompute cap_map: for each capacity value (non-zero) -> list of color indices (which are the index+1) that have that capacity.

          Sort the non-zero capacities in descending order -> B.

          Initialize: 
              used = [False]*m   # for edges
              res = [0]*m
              total_edges = 0
              next_edge_index = 0

          For b in B:
              if total_edges>=k: break
              if b==0: continue   # but we skipped zeros? 
              if b not in cap_map or cap_map[b] is empty: continue

              color_index = cap_map[b].pop()

              # Find the next unused edge:
              while next_edge_index < m and used[next_edge_index]:
                  next_edge_index += 1
              if next_edge_index == m: break

              start_edge = next_edge_index
              u0 = edges[start_edge][0]-1   # if the input is 1-indexed, convert to 0-indexed? 
              v0 = edges[start_edge][1]-1
              # Mark and assign the start edge
              used[start_edge] = True
              res[start_edge] = color_index
              total_edges += 1

              # BFS for the current subgraph:
              Q = deque()
              Q.append(u0)
              Q.append(v0)
              visited_vertices = set([u0, v0])
              s = 1

              while s < b and Q:
                  u = Q.popleft()
                  for (v, eid) in graph[u]:
                      if used[eid]: 
                          continue
                      if s == b: 
                          break
                      # Use this edge
                      used[eid] = True
                      res[eid] = color_index
                      total_edges += 1
                      s += 1
                      if v not in visited_vertices:
                          visited_vertices.add(v)
                          Q.append(v)

          if total_edges>=k:
              Output "Yes"
              Output the list res
          else:
              Output "No"

But note: the input edges: we stored them as 1-indexed? Then when building the graph, we subtract 1. 

We must be consistent.

We assume the input vertices are 1-indexed. Then we subtract 1 to make 0-indexed.

Therefore, the solution.

Let me run the sample input 2 with n=6, m=11, and we do Case1? 

  We build the graph for 6 vertices (0..5) and 11 edges.

  Then we do a BFS starting from vertex0 (which is input vertex1) to build the tree and then take the first 3 edges.

  The edges in the BFS tree: we might get:

      Start at 0: 
          We look for edges incident to 0: 
            edge0: (0,1) -> to vertex1 -> not visited -> use edge0, mark vertex1 visited.
            edge5: (0,5) -> to vertex5 -> not visited -> use edge5.
            edge6: (0,3) -> to vertex3 -> not visited -> use edge6.

      Then we have 3 edges: [edge0, edge5, edge6]. Then we stop.

      Then we choose a color: the first color with a[i]>=3: 
          a = [0,0,0,0,0,0,0,3,2,3,3] -> the first non-zero that is>=3 is at index7 (the 8th color) -> color8 (index7: we add 1? no: we are iterating i from 0 to m-1, then color = i+1 -> 7+1=8).

      Then we set:
          res[0] = 8   (edge0)
          res[5] = 8   (edge5: the edge5 is the 6th edge? the edges are stored in the input order: 
                edge0:0, edge1:1, ... edge5:5, edge6:6, ... 
          res[6] = 8   (edge6)

      The rest are 0.

      Then output: 
          "Yes"
          "8 0 0 0 0 8 8 0 0 0 0"

      But the sample output is: 
          "8 11 10 10 9 8 8 11 9 10 11"

      But our solution is also valid.

Therefore, we output any.

But the problem: the sample output has 11 edges? Why did they use 11? 

  They used multiple colors: which we did in Case1? No, we did Case1 which uses one color and leaves the rest uncolored.

  The problem allows leaving edges uncolored. So our solution is valid.

  But the sample input has many non-zero capacities: so they chose to use more edges? 

  We are only required to color at least 3. 

  Therefore, our solution is acceptable.

We can output the solution with 3 edges.

But note: the problem sample output has 11 edges. The problem does not require to minimize the number of uncolored edges. 

Therefore, we are free.

But the problem: the total of n+m over test cases is 300000. Our algorithm for Case1: we do a BFS that builds a spanning tree and then we break at k edges: that is O(n+m). 

For Case2: we do a BFS that traverses each edge at most once: O(n+m). 

So the entire solution runs in O(300000).

We must code carefully to not exceed time and memory.

But note: we are storing the graph for each test case. The total n and m over test cases is 300000. So the total memory is O(300000). 

Therefore, we are safe.

Final code structure:

  import sys
  from collections import deque

  data = sys.stdin.read().split()
  t = int(data[0])
  index = 1
  out_lines = []

  for _ in range(t):
      n = int(data[index]); m = int(data[index+1]); index+=2
      # read a array: m integers
      a_list = list(map(int, data[index:index+m])); index += m
      edges = []
      graph = [[] for _ in range(n)]   # for n vertices (0-indexed)
      for i in range(m):
          u = int(data[index]); v = int(data[index+1]); index+=2
          edges.append((u, v))
          # convert to 0-indexed
          u0 = u-1; v0 = v-1
          graph[u0].append((v0, i))
          graph[v0].append((u0, i))

      k = (n+1)//2

      # Case 1: if there exists a capacity >= k
      M = max(a_list) if m>0 else 0
      if M >= k:
          # BFS to build a spanning tree and collect the first k edges (by BFS order)
          visited_vertex = [False]*n
          q = deque()
          q.append(0)
          visited_vertex[0] = True
          chosen_edges = []   # list of edge indices
          # We break when we have k edges.
          while q and len(chosen_edges) < k:
              u = q.popleft()
              for (v, eid) in graph[u]:
                  if not visited_vertex[v]:
                      visited_vertex[v] = True
                      chosen_edges.append(eid)
                      q.append(v)
                      if len(chosen_edges)==k:
                          break

          # Now, choose a color index: the first color i (0-indexed) such that a_list[i]>=k
          color_index = -1
          for i in range(m):
              if a_list[i] >= k:
                  color_index = i+1   # because color indices are 1..m
                  break

          # If we didn't find one? then it should be found because M>=k. 
          res_arr = [0]*m
          for eid in chosen_edges:
              res_arr[eid] = color_index

          out_lines.append("Yes")
          out_lines.append(" ".join(map(str, res_arr)))

      else:
          # Case 2: M < k
          # Precompute cap_map: for non-zero capacities
          cap_map = {}
          for i in range(m):
              cap = a_list[i]
              if cap > 0:
                  if cap not in cap_map:
                      cap_map[cap] = []
                  cap_map[cap].append(i+1)   # color index = i+1

          # Sort the capacities in descending order
          B = sorted(cap_map.keys(), reverse=True)

          used_edge = [False] * m
          res_arr = [0] * m
          total_edges = 0
          next_edge_index = 0

          # We need the edges in 0-indexed vertices? we have the graph already built with 0-indexed.
          # But we also have the list 'edges' which is 1-indexed? we don't use the content for the BFS? we use the graph.

          for b in B:
              if total_edges >= k:
                  break
              # If there is no color left for capacity b, skip
              if b not in cap_map or not cap_map[b]:
                  continue
              # Get a color for this capacity
              color_index = cap_map[b].pop()

              # Find the next unused edge
              while next_edge_index < m and used_edge[next_edge_index]:
                  next_edge_index += 1
              if next_edge_index == m:
                  break

              start_edge_index = next_edge_index
              u0, v0 = edges[start_edge_index]
              u0 -= 1
              v0 -= 1

              # Use this edge
              used_edge[start_edge_index] = True
              res_arr[start_edge_index] = color_index
              total_edges += 1

              # BFS for the current subgraph
              Q = deque()
              Q.append(u0)
              Q.append(v0)
              visited_vertices = set([u0, v0])
              s = 1   # we have one edge

              while s < b and Q:
                  u = Q.popleft()
                  for (v, eid) in graph[u]:
                      if used_edge[eid]:
                          continue
                      if s == b:
                          break
                      # Use this edge
                      used_edge[eid] = True
                      res_arr[eid] = color_index
                      total_edges += 1
                      s += 1
                      if v not in visited_vertices:
                          visited_vertices.add(v)
                          Q.append(v)

          if total_edges >= k:
              out_lines.append("Yes")
              out_lines.append(" ".join(map(str, res_arr)))
          else:
              out_lines.append("No")

  # Output all lines
  print("\n".join(out_lines))

But note: the total_edges in the BFS for Case2: we are counting the start_edge at the beginning, and then each new edge we count. And we break when s (the size of the current subgraph) reaches b.

We must be cautious: the graph might be disconnected? But the entire graph is connected. However, we are starting from an edge and then we traverse adjacent edges. But we might not cover the entire graph? But we are only collecting at most b edges. 

But if the entire graph is connected, we might collect a connected component? But we are constrained by b. 

But we are starting from an edge that is in the entire graph? Then we are only traversing the connected component that contains that edge? But the graph is connected. 

Therefore, we are safe.

But note: the graph might be disconnected? The problem says connected. 

Therefore, the solution.

Let me test with the sample input 2: 
    We do Case1? because M=3>=3? 

    So we output a solution with 3 edges.

    But the sample output for that test case is a solution with 11 edges. 

    The problem: any solution is acceptable.

    But the problem sample output is provided. The judge might have multiple answers.

    We output: 
        "Yes"
        and then a list of 11 integers: with three 8's and the rest 0.

    So it is valid.

Therefore, we output.

But note: the problem constraints: the total n and m over test cases is 300000. We are building the graph for each test case. The total n and m (vertices and edges) over test cases is 300000. So we are safe.

We hope it passes.

Note: the sample input 2: n=6, m=11 -> n+m=17, which is within the total 300000.

We run the entire sample input:

  4 test cases: 
      test1: n=5, m=4 -> 9
      test2: n=6, m=11 -> 17
      test3: n=6, m=11 -> 17
      test4: n=5, m=10 -> 15
      total = 9+17+17+15 = 58.

Then the algorithm runs.

We output:

   test1: "Yes" and "1 1 0 1"
   test2: "Yes" and a string of 11 integers: with three 8's and the rest 0? 
        But the first edge (edge0) is assigned 8? and edge5 (the sixth edge) and edge6 (the seventh) are 8? 
        So the list: 
            edge0:8, edge1:0, edge2:0, edge3:0, edge4:0, edge5:8, edge6:8, edge7:0, edge8:0, edge9:0, edge10:0
        -> "8 0 0 0 0 8 8 0 0 0 0"

   test3: same as test2? 
        But the sample input 3: 
            "6 11
             0 0 0 0 0 0 0 3 2 3 3"
            same as test2? 
        Then we do Case1: output a solution with 3 edges? 
        But the sample output for test3 is: 
            "Yes"
            "11 11 11 0 0 0 0 0 0 0 0"

        Why? 

        Actually, the problem sample input 3 is:

            "6 11
             0 0 0 0 0 0 0 3 2 3 3"

        and the same edges as test2.

        But our algorithm for test3: 
            n=6, k=3, M=3 -> Case1: we build a spanning tree and take the first 3 edges.

        How did the sample output get "11 11 11 0 0 0 0 0 0 0 0"? 

        They used the first three edges: edge0, edge1, edge2? and assigned color11 to them.

        Why didn't we do that? 

        In our BFS for the spanning tree, we started at vertex0 and we traversed the edges in the order they appear in the graph? 

        The graph for vertex0: 
            The edges incident to vertex0: 
                edge0: (0,1) -> vertex1
                edge5: (0,5) -> vertex5
                edge6: (0,3) -> vertex3

        Then we take the first three edges: edge0, edge5, edge6.

        But if we change the order of edges in the graph? 

        We built the graph by the input order? 

        For vertex0, the edges: 
            edge0: (0,1)
            edge5: (0,5)
            edge6: (0,3)

        Then the order: edge0, edge5, edge6.

        But if we change the order in the graph? 

        We built the graph by:

            for i in range(m):
                u0 = u-1; v0 = v-1
                graph[u0].append((v0, i))
                graph[v0].append((u0, i))

        The order for vertex0: we add edge0, then edge5, then edge6? 

        But the input edges: 
            edge0: (1,2) -> (0,1) -> so for vertex0: add (1,0) -> (1,0) -> (1,0) is stored in graph[0]? 
            edge1: (2,3) -> (1,2) -> stored in graph[1] and graph[2] -> not in graph[0]
            edge2: (3,4) -> (2,3) -> not for vertex0
            edge3: (4,5) -> (3,4) -> not
            edge4: (5,6) -> (4,5) -> not
            edge5: (6,1) -> (5,0) -> so for vertex0: add (5,5) -> (5,5) -> no: (6,1): 6->5, 1->0 -> so (0,5) -> so we store (5,5) in graph[0]? 

        Actually, we store (v0, eid). For edge5: (6,1) -> u=6->5, v=1->0 -> so we do:
            graph[5].append((0,5))   -> for vertex5: add (0,5)
            graph[0].append((5,5))   -> for vertex0: add (5,5)

        Then edge6: (1,4) -> u=1->0, v=4->3 -> so for vertex0: add (3,6) -> (v0=3, eid=6)

        Therefore, for vertex0: 
            edge0: (1,0) -> stored as (1,0) -> but wait: we stored (v0, eid) -> so we store (1,0) for graph[0]
            edge5: (5,5) for graph[0] -> but wait: edge5: we stored (5,5) for graph[0]? 
            edge6: (3,6) for graph[0]

        Then the list for graph[0]: 
            [ (1,0), (5,5), (3,6) ]

        Then we take the first edge: (1,0) -> edge0 -> then we add vertex1.
        Then the next: (5,5) -> edge5 -> then we add vertex5.
        Then the next: (3,6) -> edge6 -> then we add vertex3.

        So the chosen_edges = [0,5,6]

        Then we output: 
            edge0:8, edge5:8, edge6:8, others 0.

        But if we want to output the first three edges as 11, we would have to choose edge0, edge1, edge2. 

        How to get that? 

        We can change the BFS: we start at vertex0, but we want to pick edge0, then from vertex1 we pick edge1, then from vertex2 we pick edge2? 

        But the BFS from vertex0: 
            We start at vertex0, then we consider edges in the order they are stored in graph[0]. 
            Then we pick edge0: go to vertex1. 
            Then from vertex0, we also have edge5 and edge6? But we have not visited vertex1, then we go to vertex1 and then from vertex1 we look at its edges. 

        The BFS queue: 
            Initially: [0]
            Then we pop 0: 
                We look at edges: 
                    (1,0): vertex1 -> not visited -> use edge0, then push 1.
                    (5,5): vertex5 -> not visited -> use edge5, then push 5.
                    (3,6): vertex3 -> not visited -> use edge6, then push 3.
                Then the queue: [1,5,3]

            Then we break because we have 3 edges.

        So we never use edge1.

        How to get edge1? 

        We would need to go from vertex1 to vertex2. But we never get to vertex1 in the BFS? 

        Actually, we do: after processing vertex0, we process vertex1. But we break when we have 3 edges. 

        So we only use the edges incident to vertex0.

        Therefore, we get the three edges incident to vertex0.

        To get a chain: we would have to use a DFS? 

        But the problem: we can use any connected subgraph of k edges.

        The three edges incident to vertex0 form a star: connected.

        So it is valid.

        Therefore, the output is as we have.

        If we want to get a chain that is the first three edges in the input, we could change the BFS to use a different order? 

        But the problem does not require a particular solution.

        Therefore, we output.

   test4: "No"

Therefore, the output for the sample:

    Yes
    1 1 0 1
    Yes
    8 0 0 0 0 8 8 0 0 0 0
    Yes
    8 0 0 0 0 8 8 0 0 0 0   [but the sample expected: "11 11 11 0 0 0 0 0 0 0 0" for the third test case?]

But the sample input 3 is the same as input 2? 

    The problem sample input:

        4
        5 4
        4 0 0 0
        2 3
        2 1
        4 5
        4 3
        6 11
        0 0 0 0 0 0 0 3 2 3 3
        1 2
        2 3
        3 4
        4 5
        5 6
        6 1
        1 4
        4 2
        2 5
        5 3
        4 6
        6 11
        0 0 0 0 0 0 0 3 2 3 3
        1 2
        2 3
        3 4
        4 5
        5 6
        6 1
        1 4
        4 2
        2 5
        5 3
        4 6
        5 10
        1 0 0 0 0 0 0 0 0 1
        1 2
        2 3
        3 4
        4 5
        5 1
        1 3
        3 5
        5 2
        2 4
        4 1

    The third test case: 
        "6 11
         0 0 0 0 0 0 0 3 2 3 3"

        and the edges are the same as the second test case.

    So our output for the third test case is the same as the second.

    But the sample output for the third test case is: 
        "Yes
         11 11 11 0 0 0 0 0 0 0 0"

    Why? 

    They are both Case1: so we output a solution with 3 edges. 

    The problem: any solution is acceptable.

    Therefore, the judge will accept our solution.

    But the problem sample output is provided. So if we want to match the sample output exactly, we would have to use the first three edges? 

    How? 

        In the BFS for the spanning tree: we can change the order in which we traverse the edges? 

        Currently, we store the graph as an adjacency list: for each vertex, the list of (neighbor, edge_id) in the order of the input.

        Then when we do BFS, we iterate over the list in that order.

        To get the first three input edges: we would have to pick edge0, edge1, edge2.

        How? 

            We start at vertex0. The edges incident to vertex0: 
                We see edge0: (0,1) -> then we go to vertex1.
                Then from vertex1: 
                    The edges: 
                         edge0: to vertex0 (visited)
                         edge1: to vertex2 (not visited) -> use edge1 -> then we go to vertex2.
                    Then from vertex2: 
                         edge1: to vertex1 (visited)
                         edge2: to vertex3 (not visited) -> use edge2.

            Then we have three edges: [0,1,2].

            Then we output: 
                res[0]=color, res[1]=color, res[2]=color, others 0.

            Then we output: 
                color for edge0, edge1, edge2: and 0 for others.

            For the second test case: 
                color: we choose the first color with capacity>=3: that is color8 (the 8th color, index7: so 8).

            Then: 
                edge0:8, edge1:8, edge2:8, others 0.

            That gives: "8 8 8 0 0 0 0 0 0 0 0"

        But the sample output for the third test case is: "11 11 11 0 0 0 0 0 0 0 0"

        Why 11? 

        Because they chose color11? 

        How? 

            We are choosing the first color that has capacity>=3. The first one is color8 (which is at index7). 

            But if we choose the last one? 

            The problem: we can choose any.

            So we can choose color11? 

            How? 

                In the for loop:

                    for i in range(m):
                        if a_list[i]>=k: 
                            color_index = i+1
                            break

                This picks the first.

            If we pick the last? 

                for i in range(m-1, -1, -1):
                    if a_list[i]>=k: 
                        color_index = i+1
                        break

            Then for the second test case: we would pick the last color that is>=3: which is color11 (index10: 10+1=11).

            Then the output: 
                "11 11 11 0 0 0 0 0 0 0 0"

            for the second test case? 

            But the second test case: we output for the second test case: 
                "Yes"
                "11 11 11 0 0 0 0 0 0 0 0"

            Then the third test case is the same, so the same output.

        Therefore, to match the sample output, we can choose the last eligible color.

        The problem: any color is acceptable.

        So we can change the selection of the color in Case1: 

            Instead of the first, we choose the last.

        Then the second test case: we choose color11 -> then the output: 
            edge0, edge1, edge2:11 -> "11 11 11 0 0 0 0 0 0 0 0"

        But note: for the first test case: 
            k=3, we choose the last color with capacity>=3: 
                a_list = [4,0,0,0] -> 
                    i=0:4>=3 -> eligible, but we are scanning backwards? 
                    i=3:0 -> skip
                    i=2:0 -> skip
                    i=1:0 -> skip
                    i=0:4 -> choose color1? 
                Then the output: "1 1 0 1"

            which matches.

        The third test case: same as second: "11 11 11 0 0 0 0 0 0 0 0"

        The fourth test case: "No"

        Then we match the sample output.

        Therefore, we change the selection in Case1 to pick the last eligible color.

        Code change:

            # Instead of:
            #   for i in range(m):
            #       if a_list[i]>=k: 
            #           color_index = i+1
            #           break

            # Do:
            color_index = 0
            for i in range(m-1, -1, -1):
                if a_list[i] >= k:
                    color_index = i+1
                    break

        But note: if we don't find one? then M>=k must hold, so we should find one.

        But to be safe, we can do:

            color_index = 0
            for i in reversed(range(m)):
                if a_list[i] >= k:
                    color_index = i+1
                    break

        Then we use that.

        Then the second test case: we pick i=10 (because a_list[10]=3>=3) -> color_index=11.

        Then we assign the three edges to 11.

        Then the output for the second test case: "11 11 11 0 0 0 0 0 0 0 0" -> but wait, we assign only the three chosen edges to 11. Which edges? 

            We did BFS and we chose the first three edges? 

            In the BFS, we chose edge0, edge5, edge6? 

            Then we output: 
                edge0:11, edge5:11, edge6:11, others 0.

            That gives: 
                [11, 0, 0, 0, 0, 11, 11, 0, 0, 0, 0]

            but the sample output: 
                "8 11 10 10 9 8 8 11 9 10 11"

            is different.

        But the problem: we are free to choose any set of k edges that is connected.

        We chose a star. The sample output chose a chain? 

        How to get the chain? 

            We did BFS starting at vertex0. The chain we got was the star. 

            To get the chain of the first three edges: 
                We start at vertex0, then we go to vertex1 (edge0), then from vertex1 we go to vertex2 (edge1), then from vertex2 we go to vertex3 (edge2). 

            How to force that? 

            We can change the BFS to traverse the edges in the order of the input? 

            But currently, the graph is built by the input order? 

            For vertex0: the edges are stored in the order: 
                edge0: (0,1)
                edge5: (0,5)
                edge6: (0,3)

            For vertex1: 
                edge0: (0,1) 
                edge1: (1,2)
                edge7: (1,3)   # which is edge7: (4,2) -> but wait, (4,2) is stored for vertex3? 

            Actually, the input edge1: (2,3) -> not incident to vertex1? 

            The input edge1: (2,3) -> vertex1: no, vertex1 is 2? 

            The input: 
                edge0: (1,2) -> (0,1)
                edge1: (2,3) -> (1,2)

            So for vertex1 (which is the input vertex2): 
                edge0: to vertex0 -> (0,0) -> stored as (0,0) in graph[1]
                edge1: to vertex2 -> (2,1) -> stored as (2,1) in graph[1]
                edge7: (4,2) -> (3,1) -> stored as (3,7) in graph[1]? 

            Then when we are at vertex1, we consider the edges in the order: 
                (0,0): to vertex0 (visited) -> skip.
                (2,1): to vertex2 (not visited) -> then we use edge1.

            Then we go to vertex2.

            Then at vertex2: 
                edge1: to vertex1 (visited)
                edge2: (3,4) -> to vertex3 -> (3,2) -> store in graph[2]: (3,2) -> then we use edge2.

            So we get: edge0, edge1, edge2.

            Then we output: 
                edge0:11, edge1:11, edge2:11, others 0.

            That gives: 
                "11 11 11 0 0 0 0 0 0 0 0"

            which matches the sample output for the third test case.

        How to force the BFS to consider the edges in the order of the input? 

            We stored the graph in the order of the input. Then for each vertex, the list of (neighbor, eid) is in the order we added.

            Then the BFS: 
                We start at vertex0: we consider the edges in the order: 
                    (1,0): vertex1 -> not visited: we use edge0 and go to vertex1.
                Then at the queue: [1]
                Then we pop vertex1: we consider the edges in the order: 
                    (0,0): visited -> skip.
                    (2,1): not visited: use edge1, go to vertex2.
                Then at the queue: [2]
                Then we pop vertex2: 
                    (1,1): visited -> skip.
                    (3,2): not visited: use edge2, go to vertex3.

                Then we have three edges: [0,1,2].

            Therefore, we get the first three input edges.

        So the BFS we implemented naturally uses the order of the graph's adjacency list, which is the input order.

        Why did we get the star in the second test case? 

            Because for vertex0, the incident edges are stored in the order: 
                edge0: (0,1) -> to vertex1 -> not visited: take it.
                edge5: (0,5) -> to vertex5 -> not visited: take it.
                edge6: (0,3) -> to vertex3 -> not visited: take it.

            Then we stop.

            But we want to avoid taking the star if we want the chain? 

            Actually, the problem does not require any particular set. 

            But if we want to get a chain, we would have to do a BFS that does not jump to another branch until the current branch is exhausted? That is DFS? 

        However, the BFS as implemented: 

            It uses a queue: 
                We start at 0.
                We visit 0 and push its neighbors: 1,5,3 (in the order of the edges) -> so the queue becomes [1,5,3].
                Then we would process 1, then 5, then 3.

            But we only take three edges: we break after the first three.

        How to get a chain? 

            We want to take edge0, then from the new vertex1, we take the next edge.

            We can change the BFS to a DFS? 

            But the problem: any connected subgraph is acceptable.

            The star is connected.

        Therefore, we don't have to change.

        But the sample output for the second test case: 
            "8 11 10 10 9 8 8 11 9 10 11"

        is a solution that uses more than 3 edges.

        And we are in Case1, which only uses 3 edges.

        The problem: we only require at least 3.

        So both are valid.

        However, the sample output has 11 edges. How did they do it? 

        They used multiple colors: which is Case2? But they are in Case1.

        Actually, the sample output for the second test case is not produced by our Case1. 

        Therefore, if we want to match the sample output exactly, we might have to use Case2 for the second test case? 

        But wait: the second test case: M=3>=3, so we use Case1.

        How did the sample output for the second test case use 11 edges? 

        They used multiple colors: so they must have done Case2.

        Why? 

        Because they did not have a color with capacity>=11? 

        But they did: they used colors 8,9,10,11, and the capacities are 3,2,3,3. 

        And they assigned 3 edges to color8, 2 to color9, 3 to color10, 3 to color11 -> total 11.

        But our algorithm: we see M=3>=3, so we use Case1.

        Therefore, we cannot produce that solution in Case1.

        The problem: the sample output for the second test case is not in Case1? 

        Why did they not use Case1? 

        They might have an algorithm that only uses Case1 if one color can cover the entire set of edges they use? But they used 11 edges, and no single color can cover 11 (since the maximum capacity is 3). 

        But the requirement: we only require to cover at least 3 edges. 

        So they could have used Case1 to cover only 3 edges.

        But they chose to cover more.

        Our algorithm for Case1 only covers 3 edges.

        How to cover more? 

        We are not restricted to one color? We can also use more colors? 

        But the problem: if we are in Case1, we have the option to use one color and cover k edges. We are not forced to use only one color. We could also use multiple colors to cover more. 

        But the problem: output any valid coloring with at least k edges.

        We have two valid solutions: 
            Solution A: Case1: cover 3 edges with one color.
            Solution B: Case2: cover 11 edges with 4 colors.

        The problem: we can output either.

        Since the sample output for the second test case is Solution B, and for the third test case is a variant of Solution A (with a chain and the last color), we have the freedom.

        But our algorithm: 
            For the second test case: we see M>=k -> we do Case1.

            For the third test case: we see M>=k -> we do Case1.

        Then we output two solutions with 3 edges.

        The problem: the sample output for the second test case is 11 edges and for the third is 3 edges.

        Why did they do differently for the same input? 

        The sample input has two test cases with the same input? 

        The problem sample input: 
            The second test case: 
                "6 11
                 0 0 0 0 0 0 0 3 2 3 3"
                ... edges ...
            The third test case:
                "6 11
                 0 0 0 0 0 0 0 3 2 3 3"
                ... same edges ...

        Then the same input twice.

        And the sample output: 
            "Yes"
            "8 11 10 10 9 8 8 11 9 10 11"
            "Yes"
            "11 11 11 0 0 0 0 0 0 0 0"

        So they output two different solutions for the same input.

        Therefore, we are free to output any.

        We output for both test cases: 
            for the second: 
                "Yes"
                "11 11 11 0 0 0 0 0 0 0 0"   (because we choose the last color in Case1, and a BFS that yields the first three input edges)

            for the third: the same.

        But the sample output for the second test case is different.

        We can also, if we want, do Case2 for the second test case? 

        But our algorithm: 
            if M>=k, we do Case1.

        How to also consider Case2? 

        We are not required to maximize the number of edges. 

        Therefore, we output.

Given the complexity and the constraints, we output the solution as described.

We hope it passes.

Note: the total sum of n and m is 300000, so we are efficient.

We'll output the code accordingly.

But note: the sample input might have the same test case twice. We treat them independently.

Therefore, the final solution.

Let me recap the sample outputs we will produce for the provided sample input:

  Test case 1: 
        n=5, m=4, a=[4,0,0,0], edges = [ (2,3), (2,1), (4,5), (4,3) ]
        Case1: 
            k=3
            We build a spanning tree: 
                vertices: 0-indexed: 
                    2->1, 2->0, 4->3, 4->2? 
                But the graph: 
                    edge0: (2,3) -> (1,2) -> vertex1 and vertex2.
                    edge1: (2,1) -> (1,0) -> vertex1 and vertex0.
                    edge2: (4,5) -> (3,4) -> vertex3 and vertex4.
                    edge3: (4,3) -> (3,2) -> vertex3 and vertex2.

                The graph is connected.

                BFS starting from vertex0 (which is vertex1 of the input? or we start from vertex0 (which might be vertex1) but there is no vertex0? 

                We have vertices: 0,1,2,3,4.

                Let's map: 
                    input vertex1 -> 0
                    input vertex2 -> 1
                    input vertex3 -> 2
                    input vertex4 -> 3
                    input vertex5 -> 4

                Then edges:
                    edge0: (2,3) -> (1,2)
                    edge1: (2,1) -> (1,0)
                    edge2: (4,5) -> (3,4)
                    edge3: (4,3) -> (3,2)

                Then the graph for vertex0: 
                    incident edges: edge1: (0,1) -> to vertex1.

                Then from vertex0: 
                    use edge1 -> to vertex1.
                Then at vertex1: 
                    incident edges: 
                         edge1: (0,1) -> visited
                         edge0: (1,2) -> to vertex2 (not visited) -> use edge0.
                         edge3: (1,3) -> to vertex3? no: edge3 is (3,2) -> so for vertex1: no edge to vertex3? 
                    Actually, edge3: (3,2) -> stored in vertex2 and vertex3.

                Then from vertex1: 
                    use edge0 -> to vertex2.
                Then at vertex2: 
                    incident edges: 
                         edge0: (1,2) -> visited
                         edge3: (2,3) -> to vertex3 (not visited) -> use edge3.
                Then we have 3 edges: [1,0,3] (edge1, edge0, edge3).

                Then we choose a color: the last one with capacity>=3: 
                    a[0]=4 -> eligible, but we scan backwards: 
                    i=3: a[3]=0 -> skip
                    i=2:0 -> skip
                    i=1:0 -> skip
                    i=0:4 -> choose color1.

                Then res = [0]*4
                    res[1] = 1   (edge1 is the second edge? but wait: we have edge0, edge1, edge2, edge3)

                    We used edge1 (index1), edge0 (index0), edge3 (index3).

                So: 
                    edge0:1 (because we set res[0]=1? no: we set res[0] for edge0? 
                    Our chosen_edges: we stored the edge indices: [1,0,3] -> 
                    Then we set:
                         res[1] = 1
                         res[0] = 1
                         res[3] = 1
                    and res[2]=0.

                Then output: "1 1 0 1"

                which matches.

  Test case 2 and 3: 
        n=6, m=11, a=[0,0,0,0,0,0,0,3,2,3,3]

        We do Case1: 
            choose the last color with capacity>=3: 
                i=10: a[10]=3>=3 -> choose color11.

            Then BFS: 
                start at vertex0 (input vertex1) -> 
                edges incident to vertex0: 
                    edge0: to vertex1 (input vertex2) -> use edge0.
                    edge5: to vertex5 (input vertex6) -> use edge5.
                    edge6: to vertex3 (input vertex4) -> use edge6.

                Then we have three edges: [0,5,6] -> 
                res[0]=11, res[5]=11, res[6]=11, others 0.

                Then output: 
                    "11 0 0 0 0 11 11 0 0 0 0"

        But the sample output for the second test case is: 
            "8 11 10 10 9 8 8 11 9 10 11"

        and for the third: 
            "11 11 11 0 0 0 0 0 0 0 0"

        We output for the second: 
            "Yes"
            "11 0 0 0 0 11 11 0 0 0 0"

        for the third the same.

        But the judge will accept it.

  Test case 4: 
        n=5, m=10, a=[1,0,0,0,0,0,0,0,0,1] -> 
        Case2: 
            non-zero capacities: [1,1] -> B=[1,1] (descending: [1,1])
            total_edges=0, next_edge_index=0.
            b=1: 
                next unused edge: edge0 -> start_edge_index=0.
                u0=0, v0=1.
                Then we form a subgraph: only this edge.
                total_edges=1.
                Then assign to a color: from cap_map[1]: pop -> say the first: color_index = 1? 
                Then res[0]=1.
            b=1: 
                next unused edge: edge1.
                then res[1]=10? (because the other color is at index9: so 10)
                total_edges=2.
            Then done: 2<3 -> "No"

        Output: "No"

Therefore, the sample output we generate:

    Yes
    1 1 0 1
    Yes
    11 0 0 0 0 11 11 0 0 0 0
    Yes
    11 0 0 0 0 11 11 0 0 0 0
    No

But the expected sample output is:

    Yes
    1 1 0 1
    Yes
    8 11 10 10 9 8 8 11 9 10 11
    Yes
    11 11 11 0 0 0 0 0 0 0 0
    No

We can change the solution for the second test case to use a DFS in the spanning tree to get a chain? 

    In the BFS for the spanning tree for the second test case, if we want to get the first three input edges: 
        The first three input edges: 
            edge0: (1,2) -> (0,1)
            edge1: (2,3) -> (1,2)
            edge2: (3,4) -> (2,3)

        How to get them? 

        We start at vertex0 (input vertex1). The incident edges: 
            edge0: (0,1) -> use it -> to vertex1.
        Then at vertex1: 
            edge0: (0,1) -> visited.
            edge1: (1,2) -> use it -> to vertex2.
        Then at vertex2: 
            edge1: (1,2) -> visited.
            edge2: (2,3) -> use it -> to vertex3.

        Then we have three edges: [0,1,2].

        Then we assign: 
            res[0]=11, res[1]=11, res[2]=11, others 0.

        Then output: "11 11 11 0 0 0 0 0 0 0 0"

    This matches the sample output for the third test case.

    How to force the BFS to not take the other edges incident to vertex0 until later? 

        The BFS is breadth-first: it explores all edges at the same level. 

        To get a depth-first like behavior, we would need to use a stack.

        But the problem: any connected subgraph is acceptable. 

        We can change the BFS to DFS? 

        Specifically, we can change the queue to a stack.

        Then in the spanning tree DFS:

            visited_vertex = [False]*n
            stack = [0]
            visited_vertex[0]=True
            chosen_edges = []
            while stack and len(chosen_edges)<k:
                u = stack.pop()   # DFS: pop last
                for (v, eid) in graph[u]:
                    if not visited_vertex[v]:
                        visited_vertex[v]=True
                        chosen_edges.append(eid)
                        stack.append(v)   # and also push u? no, we push the new vertex.
                        if len(chosen_edges)==k:
                            break

            But note: we might not be able to get exactly the first three input edges.

        Alternatively, we can do:

            We want to get the first three input edges. The input edge0 is incident to vertex0 and vertex1.
            Then input edge1 is incident to vertex1 and vertex2.

            To include edge1, we must have visited vertex1.

            In DFS: 
                Start at 0.
                Then we look at the edges in the order: 
                    edge0: (0,1) -> not visited: use it, mark vertex1, and push vertex1.
                Then we pop vertex1: 
                    look at its edges: 
                         edge0: (0,1): visited.
                         edge1: (1,2): not visited: use it, mark vertex2, push vertex2.
                Then we pop vertex2: 
                    edge1: visited.
                    edge2: (2,3): not visited: use it.

                Then we have three edges: [0,1,2].

        Therefore, DFS will give the chain.

        BFS: 
            Start at 0: 
                edge0: use