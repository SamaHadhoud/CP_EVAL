 Okay, I see the problem. We are given up to 300,000 test cases, but the sum of n and m over all test cases is at most 300,000. This implies that most test cases are very small (like one or two nodes) or we have only one big test case? Actually, the problem states: "The sum of n and m over all test cases does not exceed 300 000". So we can have at most 300,000 in total for n and m? Actually, it says "the sum of n and m" meaning (n1+m1) + (n2+m2) + ... <= 300000? But that would be too small because a single test case can have n and m each up to 300000. 

Let me reread: "The sum of n and m over all test cases does not exceed 300 000". This must be a mistake? Because the constraints say: 
  1 <= C <= 300000
  n in [2, 300000], m in [n-1, 300000]

But then the total sum of n and m over test cases is only 300000? That would imply that the test cases are very small. Actually, the problem says: "the sum of n and m over all test cases" meaning the total of all n and all m? Or the total of (n+m) for each test case? 

Looking again: "the sum of n and m over all test cases" might be ambiguous. However, in competitive programming problems, it is common to say "the sum of [some variable] over all test cases". But note: the problem says "the sum of n and m", meaning for each test case we have two numbers? Then we sum all the n's and all the m's? 

Actually, the constraints also say: the total sum of m (the number of edges) over all test cases is at most 300000? But the problem says: "the sum of n and m over all test cases does not exceed 300 000". 

So, for example, if we have C test cases, then:
  total = (n1 + m1) + (n2 + m2) + ... + (nC + mC) <= 300000.

Therefore, each test case has n and m such that the sum of all n_i and all m_i is bounded by 300000. This implies that the total number of edges and vertices in all test cases is 300000. 

But note: in one test case, we have n and m. For example, a test case with n=2, m=1: then we contribute 2+1=3. 

Therefore, the entire input size is bounded by 300000, meaning that we can have at most about 100000 test cases? But C is at most 300000, but the total n+m is 300000, so the average test case is very small. Actually, the worst-case C is 300000, but then each test case would have (n+m) = 1 on average? But n>=2. 

This is confusing. Let me check the constraints again: 
  C: number of test cases, 1<=C<=300000
  for each test case: n>=2, m>=n-1, and n, m <= 300000.

But then the sum of n and m over all test cases is <=300000? This is impossible because if C=300000, then even if each test case has n=2 and m=1 (the smallest possible), then the total n+m would be 300000 * (2+1) = 900000, which is more than 300000.

Alternatively, the problem might mean: the total n over all test cases and total m over all test cases are each at most 300000? But that would be more reasonable. However, the problem says: "the sum of n and m over all test cases" (without commas). 

Looking at the sample: 
  First test case: n=5, m=4 -> total 9
  Second: n=6, m=11 -> total 17
  Third: n=6, m=11 -> total 17
  Fourth: n=5, m=10 -> total 15
  Total: 9+17+17+15 = 58.

But 58 is less than 300000, so it's possible that the total n+m over test cases is bounded by 300000. 

But then how can the constraints for n and m in a test case be up to 300000? Then one test case alone would have 600000? which is more than 300000? 

Therefore, I think the problem statement might have a typo. Actually, the constraints say: 
  "The sum of n and m over all test cases does not exceed 300 000"

But if one test case can have n=300000 and m=300000, then that alone is 600000. 

Alternatively, the intended meaning is: the total number of vertices over all test cases is at most 300000? and the total number of edges over all test cases is at most 300000? 

But the problem says "the sum of n and m", meaning for each test case we add n_i and m_i, and the sum of these numbers is <=300000? 

That would force the test cases to be very small. For example, if we have 1000 test cases, then the average (n_i+m_i) is 300, so each test case is small.

Given that the sample has 4 test cases and the total n+m is 58, and 58<=300000, and 300000 is a big bound, it seems plausible that the total n+m over test cases is 300000.

Therefore, we can have up to 300000 test cases, but each test case is very small (like n+m=1 on average? but n>=2, so that's not possible). Actually, the minimal n is 2 and minimal m is 1 (for n=2: m>=1). So minimal n+m=3. Then the maximum number of test cases is 300000/3 = 100000. But C<=300000, so we must have C at most 100000? 

Alternatively, the problem meant: the total number of vertices over test cases is at most 300000 and the total number of edges over test cases is at most 300000? 

This is a common constraint. Let me assume that. Because the problem says: "the sum of n and m" but if we interpret that as the total number of vertices and edges (counting each vertex and edge in the entire input), then:

For vertices: each test case has n_i vertices. The total number of distinct vertices? But no, because the graphs are separate. Actually, the input describes separate test cases. So we have:

  Total_vertices = sum_i n_i <= 300000?
  Total_edges = sum_i m_i <= 300000?

But note: the problem says "the sum of n and m", which is ambiguous. However, in the constraints, it says "the sum of n and m over all test cases does not exceed 300 000". 

Alternatively, it might be: the sum of (n_i + m_i) for all test cases is at most 300000. Then:

  total = sum_{test cases} (n_i + m_i) <= 300000.

This is the same as: 
  (n1+m1) + (n2+m2) + ... <= 300000.

Then, we can only have test cases with small n and m. For example, if we have 100000 test cases, each test case must have n_i+m_i <= 3 on average. The minimal is 3 (n=2, m=1). So 100000 test cases would be 300000. Then C can be up to 100000? But the problem says C<=300000. 

However, if the minimal per test case is 3, then with total 300000 we can have at most 100000 test cases. Therefore, C is bounded by 100000? 

But the constraint says 1<=C<=300000. This is inconsistent.

After re‐examining: the problem says: "the sum of n and m over all test cases does not exceed 300 000". 

I think the intended meaning is: the total number of vertices in all test cases (i.e., the sum of all n_i) and the total number of edges in all test cases (the sum of all m_i) are each at most 300000. 

But note: the problem says "the sum of n and m", not "the sum of the n's and the sum of the m's". 

However, in competitive programming, constraints like "the total number of vertices over all test cases is at most X" are common. And 300000 is a typical bound. 

Given the confusion, I look at the sample: 
  Test case 1: n1=5, m1=4 -> total n:5, total m:4.
  Test case 2: n2=6, m2=11 -> total n:5+6=11, total m:4+11=15.
  Test case 3: n3=6, m3=11 -> total n:17, total m:26.
  Test case 4: n4=5, m4=10 -> total n:22, total m:36.

So the total n is 22 and total m is 36? and 22+36=58, which is <=300000. 

But if we have 300000 test cases, then the total n and m would be the sum of n_i and m_i. But the constraint says the sum of (n_i+m_i) for all test cases is <=300000? Then in the sample we have 5+4+6+11+6+11+5+10 = 58. 

So I think the constraint is: 
  Let S = (n1 + m1) + (n2 + m2) + ... + (nC + mC) <= 300000.

Then, we can iterate over test cases and for each test case, we process a graph with n_i nodes and m_i edges, and the total S is bounded.

With that, we can design a solution that runs in O(n_i + m_i) per test case, and the overall complexity is O(S) = O(300000).

Now, what is the problem? 

We need to decide if we can color at least ceil(n/2) edges such that:
  - Each color c has at most a_c edges.
  - For each color c, the edges of that color form a connected subgraph (meaning the subgraph induced by the color is connected).

Note: the colors are from 1 to m, and we have m edges. But we don't have to use all colors? We can leave edges uncolored (then we output 0 for that edge).

Important: the condition on the coloring: 
  - The entire set of edges of color c must form a connected subgraph. But note: the subgraph is defined by the edges of color c and the vertices incident to them. And it must be connected.

We are also given an array a[1..m] of the capacities for each color.

Additionally, we have the constraint: the total sum of a_i is at most m (which is the number of edges in the graph).

We must output:
  "Yes" and then a coloring for the edges (each edge assigned a color in [0, m] meaning 0 for uncolored) if we have at least ceil(n/2) colored edges, and "No" otherwise.

How to approach?

Observations:

1. Since the entire graph is connected, we have a spanning tree. But note: we don't need to color all edges.

2. The condition for each color class: must be connected. This is similar to partitioning the colored edges into connected components per color. However, note that an edge can be colored with one color only.

3. We are free to assign any color to an edge as long as the color class is connected and we don't exceed a_c for color c.

4. The goal is to have at least ceil(n/2) colored edges.

But note: the minimal requirement is ceil(n/2). Since the graph has n nodes, we know that a spanning tree has n-1 edges. Therefore, if we color n-1 edges (the entire spanning tree) then we have n-1 which is at least ceil(n/2) for n>=2? 
  For n=2: ceil(2/2)=1, and n-1=1 -> yes.
  For n=3: ceil(3/2)=2, and n-1=2 -> yes.
  For n=4: ceil(4/2)=2, and n-1=3 -> yes.

But we don't have to color the entire spanning tree? Actually, we only need ceil(n/2) edges. So we can leave many edges uncolored.

However, we are constrained by the capacities a_c. Also, each color class must be connected.

Idea: We note that the condition on the color classes (each being connected) is very strong. In particular, if we use k colors, then we have k connected components of edges (each color class is connected). But note: these k components might share vertices? Yes, they can. 

But each color class is a set of edges that forms a connected subgraph. However, the entire set of colored edges might form a disconnected graph? Actually, no constraint on the entire colored set: only per color.

So we can have multiple colors used on the same connected component of the graph? Actually, no: the entire graph is connected, but we are coloring edges arbitrarily. The condition is only per color: the edges of color 1 form a connected subgraph, the edges of color 2 form a connected subgraph, etc. But these subgraphs can overlap arbitrarily in vertices.

However, note: if we have two colors, then the edges of color 1 form a connected subgraph (say covering vertices A) and the edges of color 2 form a connected subgraph (covering vertices B). The sets A and B might overlap.

But the problem: we need to assign colors to edges such that the set of edges of a fixed color forms a connected subgraph. 

How can we achieve this? One idea is to use a spanning tree. But note: we can use more than one color.

Alternative approach:

We note that we are only required to color ceil(n/2) edges. Since ceil(n/2) is about half the edges, we have a lot of flexibility.

But the capacities a_c might be small. Also, the condition that the sum of a_i <= m is important.

Another observation: if we can use one color that has a capacity at least ceil(n/2), then we can color a connected subgraph that has at least ceil(n/2) edges? But we need a connected subgraph with that many edges? However, the entire graph has n nodes, and the maximum connected subgraph we can form is the entire graph (which has n-1 edges). But n-1 might be less than ceil(n/2)? 
  For n=2: ceil(2/2)=1, and n-1=1 -> okay.
  For n=3: ceil(3/2)=2, n-1=2 -> okay.
  For n=4: ceil(4/2)=2, n-1=3 -> okay (we can pick 2 edges that form a connected subgraph? but two edges that are adjacent? yes, if we pick two edges that share a vertex, then the subgraph is connected? Actually, if we pick two edges that are incident to a common vertex, then the two edges form a star? then the subgraph is connected? Yes, because the set of vertices is the two endpoints of each edge and the common vertex? and they are connected via the common vertex.

But note: the condition is that the edges of color c form a connected subgraph. This is equivalent to: the graph (V_c, E_c) is connected. So if we take two edges that share a vertex, then V_c has 3 vertices and E_c has 2 edges: the graph is connected? Yes.

But if we take two edges that are disjoint? Then V_c has 4 vertices and E_c has 2 edges? Then the graph is disconnected? So we cannot assign the same color to two disjoint edges.

Therefore, the color classes must be connected: meaning that the edges of the same color must form a connected graph (in the sense of the graph induced by those edges).

So we can only assign the same color to a set of edges that are connected.

Therefore, the entire set of colored edges is partitioned into several connected components (each one being a color class). But note: one color class is one connected component? Actually, the color class is one connected component? Or the set of edges of one color may form a connected component that is not necessarily a connected component of the entire graph? It can be embedded arbitrarily in the graph.

How to assign colors? 

We note that the problem is challenging. However, the constraints on the capacities a_i are that they are nonnegative and the sum of a_i is at most m. Also, we have m colors (from 1 to m) but we don't have to use all.

But note: the capacities a_i are given for each color from 1 to m. And the coloring: we can assign an edge to color 0 (uncolored) or to a color in 1..m.

We are free to choose which edges to color and which colors to use.

We need at least ceil(n/2) colored edges.

Strategy:

1. Since we only need ceil(n/2) edges, we can leave many edges uncolored.

2. We note that if we use a color c, we can use at most a_c edges. Also, the edges of color c must form a connected subgraph. Therefore, the maximum number of edges we can use for color c is a_c, and we can only use a connected set of edges of size at most a_c.

3. How to assign? We can try to cover as many edges as possible by connected color classes.

But note: the entire graph is connected, and we can use multiple colors. The key is: we can assign different colors to different connected components? But wait: we are not forced to have the entire colored set connected. We can have one color class in one part of the graph and another color class in another. But each color class must be connected.

Therefore, we can break the graph arbitrarily into connected subgraphs and assign each connected subgraph to a color? But note: an edge cannot be split: we assign one color per edge.

However, the same vertex can be in multiple color classes? Yes, because an edge incident to the vertex might be colored with one color, and another edge incident to the same vertex might be colored with a different color.

But the condition for a color class: the set of edges of color c must form a connected graph. So if we have two edges incident to the same vertex but we assign them different colors, then each color class (if it has only one edge) is connected? Yes: one edge is a connected graph.

Therefore, we can assign each edge a distinct color? Then each color class has one edge (which is connected) and we use one color per edge. But then we have to satisfy: for color c, we can only assign at most a_c edges. But we have m colors, and we can assign each edge to a color for which a_c>=1? 

But note: the capacities: we are given a_1, a_2, ..., a_m. And we have m edges. The condition: we can assign each edge to a color c such that a_c>=1? But we have m colors, and the sum of a_i is <= m. Actually, the condition is: the total capacity is at most m. 

But if we use one color per edge, then we need at least ceil(n/2) colors that have a_c>=1? Actually, we can assign multiple edges to the same color as long as the color class is connected and the capacity is not exceeded. But if we assign each edge a distinct color, then we use one edge per color. Then the total number of colored edges is the number of colors we use. And we can only use a color c if a_c>=1. Therefore, the maximum number of edges we can color in this way is the number of colors c for which a_c>=1. 

But we are not forced to use distinct colors. We can use the same color for multiple edges as long as they form a connected set and the capacity is not exceeded.

But note: we are free to choose which edges to color and which colors to assign. 

So what is the maximum number of edges we can color? 

We know that the entire graph is connected. We can form one big color class: if we have a color c with a_c >= (number of edges we want to put in that class) and we can form a connected subgraph of that size? Then we can use that color for that entire connected set. Then we can use the remaining edges for other colors? 

But the problem is that we have multiple colors and capacities.

We can think greedily: we want to color as many edges as possible? Actually, we only need ceil(n/2). So we can try to color at least ceil(n/2) edges.

How?

We note that if we have a set of colors with positive capacities, we can use each such color for at least one edge (if we can form a connected component of one edge). But we can also use a color for multiple edges if we can form a connected set of edges of that color.

But the problem: we have to assign the colors arbitrarily to the edges such that the color classes are connected.

We can try the following:

  Step 1: Check if the total capacity (i.e., the sum of a_i) is at least ceil(n/2). Why? Because the total number of colored edges cannot exceed the total capacity. So if the total capacity is less than ceil(n/2), we output "No".

But wait: the condition is that the sum of a_i is at most m. And ceil(n/2) might be larger than the total capacity? Then we output "No".

But note: the total capacity is the sum of a_i, and we are only constrained by that. So:

  Condition 1: If sum(a_i) < ceil(n/2) -> then we cannot color ceil(n/2) edges? Actually, no: because we are constrained by the capacities: we cannot use color c more than a_c times. Therefore, the total number of colored edges is at most sum(a_i). So if that is less than ceil(n/2), we output "No".

But is that sufficient? 

  Condition 2: But even if the total capacity is enough, we must be able to partition the edges we choose (at least ceil(n/2) edges) into connected components such that the size of the component assigned to color c is at most a_c? 

But note: we are free to assign arbitrarily: we can assign one edge to a color and then that is one connected component (if the edge is taken alone). So if we can choose a set of edges of size ceil(n/2) that can be partitioned into connected components of size at most a_c for each color c? Actually, we don't have to assign one component per color? We can assign multiple components to the same color? 

Wait: the problem says: for each color c, the set of edges with color c must form a connected graph? Actually, no: the condition is:

  "Every pair of edges with color c is reachable from each other by only using edges with color c." 

This implies that the entire set of edges with color c must be connected. So we cannot assign two disconnected edges the same color. Therefore, each color class is one connected component.

Therefore, we have to partition the set of colored edges into connected components, and then assign each connected component to a color c that has capacity at least the size of the component (and then we use the color for that entire component). And we can use a color only once? Actually, no: we can use a color for one connected component? Because if we use a color for two different connected components, then the entire set of edges of that color is disconnected? So that is not allowed.

Therefore: each color can be used for at most one connected component? And the size of that component must be at most a_c.

Therefore, the problem reduces to:

  We wish to choose a set S of edges, with |S| >= ceil(n/2), and partition S into connected components (each connected in the graph induced by S? Actually, no: we are free to choose the set S arbitrarily? But the condition for a color class is that the edges of that color form a connected subgraph. However, if we assign a connected component of edges to a color, then that is a connected subgraph. But note: the entire set S might be disconnected? And we assign each connected component of the graph (S) to one color? Then we have one color per connected component.

But the condition: the edges of a color must form a connected subgraph. If we assign one connected component to one color, then that condition is satisfied. 

So the problem becomes:

  Find a set S of at least ceil(n/2) edges that can be partitioned into k connected components (each being a connected subgraph of the entire graph) and we have k colors (each used for one component) such that for each component of size s_i, there is a color c with a_c >= s_i (and we can assign that component to that color) and each color is used at most once.

But note: we are not forced to use each color only once? Actually, we can use a color only for one component? Why? Because if we use a color for two different components, then the entire set of edges of that color is the union of two disconnected sets -> not connected. So we cannot use the same color for two different components.

Therefore, we have:

  We need to partition S into k connected components: C1, C2, ..., Ck (each is connected) and we need k distinct colors (because each color can only be used once) such that for each component Ci, we have a color c (distinct) with a_c >= |Ci|.

But note: we are free to choose the set S arbitrarily? Actually, we are free to choose which edges to color, so we can choose S arbitrarily? But we are constrained by the graph.

Alternatively, we can choose S arbitrarily? Then we can choose any set of edges? Then we can choose a set S that is a forest? 

But the condition: the components are defined by the set S: the connected components of the graph (V, S). So if we choose a set S that is disconnected, we get multiple components.

How to assign? We need to assign each component to a distinct color c such that a_c >= |Ci|.

But note: we are allowed to leave edges uncolored, so we can choose S arbitrarily.

Therefore, the problem reduces to:

  Let T = ceil(n/2). 
  We wish to choose a set S of edges with |S|>=T, and partition it into connected components (which is natural: the connected components of the graph (V,S))? Actually, no: because we are free to choose S arbitrarily, but the graph (V,S) might not be connected? Then the connected components of (V,S) are the components we have. Then we assign each component to a distinct color that has capacity at least the number of edges in that component.

But note: we can choose any set S? Then the connected components of (V,S) are the components we have. Then we need to assign each component to a distinct color.

But then we require: for each component i, we have a distinct color c_i (that hasn't been used for another component) such that a_{c_i} >= |E_i|, where |E_i| is the number of edges in component i.

But we are free to choose the set S arbitrarily? Actually, no: because the graph is fixed. We can only choose a subset of the existing edges.

But we can choose any subset? Then we can form any forest? Actually, we can form any set S that is acyclic? Or even with cycles? But the condition: each connected component of (V,S) is a connected subgraph. There is no requirement that the entire set S is connected? Only per color class? But note: each color class is one connected component? So if we assign one connected component to one color, that is fine.

Therefore, the problem becomes:

  We wish to choose a set S of edges, |S|>=T, and we wish to partition S into connected components (which is forced by the graph: the connected components of the subgraph (V, S)). Then we need to assign each component i (with size s_i) to a distinct color c such that a_c >= s_i.

  But we are free to choose the set S arbitrarily? Actually, we are constrained by the graph: we can only choose edges that exist.

But note: the entire graph is connected, but we can choose any subset. 

Then, we need to check if there exists a set S (a subgraph) with at least T edges that can be partitioned (by the natural partition of the connected components) such that each component has size at most the capacity of some distinct color.

But how to check that? 

We note:

  The connected components of S form a partition of the edges in S. Let the sizes of the components be s_1, s_2, ..., s_k. Then we have:
      s_1 + s_2 + ... + s_k = |S| >= T.

  And we need to assign each s_i to a distinct color c such that a_c >= s_i.

This is equivalent to: we can cover the list of component sizes with the capacities? 

But note: we have k components and we have m colors. We can use any k distinct colors? Then we need to check: is there an assignment of the s_i to distinct colors such that for each component i, we assign a color c with a_c>=s_i.

This is a matching condition: we can sort the component sizes in non-increasing order: s_1>=s_2>=...>=s_k, and we sort the capacities in non-increasing order: b_1>=b_2>=...>=b_m (where we ignore colors with a_c=0? Actually, we can ignore colors with a_c=0 because we cannot use them). 

Then we require: k <= m (which it is, because m>=0, and k<=|S|<=m? but m is the number of edges and also the number of colors) and for all i, b_i >= s_i? 

But that is too strong: we don't require the i-th largest capacity to be at least the i-th largest component? Actually, we can assign any color to a component as long as the capacity is at least the size. So we want to know: can we assign each component to a color that has capacity at least the size of the component? 

This is a classic matching: we can assign the largest component to a color with capacity at least the largest component? Then the next largest to a remaining color with capacity at least the next, etc. 

But note: we have k components and we have m colors. We can use any k distinct colors. So the necessary and sufficient condition is: the largest component size must be <= the largest capacity, the next largest component size must be <= the next largest capacity, ...? 

Actually, we can use a greedy matching: 
  Sort the component sizes in decreasing order: s[0]>=s[1]>=...>=s[k-1]
  Sort the capacities in decreasing order: b[0]>=b[1]>=...>=b[m-1] (we have m capacities, but we only care about the top k? because we need k distinct colors).

  Then we can assign the largest component to a color with capacity at least s[0]. Then the next largest to a color with capacity at least s[1] (from the remaining colors), etc.

But we can do: 
  for i in range(k):
        if b[i] < s[i]:
            then we fail.

Why? Because we are matching the i-th largest component to the i-th largest capacity: if we assign the largest component to the largest capacity, the second largest to the second largest, etc., then we have the best chance. If this fails, then no assignment exists.

Therefore, we can solve the problem if we can choose a set S arbitrarily? But we are constrained by the graph: the set S must be a subset of edges of the graph, and the connected components of (V,S) must be such that the list of component sizes (s_1, s_2, ..., s_k) satisfies: when sorted decreasingly, we have s_i <= b_i for all i (where b is the capacities sorted decreasingly and we take the top k).

But note: we are free to choose S arbitrarily? Actually, no: the graph is fixed. We cannot create edges. But we can choose any subset of the existing edges.

But then the question is: can we form a set S with at least T edges such that when we look at the connected components of S, the list of component sizes (number of edges in the component) satisfies: 
   s_1 <= b_1, s_2 <= b_2, ..., s_k <= b_k   [where k = number of components, and b is the capacities sorted in decreasing order, and we take the first k largest capacities]

But note: we can choose S arbitrarily. Then we can design the set S arbitrarily? 

However, the graph is fixed. We are constrained by the connectivity: we can only use existing edges.

But note: the entire graph is connected, but we can choose any forest? Actually, we can even choose a set with cycles? But if we choose a cycle, then we have one component that has the entire cycle? Then the size is the number of edges in the cycle.

But the condition: we can form any set S? Then we can form any set of edges. Then we can design the components arbitrarily? 

But no: the components are determined by the edges we choose. We cannot arbitrarily decide the component structure. 

But note: we can form any forest? Actually, the graph is connected, but we can choose a disconnected set S. 

How to form S? 

We are free to pick any subset of edges. Then the connected components of (V,S) are fixed by the edges we choose.

But the problem: we wish to form a set S that has at least T edges, and then the multiset of the sizes (in terms of number of edges) of the components must satisfy: when sorted in decreasing order, s_i <= b_i for all i (where b_i are the capacities sorted decreasingly, and we take the top k capacities for k=number of components).

But note: the total number of components k = |V| - (|S| - c) ??? Actually, no: the number of components in a graph (V,S) is:
   c = |V| - rank(S) 
where rank(S) is the number of edges in a spanning forest of S? Actually, if we have a forest, then the number of components is |V| - |S|? 

But if there are cycles, then the number of components is |V| - (|S| - (number of cycles))? Actually, the number of connected components of the graph (V,S) is:
   comp = |V| - (|S| - cycles) ??? 

Actually, the formula: 
   comp = |V| - |S| + f, 
where f is the number of "face" components? Not exactly. 

Recall: for a graph with v vertices, e edges, and c connected components, we have:
   c = v - (e - (e - (v - c))) -> no.

Actually, for each connected component, if it has v_i vertices and e_i edges, then the number of connected components is the sum over components of 1, and we have:
   sum_i (v_i) = |V|
   sum_i (e_i) = |S|
   and for each component, we have: if the component is a tree: e_i = v_i - 1, if it has cycles: e_i >= v_i.

But we don't know the internal structure.

The key: we can choose S arbitrarily? Then we can choose S to be a forest? Why? Because if we avoid cycles, we get trees and we can control the component sizes.

But note: if we form cycles, we can have a component with more edges? 

But the condition: we only care about the number of edges per component. 

So what are the constraints on the component sizes? 

  For a connected component with v_i vertices, the minimum number of edges we can use is v_i-1 (a tree), and the maximum is the number of edges in the complete graph on v_i vertices? But we are constrained by the edges available in the graph.

But we are free to choose any subset? Then we can form any connected component that is a connected subgraph (with at least one edge) of the original graph.

Therefore, the set of possible component sizes (in terms of edges) for a connected component on a set of vertices is any integer between (v_i-1) and the number of edges in the induced subgraph.

But we don't know the induced subgraphs? 

Alternatively, we can try to form the set S by taking a forest? Then each component is a tree. Then the number of edges in the component is exactly v_i-1. 

But note: we can also form cycles? Then we can have more edges. But we are constrained: we need the component to be connected.

But the problem: we want to maximize the total number of edges? Actually, we only need T = ceil(n/2). 

But we also care about the distribution of component sizes: we want the component sizes to be as small as possible? Because we have to fit them under the capacities.

Observation: to make the components as small as possible (in terms of the number of edges) we should avoid cycles. Because if we form a cycle, we use more edges without increasing the vertex set? Then the same vertex set could be covered by a tree (v_i-1 edges) and we use extra edges for the cycle. Then we have a larger component size? 

But if we avoid cycles, then each component is a tree: with size (number of edges) = v_i-1.

Then the entire set S is a forest: so |S| = |V| - comp, where comp is the number of components.

But we have: 
   |S| = |V| - comp = n - comp.

We require |S| >= T = ceil(n/2). 
   => n - comp >= ceil(n/2)
   => comp <= n - ceil(n/2) = floor(n/2)

So the number of components must be at most floor(n/2).

But note: we can also have cycles? Then we can have more edges per component? Then we can have fewer components? Or the same number of components but more edges? 

But if we add a cycle in one component, we increase |S| by one without changing the number of components. Then we have |S| = n - comp + (number of cycles). 

So we can exceed the tree size. 

But the problem: we want to minimize the maximum component size? Actually, we want the list of component sizes to be as "small" as possible in the sense that we can assign them to the capacities. 

But note: if we form cycles, we make one component larger. Then we might break the condition for the largest capacity? 

Therefore, it is beneficial to avoid cycles? Then the component sizes are minimized.

So the minimal component size for a component on v_i vertices is v_i-1 (if we take a tree). Then the total number of edges is n - comp.

But we need at least T = ceil(n/2) edges. Therefore, we require n - comp >= ceil(n/2). 

And we want the list of component sizes: each component i has s_i = (v_i - 1). Then the list of s_i is: the sizes of the trees in each component.

But note: the entire set S is a forest: so the sizes s_i are the number of edges per component. And the list of s_i must be assignable to the capacities: we sort the s_i in decreasing order, and the capacities in decreasing order, and we require that the i-th largest s_i <= the i-th largest capacity for i=1,...,comp.

But we are free to design the forest arbitrarily? Actually, we are constrained by the graph: we can only choose edges that exist. But we can form any forest that is contained in the graph? 

But note: the graph is connected, but we can form a disconnected forest? Yes.

How to form the forest? We can choose any spanning forest? Actually, we can choose any forest (any acyclic set of edges) that uses at least T edges. But we want to minimize the maximum component size? Or we want to make the component sizes as small as possible? Actually, we want the entire list of component sizes to be as small as possible? 

But the condition for the assignment is that the largest component size must be at most the largest capacity, the next largest at most the next largest, etc.

Therefore, we wish to form a forest (to avoid cycles and minimize the component sizes) that uses at least T edges, and then the list of component sizes (which are the numbers of edges per component) must be assignable to the capacities.

But note: if we form a forest, the size of a component is the number of edges in that tree, which is the number of vertices in that component minus one.

Therefore, the sizes are: [v1-1, v2-1, ..., vk-1] for k components.

And we have: v1+v2+...+vk = n, and the total edges |S| = n - k.

We require: n - k >= T = ceil(n/2).

So: k <= n - T.

But note: we can also use cycles? Then we can have more edges and the same components? Then the component sizes become larger. 

But we have an alternative: we can form a forest and then add cycles? But then the component that gets the cycle becomes larger. Then we break the forest structure: the component size increases. 

However, if we have a capacity that is large enough to cover a large component, then we can use that for the component with cycles? 

But the problem: we are forced to assign each entire component (with all its edges) to one color. So if we have a component with cycles, then the size (number of edges) is at least the number of vertices. 

But we have two strategies:

  Strategy 1: Use a forest (no cycles). Then we have k components, and the sizes are v_i-1. And |S| = n - k.

  Strategy 2: Add cycles to some components to increase |S| without increasing the number of components. Then the size of the component that gets the cycle increases by the number of cycles we add.

But we only need |S|>=T. So if in the forest we have |S| = n - k >= T, then we are done. Otherwise, we need to add edges (which must be cycles) to increase |S|.

But note: if we add a cycle, we add one edge to a component? Then we increase the size of that component by one. Then we can do that until we reach T.

But the problem: we are constrained by the capacities: the component that gets the cycle must then have a color that can cover the new size. 

So we have two steps:

  Step 1: Check if the total capacity is at least T = ceil(n/2). If not, output "No".

  Step 2: We try to form a forest that uses at least T edges? But we start by a forest that uses as many edges as possible? Actually, we can start by a spanning tree? Then we have one component (the whole graph) with n-1 edges. But then we have k=1, and the component size is n-1. Then we need one color with capacity at least n-1. But if there is no color with capacity>=n-1, we fail? 

But we can also break the graph into more components? 

We want to minimize the maximum component size? Actually, we want to minimize the entire list of component sizes? 

We can design the forest arbitrarily? As long as the graph is connected? Actually, we are constrained by the graph: we can only use edges that exist. But we can form any forest? 

But note: the graph is connected, so we can form a spanning tree? But we are not forced to use the entire graph? We can choose to not include some edges? Then we get a forest that might be disconnected.

How to form the forest? 

We can use a DFS/BFS to get a spanning tree? But then we have one tree. Then we break it? 

But we are free to choose any set of edges? Then we can form any forest. 

We can use the following: 

  We wish to partition the graph into k components (so that the forest has k trees) and then the size of the i-th tree (in edges) is the number of edges in that tree = (number of vertices in the tree) - 1.

  Then the total number of edges is n - k.

  We require n-k>=T -> k<=n-T.

  And we have a list of sizes: [v1-1, v2-1, ..., vk-1] with v1+v2+...+vk = n.

  And we want to assign these sizes to k distinct colors: we need to assign the size (v_i-1) to a color c such that a_c>=v_i-1.

  But we are free to choose the partition of the vertices? 

But note: the graph is connected. To form a forest that breaks the graph into k components, we remove k-1 edges? Actually, no: we are not removing, we are selecting edges. We are not forced to take the entire spanning tree? 

Actually, we can choose any forest. We are not forced to cover all vertices? 

But note: if we leave a vertex unconnected, then it forms a component with 0 edges? Then we don't have to assign that component to a color? But the problem: the colored edges are only the ones we choose. The uncolored edges are not used. 

But also, the uncolored edges are not part of S. 

Therefore, we can also leave vertices unconnected? Then the component for a vertex that is not covered by any edge in S is a singleton? But then we don't have any edge in that component? So we don't assign any color? 

Therefore, the components are only for the vertices that are covered by at least one edge? 

But note: an edge is incident to two vertices. So if we choose an edge, then the two vertices are covered. 

Therefore, the set of vertices covered is the union of the vertices incident to edges in S. 

But the problem: the condition for a color class: V_c is the set of vertices incident to an edge of color c. So if we leave a vertex uncovered, it doesn't appear in any V_c.

So we can have uncovered vertices? 

Therefore, the forest we form does not need to cover all vertices? 

Then the total number of edges is |S|, and the number of components is the number of connected components of the graph (V', S) where V' is the set of covered vertices.

And the size of a component is the number of edges in that component.

But then the formula: for a component that has v_i vertices, the number of edges in the tree is at least v_i-1? But we can have more if we add cycles? 

But we are only going to consider forests? 

Alternatively, we can choose to not cover some vertices? Then the covered vertices V' have size n' <= n, and the number of edges in the forest is |S| = n' - k, where k is the number of components.

We require |S|>=T.

But n' is the number of covered vertices. Then we have n' - k >= T.

We also have: the list of component sizes: each component has v_i vertices and the number of edges is v_i-1 (if we avoid cycles). 

Then the sizes are [v1-1, v2-1, ..., vk-1] and v1+...+vk = n'.

So |S| = n' - k.

We require: n' - k >= ceil(n/2).

But we also want to assign the sizes: we have k components with sizes (v_i-1). And we need to assign them to k distinct colors such that a_c>= (v_i-1).

But we are free to choose n' and the partition of V' into k components? 

However, the graph is fixed. We can only use existing edges. So we cannot cover an arbitrary set of vertices? 

But we can choose any forest? As long as the edges we choose are in the graph? Then we can cover any set of vertices that is connected in the graph? Actually, no: the graph is connected, so we can cover any subset of vertices that is connected? But we can cover a disconnected set? 

For example, we can choose two non-adjacent edges? Then we cover 4 vertices (if no shared vertices) and we have two components. 

So the only constraint is that the edges we choose must form a forest? And the covered vertices are the incident vertices.

How to maximize the chance of fitting the capacities? We wish to make the component sizes (in terms of edges) as small as possible. The smallest possible component is 1 edge (covering 2 vertices) -> size 1.

Therefore, the ideal is to have as many one-edge components as possible. Then the size list would be [1,1,...,1]. Then we need k distinct colors with capacity>=1. 

But we can have one-edge components only if we have at least one edge? 

And the total number of edges is k (if each component has one edge). Then we require k>=ceil(n/2). But k is the number of edges and also the number of components. 

But if we use one edge per component, then we cover 2k vertices? But we might have vertices shared? No, if the edges are disjoint. But we can have two edges incident to the same vertex? Then we cover 3 vertices: two edges incident to the same vertex form two separate one-edge components? Then the graph (V', S) has two edges that share a vertex? Then the entire set S is not connected? But per component: each edge is a component? Then we have two components, each of size 1.

But is it allowed to have two edges incident to the same vertex in two different components? 
  Component 1: edge (u,v) -> covers u and v.
  Component 2: edge (u,w) -> covers u and w.
  Then the entire covered set is {u,v,w}. 
  But the subgraph for component 1 has vertices {u,v} and edge (u,v). 
  The subgraph for component 2 has vertices {u,w} and edge (u,w). 
  They are disconnected? Actually, no: they share vertex u? But the condition: the subgraph for a component must be connected, and each is connected. 

But note: the definition: the subgraph (V_c, E_c) for a color c: 
   V_c = {vertices incident to edges of color c} 
   E_c = the set of edges of color c.

For component 1: V1 = {u,v}, E1 = {(u,v)} -> connected.
For component 2: V2 = {u,w}, E2 = {(u,w)} -> connected.

This is valid.

Therefore, we can use a matching: a set of edges that are pairwise non-adjacent? Or we can use edges that share a vertex? 

But if two edges share a vertex, then the vertex is covered by both, but each edge is in a separate component. 

Therefore, we can choose any set of edges? And consider each edge as a separate component? Then we have k = |S| components, each of size 1. 

Then we require: |S|>=ceil(n/2). And we need to assign each edge (each component of size 1) to a distinct color c such that a_c>=1. 

This is possible if and only if the number of colors c with a_c>=1 is at least ceil(n/2). 

But note: we are not forced to use one edge per component. We could use more. 

But this strategy (taking ceil(n/2) edges and forming each as a separate component) is always possible? Only if the graph has at least ceil(n/2) edges? It does, because m>=n-1 and n>=2, so m>=1, and ceil(n/2) <= n-1 for n>=2? 
  n=2: ceil(2/2)=1, and m>=1 -> okay.
  n=3: ceil(3/2)=2, m>=2 -> okay.
  n=4: ceil(4/2)=2, m>=3 -> okay.

So the graph has at least ceil(n/2) edges. 

And we can choose any ceil(n/2) edges? Then we can choose ceil(n/2) edges arbitrarily? 

But we have to assign each to a distinct color that has capacity>=1. 

The number of colors that have capacity>=1 is the number of nonzero capacities. But the total capacity is the sum of a_i, and we know the sum of a_i is at most m. And we need at least ceil(n/2) such colors. 

But note: the capacities a_i are given. We need at least ceil(n/2) colors with a_i>=1. 

But what if we don't have that many colors with a_i>=1? Then we cannot use this strategy.

Then we might try to form larger components: so that one color can cover multiple edges (as long as they are connected). 

Therefore, the overall solution:

  Step 1: Let T = ceil(n/2). 
  Step 2: If the total capacity (sum of a_i) < T, then output "No".
  Step 3: Count the number of colors that have capacity at least 1: let this be cnt.
          If cnt >= T, then we can do the following:
              We choose any T edges (for example, the first T edges in the input list? or any T edges). 
              We form T components, each a single edge.
              Then we assign each edge to a distinct color that has capacity>=1. (We can choose any distinct colors from the set of colors with a_c>=1, and we have at least T such colors.)

          How to assign: 
              We list the colors that have capacity>=1: say in a list L.
              Then for the first T edges, we assign the first T colors from L? 
              But note: we have to output for each edge the color. And we have to output m integers (for the m edges). The i-th edge (in input order) might not be chosen? 

          But we are choosing T edges arbitrarily. Then for the edges we choose, we assign a distinct color from L (we have T distinct colors). For the edges we do not choose, we assign 0.

          But note: we are free to choose which edges to color? So we choose T edges arbitrarily. We can choose the first T edges? 

          However, we must ensure that we don't violate the capacity? 
            For a color c, we are only using one edge, and a_c>=1, so it's okay.

  Step 4: If cnt < T, then we cannot use the above strategy. 

          But note: total capacity>=T, so there must be some colors with capacity>=2, etc.

          We then try to form a forest with at least T edges and then break it into components. We want the list of component sizes (in edges) to be assignable to the capacities.

          Specifically, we wish to minimize the maximum component size? Or to make the list of component sizes as small as possible? 

          How about: we form one big component? For example, a spanning tree? Then we have one component of size n-1. Then we require one color with capacity>=n-1. But if we don't have that, then we need to break it.

          Or we form a forest with many small components? But we need at least T edges. 

          But we know that if we form a forest, the minimal size of a component (in terms of edges) is 1 (if we have a single edge) and the maximal is at most n-1. 

          And the total number of edges is n' - k, where n' is the number of covered vertices and k is the number of components.

          We require n' - k >= T.

          And we wish to assign the components (each of size s_i = v_i - 1) to k distinct colors with capacities at least s_i.

          We can do:

            Sort the capacities in descending order: b[0] >= b[1] >= ... >= b[m-1].

            Then we want to cover at least T edges with a forest, and the list of component sizes (which are the tree sizes) should be such that when sorted descendingly, we have s_i <= b_i for all i in [0, k-1].

          How to design the forest to minimize the sorted list of s_i? We want the largest component to be as small as possible.

          One strategy: 
            We can try to use as many one-edge components as possible. But we are limited by cnt (the number of colors with capacity>=1) which is < T. So we cannot cover T edges by one-edge components.

          Then we must have at least one component with at least 2 edges.

          We can do:

            Let k = number of components = (number of colors with positive capacity)? But we can only use at most cnt components that are size 1? and then the remaining edges must be in larger components.

          Alternatively, we can use a greedy: 
            We know we need to cover T edges. We start by not using any edge. 
            We then try to cover the entire set of vertices? Or we can leave some uncovered.

          But note: the graph is connected, so we can start from a spanning tree and then break it? 

          We want to break the spanning tree into k components? Then the forest will be the spanning tree, and we break it by removing edges? But we are not removing edges, we are not selecting some edges? 

          Actually, we are free to choose the forest. We can choose any set of edges that forms a forest.

          We can compute the maximum possible number of one-edge components we can have? 

          However, given the complexity and the constraints (the total n and m over test cases is only 300000), we can try a simpler approach.

But wait: the total n and m over test cases is only 300000. So we have to design an O(n) or O(m) solution per test case? But the sum of n and m per test case is bounded by the global sum? Actually, the global sum of (n_i+m_i) for all test cases is 300000. 

Therefore, we can iterate over test cases and for each test case, we do:

   Read n, m
   Read a[1..m]
   Read the m edges.

   T = ceil(n/2) = (n+1)//2   [since ceil(n/2) = (n+1)//2 in integer]

   total_capacity = sum(a)
   if total_capacity < T:
        print("No")
        continue

   Count the number of colors with a_i>=1: call this cnt.

   if cnt >= T:
        print("Yes")
        # We will choose T edges to color, and leave the rest uncolored.
        # How to choose T edges? We can choose the first T edges in the input? 
        # But we must output for each edge (in the input order) the color.
        # We need to assign distinct colors to these T edges, using colors that have a_i>=1.

        # Step: 
        #   Create a list of color indices that have capacity>=1: 
        colors_available = []
        for c in range(1, m+1):
            if a[c-1] >= 1:
                colors_available.append(c)

        # But we only need T of them.
        # We create an array res of m zeros.
        # For the first T edges (edge index 0 to T-1), we assign the colors_available[0] to the first edge, colors_available[1] to the second, ...?
        # But note: we are free to choose any T edges? We can choose the first T edges? 
        # However, we must output the color for each edge in the input order. 
        # So if we choose the first T edges, then for edge i (0-indexed) for i in [0, T-1]: we assign color = colors_available[i]
        # For the remaining edges: we assign 0.

        res = [0] * m
        for i in range(T):
            res[i] = colors_available[i]

        # But wait: what if the graph is not simple? Actually, it has no multiple edges, but we have m edges. 
        # However, note: we are using the input order. The problem: the i-th edge we read is the i-th in the list.

        # But what if we choose T edges arbitrarily, but the input has m edges? We choose the first T? That is acceptable.

        # Output: 
        #   "Yes"
        #   and then the list res as space separated.

        print(" ".join(map(str, res)))

   else:
        # cnt < T, but total_capacity>=T.

        # We need to form a forest that has at least T edges, and the list of component sizes (each is the number of edges in the component) must be assignable to the capacities: 
        #   Sort the component sizes in descending order: s[0]>=s[1]>=...>=s[k] (k = number of components)
        #   Sort the capacities in descending order: b[0]>=b[1]>=...>=b[m]  (we only care about the top k capacities? and we will use k distinct colors)
        #   Then we require: for i=0 to k-1: s[i] <= b[i]

        # How to form the forest to minimize the maximum component size? 
        # We want to make the largest component as small as possible? And then the next, etc.

        # But we are constrained by the graph: we can only use existing edges.

        # We can use the entire graph? But we don't have to. We only need T edges.

        # Strategy: 
        #   We are going to use a spanning tree? Actually, we can start by taking a spanning tree: that uses n-1 edges. But then we have one component of size n-1. 
        #   But we require one color with capacity>=n-1. If we don't have that, then we break the tree into smaller components.

        # How to break? We remove some edges from the spanning tree? Then we get a forest. Each time we remove an edge, we break one component into two, and the total number of edges decreases? But we want at least T edges. 

        # Alternatively, we can start from an empty set and add edges? 

        # We know that we want at least T edges and we want to minimize the sorted list of component sizes. 

        # We can use a DSU? 

        # But note: the entire graph is connected. We can form the forest by taking the entire set of edges and then remove some edges to break cycles and also to break the graph into components? 

        # However, we are free to choose any forest. We can use a DFS tree and then break it arbitrarily? 

        # Since the global sum of n and m is 300000, we can do:

        #   Step 1: Find the sorted list of capacities in descending order: 
        #        b = sorted(a, reverse=True)
        #        Then we remove the zeros? Actually, we can keep all because we only consider the top k.

        #   Step 2: We want to find a forest (edge set S) such that |S|>=T and if we let the sizes of the components (in edges) be s_1, s_2, ... , s_k, and we sort them in descending order, then:
        #        for all i in [0, k-1]: s_i <= b[i]

        #   How to compute the minimal possible maximum component size? Or we can try to simulate:

        #   We start with an empty graph. Then we add edges one by one, and we use union-find to track the components. But we avoid cycles? So we only add edges that connect two different components? 

        #   But we are free to choose the order? We can choose to add edges arbitrarily? 

        #   We want to keep the components as small as possible. So we can use a greedy: we try to add edges that do not form a component larger than a threshold? 

        #   Alternatively, we can use a binary search on the maximum allowed component size? 

        #   However, we are constrained by time: the total n and m over test cases is 300000, but the total over all test cases is 300000? 

        #   Actually, the sum of (n_i+m_i) over test cases is 300000. So we can iterate over test cases and the total work is 300000.

        #   But in this branch, we have to design the forest? 

        #   We can try:

        #        We know that we have to cover at least T edges.

        #        We also know that we can use at most k0 = min(m, the number of non-zero capacities) components? Actually, the number of components k is not fixed.

        #        We wish: the list of component sizes (in edges) should be dominated by the sorted capacities.

        #   Note: the sorted capacities is b, and we only care about the largest k values? 

        #   We can simulate by building a forest with component sizes as small as possible? 

        #   We can do:

        #        Sort the capacities in descending order: b = sorted(a, reverse=True)
        #        We then consider the first min(m, T) capacities? 

        #        We want to know: can we form a forest such that the sorted list of component sizes (in edges) in descending order is component-wise <= the sorted capacities? 

        #        And the total number of edges is at least T.

        #   We can use a greedy matching: 

        #        Let k = 0  # we will count the number of components we form
        #        We have an array comp_size = []  # the sizes (in edges) of the components

        #        But we also have to account for the vertices: initially, we have n vertices and 0 edges.

        #        We want to add edges? But we are limited by the capacities: we cannot form a component that is larger than the capacity that will be assigned to it.

        #        How about: we iterate over the capacities in descending order (for the largest capacities first) and assign the largest capacity to the largest component we can form that is at most that capacity? 

        #        But we are constrained by the graph: we can only form components that are connected by existing edges.

        #   This is complex.

        # Given the complexity and the fact that the total n+m is 300000, and that the sample size is small, we note:

        #   The sample input has 4 test cases, and the last one is "No", and the second and third are "Yes" even with the same graph? 

        #   Sample test case 2 and 3: 
        #        n=6, m=11
        #        a = [0,0,0,0,0,0,0,3,2,3,3]  -> a1 to a11: a8=3, a9=2, a10=3, a11=3. The rest are 0.
        #        Then T = ceil(6/2)=3.

        #        total_capacity = 3+2+3+3 = 11 >= 3.
        #        cnt = number of colors with a_i>=1 = 4 (colors 8,9,10,11) -> 4>=3 -> so we would have taken the first branch? 

        #   But the sample output for the second test case is:
        #        Yes
        #        8 11 10 10 9 8 8 11 9 10 11
        #        and for the third test case is:
        #        Yes
        #        11 11 11 0 0 0 0 0 0 0 0

        #   Why didn't we take the first branch for the second test case? 
        #        Because the first branch is taken when cnt>=T, which is 4>=3 -> true. 
        #        Then we would output the first branch: choose any 3 edges and assign distinct colors from {8,9,10,11}. 
        #        But the sample output uses 8 edges? Actually, the output for the second test case has 11 values: 
        #            8,11,10,10,9,8,8,11,9,10,11 -> that's 11 colors? 
        #        But the uncolored edges are those with 0? There is no zero? 
        #        Actually, the sample output has 11 non-zero colors? 

        #        But the capacities: 
        #            color8: used 3 times? (positions 0,5,6) -> capacity is 3 -> okay.
        #            color9: used 2 times? (positions 4,8) -> capacity is 2 -> okay.
        #            color10: used 3 times? (positions 2,3,9) -> capacity is 3 -> okay.
        #            color11: used 3 times? (positions 1,7,10) -> capacity is 3 -> okay.
        #        And the other colors (1 to 7) are used 0 times? which is within capacity 0.

        #        But the condition per color class: 
        #            We have multiple edges per color. And each color class must be connected.

        #        So the first branch (assigning one edge per color) is not the only possibility.

        #        The first branch we described (single edge per component) is one possibility, but there are others.

        #        Why did the sample output use more than 3 edges? Because T=3, but they used 11 edges? 

        #        But the requirement: at least T=3 edges. They used 11 which is >=3.

        #        So the first branch is not the only valid solution.

        #        However, the problem says: "if there are multiple possible answers, output any one of them."

        #        So we can output any solution.

        #        Why did we not use the first branch for the sample test case 2? 
        #          Because the sample output provided a solution that uses more than T edges? 

        #        But the first branch would be a valid solution too? 

        #        However, the sample output for test case 2 is a solution that uses 11 edges, and for test case 3 is a solution that uses 3 edges.

        #        So the sample test case 3 is using the first branch? 
        #           Output: 11 11 11 0 0 ... -> so three edges are colored with color 11? 
        #           But the capacity for color 11 is 3, so that's okay.
        #           And the condition: the three edges with color 11 must be connected? 
        #           The sample graph is a complete graph on 6 vertices? 
        #           But the sample output: they only colored three edges? 
        #           Which three? The first three edges: 
        #               edge0: 1-2
        #               edge1: 2-3
        #               edge2: 3-4
        #           If we assign color 11 to these three, then they form a chain: 1-2-3-4 -> connected? 
        #           But the condition for color 11: the set of edges must form a connected subgraph? 
        #           The three edges form a connected subgraph? Yes.

        #        So why did the first branch in our algorithm (which would assign one edge per color) not used for test case 2? 
        #          Because the sample output chose to use more edges? 

        #        Our first branch is: 
        #          if cnt>=T, then we output a solution that has T components, each of one edge, and we use T distinct colors.

        #        But the problem does not require to minimize the number of colored edges? We only require at least T.

        #        So we are free to output any valid solution. 

        #        Therefore, we can output the first branch whenever cnt>=T.

        #        But the sample test case 2 output used 11 edges and 4 colors. Why would they do that? 
        #          Because they can? And it is valid.

        #        However, our first branch is simpler. 

        #        But note: the sample test case 2 also has the condition that the entire set of edges of a color must be connected. 
        #          For color8: the edges are at positions0,5,6: 
        #             edge0: 1-2
        #             edge5: 6-1
        #             edge6: 1-4
        #          Do these edges form a connected subgraph? 
        #             The edges: (1,2), (6,1), (1,4): 
        #                 They share vertex 1, so the entire graph has vertices {1,2,4,6} and the edges are incident to 1. So the graph is connected? 
        #                 Actually, we can go from 2 to 1 to 4 and 1 to 6. So it is connected.
        #          Similarly for the others.

        #        So the sample output for test case 2 is valid.

        #        Why didn't we use the first branch for test case 2? We could have, but the sample output did not. 

        #        Therefore, we can change the plan: 
        #          We only do the first branch (one edge per component) if cnt>=T.

        #          For the second branch, we do something else that might use more than T edges.

        #        But the problem: the sample test case 3 used the first branch? Actually, no: in test case 3, the output is:
        #            "11 11 11 0 0 0 0 0 0 0 0"
        #          This means: 
        #            edge0: color11
        #            edge1: color11
        #            edge2: color11
        #            the rest:0.
        #          This is not one edge per component: it has one component for the three edges of color11? Or three components? 
        #          It is one component for color11? Because the three edges are assigned the same color, and they must form a connected subgraph? 
        #          The three edges: 
        #              1:1-2, 2:2-3, 3:3-4 -> they form a connected subgraph? Yes.

        #          So this is one component of size 3.

        #        Therefore, the first branch (one edge per component) is not used in test case 3 either.

        #        How then to solve the second branch? 

        #        Given the complexity, and the fact that the overall input size is only 300000, we might do the following in the second branch:

        #          We try to use as few components as possible? 

        #        Insight: 
        #          We know that the total capacity is at least T, and we have a list of capacities. 
        #          We want to cover at least T edges. 

        #          We can use a single color for a connected subgraph that has min(a_c, as many edges as we can in a connected subgraph) for that color.

        #          Then we use a DFS/BFS to find a connected subgraph that has at most min(a_c, ...) edges? 

        #        This is complex.

        #    After rethinking, we note: 
        #        The sample test case 1: 
        #            n=5, m=4, a = [4,0,0,0] -> T=ceil(5/2)=3.
        #            total_capacity=4>=3 -> yes.
        #            cnt = number of colors with a_i>=1 = 1 (only color1) -> which is <3 -> so we go to the second branch.
        #        The sample output: 
        #            "1 1 0 1"
        #            This means: 
        #                edge0: color1
        #                edge1: color1
        #                edge2:0
        #                edge3: color1
        #            So we have three edges, all with color1. 
        #            The condition for color1: the three edges must form a connected subgraph? 
        #                The graph: 
        #                   edge0: 2-3
        #                   edge1: 2-1
        #                   edge3: 4-3   [edge2:4-5 is uncolored]
        #                The vertices covered: {1,2,3,4} and the edges: (2,3), (2,1), (4,3). 
        #                This is connected: 1-2-3-4.

        #        How can we achieve this? 

        #    Revised plan for the second branch (cnt < T):

        #        We have at most cnt components that are size1, and we need more edges. 
        #        But we can also use one component that has multiple edges, as long as the entire set of edges of that color is connected.

        #        We want to use as few components as possible to cover as many edges as possible? 
        #        Specifically, we want to cover at least T edges.

        #        We can do:

        #          Let k = the number of available colors (with a_c>=1) = cnt.
        #          We want to assign each color c a connected set of edges, and the size of the set is at most a_c, and the sets are disjoint.

        #          And the total number of edges is at least T.

        #        This is a packing of connected subgraphs.

        #        How to assign edges to colors such that the set for each color is connected and disjoint, and the total number of edges is at least T? 

        #        This is NP-hard in general, but our T is small? But we only need to know if there is a solution, and to output one.

        #        Alternatively, we can do a greedy: 
        #          We know the capacities for the available colors: we have a list of capacities for the non-zero colors, and we sort them in descending order.

        #          We then use a DFS/BFS to find a spanning tree for the entire graph? Then we remove some edges to break it into k components? 

        #        But note: we are allowed to leave edges uncolored.

        #        We can do:

        #          Step 1: Pick an arbitrary root, and do a DFS/BFS to get a spanning tree. 
        #          Step 2: We will then use a decomposition of the tree into subtrees? 

        #          We have k = cnt colors. We assign each color a subtree (a connected subgraph) that has at most a_c edges.

        #          We want to maximize the total number of edges covered.

        #          This is similar to: tree partitioning into subtrees with size constraints.

        #        But note: we are not limited to the tree? We can use non-tree edges? But if we use a non-tree edge, then it might connect two vertices in the tree, but then the subgraph for a color must be connected. If we assign a non-tree edge to a color, then we must also assign all the tree edges in the path between the two vertices? to make it connected? 

        #        This is complex.

        #    Given the complexity and the fact that the global sum of n and m is 300000, and that the sample test cases are small, we might try a simpler approach for the second branch:

        #        Since T = ceil(n/2) and n<=300000, but the total sum of n and m over test cases is 300000, then the largest n in any test case is at most 300000? But the total sum is 300000, so there is only one test case? 

        #        Actually, the sample has 4 test cases and the total n+m is 58. And the constraint is the sum of (n_i+m_i) over test cases is 300000.

        #        Therefore, the largest test case might have n+m around 300000? and there is only one test case? 

        #        But then we have to design an efficient algorithm for n+m=300000.

        #    We abandon for now.

 Given the complexity of the second branch and the time, and that the sample test cases might be small, we output a placeholder for the second branch: 

            We try to find a solution with one color: 
                If there is a color c with a_c >= T, and if we can find a connected subgraph with at least T edges, then we can assign that entire connected subgraph to color c, and leave the rest uncolored.

            How to find a connected subgraph with at least T edges? 
                The entire graph is connected and has m edges. But we only need T, and T=ceil(n/2) is about n/2, which is less than n-1 (for n>=4) so it is always available? 

                But we can take any connected subgraph with T edges? 
                  For example, we can start from any vertex and do a BFS until we have collected T edges? 

                But the subgraph must be connected. We can do: 
                  We start from an arbitrary edge? Then we grow by adding adjacent edges? 

                Actually, we can use a BFS that collects edges: 
                  We maintain a set of edges that are in the component, and we start with one edge. Then we add an edge that is incident to the current component (sharing a vertex). Then the component remains connected.

                We can do:

                  Let comp_edges = set()
                  Let comp_vertices = set()

                  We pick an arbitrary edge, and add it.

                  Then we iterate: we look for an edge that has at least one endpoint in comp_vertices and that is not in comp_edges, and add it. We stop when we have T edges.

                But it might not be able to get T edges? But the graph is connected, so we can always grow to the entire graph. And T<=m, so we can always get T edges.

                Then we assign the entire set to one color c that has a_c>=T.

                Then for the other edges, we assign 0.

                And we leave the other colors unused.

                This is valid.

            But what if there is no single color with capacity>=T? 
                Then we need at least two colors.

            But note: in the second branch, we have cnt < T, but the total capacity>=T. 
                Example: T=3, and we have two colors: one with capacity 2 and one with capacity 2. Then we need to cover 3 edges. We cannot use one color for 3 edges because no color has capacity>=3. 
                We must use two colors: one for 2 edges and one for 1 edge? 

            How about:

                We can try to find two connected edge-disjoint subgraphs: the first with s1 edges, the second with s2 edges, such that s1<=cap1, s2<=cap2, and s1+s2>=T.

                And the two subgraphs are disjoint in edges.

            But the subgraphs may share vertices.

            How to find them? 
                We can use the spanning tree. 

                We can remove an edge to break the tree into two subtrees, and then assign one subtree to one color and the other to another color? 
                But the subtrees are defined by vertices, and the edges within the induced subgraphs.

            This is complex.

        Given the time constraints, and the fact that the overall input size is 300000, but the total over test cases is 300000, meaning there is likely only one test case, we output the following for the second branch:

            If there exists a color c with a_c>=T, then we use that color to cover a connected subgraph of T edges (found by BFS as described) and output the solution.

            Else, we try to use two colors: 
                We find two connected subgraphs that are edge-disjoint, the first with s1 edges (<=cap1), the second with s2 edges (<=cap2), and s1+s2>=T.

            But note: we might need more than two. 

        Alternatively, we do a greedy over the available colors sorted in descending order of capacities: 
            Let colors = sorted list of capacities for colors that are positive, in descending order.
            Let S = set()  of edges, initially empty.
            Let comp_list = []  # list of components (each is a set of edges) that we have formed.
            For each color c in colors:
                We want to find a connected subgraph of edges not in S, with at most c edges, and as many as possible.
                We start from an edge not in S and grow a component by BFS (by adding incident edges not in S) until we have c edges or we cannot grow.
                We add the edges of this component to S, and record the component.

            Then the total number of edges = sum of the sizes of the components.

            If this total >= T, then we win.

            Then we assign the component for the first color to the first color, etc.

        But the growing order matters. We want to pack as many edges as possible.

        However, this greedy might not work: it might pack a big component that blocks others.

        But note: the graph is connected. We start with the largest capacity first.

        We do:

          used = set()  # edges used
          components = []   # list of edge sets for each color in the order of colors (which are sorted descendingly)
          for cap in colors:  # going from large to small
              if we have used all edges: 
                  break
              start from an edge not in used? But we want a connected component. 
              We do a BFS in the graph of unused edges? But we can only use unused edges.

              We start with an arbitrary unused edge e0. 
                  comp_edges = set()
                  queue = deque of edges, starting with e0.
                  mark e0 as used (in the BFS) and add it to comp_edges.
                  while queue and |comp_edges| < cap:
                      pop an edge (u,v) from the queue.
                      then for each vertex in {u,v}, we consider the incident edges that are not in used (global) and not in comp_edges.
                      we add them to the queue.
                  Then we add the entire comp_edges to the global used, and record the component.

          Then total_edges = sum(len(comp) for comp in components)

          If total_edges>=T: 
              then we output the assignment: 
                  res = [0]*m
                  for i, comp in enumerate(components):
                      c = the color corresponding to the capacity (but we sorted the colors, so we need to remember the original color index)
                  But we sorted the capacities, so we have to remember the original color index.

          But how to remember? 
                we can do: 
                  colors_with_index = [(a_i, i) for i in range(m) if a_i>0]
                  sort by a_i descending.

          Then for j in range(len(components)):
              (cap, color_index) = colors_with_index[j]
              For each edge in components[j], we assign the color_index+1? (since colors are 1-indexed)

          For edges not in any component, we assign 0.

        But will this work? 

          Conditions: 
            - Each component is connected? Yes, because we did a BFS in the unused graph? But the BFS is on the edges incident to the current component? 
                However, note: we start with one edge, and then we add edges that are incident to the current component. So the entire component is connected.

            - The components are disjoint.

          Total_edges = sum of the sizes of the components.

          We need total_edges>=T.

        But what if the greedy does not get enough edges? 
          Example: we have a star: center and n-1 leaves. 
            Edges: (center, leaf_i) for i=1..n-1.
          Then capacities: [2,2] and T=3.

          We start with the largest capacity=2: 
              We start with an edge, say (center, leaf1). Then we can add any other edge incident to center or leaf1? But leaf1 has no other edge. Center has edges to leaf2, leaf3, ... 
              So we add (center, leaf2). Then the component has two edges: connected? Yes (center, leaf1) and (center, leaf2) -> connected.
          Then we use the next capacity=2: 
              We start with an unused edge, say (center, leaf3). Then we can add (center, leaf4). 
          Then we have 4 edges>=3 -> works.

          But what if we had capacities [1,1,1] and T=3? 
              We do:
                first capacity=1: we take one edge -> 1 edge.
                second capacity=1: we take one edge -> 2 edges.
                third capacity=1: we take one edge -> 3 edges. -> works.

        But what if the capacities are [1,1] and T=3? then we only get 2 edges -> fail.

        But then we fall into the first branch? no, because in the first branch we require cnt>=T, which is 2>=3? no, so we are in the second branch.

        And then the total capacity=1+1=2<T=3, so we should have already output "No" in step 2? 

        But we did: 
            Step 2: if total_capacity < T: then "No"
            Here total_capacity=2<3, so we would have output "No".

        Therefore, in the second branch, we have total_capacity>=T.

        But in the above greedy, we might not get T edges? 
          Example: capacities [2,2] and T=4, and the graph is a star with 4 edges: 
            Then total_capacity=4>=4.
            We start with the first color (cap=2): we take two edges -> leaves 2 edges.
            Then we do the second color (cap=2): we take the remaining two edges. -> total=4, which is >=4.

        Example: capacities [2,2] and T=4, and the graph is a chain of 5 vertices: 
            edges: (1-2), (2-3), (3-4), (4-5) -> 4 edges.
            We start with an edge, say (1-2). Then we can add an incident edge: (2-3). -> then we have two edges.
            Then we have the remaining edges: (3-4), (4-5). 
            For the second color: we start with (3-4), then we can add (4-5). -> two edges.
            total=4.

        But what if we start with the edge (2-3) for the first color?
            Then we can add either (1-2) or (3-4). Then we take (1-2) and (3-4) -> then we have two edges: [ (2-3), (1-2) ] and [ (3-4), (4-5) ]? 
            But wait, when we start with (2-3), we then consider incident edges: 
                from vertex2: edge (1-2) -> add.
                from vertex3: edge (3-4) -> add? 
                But we stop when we have 2 edges? 
            Actually, we start with (2-3), then we add (1-2) and (3-4) -> that's 3 edges? but cap=2 -> so we can only take two.

            So we might take (2-3) and (1-2) for the first color? then the second color takes (3-4) and (4-5) -> but (4-5) is not incident to (3-4) in the unused graph? 
                After removing the first two edges, the graph has the edge (3-4) and (4-5) and they are incident. 
                So for the second color: start with (3-4), then add (4-5) -> two edges.

        So the greedy may work.

        Therefore, we do:

          Step 1: total_capacity = sum(a) 
          if total_capacity < T: "No"

          Step 2: cnt = number of colors with a_i>=1
          if cnt>=T: 
               // one edge per component for T edges
               pick T edges (say the first T edges in the input)
               pick T distinct colors from the set of colors with a_i>=1 (say the first T colors in the list of non-zero capacities)
               assign each edge to one of these T colors (distinct), and the rest 0.

          else: // cnt < T, but total_capacity>=T
               Let colors_with_index = sorted([(a_i, i) for i in range(m) if a_i>0], reverse=True)   // sort by a_i descending, and remember the original color index.
               used_edges = set()   # set of edge indices that are colored
               components = []   # list of lists: for each color we will have a list of edge indices

               # We need an efficient way to grow a component: we will represent the graph as an array of lists (for each vertex, list of (neighbor, edge_index))
               # But note: we have to know the edge index for incident edges.

               # Preprocessing: 
                 graph = [[] for _ in range(n+1)]
                 # We are given m edges. We know the input order.
                 for i in range(m):
                     u, v = edges[i]
                     # convert to 0-indexed? but we use 1-indexed? 
                     # the problem: vertices are 1-indexed.
                     graph[u].append((v, i))
                     graph[v].append((u, i))

               # We maintain a global set of unused edge indices.

               # Instead, we do:
                 unused_edges = set(range(m))   # we will remove edge indices as we use them.

                 # We also need to be able to find an unused edge quickly? 
                 # We can start by any unused edge.

                 # For each color in colors_with_index:
                 for (cap, color_idx) in colors_with_index:
                     if not unused_edges:
                         break
                     # pick an arbitrary edge from unused_edges
                     start_edge = next(iter(unused_edges))
                     # BFS/DFS for unused_edges, starting from this edge, and we can grow to at most 'cap' edges.
                     comp_edges = set()
                     queue = deque([start_edge])
                     comp_edges.add(start_edge)
                     unused_edges.remove(start_edge)

                     # We also need to know the vertices covered by this component? Or we can store for each edge the two endpoints? 
                     # But we have the graph. We can use the vertices to find incident edges.

                     # We will grow by vertices: 
                     #   But note: we have the edge, and we know the two endpoints. 
                     #   We maintain the set of vertices in the component? 
                     #   Actually, we can grow: 
                     #       We have a set of vertices that are covered by the edges in comp_edges.

                     #   However, we only care about incident unused edges.

                     # How to grow: 
                     #   We maintain a queue of edges (for BFS in the graph of edges? or vertices?)
                     #   Actually, we have a set of edges in the component. We also maintain a set of vertices.

                     #   Alternatively, we can do: 
                     #        queue_vertices = deque( [u, v] ) for the start_edge (u,v)
                     #        Then we mark these vertices as in the component.
                     #        Then we look for unused edges incident to these vertices.

                     #   But we already removed the start_edge from unused_edges.

                     #   We'll do:

                     vertices = set()
                     u0, v0 = edges[start_edge]   # the endpoints of the start_edge
                     vertices.add(u0)
                     vertices.add(v0)

                     # We use a queue for vertices: 
                     qv = deque([u0, v0])

                     while len(comp_edges) < cap and qv:
                         u = qv.popleft()
                         # iterate over all incident edges to u that are unused
                         for (neighbor, eidx) in graph[u]:
                             if eidx in unused_edges:
                                 # we can add this edge?
                                 if len(comp_edges) < cap:
                                     comp_edges.add(eidx)
                                     unused_edges.remove(eidx)
                                     # we add the neighbor if it's not in vertices?
                                     if neighbor not in vertices:
                                         vertices.add(neighbor)
                                         qv.append(neighbor)
                                 else:
                                     break
                         if len(comp_edges) >= cap:
                             break

                     # Then we have a component of size = len(comp_edges) (<=cap)
                     components.append( (color_idx, comp_edges) )

                 total_edges = 0
                 for (color_idx, comp_edges) in components:
                     total_edges += len(comp_edges)

                 if total_edges >= T:
                     # Then we output the solution.
                     res = [0] * m
                     for (color_idx, comp_edges) in components:
                         for eidx in comp_edges:
                             # assign this edge to color = color_idx+1? 
                             # But the color index in the input: we stored color_idx (which is the index in the a array) -> the color is color_idx+1? 
                             # Actually, the colors are from 1 to m, and the a array index 0 corresponds to color1.
                             # So the color for the color_idx is color_idx+1.
                             res[eidx] = color_idx+1
                     print("Yes")
                     print(" ".join(map(str, res)))
                 else:
                     print("No")

        However, there is a problem: when we remove edges, the graph of unused_edges may become disconnected. But we are doing BFS from the vertices in the component? and we only consider unused_edges.

        But note: we start with an edge and then we use vertices to find incident unused edges. This is essentially a BFS in the line graph? 

        This should be correct.

        But worst-case complexity: 
          We iterate over each edge at most once. 
          The total work is O(m) per test case.

        But the sum of m over test cases is at most 300000? (because the total n+m is 300000, but n and m per test case are added, and the sum over test cases of n_i and m_i is 300000) -> so the total m over test cases is at most 300000? 

        But note: the constraint: "the sum of n and m over all test cases" -> if we have multiple test cases, then the total m is the sum of m_i, and the total n is the sum of n_i, and the overall sum (n_i+m_i) over test cases is 300000.

        Therefore, the total work of the BFS in the second branch is O(total_m) = O(300000).

        So we can do it.

        But note: we also have to build the graph for each test case. The total work per test case is O(n_i+m_i). And the total over test cases is 300000.

        Therefore, we do:

          for test_case in range(C):
              read n, m
              read a list of m integers
              read m edges

              T = (n+1)//2

              total_cap = sum(a)
              if total_cap < T:
                  print("No")
                  continue

              cnt = 0
              for x in a:
                  if x>=1:
                      cnt += 1

              if cnt>=T:
                  # one edge per component
                  # get the list of non-zero colors
                  non_zero_colors = []
                  for c in range(1, m+1):
                      if a[c-1]>=1:
                          non_zero_colors.append(c)
                  # we only need T of them
                  non_zero_colors = non_zero_colors[:T]
                  res = [0]*m
                  # we choose the first T edges (by index) to assign the colors
                  for i in range(T):
                      res[i] = non_zero_colors[i]
                  print("Yes")
                  print(" ".join(map(str, res)))
              else:
                  # second branch: use BFS to pack components
                  # Build graph: 
                  graph = [[] for _ in range(n+1)]  # 1-indexed up to n
                  # edges is a list of m edges, each is (u,v)
                  # we will store for each vertex, list of (neighbor, edge_index)
                  for i in range(m):
                      u, v = edges[i]
                      graph[u].append( (v, i) )
                      graph[v].append( (u, i) )

                  # Prepare the list of non-zero colors with their capacity and original index
                  colors_with_index = []  # (a_i, i) for i in range(m) if a_i>0
                  for i in range(m):
                      if a[i] > 0:
                          colors_with_index.append( (a[i], i) )
                  # sort descending by a[i]
                  colors_with_index.sort(key=lambda x: x[0], reverse=True)

                  unused_edges = set(range(m))
                  components = []  # list of (original_color_index, set of edge indices)

                  # For each color in colors_with_index:
                  for (cap, color_idx) in colors_with_index:
                      if not unused_edges:
                          break
                      # pick an arbitrary unused edge
                      start_edge = next(iter(unused_edges))
                      # BFS in the unused_edges to grow a component of at most 'cap' edges.
                      comp_edges = set()
                      comp_edges.add(start_edge)
                      unused_edges.remove(start_edge)

                      # get the two vertices of this edge
                      u0, v0 = edges[start_edge]
                      vertices = set([u0, v0])
                      qv = deque([u0, v0])   # queue for vertices

                      while len(comp_edges) < cap and qv:
                          u = qv.popleft()
                          for (neighbor, eidx) in graph[u]:
                              if eidx in unused_edges:
                                  if len(comp_edges) < cap:
                                      comp_edges.add(eidx)
                                      unused_edges.remove(eidx)
                                      # if the neighbor is not in vertices, add it and enqueue
                                      if neighbor not in vertices:
                                          vertices.add(neighbor)
                                          qv.append(neighbor)
                                  else:
                                      break
                      components.append( (color_idx, comp_edges) )

                  total_edges_colored = 0
                  for (color_idx, comp_edges) in components:
                      total_edges_colored += len(comp_edges)

                  if total_edges_colored >= T:
                      res = [0] * m
                      for (color_idx, comp_edges) in components:
                          c = color_idx + 1   # because the color for a_i at index i is color i+1.
                          for eidx in comp_edges:
                              res[eidx] = c
                      print("Yes")
                      print(" ".join(map(str, res)))
                  else:
                      print("No")

        Let's test on sample test case 1: 
            n=5, m=4, a=[4,0,0,0] -> 
                T = (5+1)//2 = 3.
                total_cap=4>=3 -> yes.
                cnt=1 (only color0: a0=4) -> so we go to the second branch.

            colors_with_index = [(4,0)]  # (a0=4, index0)

            Build graph for 5 vertices, 4 edges: 
                edges = [ (2,3), (2,1), (4,5), (4,3) ]

            Start with start_edge = 0? (the first edge: (2,3))
                comp_edges = {0}
                unused_edges becomes {1,2,3}
                vertices = {2,3}
                qv = [2,3]

                From u=2: 
                    incident edges: 
                         edge0: already taken.
                         edge1: (2,1) -> eidx=1 in unused_edges -> add: comp_edges = {0,1}, remove 1 from unused_edges -> {2,3}
                    then add vertex 1 -> vertices={2,3,1}, qv=[3,1]

                From u=3:
                    incident edges: 
                         edge0: taken.
                         edge3: (3,4) -> eidx=3 -> add: comp_edges = {0,1,3}, remove 3 -> unused_edges={2}
                    then add vertex 4 -> vertices.add(4), qv=[1,4]

                Now we have 3 edges, and cap=4, so we can try to grow.
                From u=1: 
                    incident edges: 
                         edge1: taken.
                    no more.
                From u=4:
                    incident edges: 
                         edge3: taken.
                         edge2: (4,5) -> eidx=2 in unused_edges -> add: comp_edges = {0,1,3,2} -> size=4, which is the cap.

                Then we have a component of 4 edges.

                total_edges_colored=4>=3.

            Then we assign:
                res = [0]*4
                for the component: color0 (which becomes color0+1 = 1) to edges 0,1,3,2.
                So res = [1,1,1,1]? 
                But the sample output is "1 1 0 1" -> which is [1,1,0,1] for the four edges.

            Why the sample output has an uncolored edge? 

            But our solution colors all edges? 

            However, the sample output only requires at least 3, and we have 4 which is >=3.

            But the sample output in the sample input is "1 1 0 1", which means edge2 (the third edge) is uncolored.

            Why? 
                The sample input: 
                    edge0: (2,3) -> colored 1
                    edge1: (2,1) -> colored 1
                    edge2: (4,5) -> uncolored? 
                    edge3: (4,3) -> colored 1.

            The sample output leaves edge2 uncolored. 

            In our solution, we used edge2? 

            In our BFS, we did use edge2: the last edge we added.

            But the sample output leaves it uncolored. 

            Why is the sample output valid? 
                They have three edges of color1: edge0, edge1, edge3. 
                And they form a connected subgraph? 
                    edge0: (2,3), edge1: (2,1), edge3: (4,3) -> 
                    vertices: 1,2,3,4 -> and edges: 
                        1-2-3-4 -> connected.

            Our solution also has a valid coloring: all edges are in one connected component? 
                The entire graph: 1,2,3,4,5, with edges: 
                    (2,3), (2,1), (4,3), (4,5) -> connected? 
                But the component for color1 is the entire graph? which is connected.

            So both are valid.

            Therefore, we output [1,1,1,1] for the first test case? 

            But the sample output is [1,1,0,1] -> which is different.

            The problem says: "if there are multiple possible answers, output any one of them."

            So we can output either.

        We test sample test case 2 and 3 in the second branch? But they are handled in the first branch.

        We test sample test case 4: 
            "5 10
             1 0 0 0 0 0 0 0 0 1
             ... edges of a complete graph on 5 vertices: 10 edges.

            T = ceil(5/2)=3.
            total_cap = 1+1 = 2 < 3 -> "No"

            So output "No", which matches.

        Therefore, we code accordingly.

        However, note: the graph may not be simple? But the problem says no multiple edges.

        Let's run the second branch on a small example that fails the first branch: 
            n=3, m=2, edges: [ (1,2), (2,3) ]
            a = [0,2]   # a1=0, a2=2 -> then total_cap=2, T=ceil(3/2)=2 -> so we require 2.
            cnt = 1 (only a2=2) -> which is <2? so we go to the second branch.

            colors_with_index = [(2,1)]  # (a1=2, index1) -> note: the a array has index0: a0=0, index1: a1=2.

            Build graph: 
                graph[1] = [(2,0)]
                graph[2] = [(1,0), (3,1)]
                graph[3] = [(2,1)]

            Start_edge = 0? (the first edge: (1,2))
                comp_edges = {0}
                vertices = {1,2}
                qv = [1,2]
                From u=1: incident edges: edge0 (taken) -> nothing else.
                From u=2: incident edges: edge0 (taken), edge1 (in unused_edges) -> add edge1.
                comp_edges = {0,1} -> size=2 (which is the cap, so stop).

            Then we have total_edges_colored=2>=2 -> "Yes"
            Assign: 
                res = [0]*2
                for edge0: color = 1+1 = 2? 
                for edge1: color = 2? 
                So output: [2,2]

            But the condition: the edges of color2: 
                edge0: (1,2)
                edge1: (2,3)
                They form a connected subgraph? 
                  1-2-3 -> connected? yes.

            So it is valid.

        But wait: we are allowed to use the same color for multiple components? 
            No, we are not: the condition for a color: the entire set of edges of that color must be connected.

            Here we used the same color for two edges, and they are connected? yes.

            But we used the color only once? We used color2 for one component (which is a connected set of two edges). 

            In the second branch, we are using one color per component, and we used the color2 for the entire component? 

            However, note: the BFS we did grew one component. 

            But the problem: we are only allowed to use a color once? 
                The condition: at most a_c edges, and the set of edges of color c must be connected.

            We used 2 edges for color2, which is within the capacity (2), and they are connected.

            So it's valid.

        However, the first branch would not have handled it because cnt=1 < T=2, so we went to the second branch.

        But note: we used the same color for multiple edges, and it is allowed.

        Therefore, the algorithm for the second branch might use a color for more than one edge (as long as the entire set is connected) and that is within the capacity.

        And we are not using the same color for multiple components? Actually, in the second branch, we are iterating over the available colors and each color gets one component. 

        So one color per component, and the entire set of edges of that color is the component, which is connected.

        Therefore, it is valid.

        We'll code accordingly.

        Note: the BFS for a component: 
            We start with an edge and then grow by adding incident unused edges (and the vertices) until we either reach the capacity or run out.

        This is a BFS in the graph of unused edges? 

        We are not building an explicit graph of unused_edges, but we are using the original graph and skipping used edges.

        Complexity: the total work over all components is O(m), because each edge is processed once.

        We'll implement accordingly.

        Let's hope.

        We note: the problem sample test case 1: we output [1,1,1,1] for the four edges? 
            But the sample expected [1,1,0,1]? 
            But the problem accepts any valid solution.

        So we output:

          for test_case in range(C):
              read data

              T = (n+1)//2
              if total_capacity < T: 
                  print("No")
                  continue

              cnt = count of non-zero capacities (a_i>=1)
              if cnt>=T:
                  # do the first branch: assign T distinct colors to T edges (each as a separate component of one edge)
                  # ... 
              else:
                  # do the BFS packing as above

        We output the code.

        Note: the graph building: we assume 1-indexed vertices.

        We'll use:

          graph = [[] for _ in range(n+1)]
          for i in range(m):
              u, v = map(int, line.split())
              graph[u].append( (v, i) )
              graph[v].append( (u, i) )

        And the list of edges we store: edges[i] = (u, v)

        Then we do the BFS for each color.

        We use a set for unused_edges, and we remove from it.

        We use a deque for the BFS of vertices.

        We break if we have used the entire capacity for the color.

        This should be efficient.

        Let's run on sample test case 1 with the BFS: we got a component of 4 edges. 

        But the sample only requires 3. So we could have stopped at 3? 
            We have a cap=4, so we can use up to 4, but we only need 3 in total? 
            However, we are not required to minimize the number of colored edges, and we are allowed to color more.

        Therefore, it is acceptable.

        However, to be safe, we can break the BFS as soon as we have collected 'cap' edges, and we don't care about the total T? because we are packing as many as we can to ensure we reach T.

        But if we stop at cap, we might have a chance to use the next color to cover more edges? But we are processing the largest capacity first, and then we do the next. 

        But we are not constrained to stop at T? We can cover more.

        So we do not break early.

        We'll code accordingly.

        IMPORTANT: In the second branch, we use the available colors (non-zero) sorted by capacity descending. For each color, we grow a component until we reach the capacity or we run out of incident unused edges.

        We hope this works.

        Let me test with the sample test case that has a chain of 4 edges and capacities [2,2] and T=3.

        n=4, m=4, edges: 
            edge0: (1,2)
            edge1: (2,3)
            edge2: (3,4)
            edge3: (4,1)   # but wait, the sample was a chain? 
        Actually, let me do a chain: 1-2-3-4, with edges: (1,2), (2,3), (3,4)

        Then T = ceil(4/2)=2. -> wait, but we require T=2? then the first branch: 
            cnt = number of non-zero capacities = 2 (for the two capacities of 2) -> 2>=2 -> so we do the first branch.

        So to force the second branch, we need T=3.

        Let me make n=5: 
            Vertices: 1,2,3,4,5
            Edges: (1,2), (2,3), (3,4), (4,5) -> 4 edges.
            T = ceil(5/2)=3.
            capacities = [2,2] -> total_cap=4>=3 -> yes.
            cnt=2<3 -> second branch.

        colors_with_index = [(2,0), (2,1)]   # if the a array is [2,2] then we have two colors: index0 and index1.

        Start with the first color (cap=2): 
            start_edge: pick edge0: (1,2)
            comp_edges = {0}
            vertices = {1,2}
            qv = [1,2]
            From 1: nothing (only edge0 is incident, but used) 
            From 2: edge1: (2,3) -> unused -> add it. 
                comp_edges = {0,1} -> cap=2, so break.
            Then unused_edges = {2,3} (edge2: (3,4), edge3: (4,5))

        Then the second color (cap=2): 
            start_edge: edge2: (3,4)
            comp_edges = {2}
            vertices = {3,4}
            qv = [3,4]
            From 3: edge1 (used) and edge2 (used) -> no new? 
            From 4: edge3: (4,5) -> add.
                comp_edges = {2,3} -> cap=2, break.

        Total_edges_colored = 4>=3 -> valid.

        Then we assign:
            color0: edges0 and 1 -> color0+1 = 1 -> so edges0 and 1 get color1? 
            color1: edges2 and 3 -> color1+1=2 -> so edges2 and 3 get color2.

        Then the entire graph is covered? 
            The two components: 
                Component1: edges0 and 1: (1,2) and (2,3) -> connected? 
                Component2: edges2 and 3: (3,4) and (4,5) -> connected.

        So it is valid.

        But what if the capacities were [1,3]? 
            Then we do:
                colors_with_index = [(3,0), (1,1)]   # if a=[3,1] then we sort to [3,1] -> descending: [3,1]

            First color (cap=3): 
                start_edge0: (1,2)
                comp_edges = {0}, vertices={1,2}, qv=[1,2]
                From 1: nothing else.
                From 2: edge1: (2,3) -> add: comp_edges={0,1}
                Then from 3: edge2: (3,4) -> add: comp_edges={0,1,2} -> cap=3, stop.
            Then unused_edges = {3} (edge3: (4,5))

            Second color (cap=1): 
                start_edge = 3: (4,5)
                comp_edges={3}, and then we stop.

            Total_edges_colored=4>=3.

            Then assign:
                color0: edges0,1,2 -> color1
                color1: edge3 -> color2

            Condition: 
                Component1: edges0,1,2: (1,2), (2,3), (3,4) -> connected.
                Component2: edge3: (4,5) -> connected? yes, but the vertices are 4 and 5? connected.

            But wait: the edge3 is (4,5) -> it is connected.

            However, the vertices 4 and 5 are not in the same component as the first? But that is allowed.

        So it is valid.

        We code accordingly.

        Note: the BFS for a component might not be able to grow to the entire capacity if there are not enough unused edges incident to the component.

        But that's okay: we take as many as we can.

        We hope.

        We output the code.

        IMPORTANT: The global sum of n and m over test cases is 300000, so the total work is 300000.

        We use collections.deque.

        We assume the graph is connected? The problem says the graph is connected.

        But in the BFS, we start with an edge and then we grow: we will get a connected component.

        We'll code.

        Note: the second branch might be heavy if we do BFS for each color, but the total work is the sum of the sizes of the components, and the components are disjoint. So the total work is O(m) per test case.

        And the total m over test cases is bounded by the global sum of m, which is at most 300000? (because the sum of (n_i+m_i) over test cases is 300000, and m_i is at least n_i-1, so the total m_i is at most 300000? Actually, the total n_i and m_i over test cases is 300000, so the total m_i is at most 300000.

        So we do:

          from collections import deque

          ...

        Let's code.

        But note: the capacities a_i are given for colors 1 to m. But we only consider non-zero.

        We hope it passes.

        We output the code.

        Note: the sample test case 3 in the sample input: 
            "6 11
             0 0 0 0 0 0 0 3 2 3 3
             ... edges of a complete graph on 6 vertices? 
            T=ceil(6/2)=3.
            total_cap = 3+2+3+3 = 11>=3 -> yes.
            cnt = 4 >=3 -> so we do the first branch.

        Then we output the first branch: 
            We choose the first 3 edges (edge0, edge1, edge2) and assign them three distinct colors from the non-zero colors: 
                non_zero_colors = [8,9,10,11]  -> we take the first three: 8,9,10.

            Then res for the first three edges: [8,9,10] and the rest 8 edges: 0.

            But the sample output for test case 3 is: 
                "11 11 11 0 0 0 0 0 0 0 0"

            But we output: 
                edge0:8, edge1:9, edge2:10, the rest 0.

            This is valid? 
                Condition: 
                    color8: edge0 (one edge) -> connected.
                    color9: edge1 (one edge) -> connected.
                    color10: edge2 (one edge) -> connected.
                And 3 edges >= ceil(6/2)=3.

            So it is valid.

        But the problem says: "if there are multiple possible answers, output any one of them".

        Therefore, we are safe.

        We output the code.

        Let's run on the sample test case 2? 
            The same as test case 3? 
            "6 11
             0 0 0 0 0 0 0 3 2 3 3"
            -> first branch: we output the first 3 edges: [8,9,10] and the rest 0.

            But the sample output for test case 2 is: 
                "8 11 10 10 9 8 8 11 9 10 11"

            That's a different solution.

        We are valid.

        Therefore, we output the code as below.

        Note: the sample test case 1: 
            We do the second branch, and we output [1,1,1,1] for the four edges? 
            But the sample output is [1,1,0,1] for the four edges.

        We are valid.

        We hope.

        We note: the problem constraints: the total sum of n and m over test cases is 300000.

        We use:

          import sys
          from collections import deque

          data = sys.stdin.read().split()
          t = int(data[0])
          index = 1
          out_lines = []

          for _ in range(t):
              n = int(data[index]); m = int(data[index+1]); index+=2
              a_list = list(map(int, data[index:index+m])); index+=m
              edges = []
              for i in range(m):
                  u = int(data[index]); v = int(data[index+1]); index+=2
                  edges.append((u,v))

              T = (n+1)//2

              total_cap = sum(a_list)
              if total_cap < T:
                  out_lines.append("No")
                  continue

              # count non-zero capacities
              cnt = 0
              for x in a_list:
                  if x>=1:
                      cnt += 1

              if cnt >= T:
                  # get the non-zero color indices (1-indexed color: the index in a_list is 0-indexed, the color is the position (starting at 1) of the capacity? 
                  # But the color for the capacity at a_list[i] is i+1.
                  non_zero_colors = []
                  for i in range(m):
                      if a_list[i]>=1:
                          non_zero_colors.append(i+1)
                  # we only need the first T
                  non_zero_colors = non_zero_colors[:T]
                  res = [0] * m
                  # we choose the first T edges (edge0 to edgeT-1) and assign non_zero_colors[0] to edge0, etc.
                  for i in range(T):
                      res[i] = non_zero_colors[i]
                  out_lines.append("Yes")
                  out_lines.append(" ".join(map(str, res)))
              else:
                  # Build graph: list of lists for vertices 1..n
                  graph = [[] for _ in range(n+1)]
                  for i in range(m):
                      u, v = edges[i]
                      graph[u].append( (v, i) )
                      graph[v].append( (u, i) )

                  # Prepare list of non-zero capacities with original index
                  colors_with_index = []  # (capacity, original_index)
                  for i in range(m):
                      if a_list[i] > 0:
                          colors_with_index.append( (a_list[i], i) )
                  # sort descending by capacity
                  colors_with_index.sort(key=lambda x: x[0], reverse=True)

                  unused_edges = set(range(m))
                  components = []  # list of (original_index, set_of_edges)

                  for (cap, color_idx) in colors_with_index:
                      if not unused_edges:
                          break
                      # pick an arbitrary edge from unused_edges
                      start_edge = next(iter(unused_edges))
                      comp_edges = set([start_edge])
                      unused_edges.remove(start_edge)
                      u0, v0 = edges[start_edge]
                      vertices = set([u0, v0])
                      qv = deque([u0, v0])

                      # While we haven't reached cap and the queue is not empty
                      while len(comp_edges) < cap and qv:
                          u = qv.popleft()
                          for (neighbor, eidx) in graph[u]:
                              if eidx in unused_edges:
                                  # take this edge
                                  comp_edges.add(eidx)
                                  unused_edges.remove(eidx)
                                  if neighbor not in vertices:
                                      vertices.add(neighbor)
                                      qv.append(neighbor)
                                  if len(comp_edges) == cap:
                                      break
                      components.append( (color_idx, comp_edges) )

                  total_edges_colored = 0
                  for (color_idx, comp_edges) in components:
                      total_edges_colored += len(comp_edges)

                  if total_edges_colored >= T:
                      res = [0] * m
                      for (color_idx, comp_edges) in components:
                          c = color_idx + 1   # because the color for the capacity at index color_idx is color color_idx+1.
                          for eidx in comp_edges:
                              res[eidx] = c
                      out_lines.append("Yes")
                      out_lines.append(" ".join(map(str, res)))
                  else:
                      out_lines.append("No")

          # Output all lines
          print("\n".join(out_lines))

        We hope.

        Let me test with the sample test case 1: 
            n=5, m=4, a_list = [4,0,0,0] 
            We are in the second branch.
            colors_with_index = [(4,0)]

            Build graph: 
                vertices 1..5: 
                edges = [ (2,3), (2,1), (4,5), (4,3) ]  # edge0: (2,3), edge1: (2,1), edge2: (4,5), edge3: (4,3)

            Then:
                graph[2] = [(3,0), (1,1)]
                graph[3] = [(2,0), (4,3)]   # note: edge3 is (4,3) -> so vertex3: (4,3) and (2,0)
                graph[1] = [(2,1)]
                graph[4] = [(5,2), (3,3)]
                graph[5] = [(4,2)]

            Start_edge = 0: (2,3) -> comp_edges = {0}
            vertices = {2,3}, qv = [2,3]

            u=2: 
                neighbors: 
                    (3,0): already in comp_edges -> skip.
                    (1,1): in unused_edges -> add: comp_edges = {0,1}; remove 1 from unused_edges; then add vertex1 to vertices and qv: vertices={2,3,1}, qv=[3,1]
            u=3:
                neighbors: 
                    (2,0): skip.
                    (4,3): in unused_edges -> add: comp_edges = {0,1,3}; remove 3; add vertex4: vertices={2,3,1,4}, qv=[1,4]
            u=1: 
                neighbors: (2,1): skip.
            u=4: 
                neighbors: 
                    (5,2): in unused_edges -> add: comp_edges = {0,1,3,2}; remove 2; add vertex5: vertices={2,3,1,4,5}, qv=[5]
            Then we break because we have 4 edges (cap=4).

            Then we assign: 
                res = [0,0,0,0] 
                for color0: c = 0+1 = 1 -> assign to edges0,1,3,2: 
                    res[0]=1, res[1]=1, res[3]=1, res[2]=1.
                So res = [1,1,1,1] 

            Output: 
                "Yes"
                "1 1 1 1"

        But the sample expected: "1 1 0 1"

        However, both are valid.

        Therefore, we output.

        We run the provided sample.

        Sample Input #1:
          4
          5 4
          4 0 0 0
          2 3
          2 1
          4 5
          4 3
          6 11
          0 0 0 0 0 0 0 3 2 3 3
          1 2
          2 3
          3 4
          4 5
          5 6
          6 1
          1 4
          4 2
          2 5
          5 3
          4 6
          6 11
          0 0 0 0 0 0 0 3 2 3 3
          1 2
          2 3
          3 4
          4 5
          5 6
          6 1
          1 4
          4 2
          2 5
          5 3
          4 6
          5 10
          1 0 0 0 0 0 0 0 0 1
          1 2
          2 3
          3 4
          4 5
          5 1
          1 3
          3 5
          5 2
          2 4
          4 1

        Expected Output:
          Yes
          1 1 0 1
          Yes
          8 11 10 10 9 8 8 11 9 10 11
          Yes
          11 11 11 0 0 0 0 0 0 0 0
          No

        Our output:

          Test case1: 
              We output: 
                  Yes
                  1 1 1 1   [because we colored all 4 edges?]

          But the sample output for the first test case is: 
                  Yes
                  1 1 0 1

          However, we output a different solution. It's valid.

          Test case2: 
              n=6, m=11, a_list = [0,0,0,0,0,0,0,3,2,3,3] 
              T=3, total_cap=11>=3, cnt=4>=3 -> first branch.
              non_zero_colors: 
                  a_list[7] = 3 -> color8
                  a_list[8] = 2 -> color9
                  a_list[9] = 3 -> color10
                  a_list[10]=3 -> color11
              We take the first T=3: [8,9,10]
              Then we assign the first 3 edges (the first three in the input) to 8,9,10.

              The first three edges: 
                  edge0: 1-2 -> color8
                  edge1: 2-3 -> color9
                  edge2: 3-4 -> color10
              The rest 8 edges: 0.

              So we output: 
                  "8 9 10 0 0 0 0 0 0 0 0"

          But the sample expected:
                  "8 11 10 10 9 8 8 11 9 10 11"

          They colored 11 edges? and we only colored 3.

          Both are valid? 
            Our solution: 
                We have 3 edges, which is >= ceil(6/2)=3.
                Each color: 
                    color8: one edge -> connected.
                    color9: one edge -> connected.
                    color10: one edge -> connected.

            So valid.

          The sample output: 
                They colored every edge. 
                We already saw the capacities: 
                    color8: 3 edges -> okay.
                    color9: 2 edges -> okay.
                    color10: 3 edges -> okay.
                    color11: 3 edges -> okay.
                And each color class is connected? 
                  They provided, and the sample says it's valid.

          Therefore, we output our solution.

          But the problem says: "if there are multiple possible answers, output any one of them."

          So we are free.

          Test case3: 
              The same as test case2? 
              We output: 
                  "8 9 10 0 0 0 0 0 0 0 0"

          But the sample expected: 
                  "11 11 11 0 0 0 0 0 0 0 0"

          They used one color for the first three edges.

          Our solution: we used three colors.

          Both are valid.

          Test case4: 
              n=5, m=10, a_list=[1,0,0,0,0,0,0,0,0,1] -> total_cap=2 < 3 -> "No"

          So we output "No"

        Therefore, our output for the sample:

          Yes
          1 1 1 1
          Yes
          8 9 10 0 0 0 0 0 0 0 0
          Yes
          8 9 10 0 0 0 0 0 0 0 0   # but wait, the second and third test cases are the same? 
                Actually, the input has two different test cases? 
                The sample input has two test cases with 6 and 11 edges? 
                But the graph is the same? 

          So we output for the third test case the same as the second? 
          But note: the second test case: 
                a_list = [0,0,0,0,0,0,0,3,2,3,3] 
                and the third test case: 
                a_list = [0,0,0,0,0,0,0,3,2,3,3] 
                and the edges are the same.

          So we output the same.

        We output:

          Yes
          1 1 1 1
          Yes
          8 9 10 0 0 0 0 0 0 0 0
          Yes
          8 9 10 0 0 0 0 0 0 0 0
          No

        But the sample expected for the third test case: 
          "11 11 11 0 0 0 0 0 0 0 0"

        And the problem says "any valid solution", so we are valid.

        We'll hope it passes.

        Note: the problem says the total n and m over test cases is 300000, so we must be efficient.

        We output the code.

        One more note: in the first branch, we assign the first T edges. But what if the graph has more than T edges? We only color T edges. 

        This is valid.

        Let me test with a small graph that has multiple edges incident to a vertex: 
            n=3, m=3, edges: (1,2), (2,3), (1,3)
            a = [1,1,1] -> T=2.
            Then we are in the first branch: cnt=3>=2.
            We choose the first 2 edges: 
                edge0: (1,2) -> assign color0+1=1
                edge1: (2,3) -> assign color1+1=2
                edge2: uncolored.
            Then the coloring: [1,2,0]

            Condition: 
                color1: edge0: (1,2) -> connected.
                color2: edge1: (2,3) -> connected.

            And 2>=ceil(3/2)=2.

            Valid.

        But if the first two edges are not incident, then they form two separate components? 
            Example: edges: 
                edge0: (1,2)
                edge1: (3,4)  # but wait, n=3, so we don't have vertex4.

            In a triangle, the first two edges are incident? 

        So it's safe.

        We output.

        IMPORTANT: The indices in the graph building: the edge index i is the input order.

        We are using the same input order for the edges.

        We are done.

        Let's code accordingly.