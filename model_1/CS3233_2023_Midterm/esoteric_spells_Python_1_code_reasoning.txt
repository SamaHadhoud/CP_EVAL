 We are given up to 100 test cases, each with up to 100 numbers (n<=100) and a_i up to 10^18.
 The key insight: the maximum XOR we can get from numbers chosen from the intervals [0, a_i] is the bitwise OR of all a_i.

 Why?
 Consider that the XOR of multiple numbers can have a bit set only if at least one of the numbers has that bit set.
 The OR of all a_i (call it T) is the number that has a bit set if it is set in at least one a_i.
 Moreover, we can assign the numbers such that each bit set in T is set in an odd number of the chosen x_i.

 How to assign?
 We'll initialize an array x = [0] * n.
 Then, for each bit j (from 0 to 60, since 10^18 < 2^60), if the j-th bit is in T (i.e., set in at least one a_i), then:
   - We list all the indices i for which a_i has the j-th bit set (meaning they can set the j-th bit in their x_i).
   - We need an odd number of these indices to have the j-th bit set in their x_i. Initially, we have a list L of candidate indices.

   However, note: we are setting bits one by one. We might set multiple bits in the same x_i. But note that if we set the j-th bit in an x_i, we must ensure that x_i does not exceed a_i. Since a_i has the j-th bit set, setting the j-th bit in x_i is safe (because x_i will be at most a_i: we are only setting bits that a_i has).

   But here's the catch: we are going to set the j-th bit in some of the indices. However, if the number of indices in L is even, we cannot set the bit in all of them (because then the j-th bit would appear an even number of times and would cancel out). Therefore, we remove one index (for example, the last in the list) to make the count odd.

   Then, for every index in the (possibly reduced) list L, we set the j-th bit in x_i.

 However, we must be cautious: setting a bit in x_i might cause x_i to become larger than a_i? 
   Actually, we are only setting bits that are present in a_i. Moreover, we are setting bits from high to low? But note: the problem does not require a particular order? However, there is a potential issue: if we set a bit j in an x_i, but then later set a higher bit, that might push x_i above a_i? Actually, we are going from low bit to high bit? 

 But note: we are iterating j from 0 to 60 (low to high). However, when we set a bit j, we are adding 2^j. Since a_i has the j-th bit set, then even if we set all bits from 0 to j, the value would be at most (2^(j+1)-1, which is less than the next higher bit. But note: a_i might not have all the lower bits? 

 Actually, the problem is: we might set a bit j that is present in a_i, but then when we set a higher bit k (k>j) in the same x_i, we must check that the resulting number does not exceed a_i.

 However, consider: we are only setting bits that are present in T (which is the OR of all a_i) and for a particular x_i, we set a bit j only if a_i has that bit. But note: T might have a bit that a_i has, but if we set too many bits in x_i, the total might exceed a_i.

 Example: 
   a_i = 5 (binary 101). 
   We set bit0: set to 1 -> x_i=1 (<=5, safe)
   Then we set bit2: set to 4 -> then x_i becomes 1+4=5 (<=5, safe).

 But what if we set bits in an arbitrary order? Actually, we are setting independently: we are ORing the bits. The resulting x_i is the OR of all the bits we set for that index. Since each bit we set is in a_i, and a_i has the property that the bits we set form a subset of the bits in a_i, then the value we form for x_i will be <= a_i. Why? Because the number formed by any subset of the bits of a_i is <= a_i.

 However, note: the bits we set for one x_i are exactly the bits j (from the entire range) for which we decided to set and that index i was in the (reduced) list for that bit. And we only set bits that are in a_i. Therefore, the resulting x_i is a subset of bits of a_i, so it is <= a_i.

 Therefore, the assignment is valid.

 But note: what if for a given bit j, we have an odd number of indices in L? Then we set the bit in all of them? Actually, we set the bit in the entire (reduced) list. And if it was odd, we leave the list as is.

 However, what if the list L has even length? Then we remove one index (say the last one) to make it odd. Then we set the bit in the remaining indices.

 This ensures that the j-th bit is set in an odd number of the x_i, so the XOR result will have the j-th bit set.

 What about bits not set in T? Then we don't set them in any x_i, so the XOR result won't have that bit.

 Therefore, the XOR of the x_i will be T.

 Steps:
   For each test case:
      n = int(input())
      a = list of n integers

      T = a[0] | a[1] | ... | a[n-1]

      Initialize x = [0]*n

      For j in range(0, 61):   # 0 to 60
          bit = 1 << j
          if T has the j-th bit set:
             L = list of indices i such that a[i] has the j-th bit set.
             if len(L) is even:
                 remove one element from L (for example, the last element) to make it odd.
             For each index i in L:
                 x[i] |= bit

      Then output T and then the list x.

 However, let's test with the sample: "3\n3 7 1"

   a = [3, 7, 1]
   T = 3 | 7 | 1 = 7 (binary 111)

   Now we break down by bit:

     bit0 (1 << 0 = 1): 
        T has bit0? 7 has bit0 -> yes.
        Which a_i have bit0? 
           3 (binary 11) -> has bit0? yes (last bit is 1)
           7 (111) -> yes
           1 (1) -> yes
        L = [0,1,2] -> length=3 (odd) -> we set x[0], x[1], x[2] to have bit0: 
           x[0]=1, x[1]=1, x[2]=1.

     bit1 (1<<1=2):
        T has bit1? 7 has bit1 -> yes.
        Which a_i have bit1?
           3: 3 in binary: 11 -> bit1 is set? yes (because 3>=2 and 3 & 2 !=0)
           7: yes
           1: 1 in binary: 01 -> no.
        L = [0,1] -> even -> remove one (say the last one -> index1) so now L=[0]
        Set bit1 in x[0]: x[0] = 1 | 2 = 3.

     bit2 (1<<2=4):
        T has bit2? 7 has bit2 -> yes.
        Which a_i have bit2?
           3: 3 < 4? -> no, but 3 in binary: 11 -> no bit2? actually 3 has no bit2 (bit2 is the 4's place) -> so no.
           7: 7 in binary: 111 -> bit2 is set? yes (because 4 is 100, and 7>=4 and 7 & 4 !=0)
           1: no.
        L = [1] -> odd -> set bit2 in x[1]: x[1] = 1 | 4 = 5.

     bit3 and above: T has no bits beyond bit2.

     So we have x = [3,5,1] -> which matches sample.

   Now sample 2: "4\n3 2 3 3"
      a = [3,2,3,3]
      T = 3 | 2 | 3 | 3 = 3 | 2 = 3 (binary 11)

      bit0 (1):
          T has bit0? 3 has bit0 -> yes.
          Which a_i have bit0?
             3: yes -> indices 0,2,3
             2: 2 in binary: 10 -> bit0 is 0 -> no.
          So L = [0,2,3] -> odd -> set bit0 in x0, x2, x3 -> [1,0,1,1]

      bit1 (2):
          T has bit1? yes.
          Which a_i have bit1?
             3: yes -> indices 0,2,3
             2: yes -> index1
          L = [0,1,2,3] -> even -> remove one (say the last one: index3) -> L=[0,1,2]
          Set bit1 in x0, x1, x2:
             x0: 1 | 2 = 3
             x1: 0 | 2 = 2 -> but wait, a1=2, so 2 is allowed? yes. But note: we set 2 for x1? but then later we don't set anything else? 
             x2: 1 | 2 = 3
          Now x = [3,2,3,1] -> but wait, we set x3 to 1? and we didn't set bit1 in x3? that's correct.

      Now check: 3 XOR 2 XOR 3 XOR 1 = (3 XOR 3) XOR (2) XOR 1 = 0 XOR 2 XOR 1 = 3 -> correct.

      However, the sample output is "3 0 3 3", which also gives 3 XOR 0 XOR 3 XOR 3 = (3 XOR 3 XOR 3) XOR 0 = 3.

      But our assignment is [3,2,3,1]. Why the sample output is [3,0,3,3]? 
      The problem says: "If there are multiple possible answers, output any one of them."

      So both are valid. However, the problem sample output is [3,0,3,3]. 

      Why did we get [3,2,3,1]? 
        For bit0: we set indices 0,2,3 to 1 -> so x0=1, x2=1, x3=1.
        For bit1: we set indices 0,1,2 to 2 -> so x0=1+2=3, x1=2, x2=1+2=3, x3 remains 1.

      How can we get [3,0,3,3]? 
        For bit0: we set in an odd number of the indices that can set bit0: 
            We have indices 0,2,3 (for a_i that have bit0) -> we could set in two of them (say 0 and 2) and not set in 3? but then we have even (two) set? so we need one more? Actually, we must set an odd number. 
        Alternatively, we can choose which one to remove arbitrarily? 

      The algorithm above for bit0: 
          L = [0,2,3] -> odd -> we set all -> so we get 1 in all three.

      But if we change the removal strategy: for the even case we remove one arbitrarily, but for the odd case we do nothing. 

      However, for the bit0 we didn't have to remove. But for bit1 we had to remove one. We removed the last one (index3) in the list for bit1? 

      But note: for bit1, the list L was [0,1,2,3] (because a0,a2,a3 have bit1? actually, 3 has bit1? yes, and a1=2 has bit1? yes). We then removed the last one (index3) to get [0,1,2]. 

      How to get the sample output? 
        In the sample output: 
          x0=3 (binary 11) -> bits0 and 1 set.
          x1=0 -> no bits set.
          x2=3 -> bits0 and 1 set.
          x3=3 -> bits0 and 1 set.

        For bit0: 
          We set in indices 0,2,3 -> that's three (odd) -> so that matches.
        For bit1:
          We set in indices 0,2,3 -> that's three (odd) -> so we should set bit1 in x0,x2,x3.

        How do we get that? 
          For bit1: the list L is [0,1,2,3] (because a0=3 has bit1, a1=2 has bit1, a2=3 has bit1, a3=3 has bit1). 
          Then we have to remove one to make it odd. We can remove any one. If we remove index1 (the second element) then we get [0,2,3] and then we set bit1 in x0, x2, x3 -> which gives x0=1 | 2 = 3, x1=0 (not set), x2=1 | 2 = 3, x3=1 | 2 = 3.

        That yields [3,0,3,3] -> the sample output.

      So we can change the removal: instead of removing the last element, we can remove a specific one? How about we remove the first element? or the last? It doesn't matter as long as we remove one. But note: we want to avoid setting the bit1 in x1? because then we get 2 for x1? but the sample output has x1=0.

      Therefore, we can modify: for the even case, we remove the last element? But that gave us [3,2,3,1] for the second sample. To get the sample output, we need to remove a different element.

      However, the problem does not require a specific assignment. But the sample output is [3,0,3,3]. 

      Since the problem says "any one", we can choose arbitrarily. But note: we have to make sure that the assignment we produce is valid.

      How about we remove the element that has the smallest a_i? or the largest? Actually, it doesn't matter. But let's try to avoid setting a bit in an a_i that is exactly 0? 

      Actually, note: if an a_i is 0, then the only spell is 0. Then we cannot set any bit in that x_i. 

      However, in the list L for a bit j, we only include i if a_i has the j-th bit set. If a_i is 0, then it has no bits set, so it won't be included in any L. So we are safe.

      Therefore, we can remove any element arbitrarily. But to match the sample, we can remove the element that we don't want to set? 

      However, the problem does not require matching the sample output exactly. But the sample input 2 must output 3 and then an assignment that gives 3.

      We can change the removal: remove the first element? 

      Let's try for sample 2 with removal of the first element in the even list:

        bit0: 
          L = [0,2,3] -> odd -> set in all: x0=1, x2=1, x3=1.
        bit1:
          L = [0,1,2,3] -> even -> remove the first element (index0) -> then L = [1,2,3] -> odd -> set bit1 in x1, x2, x3.
          Then x1 = 0 | 2 = 2, x2 = 1 | 2 = 3, x3 = 1 | 2 = 3, and x0 remains 1.
          Then we get [1,2,3,3] -> XOR: 1 XOR 2 XOR 3 XOR 3 = 1 XOR 2 = 3 -> correct.

      But that doesn't match the sample output.

      Alternatively, remove the last element? as originally? then we get [3,2,3,1] -> which is also correct.

      How about we remove the element that has the smallest value? 

      Actually, we don't care. The problem says "any one". 

      But note: the sample output is [3,0,3,3]. How can we get that? 
          For bit1: we set in indices 0,2,3 and skip index1. So we must remove index1 from the list for bit1.

      How about: for the even case, we try to remove an element that we have not set any bit yet? Or we can remove an element arbitrarily? 

      However, note: we are processing bits from low to high. We have already set the lower bits. 

      Actually, we can decide which one to remove arbitrarily. Since the problem does not specify, we can remove the last element for simplicity.

      But the sample input 2 in the problem output is "3 0 3 3". How did they get that? 
          They set x1 to 0. That means they did not set any bit in x1.

      How can we do that? 
          For bit0: we set in indices 0,2,3 -> so we skip index1 -> so that's fine.
          For bit1: we set in indices 0,2,3 -> skip index1 -> so we set bit1 in x0,x2,x3.

      How to get that in our algorithm?
          For bit0: we have L = [0,2,3] -> odd -> set all -> so we set bit0 in x0,x2,x3 -> then x1 remains 0? but we haven't set anything in x1? 
          Then for bit1: we have L = [0,1,2,3] -> even -> we remove one. If we remove index1, then we set in [0,2,3] -> which is what we want.

      So if we remove the element that we don't want to set? 

      Actually, we can remove the element that has the smallest a_i? Or we can remove an element that we are going to set as few as possible? 

      But note: we are building the number for each x_i. We don't have a preference. 

      However, we can remove the element that has the smallest a_i? Actually, the problem doesn't specify. 

      Alternatively, we can remove the element that has the smallest index? the largest? 

      Let me try: for the even case, remove the first element? 
          Then for bit1: remove index0 -> then we set indices1,2,3 -> then x0=1 (only bit0) -> x1=2, x2=1|2=3, x3=1|2=3 -> then we get [1,2,3,3] -> which is valid.

      How about we remove the last element? 
          Then for bit1: remove index3 -> then we set indices0,1,2 -> then x0=1|2=3, x1=2, x2=1|2=3, x3=1 -> [3,2,3,1] -> valid.

      How about we remove the one that has the smallest a_i? 
          In the list L for bit1: 
            indices: 0: a0=3, 1: a1=2, 2: a2=3, 3: a3=3.
          The smallest a_i is at index1 (a1=2). So we remove index1 -> then we set in indices0,2,3 -> then we get x0=1|2=3, x1=0, x2=1|2=3, x3=1|2=3 -> [3,0,3,3] -> the sample output.

      Therefore, we can remove the element in L that has the smallest a_i? 

      Why remove the smallest a_i? 
          Because we are setting a bit j. We want to avoid pushing an x_i beyond its a_i? But note: we are only setting bits that are in a_i, and we are setting them independently. The value of x_i is the OR of the bits we set for it. Since each bit we set is in a_i, then x_i <= a_i. So we don't have to worry.

      However, there is no harm. And if we remove the smallest a_i, we might avoid setting a bit in a spellcaster that has a very small a_i? But we are only setting bits that the a_i has. 

      Actually, we are only including i in L if a_i has the bit. So setting the bit j in x_i is safe. 

      Therefore, we can remove arbitrarily. But the problem sample output used [3,0,3,3] and they removed the one with the smallest a_i? 

      We can do: for the even case, we remove the element i in L that has the smallest a_i. Why? 
          Because if we set a lot of bits in a spellcaster that has a small a_i, we might run into problems? Actually, we are only setting the bits that are in a_i, so the x_i will not exceed a_i. 

      But there is no such problem. However, if we remove the smallest a_i, then we avoid setting that bit in the one that has the smallest a_i? and that might be beneficial for setting higher bits? 

      Actually, note: we are processing from low bit to high bit. The higher bits are more significant. But the assignment for each bit is independent? 

      However, consider: if we set a low bit in a spellcaster that has a very small a_i (for example, a_i=1, which only has bit0), then when we process higher bits, we cannot set any higher bit in that spellcaster. But that is inherent: we cannot set a higher bit if a_i doesn't have it. 

      Therefore, it doesn't matter which one we remove. But to match the sample output, we remove the element in L with the smallest a_i.

      How about: we sort L by a_i in ascending order and then remove the last element? or the first? 

      Actually, we want to remove one element to make the list odd. We choose the element with the smallest a_i to remove? 

      Why? Because if we remove an element that has a small a_i, then we free up the higher bits for the others? But note: the higher bits are independent: we only set bits that are in a_i. 

      However, we can do: 
          In the even case, we remove the element in L that has the smallest a_i. 

      Why the smallest? 
          The sample: for bit1, the list L=[0,1,2,3] -> the a_i values: [3,2,3,3]. The smallest a_i is 2 (at index1). So we remove index1.

      How to implement?
          For each bit j:
            L = [i for i in range(n) if (a[i] has bit j)]
            if len(L) % 2 == 0:
                if L is not empty:
                    # find the element in L with the smallest a_i
                    min_val = a[L[0]]
                    min_index_in_L = 0
                    for pos in range(1, len(L)):
                        if a[L[pos]] < min_val:
                            min_val = a[L[pos]]
                            min_index_in_L = pos
                    # remove the element at min_index_in_L
                    L.pop(min_index_in_L)

      Then set the bit j for all i in L.

      Alternatively, we can do:

          min_index = None
          for i in L:
              if min_index is None or a[i] < a[min_index]:
                  min_index = i
          Then we remove min_index from L? But note: L is a list of indices. We want to remove the element that has the smallest a_i. But we have to remove one occurrence. We can do:

          candidate = min(L, key=lambda i: a[i])
          Then remove one occurrence of candidate? 

          Actually, we can create a new list without the candidate? But note: what if there are multiple with the same smallest a_i? Then we remove one of them (the first occurrence? or any one). 

          We can do: 
            min_val = min(a[i] for i in L)
            for idx, i in enumerate(L):
                if a[i] == min_val:
                    del L[idx]
                    break

      But note: we only need to remove one element.

      However, we must consider: what if the smallest value appears multiple times? Then we remove one of them (the first one we find).

      But the problem does not specify which one to remove. 

      Alternatively, we can do:

          if L:
              min_val = a[L[0]]
              min_pos = 0
              for idx in range(1, len(L)):
                  if a[L[idx]] < min_val:
                      min_val = a[L[idx]]
                      min_pos = idx
              L.pop(min_pos)

      This removes the first occurrence of the smallest a_i in L.

      Then we set the bit for the rest.

      Let's test with the second sample for bit1:
          L = [0,1,2,3] -> 
            a[0]=3, a[1]=2, a[2]=3, a[3]=3 -> the smallest a_i is 2 at index1 -> which is at position 1 in L -> we remove L[1] -> so L becomes [0,2,3] -> then we set bit1 in x0, x2, x3.

      Then the assignment for the second sample becomes:
          x0 = 1 (from bit0) | 2 (from bit1) = 3
          x1 = 0 (because we didn't set any bit? actually we set bit0? no: for bit0, we set indices0,2,3 -> so x1 was not set in bit0 -> and then for bit1 we skipped x1 -> so x1=0.
          x2 = 1 (bit0) | 2 (bit1) = 3
          x3 = 1 (bit0) | 2 (bit1) = 3

      So we get [3,0,3,3] -> which matches the sample.

      Therefore, we can use: for the even case, remove the element in L that has the smallest a_i (and if there are multiple, we remove the first one that we find with the smallest a_i).

      However, we must be cautious: what if we remove an element that we set in a previous bit? 
          But note: we are processing from low to high. The assignment for previous bits is already done. We are only setting the current bit. Removing the element from L for the current bit only means we won't set the current bit in that element. 

      But the element might have been set in previous bits. That is okay. We are not changing the previous bits.

      Therefore, the plan is:

        T = OR of all a_i

        x = [0]*n

        for j in range(0, 61):
            bit = 1 << j
            if T has the j-th bit:
                L = [i for i in range(n) if a[i] & bit]
                if len(L) % 2 == 0:
                    if L: 
                        # find the element in L with the smallest a_i and remove one occurrence of it
                        min_val = a[L[0]]
                        min_idx_in_L = 0
                        for pos in range(1, len(L)):
                            if a[L[pos]] < min_val:
                                min_val = a[L[pos]]
                                min_idx_in_L = pos
                        L.pop(min_idx_in_L)
                for i in L:
                    x[i] |= bit

      Then output T and x.

      But note: what if L is empty? then we skip. But if T has the bit, then by definition there must be at least one a_i that has the bit? So L cannot be empty. 

      Therefore, we are safe.

      However, what if the even case: L is non-empty? we remove one and then set the rest? 

      This should work.

      Let me test with the first sample: 
        a = [3,7,1]
        T = 7.

        bit0: 
          L = [0,1,2] -> odd -> no removal -> set bit0 in all: x=[1,1,1]
        bit1:
          L = [0,1] -> even -> remove the smallest a_i: 
              a[0]=3, a[1]=7 -> smallest is 3 at index0 -> remove index0 -> then L=[1] -> set bit1 in x1 -> x1 = 1 | 2 = 3 -> but wait, then we get x0=1, x1=3, x2=1 -> then XOR = 1^3^1 = 3 -> not 7.

      Oh no! That doesn't work.

      What happened? 
          We need the XOR to be 7 (111). 
          We set:
            bit0: set in all -> so the XOR for bit0 is 1 (because 3 ones: 1 XOR 1 XOR 1 = 1) -> that's correct (bit0 set in 7).
            bit1: set in x1 only -> then the XOR for bit1: 0 (from x0) XOR 1 (from x1: because 3 in binary? 3 is 11 -> bit1 is set? yes) XOR 0 (from x2: 1 has bit1? no) -> so the bit1 is set in only one -> so it will be set in the XOR? yes -> so we have 3 (binary 11) so far? but 7 has bit2 as well.

          bit2: 
            L = [1] (because only a1=7 has bit2) -> odd -> set bit2 in x1 -> x1 = 3 | 4 = 7.

          Then x = [1,7,1] -> XOR: 1 XOR 7 XOR 1 = 7.

          So that works. 

          But why did we get 1 XOR 7 XOR 1 = 7? 
            1: 001
            7: 111
            1: 001
            XOR: 001 XOR 111 = 110, then 110 XOR 001 = 111 -> 7.

          So it is correct.

      However, the sample output was [3,5,1] -> which is also correct.

      So both are valid. 

      Therefore, the algorithm is:

        T = 0
        for each a_i: T |= a_i

        x = [0] * n

        for j in range(61):
            bit = 1 << j
            if T & bit:
                L = []
                for i in range(n):
                    if a[i] & bit:
                        L.append(i)
                if len(L) % 2 == 0:
                    if L:
                        # Find the index in L with the smallest a[i]
                        min_val = a[L[0]]
                        min_pos = 0
                        for idx in range(1, len(L)):
                            if a[L[idx]] < min_val:
                                min_val = a[L[idx]]
                                min_pos = idx
                        L.pop(min_pos)
                for i in L:
                    x[i] |= bit

        Output T and then x.

      We'll run the first sample: 
        a = [3,7,1] -> T=7.

        j=0 (bit=1): 
            L = [0,1,2] -> even? no -> so we set x[0] |=1 ->1, x[1]|=1->1, x[2]|=1->1.

        j=1 (bit=2):
            L = [0,1] -> even -> remove the one with smallest a_i: 
                a[0]=3, a[1]=7 -> smallest is a[0]=3 -> remove index0 -> L=[1]
            set x[1] |= 2 -> 1|2=3.

        j=2 (bit=4):
            L = [1] -> odd -> set x[1] |=4 -> 3|4=7.

        So x = [1,7,1] -> which is valid: 
            x0=1 <=3, x1=7<=7, x2=1<=1.
        And XOR = 1^7^1 = 7.

      So we have two valid assignments: [3,5,1] and [1,7,1]. 

      The problem says "any one", so both are acceptable.

      Therefore, we'll implement with the removal of the element with the smallest a_i in the even case.

      Complexity: 
          We have up to 61 bits, and for each bit we iterate over at most 100 elements (n<=100). The inner loop for removal also is O(n). So total 61 * 100 * 100? Actually, the removal loop (to find the min) is O(n). So total O(61 * n) which is acceptable.

      Let's code accordingly.

      Note: We must be cautious for j from 0 to 60 (inclusive) because 10^18 < 2^60, so we go from 0 to 60 (61 bits).

      We'll write the code accordingly.

      Edge: n=0? but n>=1.

      Let me test with the provided samples.

      Sample1: [3,7,1] -> T=7, then we get [1,7,1] (if we remove the smallest a_i for the even case at bit1) but the sample output was [3,5,1]. 
          However, the problem says "any one", so we can output [1,7,1] as well.

      But the problem sample output is:

          7
          3 5 1

      We are getting:

          7
          1 7 1

      That is acceptable.

      However, if we want to exactly match the sample output, we might need a different removal strategy? 

      But the problem does not require matching the sample output exactly. 

      Alternatively, we can note: the sample output [3,5,1] is achieved by:

          bit0: set in all -> [1,1,1]
          bit1: set in indices0 and1? -> but then we have two -> even -> so we remove one? which one? 
                If we remove index2? but index2 is not in L for bit1 (because a2=1 doesn't have bit1). 
                Then we set in indices0 and1: x0=1|2=3, x1=1|2=3 -> then for bit2: 
          bit2: L=[1] -> set in x1: x1=3|4=7 -> then we have [3,7,1] -> which gives 3^7^1=5, not 7.

      Actually, the sample output [3,5,1] is achieved by:
          x0=3 (binary 11), x1=5 (101), x2=1 (001) -> 3^5^1 = 7.

      How to get 5? 
          bit0: set? in x0: set, x1: set (5 has bit0? 5 mod 2=1 -> set), x2: set -> so we set bit0 in all three? -> that's the same as we did.
          bit1: 
             x0: set (3 in binary: 11 -> bit1 set), 
             x1: 5: 101 -> bit1 not set? 
             x2: not set.
          So we set bit1 in only one? -> then the XOR for bit1 is set? but we want 7 (111) -> bit1 must be set? 
          However, 7 in binary: 111 -> bit1 is set. How do we set bit1 in an odd number? 
          In this assignment, bit1 is set only in x0 -> one -> odd -> so it is set.

          bit2: 
             x0: 3 -> 11 -> no bit2? 
             x1: 5 -> 101 -> bit2 set (the 4's place) -> so set in one -> odd -> set.
             x2: not set.

          Therefore, the assignment [3,5,1] has:
            bit0: set in three -> odd -> set.
            bit1: set in one -> odd -> set.
            bit2: set in one -> odd -> set.

          So the XOR is 111 = 7.

      How did they get 5? 
          For x1: they set bits0 and bit2 -> 1+4=5.

      How can we get that in our algorithm? 
          For bit0: we set in all -> [0,1,2] -> set to 1 in each.
          For bit1: 
             L = [0,1] -> even -> we remove the one with the smallest a_i? 
                 a0=3, a1=7 -> smallest is a0=3 -> so we remove index0 -> then we set bit1 only in index1 -> then x1 = 1 | 2 = 3.
          For bit2: 
             L = [1] -> set bit2 in x1 -> then x1 = 3 | 4 = 7.

          Then we get x0=1, x1=7, x2=1.

      How to get x1=5? 
          We need to set bit0 and bit2 in x1, but not bit1.

          How about: for bit1, we remove index1 instead of index0? 
          Then we set bit1 in index0 -> then x0=1|2=3, and x1 remains 1 (from bit0) -> then for bit2: we set in x1 -> x1=1|4=5.

          Then we get [3,5,1] -> the sample output.

      How to decide to remove index1? 
          We remove the element with the smallest a_i? 
          a0=3, a1=7 -> smallest is a0? so we remove index0.

      But if we remove the element with the largest a_i? then we remove index1 -> then we set bit1 in index0 -> and then we get [3,5,1].

      Therefore, we can remove the element with the largest a_i? 

      Actually, we can remove arbitrarily. The problem does not specify. 

      But to get the sample output, we can remove the element with the largest a_i? 

      Why? 
          In the sample output, they set bit1 in the one that has a_i=3 (the smallest) and skip the one with a_i=7 (the largest) for bit1? 
          Actually no: they set bit1 in x0 (a0=3) and skipped x1 (a1=7) for bit1? 

      How about: we remove the element with the largest a_i? 
          Then for bit1: 
              L=[0,1] -> we remove the one with the largest a_i -> a1=7 -> remove index1 -> then we set bit1 in index0 -> then we get x0=3, x1 remains 1 -> then for bit2: set in x1 -> x1=5.

      That gives [3,5,1] -> the sample output.

      So we can do: 
          if even:
             remove the element with the largest a_i? 

      But then test sample2: 
          a=[3,2,3,3]
          bit0: L=[0,2,3] -> odd -> set all -> x0=1, x2=1, x3=1.
          bit1: L=[0,1,2,3] -> even -> remove the element with the largest a_i? 
                a0=3, a1=2, a2=3, a3=3 -> the largest is 3, and there are multiple. We remove the first one that has the largest? 
                Let's remove the first one with a_i=3 (which is index0) -> then L=[1,2,3] -> then set bit1 in x1,x2,x3 -> 
                x1=0|2=2, x2=1|2=3, x3=1|2=3 -> then x0=1 -> [1,2,3,3] -> which is valid.

          But the sample output was [3,0,3,3]. 

      How can we get [3,0,3,3]? 
          We remove the element with a_i=2? which is the smallest? 

      Therefore, we have two possibilities: 
          Possibility 1: remove the smallest a_i -> then we get [3,0,3,3] for sample2, and [1,7,1] for sample1.
          Possibility 2: remove the largest a_i -> then we get [3,5,1] for sample1, and [1,2,3,3] for sample2.

      The problem says "any one".

      Since the problem sample output uses:
          sample1: [3,5,1]
          sample2: [3,0,3,3]

      We can try to mimic that by:
          For sample1, we remove the largest a_i for the even case? 
          For sample2, we remove the smallest a_i for the even case? 

      But we want a consistent rule.

      Alternatively, we can note: 
          In sample1, the sample output removed the largest a_i? 
          In sample2, the sample output removed the smallest a_i? 

      Actually, for sample1: 
          For bit1: we had L=[0,1] -> we removed index1 (which has a_i=7, the largest) -> then we set bit1 in index0 -> got 3 in x0.
      For sample2:
          For bit1: we had L=[0,1,2,3] -> we removed index1 (which has a_i=2, the smallest) -> then we set bit1 in the others -> got 3,0,3,3.

      Therefore, we can do: 
          if even:
              # We want to remove one element. 
              # We choose: 
              #   If we remove the largest a_i, we might leave the smaller ones to be set? 
              #   Or remove the smallest? 
              # The problem sample outputs are inconsistent.

      But note: the problem sample outputs are two different test cases.

      How about we remove the element that has the smallest a_i? 
          Then sample1: [1,7,1] -> valid.
          sample2: [3,0,3,3] -> valid and matches sample output for sample2.

      How about we remove the element that has the largest a_i? 
          sample1: [3,5,1] -> matches sample output for sample1.
          sample2: [1,2,3,3] -> valid, but not the sample output.

      Since the problem says "any one", both are acceptable.

      However, the problem sample output for sample1 is [3,5,1] and for sample2 is [3,0,3,3]. 

      We can produce both if we do:

          In the even case, remove the element with the largest a_i for the first sample and remove the element with the smallest a_i for the second sample? 

      But we don't know which test case is which.

      We can decide arbitrarily. 

      Let me choose: remove the smallest a_i. Then sample2 matches. For sample1 we get [1,7,1] which is valid.

      Alternatively, remove the largest a_i: then sample1 matches, sample2 is [1,2,3,3] which is valid.

      The problem does not specify. 

      Since the problem sample output for sample1 is [3,5,1] and sample2 is [3,0,3,3], and the problem statement, I'll choose the removal strategy that matches sample1: remove the largest a_i? 

      But then sample2 output is not matching.

      How about we do: 
          if we are in the first test case, remove the largest? 
          if we are in the second test case, remove the smallest? 

      But we don't know the test case order.

      Alternatively, we can do a hybrid: 
          We want to be able to set as many high bits as possible? 
          Removing a spellcaster with a large a_i might be better because that spellcaster can potentially set higher bits? 

          However, if we remove a spellcaster with a small a_i, then we free up that spellcaster from setting this bit, but it might not be able to set higher bits anyway.

      Actually, it doesn't matter. 

      We'll choose to remove the largest a_i? 

      Then for sample1 we get the sample output [3,5,1]? 
          Let me simulate with removal of the largest a_i:

        sample1: a=[3,7,1]
          bit0: set in all: [0,1,2] -> set to 1 -> x=[1,1,1]
          bit1: L=[0,1] -> even -> remove the one with the largest a_i: 
                a0=3, a1=7 -> largest is a1=7 -> remove index1 -> then L=[0] -> set bit1 in x0: x0=1|2=3 -> then x=[3,1,1]
          bit2: L=[1] -> set bit2 in x1: x1=1|4=5 -> then x=[3,5,1] -> matches.

        sample2: a=[3,2,3,3]
          bit0: L=[0,2,3] -> odd -> set to 1 -> x0=1, x1=0, x2=1, x3=1.
          bit1: L=[0,1,2,3] -> even -> remove the largest a_i? 
                The a_i: 3,2,3,3 -> largest is 3 -> we remove the first occurrence (index0) -> then L=[1,2,3] -> set bit1 in x1,x2,x3 -> 
                x1=0|2=2, x2=1|2=3, x3=1|2=3 -> then x=[1,2,3,3] -> which is valid.

          But the sample output for sample2 is [3,0,3,3]. 

      How about we remove the last occurrence of the largest a_i? 
          In sample2, the largest a_i=3, the last occurrence is index3? 
          Then remove index3 -> then L=[0,1,2] -> then set bit1 in x0,x1,x2 -> 
          x0=1|2=3, x1=0|2=2, x2=1|2=3, x3=1 -> then [3,2,3,1] -> valid.

      Or remove the smallest a_i? 
          In sample2: the smallest a_i=2 (at index1) -> remove index1 -> then L=[0,2,3] -> set bit1 in x0,x2,x3 -> 
          x0=1|2=3, x1=0, x2=1|2=3, x3=1|2=3 -> [3,0,3,3] -> which matches sample2.

      Therefore, to match both sample outputs, we would need to remove the largest a_i for sample1 and the smallest a_i for sample2.

      But we don't know which test case is which.

      Since the problem says "any one", we can choose one strategy consistently.

      Let's choose to remove the smallest a_i in the even case. Then:

        sample1: 
          Output: 7
          Assignment: [1,7,1]

        sample2:
          Output: 3
          Assignment: [3,0,3,3]

      This matches sample2 but not sample1's assignment.

      But the problem sample output for sample1 is [3,5,1], not [1,7,1]. 

      How about we try a different removal strategy for even case: 
          We remove the first element in the list L? 
          sample1: 
             bit1: L=[0,1] -> remove the first (index0) -> then set bit1 in index1 -> then x0=1, x1=1|2=3, then bit2: set in x1: 3|4=7 -> [1,7,1] -> same as before.

      Or remove the last element in L? 
          sample1: bit1: remove index1 -> set in index0 -> then x0=3, x1=1 -> then bit2: set in x1: 1|4=5 -> then [3,5,1] -> sample1 output.

      sample2: 
          bit1: L=[0,1,2,3] -> remove the last (index3) -> then set in [0,1,2] -> 
                x0=1|2=3, x1=0|2=2, x2=1|2=3, x3=1 -> [3,2,3,1] -> valid.

      But sample2 output is [3,0,3,3] in the sample.

      Therefore, if we remove the last element in L for the even case:

        sample1: [3,5,1] -> matches.
        sample2: [3,2,3,1] -> valid but not matching.

      How about we remove the first element in L for sample1 and last element for sample2? -> we can't.

      We need one rule.

      Let me try: remove the last element in L for the even case.

      Then sample1 matches the sample output.

      For sample2, we get [3,2,3,1] which is valid.

      The problem sample output for sample2 is [3,0,3,3]. 

      But the problem says "any one".

      Therefore, we can choose the removal strategy arbitrarily. 

      We'll choose: for even case, remove the last element in L.

      Why? 
          It matches sample1's sample output.

      Then we have:

        T = 0
        for a_i in a: T |= a_i

        x = [0]*n
        for j in range(61):
            bit = 1 << j
            if T & bit:
                L = []
                for i in range(n):
                    if a[i] & bit:
                        L.append(i)
                if len(L) % 2 == 0:
                    if L:
                        L.pop()   # remove the last element
                for i in L:
                    x[i] |= bit

      Test sample1:
        j0: L=[0,1,2] -> even? -> no (3 is odd) -> skip removal -> set all: [1,1,1]
        j1: L=[0,1] -> even -> remove the last (index1) -> then set in [0]: x0 = 1|2=3 -> x=[3,1,1]
        j2: L=[1] -> set in x1: 1|4=5 -> [3,5,1] -> matches.

      Test sample2:
        j0: L=[0,2,3] (3 elements, odd) -> set in all -> x0=1, x1=0, x2=1, x3=1.
        j1: L=[0,1,2,3] -> even -> remove last (index3) -> set in [0,1,2]: 
            x0=1|2=3, x1=0|2=2, x2=1|2=3, x3=1 -> [3,2,3,1] -> valid.

      But the sample expected assignment for sample2 is [3,0,3,3] -> but we got [3,2,3,1]. 

      However, the problem accepts any valid assignment.

      Therefore, we can output [3,2,3,1] for sample2.

      But the problem sample output for sample2 is:

          3
          3 0 3 3

      How about we try to remove the first element in L for the even case? 
          sample2: j1: L=[0,1,2,3] -> remove the first (index0) -> then set in [1,2,3]: 
                x0=1 (remains), x1=0|2=2, x2=1|2=3, x3=1|2=3 -> [1,2,3,3] -> not [3,0,3,3].

      How about we remove a specific element: the one that has the smallest a_i? 
          We did that and got [3,0,3,3] for sample2, and [1,7,1] for sample1.

      But [1,7,1] for sample1 is not the sample output.

      Given the above, we have two options:

        Option 1: Remove the last element -> sample1 matches the sample output, sample2 is [3,2,3,1] (valid).
        Option 2: Remove the element with the smallest a_i -> sample2 matches the sample output, sample1 is [1,7,1] (valid).

      Since the problem has two sample test cases and we want to match both sample outputs if possible, but the problem does not require it, we can choose either.

      But the problem sample output for the first test case is:

          7
          3 5 1

      and for the second test case:

          3
          3 0 3 3

      We can try to design a strategy that produces both:

        How about: 
          In the even case, if there is an element in L that has a_i = 0, we cannot set any bit in it, but we shouldn't have included it because we only include if a_i has the bit. And a_i=0 has no bit set, so it won't be in L.

        We can do: 
          if there is an element in L that has a_i being the minimum of the entire a (not just in L) and that minimum is the only one with that value? 
          But it's complicated.

      Given the complexity and the fact that any valid assignment is acceptable, and the constraints are small, we can choose one.

      We'll choose Option 1: remove the last element in L for the even case, so that sample1 matches the sample output.

      Then for sample2, we output:
          3
          3 2 3 1

      But the sample input has two test cases, and the second test case is:

          4
          3 2 3 3

      and our output is:

          3
          3 2 3 1

      That is acceptable.

      Let me check: 
          x0=3, x1=2, x2=3, x3=1.
          XOR: 3^2^3^1 = (3^3)^(2)^1 = 0^2^1 = 3.

      And each x_i is within [0,a_i]: 
          3<=3, 2<=2, 3<=3, 1<=3 -> valid.

      Therefore, we output:

        for test cases:
          First line: T
          Second line: the list x (after processing)

      Code accordingly.

      However, note: the sample output for the second test case in the problem is "3 0 3 3", but we are outputting "3 2 3 1". 

      We can change to removal of the smallest a_i to get sample2 to match, but then sample1 will be [1,7,1] and the problem sample output for sample1 is "3 5 1". 

      Since the problem says "any one", I'll choose the removal of the last element in L for the even case.

      But note: what if the last element is the only one that has a high bit that we need later? 
          For example, if we remove the last element which has a high a_i, then later we might need to set a high bit and that element was the only one that could set it? 
          However, if we remove it in the even case, we are not setting the current bit in it. But the high bit might be set by it later? 
          But when we process the high bit, if it is set in T, then we will include it in the list for that bit, and then we can set it.

          Example: 
            a = [1, 3]  # n=2
            T = 1|3 = 3.
            We want to achieve 3.

            bit0: 
                L = [0,1] -> even -> remove the last (index1) -> then set bit0 in index0: x0=1, x1=0.
            bit1:
                T has bit1? 3 has bit1 -> yes.
                L = [1] (because a0=1: bit1? 1 in binary: 01 -> no; a1=3: 11 -> yes) -> then set bit1 in x1: x1=0|2=2.
            Then x = [1,2] -> XOR=1^2=3.

          But note: we were able to set the high bit in x1 even though we removed it for bit0.

      Therefore, it is safe.

      Final code:

        for each test case:
            n = int(input_line)
            a = list of n integers

            T = 0
            for num in a:
                T |= num

            x = [0]*n

            for j in range(61):   # 0 to 60
                bit = 1 << j
                if T & bit:
                    L = []
                    for i in range(n):
                        if a[i] & bit:
                            L.append(i)
                    if len(L) % 2 == 0:
                        if L:
                            L.pop()   # remove the last element
                    for i in L:
                        x[i] |= bit

            print(T)
            print(" ".join(map(str, x)))

      Let's run the sample2 with this:

        a = [3,2,3,3]
        T = 3

        j0 (bit=1):
            L = [0,2,3]  -> because a0=3 (bit0 set), a1=2 (bit0 not set: 2 in binary 10 -> not set), a2=3, a3=3.
            odd -> no removal -> set bit0 in indices0,2,3: x=[1,0,1,1]
        j1 (bit=2):
            L = [0,1,2,3]  because:
                a0=3: 11 -> has bit1? 3 & 2 !=0 -> yes.
                a1=2: 10 -> has bit1? yes.
                a2=3: yes, a3=3: yes.
            even -> remove the last (index3) -> then L=[0,1,2]
            set bit1 in x0, x1, x2:
                x0 = 1 | 2 = 3
                x1 = 0 | 2 = 2
                x2 = 1 | 2 = 3
                x3 remains 1
            x = [3,2,3,1]

        Then output:
            3
            3 2 3 1

      This is as expected.

      We'll submit accordingly.

      However, note: the sample output for sample2 in the problem is "3 0 3 3". 

      But the problem allows any valid assignment.

      So we output 3 and then [3,2,3,1] for the second test case.

      If the judge expects exactly the sample output, it will fail. But the problem says "any one".

      We hope the judge is flexible.

      But note: the problem sample input and output are provided for clarity. We are not required to match the assignment exactly.

      We'll go with this.

      Code: