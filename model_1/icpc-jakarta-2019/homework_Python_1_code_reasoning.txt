 We are guaranteed that n>=2, so we don't really need the n==1 case, but the problem states N>=2.
 The cyclic shift: 
   We shift the array A one position to the left. That is, B[0] = A[1], B[1]=A[2], ... , B[n-2]=A[n-1], B[n-1]=A[0].

 However, note that the problem sample input 2: 
   Input: 2
           2 1
   Output: 1 2

 For A = [2, 1]:
   Cyclic shift: [1, 2] -> which matches the sample output.

 Why is the condition satisfied?
   We have: diff(A, B) = |2-1| + |1-2| = 1+1 = 2, which is >= 2 -> valid.

 But is it always at least N?
   Consider: The cyclic shift gives:
        diff(A, B) = |A0 - A1| + |A1 - A2| + ... + |A_{n-2} - A_{n-1}| + |A_{n-1} - A0|

   However, note that this is the sum of absolute differences around a cycle. 
   Actually, we can argue that the entire set of differences forms a cycle. 
   And note that the entire set of numbers from 1 to N is present.

   The minimal value of the cyclic shift sum? 
     Actually, it can be as small as 2*(N-1) if the array is sorted (either increasing or decreasing). 
     For example: A = [1,2,...,n]
        Then cyclic shift: B = [2,3,...,n,1]
        Then the differences:
          |1-2| + |2-3| + ... + |n-1 - n| + |n - 1|
          = 1 + 1 + ... + 1 + (n-1) 
          = (n-1 terms of 1) for the consecutive differences (from index0 to index n-2) and then |n-1| = n-1?
          Actually, the last term is |A_{n-1} - A0| = |n - 1| = n-1.
          So the total = (n-1) ones from the consecutive differences (from 1 to n-1) and then the last term n-1 -> total = (n-1) + (n-1) = 2*(n-1)

     Since n>=2, we have 2*(n-1) >= n? 
        2n-2 >= n  -> n>=2, which holds.

   However, what if the array is not sorted? 
     The cyclic shift does not depend on the order of the array. The formula is the same: 
        diff = |A0-A1| + |A1-A2| + ... + |A_{n-1}-A0|

     But note: This is a closed loop. The entire set of numbers from 1 to N is present. 
     The minimal possible value for a cycle of distinct numbers from 1 to N is achieved when the numbers are in increasing order? 
     Actually, no: consider the cycle 1,2,...,n,1: the minimal cycle sum is 2*(n-1) as above.

     However, if the array is in decreasing order? 
        A = [n, n-1, ..., 1]
        Then cyclic shift: B = [n-1, n-2, ..., 1, n]
        Then:
          |n - (n-1)| = 1
          |n-1 - (n-2)| = 1
          ... 
          |2 - 1| = 1
          |1 - n| = n-1
        Total = (n-1)*1 + (n-1) = 2*(n-1) again.

     Therefore, the cyclic shift always gives a total difference of at least 2*(n-1) (which is the minimum for any cyclic arrangement of distinct numbers 1..n) and since 2*(n-1) >= n for n>=2, we are safe.

 However, note: the problem does not require the maximum permutation, just any permutation with difference at least N. The cyclic shift meets that.

 But wait: what if the array is arbitrary? 
   The cyclic shift does not necessarily give the maximum permutation, but it is a valid one.

   Why not the maximum? 
     The maximum permutation would be the one that pairs the smallest in A with the largest in B, and so on. 
     Actually, the maximum possible difference is achieved by pairing the smallest element in A with the largest in B, the next smallest with the next largest, etc. 
        But note: we are constrained that B is a permutation of 1..n.

     However, the problem does not require the maximum, just at least N.

 Implementation: 
   We simply do: 
        B = A[1:] + [A[0]]

 Let's test with sample: 
        A = [1,3,2,4] -> B = [3,2,4,1] -> but the sample output is [4,2,3,1] which gives 8.

   Our method gives: 
        |1-3| + |3-2| + |2-4| + |4-1| = 2 + 1 + 2 + 3 = 8 -> same as the sample output? 
        Actually the sample output is 8 as well, but the sample output is [4,2,3,1]. 

   Why did the sample output use [4,2,3,1]? 
        They are different permutations. However, both are valid.

   But note: the problem says "you can output any permutation that satisfies the condition".

   However, our cyclic shift for the sample input [1,3,2,4] produces [3,2,4,1] which is different from the sample output [4,2,3,1]. 
   But the problem does not require a particular one.

   But let's check the difference for [3,2,4,1]:
        |1-3| = 2
        |3-2| = 1
        |2-4| = 2
        |4-1| = 3
        Total = 2+1+2+3 = 8 >=4 -> valid.

   However, the sample output is [4,2,3,1]. Why? 
        It was just an example.

   But note: the problem says "if there is more than one valid solution, you can output any of them".

   Therefore, we can output the cyclic shift.

 However, there's a caveat: what if the cyclic shift produces a difference that is less than N? 
   We have argued that the cyclic shift gives at least 2*(n-1) and 2*(n-1) >= n for n>=2. 
   Therefore, it is safe.

 But note: the cyclic shift we are doing is a left shift by one. 

 However, the problem sample input 2: 
        n=2, A=[2,1] -> output [1,2] -> which we get by left shift: [1] and then append A[0]=2? 
        Actually: A[1:] is [1] and then [A[0]] is [2] -> [1,2] -> which is correct.

 But wait: what if we do a right shift? 
        We could also do: [A[-1]] + A[0:-1] -> which for [1,3,2,4] would be [4,1,3,2]. 
        Then the differences: 
            |1-4| = 3
            |3-1| = 2
            |2-3| = 1
            |4-2| = 2 -> total=8.

   Both left shift and right shift give the same total? 

   Actually, note that the cyclic shift (whether left or right) forms a cycle. The sum of absolute differences around the cycle is the same regardless of the starting point? 
        But the starting point matters in the arrangement. However, the entire cycle is the same set of edges. 
        The sum of the absolute differences for the entire cycle (if we consider the cyclic graph) is independent of the starting point? 
        But note: the problem breaks the cycle at one point: 
            In the left shift: 
                We break the cycle at the edge from the last element to the first? 
                Actually, we are forming: 
                    edge from A0 to A1, then A1 to A2, ... , A_{n-2} to A_{n-1}, and then A_{n-1} to A0.

            In the right shift: 
                We break the cycle at the edge from the last element to the first? 
                Actually: 
                    B = [A_{n-1}, A0, A1, ..., A_{n-2}]
                    Then the differences: 
                         |A0 - A_{n-1}| 
                         |A1 - A0|
                         |A2 - A1|
                         ... 
                         |A_{n-1} - A_{n-2}|

                So the edges are: 
                    A0->A_{n-1} (which is the same as A_{n-1}->A0 in absolute value) and then the consecutive edges.

        Therefore, the set of edges is the same as the left shift: 
            Left shift: 
                edges: (A0,A1), (A1,A2), ... , (A_{n-2}, A_{n-1}), (A_{n-1}, A0)
            Right shift: 
                edges: (A0, A_{n-1}), (A_{n-1}, A_{n-2})? ... actually no, the edges in the differences for the right shift are:
                    (A0, A_{n-1})   -> |A0 - A_{n-1}|
                    (A1, A0)        -> |A1 - A0|
                    (A2, A1)        -> |A2 - A1|
                    ... 
                    (A_{n-1}, A_{n-2}) -> |A_{n-1} - A_{n-2}|

            But note: the set of edges is the same as the left shift? 
                Left shift: 
                    (A0,A1), (A1,A2), ... , (A_{n-2},A_{n-1}), (A_{n-1},A0) -> which is the same set of edges as the right shift? 
                However, the direction of the edge doesn't matter because we use absolute value.

            Therefore, the total is the same.

   So both shifts give the same total.

   Therefore, we can choose either. 

   However, note: the problem sample output for n=4 is [4,2,3,1]. How can we get that?
        For A = [1,3,2,4]:
          Our left shift: [3,2,4,1] -> which is not [4,2,3,1].
          Our right shift: [4,1,3,2] -> which is not [4,2,3,1].

   How can we get [4,2,3,1]? 
        It is a different permutation. 
        We note: 
            B0 = 4 -> which is the maximum? 
            B1 = 2 -> which is A1? but A1=3 -> so |3-2|=1
            B2 = 3 -> which is the same as A2=2 -> |2-3|=1
            B3 = 1 -> which is the minimum.

        This is a pairing of extremes? 

   But the problem does not require a particular one, so we can stick with the cyclic shift.

   However, we must note: the cyclic shift we are doing is very efficient: O(n) time and O(n) space.

   But there is one more issue: what if the array has only 2 elements? 
        We have n=2: 
            A = [a, b] 
            Left shift: [b, a] -> 
                diff = |a-b| + |b-a| = 2*|a-b|
            Since a and b are distinct and from {1,2}, |a-b|=1 -> diff=2, which is >=2 -> valid.

   Therefore, the cyclic shift (left shift) is a valid solution.

   We'll output: A[1:] + [A[0]]

   However, note: the problem sample input 2: 
        Input: 2
                2 1
        Our output: [1,2] -> which is the same as the sample output.

   So we write:

        if n==1: ... (but n>=2) so we skip.
        else:
            B = A[1:] + [A[0]]

   But wait: what if the problem expects a particular format? 
        The problem says: Output in a line N integers (each separated by a single space).

   We are doing: 
        print(" ".join(map(str, A[1:] + [A[0]])))

   This is efficient and meets the constraints.

 However, note: the problem states that the permutation must be distinct and from 1 to N. 
        Since A is a permutation, shifting it cyclically still yields a permutation.

   Therefore, the solution is complete.

 But note: the problem also says that we can return any permutation with diff(A, B)>=N. 
        We have a proof that the cyclic shift gives at least 2*(n-1) which is >=n for n>=2.

   Therefore, we can use the cyclic shift.

 Let's run the sample: 
        Input: 4
                1 3 2 4
        Output: 3 2 4 1

   But the sample output in the problem is 4 2 3 1. 

   However, the problem says: "if there is more than one valid solution, you can output any of them".

   So both [3,2,4,1] and [4,2,3,1] are acceptable.

   But if the problem expects the sample output [4,2,3,1] and we output [3,2,4,1], that is acceptable.

   However, the problem provides two sample inputs and outputs. The second sample input is:
        Input: 2
                2 1
        Output: 1 2 -> which we match.

   Therefore, we output the left cyclic shift.

 However, note: the problem sample input 1 output in the problem is [4,2,3,1] and not [3,2,4,1]. 
        But the problem says: "Sample Output #1" for the first sample and then "Sample Input #1" again for the second? 
        Actually, the problem has two samples: 
            Sample Input #1: 
                4
                1 3 2 4
            Sample Output #1: 
                4 2 3 1

            Then Sample Input #2: 
                2
                2 1
            Sample Output #2: 
                1 2

        But the problem wrote "Sample Input #1" twice? Actually, the problem statement says:

            # Sample Input #1
            4
            1 3 2 4
            # Sample Output #1
            4 2 3 1

            # Sample Input #1   -> This seems to be a typo? It should be Sample Input #2?
            2
            2 1
            # Sample Output #1
            1 2

        So the second sample is for n=2.

   We have passed the second sample. For the first sample, our output is [3,2,4,1] and the problem sample output is [4,2,3,1]. 
        But both are valid.

   If we want to match the sample output for the first sample, we could also consider a different shift? 
        The problem does not require a particular one. 

   Alternatively, we can do a right cyclic shift to get [4,1,3,2] for the first sample. 
        But that doesn't match [4,2,3,1] either.

   How about reversing the array? 
        For A = [1,3,2,4], reverse gives [4,2,3,1] -> which matches the sample.

        Then the differences: 
            |1-4| = 3
            |3-2| = 1
            |2-3| = 1
            |4-1| = 3 -> total=8.

        So reversing also works? 

        Why? 
            The reversed array is: 
                B[0] = A[n-1]
                B[1] = A[n-2]
                ... 
                B[i] = A[n-1-i]

        Then the difference: 
            diff = |A_i - A_{n-1-i}| for each i.

        Now, what is the total? 
            For the entire array, we are pairing the first with the last, the second with the second last, etc.

        This is actually the pairing that maximizes the absolute difference? 
            Because the maximum absolute difference for a fixed element is achieved by pairing it with the element farthest away? 
            However, note: we are constrained by the permutation: each element must be used exactly once.

        It is known that the maximum possible sum of absolute differences for two permutations is achieved by pairing the largest with the smallest, the second largest with the second smallest, etc. 
            But that would be: 
                Sort A: a0, a1, ..., a_{n-1} (in increasing order)
                Then pair: 
                    (a0, a_{n-1]), (a1, a_{n-2}), ... 

            And that yields the maximum.

        How do we compute that? 
            We can sort A to get the sorted list, then form the permutation B by:
                For i in range(n):
                    if i is even -> assign the next largest?
                Actually, we can do:
                    Let sorted_A = sorted(A)
                    Then B should be: 
                         [sorted_A[n-1], sorted_A[0], sorted_A[n-2], sorted_A[1], ...] 
                    But note: we must assign without conflict.

            However, we are not required to output the maximum permutation, but any permutation with at least N.

        But the problem says we can output any.

        Therefore, we have two simple options:
          Option 1: cyclic shift (left or right) -> total difference is 2*(n-1) (minimum for the cycle) which is >=n for n>=2.
          Option 2: reverse the array -> total difference is sum_{i} |A_i - A_{n-1-i}|.

        For the reverse, what is the minimal total? 
            The minimal total for the reverse would be when the array is symmetric? 
            For example: [1,2,3,4] -> reverse: [4,3,2,1] -> 
                |1-4|+|2-3|+|3-2|+|4-1| = 3+1+1+3 = 8 -> same as the cyclic shift.

            Actually, for distinct numbers 1..n, the reverse of [1,2,...,n] is [n, n-1, ..., 1] and the sum is:
                For the first half: 
                  |1 - n| = n-1
                  |2 - (n-1)| = n-3? 
                Actually, if n is even: 
                    pairs: (1,n), (2,n-1), ... (n/2, n/2+1) -> each pair (i, n+1-i) has difference (n+1-2*i) for the first half? 
                Alternatively, the sum is: 
                    |1-n| + |2 - (n-1)| + ... + |n - 1| 
                    = (n-1) + (n-3) + ... + 1? (if n is even) 
                    = (n/2) * (n-1 + 1) / 2 * 2? ... 

                Actually, the sum of the absolute differences for the reverse of a sorted array is:
                    = (n-1) + (n-3) + ... for n even: 
                    There are n/2 pairs, each pair (i, j) gives a difference of (n+1-2*i) for the i-th element? 

                Alternatively, note: 
                    The sum = 2 * [ (n-1) + (n-3) + ... + 1 ]   [if n is even: the last term is 1; if n is odd, the middle term is 0?]

                For even n: 
                    sum = 2 * (1 + 3 + ... + (n-1))? 
                    Actually, the differences are: 
                        for the first pair: n-1, then n-3, then n-5, ... until 1.
                    The sequence: n-1, n-3, ..., 1 -> which is an arithmetic progression of (n/2) terms with first term n-1 and last term 1.
                    Sum = (n/2) * (n-1+1)/2 * 2? -> no, the entire sum without doubling? 
                    Actually, we have n/2 terms: 
                        sum = (n-1) + (n-3) + ... + 1 = (n/2)*(n/2) = n^2/4.

                    Then the total? We have two of each? Actually, no: the entire array is one reversal: 
                        The reversal of [1,2,...,n] is [n, n-1,...,1] and the absolute differences are:
                            |1-n|, |2-(n-1)|, |3-(n-2)|, ... -> each term is (n-1), (n-3), ... 
                        So the entire sum is (n-1) + (n-3) + ... + (n-1) [but wait, there are n terms?]

                    Actually, the pairs: 
                        i and n-1-i: 
                            for i=0: |a0 - a_{n-1}| = |1-n| = n-1
                            for i=1: |a1 - a_{n-2}| = |2 - (n-1)| = |2 - n+1| = |3-n|? 
                        This doesn't look like consecutive odd numbers.

                Actually, for the sorted array in increasing order: 
                    The reversal: 
                        For index i: 
                            a_i = i+1
                            a_{n-1-i} = n - i
                            |a_i - a_{n-1-i}| = |(i+1) - (n-i)| = |2*i+1 - n|

                Then the total = sum_{i=0}^{n-1} |2*i+1 - n|

                This is a standard formula: 
                    = (if n is even) 
                        2 * [ (n-1) + (n-3) + ... + 1 ] = 2 * (n/2 * n/2) = 2 * (n^2/4) = n^2/2.

                Example: n=4 -> total = 3+1+1+3 = 8, and n^2/2 = 16/2=8 -> matches.

                For n=2: 
                    total = |2*0+1-2| + |2*1+1-2| = |1-2|+|3-2| = 1+1 = 2 -> which is 2^2/2 = 4/2=2 -> matches.

                For n=3: 
                    sorted_A = [1,2,3] -> reverse = [3,2,1]
                    differences: |1-3|=2, |2-2|=0, |3-1|=2 -> total=4.
                    Formula: 
                        i=0: |1-3| = 2
                        i=1: |2-2| = 0
                        i=2: |3-1| = 2 -> total=4.
                    Formula: n^2/2? 9/2 = 4.5 -> not an integer.

                Actually, for n=3: 
                    The expression: 
                        |2*0+1-3| = |1-3|=2
                        |2*1+1-3| = |3-3|=0
                        |2*2+1-3| = |5-3|=2
                    total=4.

                And 4 = (n^2-1)/2? -> (9-1)/2=4 -> yes.

                So we can write: 
                    if n is even: total = n^2/2
                    if n is odd: total = (n^2-1)/2? 

                But note: (n^2-1)/2 = (n-1)(n+1)/2? 

                However, we don't need the exact value. We know that for n>=2: 
                    even: n^2/2 = (n*n)/2 >= (2*n)/2 = n? -> n^2/2 >= n? -> n^2 >= 2n -> n>=2 -> true.
                    odd: (n^2-1)/2 = (n-1)(n+1)/2 = (n^2-1)/2 
                         (n^2-1)/2 >= n? 
                         n^2-1 >= 2n 
                         n^2 - 2n - 1 >= 0 -> for n>=3 (since n>=2 and the next odd is 3) 
                         at n=3: 9-6-1=2>=0 -> true.

                Therefore, the reversal also works.

        So we have two options: 
          Option1: cyclic shift (left): 
                B = A[1:] + [A[0]]

          Option2: reversal: 
                B = list(reversed(A))

        Both are valid. 

        Which one to choose? 
          The problem says: any permutation. 

        However, the problem sample input 1: 
            Input: [1,3,2,4]
            Option1: [3,2,4,1] -> difference 8
            Option2: [4,2,3,1] -> difference 8 -> which matches the sample output.

        Therefore, if we choose reversal, we match the sample output.

        But the problem sample input 2: 
            Input: [2,1] 
            Reversal: [1,2] -> which matches the sample output.

        So reversal matches both sample outputs.

        Why not use reversal then? 

        Time and space: 
            Reversal: O(n) time and O(n) space -> same as cyclic shift.

        So we can use:

            n = int(input().strip())
            A = list(map(int, input().split()))
            B = A[::-1]   # reverses the list

        Then print B.

        But note: the problem says "any permutation", and reversal is a permutation.

        And we have proved that the total difference for reversal is at least n.

        Therefore, we can use reversal.

        However, we must be cautious: 
          The reversal method does not depend on the content of A? 
          The total difference is the sum of |A_i - A_{n-1-i}| for i in [0, n-1]. 
          Since the set {A_i} is exactly {1,2,...,n}, the same as the set for the sorted array, 
          the total difference for the reversal is the same as for the sorted array? 

          Actually, no: 
            Consider A = [1,3,2,4] -> 
                reversal: [4,2,3,1]
                Then the differences: 
                    |1-4|=3, |3-2|=1, |2-3|=1, |4-1|=3 -> total=8.

            But if we sort A: [1,2,3,4] and reverse: [4,3,2,1] -> 
                differences: |1-4|=3, |2-3|=1, |3-2|=1, |4-1|=3 -> total=8.

          So the total difference is independent of the order? 
            Actually, the reversal of A is the same as the reversal of the sorted array only if we rearrange the positions? 

          Let F(A) = sum_i |A_i - A_{n-1-i}|.

          This is the same as: 
            = |A0 - A_{n-1}| + |A1 - A_{n-2}| + ... 

          Now, if we rearrange A arbitrarily, the pairs (A_i, A_{n-1-i}) are fixed by the positions. 

          But note: the pairs are determined by the positions, not by the values. 

          Therefore, the total depends on the particular arrangement of A.

          However, we don't care about the exact value as long as it is at least n.

          We have an example: 
                A = [1,2] -> reversal: [2,1] -> 
                    |1-2|+|2-1| = 1+1 = 2 >=2 -> valid.

          Another: 
                A = [1,2,3,4] -> reversal: [4,3,2,1] -> 3+1+1+3=8>=4 -> valid.

          What if A is arranged such that adjacent pairs are close? 
                A = [1,2,3,4] -> we know it's 8.

          What if A is arranged arbitrarily? 
                Consider A = [1,3,2,4] -> we computed 8.

          How about A = [1,2,4,3]? 
                reversal: [3,4,2,1]
                differences: 
                    |1-3|=2, |2-4|=2, |4-2|=2, |3-1|=2 -> total=8.

          How about A = [1,4,2,3]? 
                reversal: [3,2,4,1]
                differences: 
                    |1-3|=2, |4-2|=2, |2-4|=2, |3-1|=2 -> total=8.

          It seems for n=4, regardless of A, the reversal gives 8? 

          Why? 
            The set of pairs in the reversal: 
                The pairs of indices: (0,3), (1,2), (2,1), (3,0) -> but note the entire set is the same: 
                The absolute differences: 
                    |A0 - A3| + |A1 - A2| + |A2 - A1| + |A3 - A0| 
                = 2*(|A0 - A3| + |A1 - A2|)   -> but wait, the last two terms are the same as the first two? 
                Actually, no: 
                    The terms: 
                         i=0: |A0-A3|
                         i=1: |A1-A2|
                         i=2: |A2-A1| = |A1-A2|
                         i=3: |A3-A0| = |A0-A3|
                So total = 2*(|A0-A3|+|A1-A2|)

            Now, what is the sum of |A0-A3|+|A1-A2| over all permutations? 
                The set of values is {1,2,3,4}. 
                The pairs (A0,A3) and (A1,A2) are two disjoint pairs that cover the entire set.

                The sum of the absolute differences of the two pairs? 
                    The two pairs: (x,y) and (z,w) such that {x,y,z,w} = {1,2,3,4}. 
                    The minimal value of |x-y|+|z-w| is 1+1 = 2? 
                    The maximal is 3+? 

                Actually, the sum of the absolute differences of any partition of {1,2,3,4} into two pairs is always 4? 
                    Let's enumerate: 
                      Partition1: (1,2) and (3,4): |1-2|+|3-4| = 1+1=2 -> then total=2*2=4? but we have 2*(2)=4? -> then the entire sum=4? 
                      But we computed 8 above? 

                Actually, total = 2*(|A0-A3|+|A1-A2|) = 2 * (|1-2|+|3-4|) = 2*(1+1)=4 -> that would be 4.

                But wait: we computed for A=[1,2,4,3] -> we got 8? 
                    How? 
                    A = [1,2,4,3] -> reversal: [3,4,2,1]
                    Then: 
                         |1-3|=2
                         |2-4|=2
                         |4-2|=2
                         |3-1|=2 -> total=8.

                What's the breakdown? 
                    The reversal: 
                         B0 = A3 = 3
                         B1 = A2 = 4
                         B2 = A1 = 2
                         B3 = A0 = 1

                    Then the differences: 
                         |A0-B0| = |1-3|=2
                         |A1-B1| = |2-4|=2
                         |A2-B2| = |4-2|=2
                         |A3-B3| = |3-1|=2

                But note: in our reversal, we are comparing:
                    Original A: [1,2,4,3]
                    B: [3,4,2,1]

                And we are computing: 
                    |1-3|, |2-4|, |4-2|, |3-1| -> which are the element-wise absolute differences.

                However, the formula we thought: 
                    F(A) = |A0 - A3| + |A1 - A2| + |A2 - A1| + |A3 - A0| 
                    is not the same as the reversal.

                Actually, the reversal permutation is defined by:
                    B_i = A_{n-1-i]

                Then the element-wise difference: 
                    |A_i - B_i| = |A_i - A_{n-1-i]|

                So the total = sum_i |A_i - A_{n-1-i]|

                For A = [1,2,4,3]: 
                    i=0: |1 - A_{3}| = |1-3|=2
                    i=1: |2 - A_{2}| = |2-4|=2
                    i=2: |4 - A_{1}| = |4-2|=2
                    i=3: |3 - A_{0}| = |3-1|=2 -> total=8.

                How do we express this? 
                    It is the sum over i of |A_i - A_{n-1-i]|.

                Now, note that the pairs (i, n-1-i) for i from 0 to n-1: 
                    For n=4: 
                        i=0 -> pair (0,3)
                        i=1 -> pair (1,2)
                        i=2 -> pair (2,1) -> same as (1,2) but the absolute value is the same.
                        i=3 -> pair (3,0) -> same as (0,3)

                So the entire sum = 2*(|A0-A3| + |A1-A2|) -> for n=4.

                Then the minimal value? 
                    We need to minimize 2*(|x0-x3|+|x1-x2|) over distinct {x0,x1,x2,x3} in {1,2,3,4}. 
                    The minimal value of (|x0-x3|+|x1-x2|) is 1+1=2, so total=4.

                Therefore, the minimal total for reversal for n=4 is 4, which is >=4 -> valid.

          Therefore, regardless of the arrangement of A, the reversal method gives a total difference of at least n (since for n=4, minimal is 4).

          For n=3: 
                The total = |A0-A2| + |A1-A1| + |A2-A0| = 2*|A0-A2| 
                The minimal |A0-A2|? 
                    The values are distinct from {1,2,3}. 
                    The minimal |A0-A2| is 1 (for example A0=1, A2=2 -> then |1-2|=1, then total=2*1=2, but then the middle term |A1-A1|=0 -> total=2+0=2? 
                    Actually, the terms: 
                         i=0: |A0 - A2| = |1-2|=1
                         i=1: |A1 - A1| = |2-2|=0? -> no: 
                         A = [1,2,3] -> 
                             reversal: [3,2,1]
                             differences: 
                                 |1-3|=2
                                 |2-2|=0
                                 |3-1|=2 -> total=4.

                Actually, for n=3: 
                    The reversal: 
                         B0 = A2 = 3
                         B1 = A1 = 2
                         B2 = A0 = 1
                    Then the differences: 
                         |1-3|=2
                         |2-2|=0
                         |3-1|=2 -> total=4.

                The minimal total for reversal for n=3: 
                    We want to minimize: |A0-A2| + |A1-A1| + |A2-A0| = 2*|A0-A2| 
                    because the middle term is zero? 

                    But note: the middle term is |A1 - B1| = |A1 - A1| = 0? 
                    Actually, for the reversal: 
                         B1 = A_{n-1-1} = A_{2-1} = A1 -> so the middle element is fixed to A1, so the middle difference is 0.

                    Then the total = |A0-A2| + 0 + |A2-A0| = 2*|A0-A2|.

                    The minimal |A0-A2| is 1? 
                         Then total=2.

                But is 2>=3? no -> wait, that would be a problem.

          Therefore, we must check: 
                n=3: 
                    The minimal total we can get by reversal is 2? 
                    Example: 
                         A = [1,2,3] -> we get 4? 
                         How do we get 2? 
                         We need |A0-A2|=1, then total=2.

                         Example: 
                            A = [1,3,2] 
                            Reversal: [2,3,1]
                            Differences: 
                                 |1-2|=1
                                 |3-3|=0
                                 |2-1|=1 -> total=2.

                Then 2 < 3 -> not valid.

          Therefore, reversal does not always work? 

          But wait: the problem says: "it can be proven that diff(A, B_max)>=N for any permutation A and N>1". 
          And we know the reversal for A=[1,3,2] gives 2 which is less than 3.

          So we cannot use reversal arbitrarily.

          What went wrong? 
            The problem requires any permutation B such that diff(A, B)>=N. 
            For A=[1,3,2] and n=3, we must output a permutation B with diff>=3.

          How about if we do the cyclic shift? 
            Cyclic shift (left): B = [3,2,1] -> 
                |1-3|=2, |3-2|=1, |2-1|=1 -> total=4>=3 -> valid.

          How about reversal? 
            We found one reversal that failed: [2,3,1] -> diff=2, which is not valid.

          But note: we can use any reversal? Actually, no: the reversal we defined is the entire array reversed.

          However, the problem does not require the reversal of the entire array. It was just one option.

          Therefore, we must go back to the cyclic shift.

          The cyclic shift: 
            For A=[1,3,2]: 
                left shift: [3,2,1] -> total=4 (as above) -> valid.

          For A=[1,2,3] (n=3): 
                left shift: [2,3,1] -> 
                    |1-2|=1, |2-3|=1, |3-1|=2 -> total=4>=3 -> valid.

          For A=[1,3,2] (n=3): 
                left shift: [3,2,1] -> total=4.

          Therefore, the cyclic shift (left) works for n=3.

          And for n=2: 
                A=[2,1] -> [1,2] -> |2-1|+|1-2|=1+1=2>=2 -> valid.

          And for n=4: 
                A=[1,3,2,4] -> [3,2,4,1] -> total=8>=4 -> valid.

          Therefore, we choose the cyclic shift (left) as it is proven to yield at least 2*(n-1) which is >=n for n>=2.

          The reversal method we initially thought of (entire array reversal) does not always work? 
            But we see that for n=3, the reversal of [1,3,2] is [2,3,1] which gives 2, which is not >=3.

          Why did we think the reversal of the sorted array gives (n^2-?)/2? 
            That was for the sorted array. For an arbitrary array, the reversal might be small.

          Therefore, we stick to the cyclic shift.

          Code for cyclic shift (left):
            n = int(input().strip())
            A = list(map(int, input().split()))
            if n == 1:
                print(A[0])
            else:
                # Shift left: take from index1 to the end, then append index0.
                B = A[1:] + [A[0]]
                print(" ".join(map(str, B)))

          This will pass the sample inputs:

            Sample1: 
                Input: 4
                        1 3 2 4
                Output: 3 2 4 1

            Sample2: 
                Input: 2
                        2 1
                Output: 1 2

          But the problem sample output for sample1 is 4 2 3 1. 
            However, the problem says: "if there is more than one valid solution, you can output any of them".

          We are outputting a valid solution.

          Therefore, we use the cyclic shift.

          However, note: the problem sample input 1 in the problem statement is [1,3,2,4] and the sample output is [4,2,3,1]. 
          Our output is [3,2,4,1]. 

          If we want to match the sample output, we can do a cyclic shift to the right? 
            Right shift: take the last element and put it at the front: 
                B = [A[-1]] + A[:-1]

            For A = [1,3,2,4]:
                B = [4] + [1,3,2] = [4,1,3,2] -> 
                differences: 
                    |1-4|=3, |3-1|=2, |2-3|=1, |4-2|=2 -> total=3+2+1+2=8>=4 -> valid.

            But that is not [4,2,3,1].

          How about two shifts? 
            Or we can do a different transformation.

          Alternatively, we can do the pairing that minimizes the difference for the middle? 

          However, the problem does not require to match the sample output exactly.

          Since the problem accepts any valid permutation, we output the left cyclic shift.

          But note: the problem statement sample output for the first sample is [4,2,3,1]. 
            How was that obtained? 
                It is the reversal of [1,3,2,4]? -> [4,2,3,1] -> no, because reversing [1,3,2,4] gives [4,2,3,1]. 
                But we saw that reversal for n=3 fails, so we avoid reversal.

          However, note: for n=4, the reversal of [1,3,2,4] is [4,2,3,1] -> and we computed the total=8 which is>=4, so it is valid. 
            But for n=3 we found a reversal that fails. 

          Therefore, we cannot use reversal for all n. 

          But the problem says: any permutation. And for the particular instance of n=3, we must avoid the reversal if the reversal yields a total<3.

          How to know which transformation to use? 

          Alternatively, we can use the cyclic shift for n=3 and reversal for n>=4? 
            But the problem says n>=2, and for n=2 both cyclic shift and reversal are the same? 
                For n=2: 
                    Cyclic shift (left) of [a0,a1] -> [a1, a0] -> which is the reversal.

          But for n=3: 
            reversal might fail: 
                Example: A=[1,3,2] -> reversal gives [2,3,1] -> total=2 (invalid).
            cyclic shift (left) of [1,3,2] -> [3,2,1] -> total=4 (valid).

          So we can do:

            if n==2:
                B = [A[1], A[0]]
            else:
                # use cyclic shift? 
                # But we want to avoid reversal for n=3? 
                # Actually, we can use cyclic shift for any n>=2.

          Why not use cyclic shift for all n>=2? 

          Therefore, we choose cyclic shift (left) for all n>=2.

          However, note: what if the cyclic shift yields a total less than n? 
            We have proven that the cyclic shift yields at least 2*(n-1) and 2*(n-1)>=n for n>=2. 
            Therefore, it is safe.

          Code:

            n = int(input().strip())
            A = list(map(int, input().split()))
            if n == 1:
                print(A[0])
            else:
                # Shift left: take from index1 to the end, then append index0.
                B = A[1:] + [A[0]]
                print(" ".join(map(str, B)))

          But note: the problem says n>=2, so we don't need to handle n==1? 
            The input constraint: 2<=N<=100000.

          Therefore, we can do:

            n = int(input().strip())
            A = list(map(int, input().split()))
            # Since n>=2, we do:
            B = A[1:] + [A[0]]
            print(" ".join(map(str, B)))

          Let's test with the provided examples.

          Example1: n=4, A=[1,3,2,4] -> B=[3,2,4,1] -> output "3 2 4 1"

          Example2: n=2, A=[2,1] -> B=[1,2] -> output "1 2"

          This matches the second sample.

          But the first sample output in the problem statement is "4 2 3 1", not "3 2 4 1". 
            However, the problem says: "if there is more than one valid solution, you can output any of them".

          Therefore, we output "3 2 4 1" for the first sample.

          But if the problem expects the sample output to be matched exactly (for the sample input), and the judge might have sample tests, 
          we must be cautious. However, the problem does not require to match the sample output, only the condition.

          We have computed that the difference for [3,2,4,1] is 8>=4 -> valid.

          Therefore, we are safe.

          However, if the problem's sample test expects "4 2 3 1", and we output "3 2 4 1", the judge should accept it.

          We'll submit the cyclic shift.

          But note: the problem also says: "Darto and Danang" and the sample output is provided as "4 2 3 1". 
          The problem says: "Sample Output #1" for the first sample. 

          To be safe, we can use a different transformation that yields the sample output for the first sample? 
          But the problem does not require that.

          We'll trust the judge to have multiple valid answers.

          Therefore, final code:

            n = int(input())
            A = list(map(int, input().split()))
            # Create B by shifting left: 
            B = A[1:] + [A[0]]
            print(" ".join(map(str, B)))

 However, note: the problem also has a sample input of 2 which we match.

 But wait: what if we do a right cyclic shift for the first sample? 
        A = [1,3,2,4] -> right shift: [4,1,3,2] -> which is not [4,2,3,1] either.

        But we don't care.

        However, there is an alternative: 
          The sample output [4,2,3,1] is the reversal of the array? 
          For A=[1,3,2,4] -> reversal is [4,2,3,1] -> and that is valid for n=4.

        But we saw that reversal might fail for n=3.

        Therefore, we cannot use reversal for all n.

        But we can do: 
          for n>=4, use reversal? 
          for n==2, use reversal (which is cyclic shift) -> valid.
          for n==3, use cyclic shift (which we know works) -> valid.

        Then:

            if n==2:
                B = [A[1], A[0]]
            elif n==3:
                B = A[1:] + [A[0]]   # or any cyclic shift
            else:
                B = A[::-1]

        Then for the first sample (n=4) we output [4,2,3,1] and for the second sample (n=2) we output [1,2] and for n=3 we output a cyclic shift.

        Why is reversal safe for n>=4?
            We have: 
                total = sum_{i} |A_i - A_{n-1-i}|
                = 2 * (for i from 0 to floor((n-1)/2) of |A_i - A_{n-1-i}|)   [if we group the symmetric terms]

            For n>=4, what is the minimal value of this sum? 
                The minimal value occurs when we minimize each |A_i - A_{n-1-i}|.

                The entire set is 1..n. 
                Consider the entire set is partitioned into pairs: (i, n-1-i) for i in [0, floor((n-1)/2)].

                For each pair, the minimal absolute difference is 0? but the elements are distinct -> minimal is 1.

                How many pairs? 
                  For n even: n/2 pairs -> then total = 2 * (n/2 * 1) = n? -> which is exactly n, so valid.
                  For n odd: (n-1)/2 pairs, and the middle element is paired with itself -> difference 0, so total = 2 * ( (n-1)/2 * 1 ) = n-1? 
                    Then n-1 >= n? -> no, fails.

            Therefore, for n>=4 and odd, the minimal total might be n-1? 
                Example: n=5, can we get total=4? 
                    We need: 
                         |A0-A4|>=1, |A1-A3|>=1, and the middle term |A2-A2|=0.
                         Then total = 2*(1+1) = 4? -> but wait, we have two pairs? 
                         Actually, the total = |A0-A4| + |A1-A3| + |A2-A2| + |A3-A1| + |A4-A0| = 2*(|A0-A4|+|A1-A3|) = 2*(1+1)=4.
                    And 4 < 5 -> invalid.

            Therefore, reversal is not safe for n=5.

          How to get at least 5? 
            The minimal we can get is 4, which is less than 5.

          Therefore, reversal is not safe for n>=4 in the odd case.

        Alternatively, we can use cyclic shift for all n.

        Given the complexity and the guarantee that cyclic shift works for all n>=2, we stick to cyclic shift.

        Final decision: cyclic shift (left) for all n>=2.

        Code:

            n = int(input())
            A = list(map(int, input().split()))
            if n == 1:
                print(A[0])
            else:
                B = A[1:] + [A[0]]
                print(" ".join(map(str, B)))

        We'll run the sample n=5: 
            A = [1,2,3,4,5] -> 
                B = [2,3,4,5,1]
                diff = |1-2|+|2-3|+|3-4|+|4-5|+|5-1| = 1+1+1+1+4 = 8>=5 -> valid.

        How about n=5 with an arrangement that might give minimal total in reversal? 
            A = [1,2,3,5,4] -> 
                reversal: [4,5,3,2,1]
                diff = |1-4|+|2-5|+|3-3|+|5-2|+|4-1| = 3+3+0+3+3 = 12>=5 -> valid.

        But with cyclic shift: 
            A = [1,2,3,5,4] -> 
                B = [2,3,5,4,1]
                diff = |1-2|+|2-3|+|3-5|+|5-4|+|4-1| = 1+1+2+1+3 = 8>=5 -> valid.

        Both are valid, but cyclic shift is simpler and uniformly applied.

        Therefore, we output the cyclic shift.

        Note: The time complexity is O(n) and space O(n), which meets the constraints.

        Let's code accordingly.

        IMPORTANT: The problem constraints: 2<=N<=100000, so we must be efficient.

        We are creating a new list of size n: A[1:] is a slice of n-1 elements and then we append one element -> total O(n) space and time.

        Since n<=100000, it is acceptable.

        Final code: