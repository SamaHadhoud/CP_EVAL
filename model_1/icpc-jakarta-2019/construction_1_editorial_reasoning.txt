We are given N cities and K workers. Each city i proposes a road to city A_i, and for that road there are M_i materials (represented by a sorted list B_i). Note that no two cities like each other (so no mutual edge proposal) and the graph of all proposed edges is connected.

We are also given an array C of length K, where C_i is the material the i-th worker can work with.

We can assign a worker to construct a road (if the worker is familiar with one of the materials allowed for that road) or leave the worker idle (output `0 0`). However, we must end up with a connected graph on the N cities, and we cannot assign two workers to the same road.

Important: Each road (edge) is proposed by exactly one city? Actually, note that the road between i and A_i is the same as the road between A_i and i. However, the problem states that the road is bidirectional and the proposal is made by city i. But the same road might appear again in the proposal for city A_i? Let's look at the input: we have N lines, each for city i. Therefore, each edge (i, A_i) is represented twice: once in the line for city i and once in the line for city A_i? Actually, the problem says "city i likes to connect with city A_i", so each city proposes one road. But note that the road (i, j) is proposed by both endpoints? The input does not say that. It says: "Input begins with ... The next N lines each contains ...". So we have one line per city. Therefore, the road between i and A_i is described twice: in the line for city i and in the line for city j (if j = A_i). However, the problem states: "It is guaranteed that no two cities like to connect with each other" meaning that if city i likes j, then city j does not like i. Therefore, each edge is proposed exactly once? Actually, the road (i, j) might be proposed by one of the endpoints? The sample input:

4 5
2 2 1 2   -> city1: A_1=2, materials [1,2]
3 2 2 3   -> city2: A_2=3, materials [2,3]   [Note: but the city index is 2, so this is for city2? Actually, the second line is for city2? The input order is for city1, city2, city3, city4?]

But the sample input has:
Line1: "2 2 1 2" -> for city1: A_1=2, so road (1,2) with materials [1,2]
Line2: "3 2 2 3" -> for city2: A_2=3, so road (2,3) with materials [2,3]
Line3: "4 2 3 4" -> for city3: A_3=4, so road (3,4) with materials [3,4]
Line4: "2 2 4 5" -> for city4: A_4=2, so road (4,2) with materials [4,5]

But note: the road (4,2) is the same as (2,4). However, the problem states that no two cities like to connect with each other: meaning that if city1 likes city2, then city2 does not like city1? But in the sample, city4 likes city2 and city2 likes city3. So that condition is satisfied? The condition says: "there is no pair of integers i and j where A_i = j and A_j = i". So if city i proposes to connect to j and city j proposes to connect to i, that would be disallowed. Here, for city2: A_2=3, and for city3: A_3=4, so no mutual. For city4: A_4=2, and city2: A_2=3 (not 4) so no mutual? Then why does the sample output assign the fifth worker to the road (4,2) and also we see the road (4,2) in the input? 

Actually, the problem says: "each city i proposes a road to A_i". So the road (i, A_i) is proposed by city i. Therefore, the set of proposed roads is exactly the set of edges: { (i, A_i) for i from 1 to N }.

But note: the graph is undirected and the edge (i, A_i) is the same as (A_i, i). However, the condition "no mutual" means that if an edge (i,j) is proposed by i, then j does not propose an edge to i. Therefore, each edge is proposed exactly once? Actually, no: because the road (4,2) is proposed by city4, and the road (2,4) is the same as (4,2). But the problem does not say that the same edge might be proposed twice. Actually, the input for city4 says A_4=2, meaning the road (4,2). But the road (2,4) is the same as (4,2). However, the road (2,4) is not proposed by city2 because city2 proposed (2,3). Therefore, the set of roads is:

city1: (1,2)
city2: (2,3)
city3: (3,4)
city4: (4,2)

So the edges are: (1,2), (2,3), (3,4), (4,2). This forms a connected graph? Actually, it's a cycle: 1-2-3-4-2? But note that 2 is connected to both 3 and 4, and 1 is connected to 2. So the entire graph is connected.

But note: the edge (4,2) is the same as (2,4). Therefore, we have 4 distinct edges.

However, the problem says: "It is guaranteed that any pair of cities are connected by a sequence of road proposals", meaning the graph of proposed edges is connected.

But note: the graph of proposed edges has N edges? But a connected graph with N nodes must have at least N-1 edges. Here we have N edges? Actually, we have exactly N edges. So it's a connected graph with N nodes and N edges? Then it must have exactly one cycle. Therefore, the graph is a pseudoforest with one connected component and one cycle.

In fact, the problem states: "It is guaranteed that any pair of cities are connected by a sequence of road proposals", meaning the entire graph is connected. So we have one connected component with N nodes and N edges -> one cycle.

Therefore, the graph is a unicyclic graph (a connected graph with exactly one cycle).

Now, we have K workers. Each worker has a material C_i. We can assign a worker to build a road (edge) only if the worker's material is one of the materials allowed for that edge. However, note that each edge is described in one proposal? Actually, each edge appears in two proposals? Because the road (i, A_i) is proposed by city i, but then when we look at the other endpoint A_i, we have a proposal for city A_i to its A_{A_i}. But wait, the condition says no mutual, so the edge (i, A_i) is only proposed by city i? Actually, the input gives one line per city, and each line gives the road that the city proposes. Therefore, the edge (i, A_i) is associated with two sets of materials? 

Looking at the sample: 
Edge (1,2): 
  from city1: materials [1,2]
  from city2: we have a proposal for (2,3), not (2,1). So the edge (1,2) is only described in city1? But what about the other endpoint? The sample output assigns the first worker to (1,2) and the fifth worker to (4,2) [which is the same as (2,4)].

However, the input for city4: A_4=2 and materials [4,5]. So the edge (4,2) has two descriptions? Actually, no: the edge (4,2) is proposed by city4. But what if we look at city2? The proposal for city2 is to city3. So the edge (4,2) is only described by city4? Then how do we know the materials for the edge (2,4)? We don't? 

But wait: the problem says "The material that can be used for the road connecting city i and city A_i is represented by an array B_i". So for the road (i, A_i), the materials are given by the array for city i. The other endpoint (city A_i) has its own proposal for a road to A_{A_i}, which is a different road. Therefore, each edge is described exactly once: by the city that proposed it.

So we have exactly N edges, and each edge e is described by one line: the city i that proposed the edge (i, A_i). Therefore, the edge is uniquely identified by (min(i, A_i), max(i, A_i))? Actually, we don't need to do that because the problem does not require symmetry. But we must note: when we output the road, we can output in any order (so for the road between u and v, we can output "u v" or "v u").

Therefore, we have a set of edges E = { (i, A_i) for i in [1, N] }.

But note: the graph is connected and has N edges and N nodes -> one cycle.

We are to assign some workers to build some of these edges. We cannot build an edge if we don't have a worker with a material that is in the set B_i for that edge. Moreover, each worker can be assigned to at most one edge, and each edge can be built at most once.

However, we are allowed to leave a worker idle. But we must end up with a spanning tree? Actually, no: the problem says "any pair of cities are connected by a sequence of constructed road". This means the built edges must form a connected graph. Since we have N nodes, we need at least N-1 edges. We have K workers, so we can build up to K edges, but we must build at least N-1 edges. However, note that we cannot build an edge more than once.

But we have only N edges available. And we know that the graph of all proposed edges is connected and has exactly N edges (so one cycle). Therefore, if we remove one edge from the cycle, we get a spanning tree? Actually, we can also build all edges? Then we have a connected graph with N edges? But the condition only requires connectivity, so having cycles is acceptable? The problem does not require a tree. It requires connectivity.

Therefore, the built graph must be connected and must include all N nodes. We can build any subset of the edges as long as the graph is connected. The minimal way is to build a spanning tree (N-1 edges). But we can build more.

However, we have K workers. We are going to assign each worker to at most one edge. We can build at most min(K, N) edges? Actually, we have N edges and K workers, so we can build at most min(K, N) edges.

But note: we must cover all N nodes? Actually, the graph must be connected. The minimal connected graph has N-1 edges.

So the problem reduces to: we have an undirected connected graph G with N nodes and N edges (so one cycle). We have a set of edges E (size N). Each edge e has a set of materials S_e (which we know from the proposal of the city that proposed that edge). We have K workers, each with a material C_i. We wish to assign each worker to at most one edge (each edge at most once) such that the set of edges built forms a connected graph.

But note: we are allowed to leave workers idle. So we do not need to assign every worker. However, we must build a connected graph. Since the entire graph G is connected, we can in principle build the entire graph. But we cannot build an edge if we don't have a worker with a material in S_e. And we cannot use a worker for an edge that doesn't have the material that the worker knows.

But note: we are not forced to build the entire graph. We can build a spanning tree. How do we choose which edges to build? We have two constraints:
1. The set of built edges must form a connected graph (so it must span all nodes).
2. The assignment of workers to edges must satisfy: the worker assigned to an edge e must have a material that is in S_e.

We are free to choose which edges to build (as long as the graph is connected) and which worker builds which edge.

But we have to output the assignment for each worker in the order of the input of workers.

How to approach?

Step 1: Recognize the graph structure.

We have a connected graph with N nodes and N edges -> one cycle. We can break the cycle by removing one edge. Then we have a tree. But we are not limited to trees: we can build the entire graph? However, note that if we build the entire graph, we use N edges. But we only have K workers. So we must build at least N-1 edges and at most min(K, N) edges.

But what if K < N-1? Then we cannot build a connected graph (since we need at least N-1 edges). Therefore, one necessary condition is: K >= (the number of edges we need) but note we can build as many as we have workers, but we must build at least N-1. Therefore, if K < N-1, output `-1`.

But note: we are allowed to leave workers idle? However, we must build at least N-1 edges. So if K < N-1, we cannot build N-1 edges -> impossible.

So condition 1: if K < N-1, output `-1`.

But what if K >= N-1? Then we can build at least N-1 edges.

However, we must also check that we have enough workers with the right materials to cover at least N-1 edges that form a spanning tree? Or even more? Actually, we are free to choose any connected subgraph that spans the entire graph.

But note: we have a unicyclic graph. The spanning trees of this graph are exactly the graph with one edge removed from the cycle. Therefore, we can form a spanning tree by removing one edge from the cycle. Then, we can also add the remaining edge if we have an extra worker? 

But we are not forced to use a spanning tree. We can use any connected spanning subgraph. However, the minimal one is the spanning tree (N-1 edges). Then if we have more workers, we can build extra edges.

Therefore, the problem becomes:

We must choose a set of edges F ⊆ E such that:
  - F forms a connected graph (spanning all N nodes).
  - |F| >= N-1 (and since we are connected, |F| must be at least N-1; we can have |F| from N-1 to min(K, N)).
  - And we can assign workers to the edges in F: meaning for each edge e in F, there must be at least one worker with a material in S_e that we can assign to e (and each worker can only be assigned to one edge).

But note: we are also free to not assign a worker to an edge? Actually, we must assign a worker to an edge to build it. And we cannot assign a worker to an edge that is not built. Also, we can have workers that are idle. So we are building exactly |F| edges, and we need |F| distinct workers (each building one edge). Therefore, we require that |F| <= K.

Moreover, we must have for each edge e in F, there is at least one worker (among the K) that has a material in S_e. However, the same worker cannot be used twice.

So we can rephrase: we are looking for a connected spanning subgraph F (with N nodes) such that |F| is at least N-1 and at most K. Then, we must assign |F| distinct workers to the edges in F such that for edge e, the worker assigned has a material in S_e.

But note: we have a fixed set of workers and their materials. So the feasibility of assigning workers to edges is a bipartite matching: left side: edges in F, right side: workers. An edge (e, worker i) exists if C_i is in S_e.

But K and N are at most 2000, but the sets S_e can be large? However, the total sum of M_i is at most 10000, so we can precompute for each edge which workers can build it.

But the problem: we have to choose F and then check if there is a matching that covers F. However, the choice of F is constrained: F must be a connected spanning subgraph. And the graph is unicyclic.

How to choose F? We know that the entire graph is connected. The minimal F is a spanning tree. There are exactly two types of spanning trees: they are the entire set of edges except one edge from the cycle. So we have a cycle, and we remove one edge from the cycle. Then we get a tree. How many spanning trees? The cycle has length = the number of edges in the cycle. Let L = length of the cycle. Then there are L possible spanning trees (by removing each edge of the cycle in turn). But note: the graph has one cycle? Actually, the graph is a unicyclic graph: one cycle and trees attached to the cycle.

But note: the entire graph is connected and has N edges and N nodes -> one cycle. So the cycle is unique.

Therefore, we have L choices for which edge to remove from the cycle to form a spanning tree. Then, if we want to build more edges, we can add back the removed edge? Or we can also add any other edge? Actually, we can build any set of edges as long as it is connected. But note: if we remove two edges from the cycle, then the graph becomes disconnected? Actually, if we remove two edges from the cycle, the cycle breaks into two chains and the graph remains connected only if the two edges are adjacent? Actually, no: the graph becomes disconnected if we break the cycle in two non-adjacent edges? Actually, no: because the cycle is a ring. Removing two edges may break the cycle into two disconnected pieces? Actually, if we remove two edges, we get two chains and the graph remains connected? Actually, no: the cycle is broken, but the rest of the graph is trees attached to the cycle. The entire graph remains connected because the non-cycle parts are attached to the cycle? Actually, if we remove two edges from the cycle, the cycle is broken into two chains. Then the graph is still connected? Actually, no: the cycle is broken into two disconnected chains? Only if the two edges are not adjacent? Actually, no: if we remove two edges, we break the cycle into two disconnected chains? Then the graph would become disconnected? 

But consider: if the cycle has nodes 1-2-3-4-1. If we remove edges (1,2) and (3,4), then we break the cycle: we have two chains: [2-3] and [4-1] and the rest of the graph? But note: the entire graph has trees attached to the cycle. So if there is a tree attached to node 1 and a tree attached to node 2, then without the cycle, the tree attached to 1 is connected to 1 and the tree attached to 2 is connected to 2. But if we remove (1,2), then 1 and 2 become disconnected? Actually, no: we also removed (3,4). How does that affect? Actually, the graph becomes two connected components? 

But actually, the graph is unicyclic: the entire graph is built on the cycle. The cycle is the backbone. Removing two edges from the cycle will break the cycle into two pieces? Actually, it breaks the cycle into two chains? Then the graph becomes two connected components? Therefore, we cannot remove two edges from the cycle. The only way to have a spanning tree is to remove exactly one edge from the cycle.

Then, if we want to build more than N-1 edges, we can only add edges that are not in the spanning tree? But note: we have only N edges. The spanning tree we built has N-1 edges. The only edge left is the one we removed from the cycle. So we can only add that one edge? Therefore, the possible sets F are:
  Option 1: a spanning tree (by removing one edge from the cycle) -> size = N-1.
  Option 2: the entire graph (all edges) -> size = N.

Therefore, the possible sizes for F are: either N-1 or N.

So we have at most L (where L is the length of the cycle) choices for the spanning tree (by removing one of the L cycle edges). And then we have one more option: the entire graph (which is the same for all? Actually, the entire graph is fixed: all edges).

But note: we must also consider that we might not have to use the entire graph? Actually, we can build any connected subgraph that spans the nodes. But the minimal is the spanning tree (N-1 edges). And the maximal we can build is the entire graph (N edges). And there is no connected spanning subgraph with exactly N edges? Actually, the entire graph has N edges and is connected. But also, we can build a spanning tree (N-1 edges) and then add one more edge? But the only edge we can add is the one we removed? Because we only have one extra edge: the one we removed to break the cycle. Therefore, the sets F we can choose are:
   - Any spanning tree (which is the entire edge set except one cycle edge) -> size = N-1.
   - The entire graph -> size = N.

So we have L+1 choices: L choices for the spanning tree and one for the entire graph.

But note: the entire graph is the same as not removing any edge? Actually, the entire graph is the union of all edges. But if we don't remove any edge, we have the entire graph? Actually, we started with the entire graph? So the entire graph is one choice.

Therefore, we have L+1 candidate sets F.

But note: we are not forced to use the entire graph. We can use any of these candidate sets as long as we can assign |F| distinct workers to the edges in F (with the material constraint) and |F| <= K.

Moreover, we are free to choose which worker builds which edge? And we have to output the assignment for each worker in the input order.

How to check a candidate set F?
   Let m = |F| (either N-1 or N). We require m <= K.
   Then, we must check if there is an assignment of m distinct workers (from the K) to the edges in F such that for each edge e in F, the worker assigned to e has a material in S_e.

This is a bipartite matching between the edges in F and the workers. But note: the workers have fixed materials. We can build a bipartite graph:
   Left: edges in F (m nodes).
   Right: workers (K nodes). But we only need to consider workers that can be matched to at least one edge? Actually, we can do a bipartite matching.

But K and m are at most 2000? Then we can run a DFS for each left node? The total time would be O(m * (K + total_degree))? But the total_degree: for each edge e, we know which workers can build it? We can precompute for each edge e, the list of workers that have a material in S_e.

But the sets S_e can be large? However, the total sum of M_i (the sizes of the sets S_e) is at most 10000. So for each edge e, we can have a list of worker indices that have a material in S_e? But note: the materials are integers in [0,10^9] and the workers have materials in that range. How to compute for a fixed edge e (with a set S_e) and the entire list of workers (with materials C_i) which workers can build e?

We can do: for each edge e, we have a sorted list S_e (given) and we have an array of workers. But we cannot iterate over all workers for each edge because K can be 2000 and the total M_i is 10000, but the total number of edges is N (2000). So 2000 * 2000 = 4e6 which is acceptable? But we have to do it for each candidate set? And we have L+1 candidate sets (L is the cycle length, which can be up to N, so 2000). Then total 2000 * 2000 * 2000 = 8e9 which is too high.

We need a better approach.

Alternative:

Precomputation for each edge e: we want to know the list of workers that can build it. We can do:

  For each edge e (from 1 to N), we have a set of materials S_e (with M_e elements). We are given an array of worker materials C[0..K-1].

  We want for each edge e, to get a list of worker indices i such that C[i] is in S_e.

But note: the total sum of M_e is 10000. So we can do:

  For each edge e, we have S_e. We can do a binary search for each material in S_e? But we don't have the workers sorted by material? 

Actually, we can precompute an array for the workers: we can group workers by material. But note: the materials are in [0,10^9], so we cannot index by material. Instead, we can:

  Precompute a mapping: for each material value that appears in any S_e or in C, we might care? But the workers have materials C_i. We can:

  Step 1: collect all material values that appear in the workers? Actually, we can create a list of all worker materials and sort them. Then for each edge e, we can iterate over the materials in S_e and for each material, we can use the sorted worker list to find the workers that have that material? But then we have to avoid duplicates: the same worker might be counted multiple times if the same material appears in multiple edges? But for one edge, if the same material appears only once in S_e? Actually, the set S_e is sorted and distinct.

  Alternatively, we can create a mapping: material_value -> list of worker indices that have that material.

  How to do:

    Create an empty dictionary: material_map: key = material, value = list of worker indices.

    Then, for worker index i (from 0 to K-1):
        material = C[i]
        append i to material_map[material]

    But note: multiple workers can have the same material? Yes.

  Then, for an edge e with set S_e, we can:

        worker_set = set()
        for material in S_e:
            if material in material_map:
                for worker_index in material_map[material]:
                    worker_set.add(worker_index)

        Then the list of workers that can build edge e is the worker_set.

  However, the total sum of M_i is 10000, so the total number of iterations is 10000. But the inner loop: if a material appears in the workers, we iterate over the list of workers for that material. The same worker might appear multiple times? Actually, we are using a set to deduplicate.

  But worst-case: a material might appear in many workers? The total K is 2000, so the list for one material is at most 2000. And the total work over all edges: 10000 * (maximum frequency of a material in the mapping) ... but note: the same worker is added for each material that it has? Actually, we are iterating by material in S_e, and for each material we get the list of workers. Then we add them to a set for that edge.

  The total work per edge: the sum over materials in S_e of (number of workers for that material). Then total over all edges: the sum_{e} [ sum_{m in S_e} (number of workers for material m) ].

  But note: the same worker might be counted multiple times for the same edge? But we use a set to deduplicate. However, the work to build the set: the total number of worker occurrences we iterate over is the same as the above sum. And then we do a set insertion (which is O(1) per element?).

  The worst-case total work: the total number of (material, worker) pairs? Actually, for each edge e and each material m in S_e, we iterate over all workers with material m. The total over all edges: 

        = sum_{e} [ sum_{m in S_e} (freq(m)) ]

        = sum_{m} [ freq(m) * (number of edges e that have m in S_e) ]

  Now, the total sum of |S_e| is 10000. But note: the same material m might appear in multiple sets S_e. And freq(m) is the number of workers with material m.

  The worst-case: a material m might appear in many sets S_e? But the total number of edges is 2000. And the total |S_e| is 10000. So the worst-case total work could be 10000 * (max frequency of a material in the worker list). But the max frequency: a material m can appear at most K (2000) times? Then worst-case total work: 10000 * 2000 = 20e6, which is acceptable.

  Then we can precompute for each edge e, the list of workers that can build it. Store as a list or a set? We will then use this for matching.

But note: we have to do this for each candidate set? Actually, we can precompute for every edge (all N edges) the list of workers that can build it. Then for a candidate set F (which is a set of edges), we know for each edge in F, the list of workers that can build it.

Then we run a bipartite matching on the graph: left nodes = edges in F, right nodes = workers (all K workers? but we only care about the ones that appear in the lists for edges in F). However, we want to assign each edge to one worker and each worker to at most one edge.

Algorithm for bipartite matching: we can use DFS (augmenting path) for each edge. The time complexity: O(|F| * (number of workers per edge))? The worst-case |F| is N (2000) and the total degree of the left side is the sum over edges in F of (number of workers that can build that edge). The worst-case for one edge: up to K (2000) workers. Then the total time for one matching: O(|F| * K) = 2000 * 2000 = 4e6, which is acceptable.

But note: we have up to L+1 candidate sets, and L can be up to 2000. Then total time: 2000 * 4e6 = 8e9, which might be borderline in C++ but in Python it is too high.

We need to optimize.

Alternative approach: we can try to avoid checking all candidate sets.

Observation: the candidate sets F are either:

   F1: the entire graph (all edges) -> size = N.

   F2: a spanning tree obtained by removing one cycle edge e -> size = N-1.

We require that |F| <= K.

We are going to check:

   Option A: entire graph: if N <= K and there is a matching for all N edges? Then we can assign and we have a solution.

   Option B: spanning trees: for each cycle edge e, we remove e and then check if we can match the remaining N-1 edges.

But note: if the entire graph works, then we can output that. However, the entire graph requires N workers. If we have K >= N, then we can consider it. But if K == N-1, then we can only consider the spanning trees.

But we must choose the one that works? Or if none works, then we output -1.

But note: we have to output the assignment for each worker in the input order. And we are allowed to leave workers idle if we build fewer than K edges. However, we must build at least N-1 edges. Therefore, we must build at least N-1 and at most min(K, N) edges.

Therefore, we have:

   If K < N-1: impossible -> output -1.

   Then, we consider:

        if K >= N: try the entire graph first? Because if we can build the entire graph, we have a solution that uses N edges. But we have K workers, so we leave K-N workers idle. However, we are allowed to leave workers idle.

        Then, if we don't find a matching for the entire graph, we try the spanning trees: for each cycle edge e, we remove e and then try to match the remaining N-1 edges.

        If we find one candidate set that has a matching, we output the assignment.

        If none works, output -1.

But note: we have to output the assignment in the order of the workers. So we need to record the matching.

But we have to try at most 1 (entire graph) + L (spanning trees) candidate sets. L is the cycle length, which is at most N (2000). And for each candidate set we run a bipartite matching for a graph of size at most 2000 edges and 2000 workers. The bipartite matching runs in O(|F| * (max_degree))? But we can use the standard DFS matching: worst-case O(|F| * |E_bipartite|). But |E_bipartite| for one edge can be the number of workers that can build it, which is at most K. And we have |F| edges. So worst-case O(|F| * K) = 2000 * 2000 = 4e6 per candidate set. Then for 2000 candidate sets: 2000 * 4e6 = 8e9 operations, which is 8e9 in worst-case. In C++ it might pass, but the problem says time limit 2s? 8e9 operations is too high.

We need a better way.

Alternative idea: we can precompute the bipartite matching for the entire set of edges? Then for each candidate set, we are essentially taking a subset of edges and asking: is there a matching that covers this subset? But note: the entire set of edges is N. And we are considering two types of subsets: the entire set (size N) and the set of all edges except one cycle edge (size N-1). 

But the matching for a subset F is independent.

We can use a different approach: we can try to assign workers to edges in a global way. But we have to choose which edges to build.

However, note that we have to build a connected graph. But the graph is unicyclic. The only constraint for connectivity is that we must not remove two edges from the cycle. Therefore, the set F must include all the non-cycle edges? Actually, no: the non-cycle edges are bridges? They must be included? Actually, if we remove a non-cycle edge, the graph becomes disconnected? So the non-cycle edges are critical: they are bridges. Therefore, we must build every non-cycle edge? Then the cycle edges are the only ones we can choose to remove.

But wait: the graph is unicyclic. The edges that are not in the cycle are bridges. So if we remove any bridge, the graph becomes disconnected. Therefore, we must build all non-cycle edges. Then the only edges we can skip are the cycle edges? And we must build at least all non-cycle edges and at least |cycle|-1 cycle edges? Actually, we must build at least one path through the cycle? 

Actually, the entire graph is connected. The non-cycle edges (the trees attached to the cycle) must be built? Because if we remove one, then the node in the tree becomes disconnected. Therefore, we must build all non-cycle edges. Then the cycle edges: we can skip at most one? Because skipping one cycle edge still leaves the cycle as a path? Actually, skipping one cycle edge leaves the entire graph connected (because the non-cycle edges are attached to the cycle, and the cycle is broken but still a chain that connects all cycle nodes). If we skip two cycle edges, then the cycle breaks into two disconnected chains? Then the graph becomes disconnected.

Therefore, we must build:

   - All non-cycle edges (bridges) -> let T_non_cycle be the number of non-cycle edges? Actually, the graph has N edges and the cycle has L edges, so the non-cycle edges are N - L.

   - And at least L-1 cycle edges.

Therefore, the set F must include:

   - All non-cycle edges (N - L edges)
   - And a connected set of cycle edges that form a connected path? Actually, any set of cycle edges that leaves the cycle connected? But we can skip at most one cycle edge? Actually, skipping one cycle edge we get a path? Then the entire graph remains connected. Skipping two cycle edges breaks the cycle into two pieces.

Therefore, we must skip at most one cycle edge.

So the candidate sets are:

   Option 1: skip no cycle edge: then F = all edges -> size = N.
   Option 2: skip exactly one cycle edge: then F = all non-cycle edges + all cycle edges except one -> size = N - 1.

So we have exactly 1 + L candidate sets? Actually, we have L choices for which cycle edge to skip? And one candidate set for skipping none.

But note: we must build all non-cycle edges. So we have no choice for non-cycle edges: they must be built.

Therefore, the problem reduces to:

   We must assign workers to:

        - All non-cycle edges (mandatory)
        - And then either all cycle edges (if we choose to skip none) or all cycle edges except one (if we skip one).

   And we must do that with the constraint that we have K workers and we cannot assign a worker to two edges.

But note: if we skip a cycle edge, then we are not building that edge, so we don't assign a worker to it.

So the steps:

   Step 1: Identify the cycle and the non-cycle edges.

        We have a graph of N nodes and N edges? We can do:

          - The graph has one cycle? We can find the cycle by DFS? Or we can use a degree-based method? Actually, we can use a queue to remove leaves? Because a leaf has degree 1? Then the remaining graph is the cycle? But note: the graph is connected and unicyclic.

          Algorithm to find the cycle:

            Let in_degree be the degree of each node? Actually, the graph is undirected. We can do:

            Step: 
               Let deg[i] = the number of edges incident to node i? But we know the edges: each edge (i, A_i). Then the graph is undirected: so the degree of node i: it is the number of edges incident to i? But we have an edge list.

            Actually, we have:

                For each i, we have an edge (i, A_i). So we can build an adjacency list.

            Then:

                We can use Kahn's algorithm for the undirected graph? Actually, we can use a queue to remove leaves:

                  Let deg[i] = the number of edges incident to node i? But we can compute:

                     Build graph: for each edge (i, A_i), add an edge from i to A_i and vice versa.

                  Then:

                     Q = queue of all nodes with degree 1.
                     While Q is not empty:
                         pop a node u, then remove u and the edge (u, v) (where v is the only neighbor of u) and then reduce the degree of v by 1.

                  The remaining nodes (if any) form the cycle? Actually, the entire graph is unicyclic: so after removing leaves, we are left with the cycle? But note: the cycle might have trees attached? We remove leaves until we get a graph with minimum degree 2? Then the remaining graph is the cycle? And the edges that we removed are the non-cycle edges.

            So:

                We start with the graph: nodes 1..N, and edges: for each i, add edge (i, A_i). Then we get an undirected graph with N edges.

                Then:

                  deg[i] = number of neighbors of i.

                  We can use a queue: 

                    Q = deque()
                    for i from 1 to N: if deg[i] == 1, push i.

                  Then:

                    while Q not empty:
                         u = Q.popleft()
                         mark u as removed? and then for each neighbor v of u (in the current graph) that is not removed:
                             remove the edge (u, v) -> this edge is a non-cycle edge (bridge) and must be built.
                             then deg[v]--
                             if deg[v] == 1, push v.

                  Then the remaining nodes (that were not removed) form the cycle.

            Then we get:

                non_cycle_edges: the edges we removed during the BFS.

                cycle_edges: the edges that remain in the graph? Actually, the edges that are incident to two non-removed nodes? 

            But note: we have exactly L nodes in the cycle? Then the cycle edges: the edges that form the cycle? How to get the list of cycle edges?

            Actually, we can note: the edges that were not removed during the BFS are the cycle edges? Because the BFS removes all edges that are bridges (attached to leaves). Then the remaining graph is the cycle? But the cycle has no leaves? So we are left with the cycle.

            Therefore, we have:

                non_cycle_edges = set of edges removed during the BFS.

                cycle_edges = set of edges that are not removed.

            How many cycle edges? The cycle has L nodes and L edges? So we have L cycle edges.

            And non_cycle_edges: N - L.

   Step 2: Precomputation: for each edge, the list of workers that can build it.

        We do:

          Build a dictionary: material_to_workers: 
              for worker index i (0-indexed) with material c = C[i]:
                 append i to material_to_workers[c]

          Then for each edge e (each edge is represented by (u, v) and we know the proposal came from one city, so we know the set S_e from the input) -> note: we have stored the set S_e for the edge from the city that proposed it? Actually, we have the input for city i: the road (i, A_i) and the materials B_i.

          But note: during the BFS we don't know which edge is which? Actually, we have stored the edges in the graph. We need to associate the set of materials to the edge. How? 

          We can store for an edge (min(u, v), max(u, v)) the set of materials? But note: the same edge is represented by the proposal of the smaller city? Actually, the problem: the proposal for the edge (i, A_i) is given in the input for city i. So we can store:

                edge_material[i] = the set for the edge (i, A_i)   [but note: we don't use the symmetric representation?]

          But when we build the graph, we have edges (i, A_i) for each i. So we can store for an edge (i, A_i) the set B_i. However, if we represent the edge as (min(i, A_i), max(i, A_i)), then we have two representations: the same edge (i, j) might be represented by the proposal from the smaller index? Actually, we don't care: we only have one proposal per edge? Actually, because no mutual: each edge is proposed by exactly one city? 

          How to know which city proposed the edge? The input: the i-th line is for city i. So we can store for the edge (i, A_i) the set B_i. And note: during the BFS, we traverse the graph by edges. We need to associate the material set to the edge.

          We can store:

                For each edge, we can store the material set from the proposal that created it.

          But note: the edge (i, A_i) is the same as (A_i, i). But we have stored the material set from the proposal of city i. There is no proposal from the other endpoint for the same edge? Because no mutual.

          Therefore, we can store:

                materials_of_edge[i] = B_i   for the edge (i, A_i)

          But then when we have an edge (u, v) and we don't know which endpoint proposed it? Actually, we know: the edge (u, v) was proposed by either u or v? But we don't know? 

          However, note: the edge (i, A_i) is stored in the input for i. So we can build an array for the edge by the starting city? But when we build the graph, we don't store the direction. 

          We can do: 

                When we add the edge (i, A_i), we store:

                    edge_index = i   (meaning we are storing the material set from the proposal of city i) for the edge (i, A_i)

                But then if we traverse the graph and we see an edge from u to v, how do we know if it was proposed by u or by v? 

          Alternatively, we can store for each edge (u, v) (with u < v) the material set? But we have to know which one? Actually, the proposal is made by one of the endpoints. And we know: the edge (i, A_i) is stored in the input for city i. So if we have an edge (u, v), then the proposal was made by either u or by v? But we know: the input for city u: if A_u = v, then the material set is the one from city u. Otherwise, the input for city v: if A_v = u, then the material set is the one from city v. But the condition of no mutual ensures that exactly one of the two is true.

          Therefore, we can define:

                for an edge (u, v) (with u and v arbitrary), we have:

                    if A_u == v, then the material set is the one from city u.
                    else (then it must be that A_v == u) then the material set is the one from city v.

          So we can store:

                mat_set[u, v] = 
                    if A_u == v: then the set for city u
                    else: the set for city v   [which we know because A_v must be u?]

          How to store: we can build an array for edges? We can create a dictionary keyed by (min(u,v), max(u,v)) to store the material set.

          Steps:

                materials_dict = {}
                for i from 1 to N:
                    u = i, v = A_i
                    key = (min(u,v), max(u,v))
                    materials_dict[key] = B_i   # the list of materials for the edge (u,v) from the proposal of city i.

          Then for any edge (u, v) we can get the material set by the key (min(u,v), max(u,v)).

   Step 3: Precompute for each edge (all N edges) the list of workers that can build it.

        For each edge e (with key (u,v)), we have the set S_e = materials_dict[key] (which is a sorted list? but we don't need to sort, we can use as is).

        Then:

            worker_list[e] = []
            for each material m in S_e:
                if m in material_to_workers:
                    for worker_index in material_to_workers[m]:
                        worker_list[e].append(worker_index)

            Then we can deduplicate? Actually, the same worker might appear multiple times? Because the worker has a material that appears in the set? But if the set has distinct materials, then the same worker won't be added twice for the same set? Actually, if the worker has material m and m appears only once in the set? But we are iterating over distinct m? So the same worker might appear if the worker has two different materials that both are in S_e? Actually, no: the worker has one material. So the same worker cannot appear twice.

            Therefore, we don't need to deduplicate.

        But wait: if the same worker appears for two different materials? Then we would get duplicates? Actually, the worker has one material. So if we iterate over materials, and the same worker appears for two different materials? That cannot happen: because the worker has only one material. So the worker will be added only once per edge.

        Therefore, worker_list[e] is the list of workers that can build edge e.

   Step 4: Check the candidate sets.

        Candidate 0: skip no cycle edge -> build all edges.

            F = all N edges.

            Then we need to assign N workers to these N edges. But we have K workers. We require N <= K.

            Then run bipartite matching for left = the N edges, right = the K workers.

            How: we build a graph for matching: 

                left: edges (indexed by, say, the key or we can assign an index to each edge? We have the list of edges. Actually, we have the non_cycle_edges and cycle_edges. But we can have a list of all edges.

            We can do:

                Create a list: edges_all = list of all edges (each edge has an id, and we know worker_list for that edge).

                Then run bipartite matching: 

                    matchR[worker] = which edge is matched to the worker? Or we don't care about that? We care: for each edge, we want to know which worker is assigned.

                    We can do:

                      We create an array: match[edge_index] = worker_index assigned, or -1 if not matched.

                      We do:

                         for each edge_index in [0, N-1]:
                             mark all workers as not visited for this edge
                             then do DFS: try to find a worker for edge_index

            But if we find a matching of size N, then we have a solution.

        Candidate 1 to L: skip one cycle edge.

            For each cycle edge e_skip (in the cycle_edges set), we build:

                F = all non_cycle_edges (which are mandatory) + (cycle_edges without e_skip) -> total N-1 edges.

                Then we run bipartite matching for these N-1 edges.

                If we find a matching, we have a solution.

        If we find one candidate that works, we output the assignment for the workers in the input order.

        How to output: 

            We are going to assign workers to edges. For each worker i (0-indexed), if it is matched to an edge e (which is represented by (u, v)), then output "u v" (in any order). But note: the edge e is stored as (min, max) or as (i, A_i)? 

            Actually, we stored the edge by (min, max) for the material set? But we can store the original representation? Actually, when we output, we can output the endpoints in any order.

            We can store for each edge: the two endpoints. We know: the edge is (u, v) where u and v are the cities.

            For worker i, if it is matched to an edge (u, v), then output either "u v" or "v u".

            If the worker is not matched, output "0 0".

        But note: we must output in the same order as the workers input.

        Therefore, after we run the matching for the candidate set, we get:

            For each edge in F, we have a worker assigned to it.

            Then we create an array ans[0..K-1] for the workers: 

                Initially, for each worker, ans[i] = "0 0"

            Then, for each edge e in F:

                worker_id = the worker assigned to e.

                Then ans[worker_id] = the string representation of the edge: for example, we can output the two endpoints in increasing order? But the problem says "in any order". 

            However, note: the problem does not require a particular order. But we must output the assignment for the i-th worker in the i-th line.

            But note: we are matching workers to edges. We know the worker id (which is the index in the worker input). So we can:

                For worker i, if we assigned it to edge e, then output the endpoints of e (say, we stored the edge as (u, v) and we output "u v" or "v u", it doesn't matter).

            But what if the edge was stored as (min, max)? Then we can output min then max? Or we can output as in the original proposal? Actually, any order is acceptable.

        However, there is a catch: the sample output for the fifth worker: "4 2" for the edge (4,2). So we can output in any order.

   Step 5: If we try all candidates and none works, output -1.

But the time: we have up to L+1 candidates, and L can be up to 2000. For each candidate, we run a bipartite matching for a graph of size |F| (either N or N-1). The bipartite matching for N=2000 and K=2000: worst-case O(N*K) = 4e6 per candidate. Then 2000 * 4e6 = 8e9 operations, which is too high.

We need to optimize the matching.

Observation: the candidate sets are very similar. The entire graph set F0 = all edges. The candidate set for skipping a cycle edge e_i: F_i = F0 without e_i.

Therefore, we can do:

   First, check candidate0: entire graph.

      matching0: if we can match all N edges.

   Then for each cycle edge e_i, we want to check: can we match the set F_i = F0 without e_i? 

      This is equivalent to: we have a matching for F0, but we remove one edge e_i. Then we want to know if we can match F_i? 

      However, if we have a matching for F0, then removing e_i we get a matching for F_i? But only if the matching for F0 used the edge e_i? Then we can simply remove the assignment for e_i and leave that worker idle? But then we have an unmatched worker and we don't assign that worker to any edge? That is allowed. However, the matching for F_i must cover all edges in F_i? And we have to reassign the worker that was assigned to e_i? Actually, no: we are not building e_i, so we don't need to assign a worker to e_i. Therefore, the matching for F0 without the assignment for e_i is a matching for F_i? 

      But wait: the worker that was assigned to e_i is now free. But we don't need to assign that worker to any edge? So we can simply remove the edge e_i from the matching? Then we have a matching for F_i? 

      Therefore, if candidate0 (entire graph) has a matching, then every candidate set F_i (by removing a cycle edge e_i) also has a matching? 

      But that is not true: because the matching for the entire graph might not use the edge e_i? Actually, we built the entire graph, so we matched every edge. So the edge e_i is matched to some worker. Then if we remove e_i, we have to free that worker? But we don't need to build e_i, so we don't need that worker for e_i. The other edges are still built and they still have the same workers? So we can use the same matching without e_i? 

      Therefore, if candidate0 works, then we can choose to skip any cycle edge? But note: we are building the entire graph, so we are not skipping any edge? Actually, candidate0 is the entire graph. The candidate sets for skipping a cycle edge are for building a spanning tree. 

      But if we have a matching for the entire graph, then we can output that matching and then if we want to skip an edge, we don't? Actually, we are building the entire graph. So we don't skip any edge.

      Therefore, if candidate0 works, we can output the entire graph matching.

      Then, we don't need to check the candidate sets for the spanning trees? Because we have a solution: building the entire graph.

      But what if we want to minimize the number of edges? The problem does not require that. We can build the entire graph.

      So:

          if K >= N and we find a matching for the entire graph, we output that.

      Then, if we don't find the entire graph matching, we try the spanning trees: for each cycle edge e_i, we remove e_i and try to match the remaining N-1 edges.

      And note: the set of edges for the spanning tree F_i is F0 without e_i.

      How to check F_i? We can run a bipartite matching for F_i? 

      But note: we can use the matching for the entire graph as a starting point? Actually, we are missing one edge. We can try to remove the edge e_i and then see if we can match the remaining edges? But we don't have a matching for the entire graph.

      Alternatively, we can use the Hopcroft-Karp algorithm? But worst-case we are doing 2000 matchings.

      We need a faster way.

      Idea: we can precompute a matching for the entire graph without one edge? But note: we don't have a matching for the entire graph.

      Alternatively, we can do:

          First, try to match the non_cycle_edges. There are N-L edges. We must match these. Then, for the cycle_edges, we are going to skip one, so we need to match L-1 cycle_edges.

          Then, we can:

              Step 1: match the non_cycle_edges. How? We run a bipartite matching for the non_cycle_edges. If we cannot match them, then no candidate works.

          Step 2: for the cycle_edges, we want to match L-1 of them. And we have the remaining workers (K - (N-L) workers available? Actually, we have used N-L workers for the non_cycle_edges. Then we have K - (N-L) workers left, and we have L cycle_edges, and we want to match L-1 of them.

          Then, we can run a bipartite matching for the cycle_edges with the remaining workers? But we want to match L-1 edges. And then we choose which one to skip.

          How? 

              We can run a bipartite matching for the entire set of cycle_edges (L edges) with the entire set of workers (but note: some workers are already used for non_cycle_edges). 

              We have to use only the available workers. 

              Then, if we can match L edges, then we can skip any one cycle edge? Actually, no: we only need to match L-1. 

              But if we can match L edges, then we can match any L-1? Actually, if there is a matching for L edges, then there is a matching for any L-1 edges? 

              But not necessarily: because the matching for L edges might be such that a particular edge is matched to a worker that is not available for any other edge? 

          Alternatively, we can try to match the cycle_edges to the available workers for L-1 of them? But we don't know which one to skip.

          We can do:

              Let G_cycle be the bipartite graph for the cycle_edges and the available workers (the workers not used in non_cycle_edges).

              We want to know: is there a subset of L-1 cycle_edges that can be matched? 

              This is equivalent to: the maximum matching in G_cycle has size at least L-1.

              Then, if the maximum matching in G_cycle is at least L-1, then we can skip one edge arbitrarily? But we have to output the assignment, so we need to know which edge to skip.

              Actually, if the maximum matching is L, then we can skip any edge. If the maximum matching is L-1, then we can only skip an edge that is not matched? But then we have to choose an unmatched edge to skip.

              But if the maximum matching is L-1, then there is no matching of size L, so we cannot skip arbitrarily: we have to skip an edge that is not in the matching? But then the matching we have is for L-1 edges, so we skip one edge and it can be any unmatched edge? Actually, we skip one edge arbitrarily? But we have L-1 edges matched, so we skip one of the cycle_edges that is not matched? But there is exactly one unmatched edge? 

          Therefore, we can:

              Step 1: match the non_cycle_edges. If we cannot match all non_cycle_edges, then output -1.

              Step 2: run a bipartite matching for the cycle_edges with the available workers. Let M be the size of the matching.

              If M >= L-1, then we can form a solution: we will skip one cycle edge that is not matched (if there is an unmatched edge) or if M==L, then we can skip any edge (because we only need L-1, so we arbitrarily skip one edge and remove it from the matching? But then we have to remove one matched edge? and free the worker? but we don't need to build that edge).

              But note: if M = L, then we have matched all cycle_edges. Then we can choose to skip any one cycle edge? But then we have to not build that edge and leave the worker idle? That is allowed.

              If M = L-1, then we have one cycle_edge unmatched. Then we skip that unmatched edge.

              But what if M < L-1? Then we cannot match L-1 cycle_edges? Then output -1.

          Therefore, we only need two bipartite matchings:

              Matching1: for non_cycle_edges (size = N-L) -> time O((N-L)*K) worst-case 2000*2000=4e6.

              Matching2: for cycle_edges (size = L) -> time O(L*K) = 2000*2000=4e6.

          Total time: 8e6, which is acceptable.

          Then we can output:

              We build all non_cycle_edges and all cycle_edges except one skipped edge.

              The skipped edge: if we have M = L, then we can skip any cycle edge? But which one? The problem doesn't care. But we have to output the assignment for the workers. 

              For the cycle_edges: we have a matching for L edges? But we only need to build L-1. So we will skip one cycle edge arbitrarily. How? 

                  We can choose any cycle edge to skip. But then we have to remove its assignment? 

                  Actually, we can skip any cycle edge. So we can choose one arbitrarily, say the first cycle edge in our list. Then we remove it from the matching. Then the worker that was assigned to it becomes idle.

              But wait: we haven't matched it yet? In our matching for cycle_edges, we matched L edges. But we only have L-1 to build. So we can remove one assignment.

              Specifically:

                  We have a matching for cycle_edges: we have matched every cycle edge to a worker.

                  Then we decide to skip one cycle edge e. Then we remove e from the matching: then the worker that was matched to e is now idle.

              Therefore, for the worker that was matched to e, we output "0 0" in his line? But note: we have already used that worker for a non-cycle edge? No: the available workers for cycle_edges are distinct from those for non_cycle_edges. And we haven't assigned the worker for e yet? 

              Actually, we did two matchings: first for non_cycle_edges, then for cycle_edges. The cycle_edges matching uses workers that are not used in non_cycle_edges.

              Then, after matching, we have an assignment for all non_cycle_edges and all cycle_edges. Then we decide to skip one cycle edge e. Then we remove the assignment for e: the worker that was assigned to e is now not assigned to any edge? So for that worker, we output "0 0".

              But note: the worker is still used? In the matching for cycle_edges we used that worker. But then we remove the assignment. So that worker is not building any edge.

              This is allowed.

          Then, if M = L-1, then we skip the unmatched cycle edge. We don't need to do anything extra.

   But wait: what about the entire graph option? We haven't considered candidate0 (entire graph). 

        We can do:

            if K >= N:
                Try to match the non_cycle_edges and then the cycle_edges without skipping any? 
                But note: we have to match all edges. 

            We can do:

                Step 1: match non_cycle_edges: must be matched.
                Step 2: match cycle_edges: must be matched completely (L edges).

            If both succeed, then we have a matching for the entire graph.

            Then we output that matching.

            Otherwise, we proceed to the spanning tree option: skip one cycle edge.

        Then for the spanning tree option:

            if K < N-1: then we already know impossible.

            But we require at least N-1 workers? We have K >= N-1 (since if K < N-1 we output -1).

            Then:

                Step 1: match non_cycle_edges: must be matched (N-L edges).
                Step 2: match cycle_edges: we only require a matching of size L-1? Actually, we have a bipartite graph for cycle_edges and available workers. We want to know if the maximum matching is at least L-1.

            But note: in the spanning tree option, we are not building one cycle edge, so we only need to match L-1 cycle_edges.

        However, we can combine the entire graph option in the same structure? 

            Entire graph: requires matching non_cycle_edges and then matching cycle_edges (size L) with the available workers.

            Spanning tree: requires matching non_cycle_edges and then matching at least L-1 cycle_edges.

        Therefore, we can:

            Step 1: Match non_cycle_edges. If fail, output -1.

            Step 2: Let R = the set of available workers (workers not used in non_cycle_edges). 

                    Then, we want to know if we can match the cycle_edges in two ways:

                        Option A: match all L cycle_edges (if we want to build the entire graph) -> requires that the matching size for cycle_edges is L.

                        Option B: match at least L-1 cycle_edges (for spanning tree) -> requires that the matching size for cycle_edges is at least L-1.

            Then:

                if K >= N and Option A is successful, then we can build the entire graph: skip no edge.

                else, if Option B is successful (matching size for cycle_edges >= L-1), then we build the spanning tree: skip one cycle edge (which is either an unmatched edge or an arbitrary one if all are matched).

                else, output -1.

        How to get the matching for cycle_edges? We run one bipartite matching for the cycle_edges with the available workers R. We record the matching.

        Then:

            Let M = size of the matching for cycle_edges.

            For the entire graph: we need M == L.

            For the spanning tree: we need M >= L-1.

        Then, for the spanning tree: we skip one edge:

            if M == L: then we have matched all cycle_edges. We can skip any cycle edge? We choose one arbitrarily (say the first in our list) and remove it from the matching. Then we have matched L-1 cycle_edges.

            if M == L-1: then we skip the unmatched cycle edge.

        Then, the set of built edges is: non_cycle_edges + the cycle_edges that are matched (which is L-1 edges).

        And the assignment: 

            For non_cycle_edges: we have the matching.

            For cycle_edges: we have the matching we computed, and then we removed one assignment (if M==L) or we did nothing (if M==L-1).

        Then, for each worker:

            If the worker was assigned to a non_cycle_edge, output that edge.

            If the worker was assigned to a cycle_edge that we are building (not skipped), output that cycle_edge.

            If the worker was assigned to the skipped cycle_edge (only if M==L and we skipped one matched edge), then we output "0 0" for that worker.

            For workers that were not assigned at all, output "0 0".

        But note: the available workers R: we used exactly (N-L) + (L-1) = N-1 workers? And we have K workers. The rest are idle.

        And we output in the order of the worker input.

   Therefore, the algorithm:

        Step 0: if K < N-1, output -1.

        Step 1: Build the graph and find the cycle.

        Step 2: Precompute for each edge the list of workers that can build it.

        Step 3: Match the non_cycle_edges:

            Let F1 = non_cycle_edges (size = N-L)

            Run bipartite matching for F1 and all K workers.

            If we cannot match all edges in F1, output -1.

            Let used_worker = set of workers matched to F1.

            available_workers = all workers not in used_worker.

        Step 4: Match the cycle_edges:

            Let F2 = cycle_edges (size = L)

            Run bipartite matching for F2 and available_workers.

            Let M = size of the matching for F2.

        Step 5: Check:

            If K>=N and M == L:
                Then we build the entire graph: skip no edge.
                Then the assignment for cycle_edges is the matching we found.

            Else if M >= L-1:
                Then we build the spanning tree: skip one cycle edge.
                How to skip:
                    If M == L:
                        We choose an arbitrary cycle edge e0 to skip (say the first edge in our list of cycle_edges).
                        If e0 is matched to worker w, then we remove the assignment for e0: so we set the worker w to idle.
                        For the other cycle_edges, we keep the assignment.
                    Else (M == L-1):
                        There is exactly one cycle edge that is unmatched. We skip that edge.
            Else:
                output -1.

        Step 6: Output the assignment:

            We create an array res[0..K-1] of strings, initially all "0 0".

            For each non_cycle_edge e:
                worker_id = the worker matched to e (from Step3)
                res[worker_id] = string representation of edge e.

            For each cycle_edge e that is built (i.e., not skipped and matched in the cycle_edges matching (if we are in the entire graph) or in the spanning tree we skip one edge and the rest are built as per the matching after removal):

                worker_id = the worker matched to e (from Step4, but if we skipped e and it was matched, then we skip this assignment? Actually, we skip the edge, so we don't output the edge for the worker that was matched to it? But wait: we have two cases:

                  - In the entire graph: we use the matching as is -> so every cycle_edge is built and we output the assignment.

                  - In the spanning tree: we skip one edge. For the skipped edge, we do nothing. For the other cycle_edges, we output the assignment.

            But note: in the spanning tree, we removed the assignment for the skipped edge? How did we record that?

                We know which edge we skipped: e_skip.

                For the cycle_edges matching we did in Step4, we had a matching that covered M cycle_edges. For the skipped edge, we don't build it, so we don't assign any worker to build it? But note: in the matching for Step4, we might have matched the skipped edge? 

                In the case M==L, we did match the skipped edge. Then we remove that assignment: so for the worker that was matched to e_skip, we do not output the edge? We leave that worker as idle? So we leave res[worker_id] = "0 0" (which was the initial value).

                In the case M==L-1, the skipped edge was not matched, so we do nothing.

            Therefore, for each cycle_edge e that is not skipped and that is matched (which is all cycle_edges except the skipped one, and note that in the entire graph we skip none) we assign:

                worker_id = the worker from the matching in Step4 (for the cycle_edges)

                and set res[worker_id] = string representation of edge e.

            But note: in the entire graph, we don't skip any edge, so we assign every cycle_edge.

            And in the spanning tree, we skip one edge, so we assign the other L-1 cycle_edges.

            Then, for the workers that are not assigned to any edge, res[i] remains "0 0".

        Step 7: Output res[0] to res[K-1] in separate lines.

   But note: what if in the entire graph we have a worker that was not assigned? That cannot happen: because we built the entire graph: we used N = (N-L) + L workers. And we matched all non_cycle_edges and all cycle_edges. So every worker that was assigned in the two matchings is used. But there might be workers that are not assigned? We have K workers, and we used N workers. But we only use N workers. The rest are idle. And we output "0 0" for them (which is the initial value).

   Similarly, in the spanning tree: we use (N-L) + (L-1) = N-1 workers. The rest are idle.

   This meets the requirement.

   However, note: the matching for non_cycle_edges: we used a bipartite matching that might use any worker. The matching for cycle_edges: we used workers from the available set. Then in the entire graph, we used N workers. In the spanning tree, we used N-1 workers.

   The output: for each worker in the input order, we output either the edge that the worker built or "0 0".

   Therefore, we are done.

   But note: what if we have duplicate materials? The problem says: workers have materials C_i. The same material can appear multiple times? Yes. And we handled that: in the material_to_workers mapping, we have a list of worker indices for a material.

   Also, the total sum of |S_e| is 10000, so the precomputation for the worker list for each edge is acceptable.

   Time: 
        Step1: BFS for the graph: O(N)
        Step2: Precomputation of worker lists for edges: O( total_work ) = O( sum_{e} ( sum_{m in S_e} (freq(m)) ) ) = O( sum_{m} (freq(m) * (number of edges with m)) ) 
                and the total_work is bounded by 10000 * (max frequency of a material in workers) and the max frequency is at most 2000, so 20e6 worst-case? But the total_work is the sum over m of (freq(m) * (#edges containing m)). And note: the sum of (#edges containing m) over m is the total |S_e| = 10000. But the worst-case is if one material appears in many edges and also has many workers? 

                Actually, we do:

                  for each edge e: 
                      for each material m in S_e: 
                         for each worker index w in material_to_workers[m]: 
                             add w to the list for e.

                The total number of iterations is: for each material m, we iterate over each occurrence in an edge and then over each worker with that material: so total = sum_{m} (freq(m) * (number of edges that have m)).

                And the sum over m of (number of edges that have m) = total |S_e| = 10000.

                But the worst-case total iterations: 10000 * (max freq(m)) and max freq(m) is at most K=2000 -> 20e6, which is acceptable.

        Step3: Bipartite matching for non_cycle_edges: size = N-L <= N-1 (since L>=1) -> at most 2000. The time: O( (N-L) * (max_degree for an edge) ). The max_degree for an edge: the number of workers that can build it, which is at most K=2000. So worst-case O( (N-L) * K ) = 2000*2000 = 4e6.

        Step4: Bipartite matching for cycle_edges: size L, time O(L * (max_degree)) = 2000*2000 = 4e6.

        Total: 20e6 + 4e6 + 4e6 = 28e6, which is acceptable.

   Let's test with the sample:

        Sample Input #1:
            4 5
            2 2 1 2   -> city1: edge(1,2) with materials [1,2]
            3 2 2 3   -> city2: edge(2,3) with materials [2,3]
            4 2 3 4   -> city3: edge(3,4) with materials [3,4]
            2 2 4 5   -> city4: edge(4,2) with materials [4,5]
            Workers: [1,2,3,4,5]

        Step1: Build graph and find cycle.

            Edges: 
                1: (1,2)
                2: (2,3)
                3: (3,4)
                4: (4,2)

            Adjacency:
                1: [2]
                2: [1,3,4]
                3: [2,4] -> wait, no: 
                  Actually: 
                    edge1: 1-2
                    edge2: 2-3
                    edge3: 3-4
                    edge4: 4-2

                So:
                  1: [2]
                  2: [1,3,4]   -> deg2=3
                  3: [2,4]      -> deg3=2
                  4: [3,2]      -> deg4=2

            Then we do BFS with leaves:

                deg1=1 -> push 1.
                Process 1: remove edge (1,2); then deg2 becomes 2 (because it had 3, then remove 1, so 3-1=2). 
                Then we have no leaf? 

                Then the remaining graph: 
                    nodes 2,3,4: 
                    edges: (2,3), (2,4), (3,4) -> but wait, (3,4) is also there? 
                Actually, the edges are:
                  (2,3), (2,4), (3,4) -> but (3,4) is present? Then the cycle is 2-3-4-2? 

            So:

                non_cycle_edges: [ (1,2) ]
                cycle_edges: [ (2,3), (3,4), (4,2) ]

            L = 3.

        Step2: Precompute worker lists for edges:

            Workers: [1,2,3,4,5] -> worker0:1, worker1:2, worker2:3, worker3:4, worker4:5.

            For edge (1,2): materials [1,2] -> workers: worker0 (1) and worker1 (2). -> list = [0,1]
            For edge (2,3): materials [2,3] -> workers: worker1 (2), worker2 (3). -> list = [1,2]
            For edge (3,4): materials [3,4] -> workers: worker2 (3), worker3 (4). -> list = [2,3]
            For edge (4,2): materials [4,5] -> workers: worker3 (4), worker4 (5). -> list = [3,4]

        Step3: Match non_cycle_edges: only one edge: (1,2)

            We run matching for edge (1,2): the list of workers = [0,1]. We pick worker0? (or worker1). Let's say we pick worker0.

            Then used_worker = {0}
            available_workers = {1,2,3,4}

        Step4: Match cycle_edges: 3 edges: 
            e1: (2,3): workers [1,2]
            e2: (3,4): workers [2,3]
            e3: (4,2): workers [3,4]

            We run bipartite matching:

                e1: (2,3) -> try worker1: available -> match e1 to worker1.
                e2: (3,4) -> try worker2: available -> match e2 to worker2.
                e3: (4,2) -> try worker3: available -> match e3 to worker3.

            Then M = 3.

        Then we have two options:

            Option: entire graph: K>=N? K=5, N=4 -> 5>=4 -> yes. And M=3 (which is L) -> so we build the entire graph.

            Then assignment:

                non_cycle_edge (1,2) -> worker0: output for worker0: "1 2" (or "2 1")
                cycle_edges:
                    (2,3) -> worker1: output "2 3" (or "3 2")
                    (3,4) -> worker2: output "3 4" (or "4 3")
                    (4,2) -> worker3: output "4 2" (or "2 4")

                Worker4: not assigned -> "0 0"

            Then output:

                worker0: 1 2
                worker1: 2 3
                worker2: 3 4
                worker3: 4 2
                worker4: 0 0

            But the sample output is:

                1 2
                2 3
                3 4
                0 0
                4 2

            So the order of the workers: the workers are given in the input as [1,2,3,4,5]. 

            We have:

                worker0: material=1 -> assigned to (1,2) -> output "1 2"
                worker1: material=2 -> assigned to (2,3) -> output "2 3"
                worker2: material=3 -> assigned to (3,4) -> output "3 4"
                worker3: material=4 -> assigned to (4,2) -> output "4 2"
                worker4: material=5 -> not assigned -> output "0 0"

            But the sample output for the fifth worker (worker4) is "4 2", but we assigned worker3 to (4,2) and worker4 is idle.

            However, the problem says: output in the same order as the input of workers.

            The input of workers: the next line: "1 2 3 4 5"

            So:

                first worker (worker0): output "1 2"
                second worker (worker1): output "2 3"
                third worker (worker2): output "3 4"
                fourth worker (worker3): output "4 2"
                fifth worker (worker4): output "0 0"

            But the sample output:

                first: 1 2
                second: 2 3
                third: 3 4
                fourth: 0 0
                fifth: 4 2

            Why the difference? 

            The sample output has the fifth worker (last worker, material=5) building the edge (4,2). But our assignment: the worker with material=4 built the edge (4,2). The worker with material=5 is not building anything.

            But the edge (4,2) can be built by worker3 (material=4) or worker4 (material=5)? Because the materials for (4,2) are [4,5]. 

            So we could assign worker4 to (4,2) and leave worker3 idle? 

            How did we assign? 

                In the cycle_edges matching, we tried:

                    e1: (2,3) -> we tried worker1 (material=2) -> works.
                    e2: (3,4) -> we tried worker2 (material=3) -> works.
                    e3: (4,2) -> we tried worker3 (material=4) -> works.

                But we could have assigned:

                    e1: worker1 (2)
                    e2: worker2 (3)
                    e3: worker4 (5)   -> then worker3 (material=4) is idle.

            Then the output:

                worker0: "1 2"
                worker1: "2 3"
                worker2: "3 4"
                worker3: "0 0"   (because worker3 is not assigned to any edge)
                worker4: "4 2"

            This matches the sample.

            Therefore, we must be cautious: the bipartite matching might use different matchings. The standard DFS matching for bipartite matching uses an arbitrary order? 

            We can try to assign the workers in the order of the edge list? But the sample matching we described is also valid.

            The problem does not require a specific valid assignment. So either is acceptable.

            However, the problem says: "You may output any assignment as long as any pair of cities are connected by a sequence of constructed road."

            So both are acceptable.

        How to ensure we get the sample assignment? 

            In the bipartite matching for cycle_edges, we iterate the edges in a fixed order (say the order we stored: (2,3), (3,4), (4,2)). Then for each edge, we iterate the worker list in the given order? 

            The worker list for (4,2) is [3,4] (workers with material 4 and 5, but we stored the list as the workers we found: we iterated over materials [4,5] and then for each material, we iterated the workers. But the workers for material4: [worker3] and for material5: [worker4]. So the list is [3,4] (worker3 then worker4).

            Then we try worker3 first? Then we assign worker3.

            To get the sample, we would have to try worker4 first? 

            We can sort the worker list for an edge arbitrarily? But to mimic the sample, we might try the worker with the same material as the worker's input order? Not necessary.

            Alternatively, we can try to assign the workers in the order of the worker input? But the bipartite matching algorithm: we can try the workers in any order. The DFS for an edge: we try the workers in the order we stored. 

            Since the problem allows any assignment, we can do as we did.

        But note: the sample input #2:

            4 5
            2 2 10 20   -> edge (1,2) with materials [10,20]
            ... others as before.

            Workers: [1,2,3,4,5]

            Then:

                non_cycle_edges: (1,2) -> materials [10,20]: which workers have material 10 or 20? None of the workers [1,2,3,4,5] have 10 or 20? 

                Then matching for non_cycle_edges fails -> output -1.

            Matches sample.

   Implementation:

        Step1: Build graph and find non_cycle_edges and cycle_edges.

            We will:

                Build an array of edges: 
                    edge[i] = (i, A_i)   for i from 1 to N.

                Build an undirected graph: 
                    We can use an array of vectors: graph[1..N]

                Then:

                    deg[i] = number of neighbors (but we will build the graph: for each edge (u,v), add v to graph[u] and u to graph[v])

                Then:

                    from collections import deque
                    q = deque()
                    deg = [0]*(N+1)
                    for i in range(1, N+1):
                        deg[i] = len(graph[i])
                    # But we can build the graph and then the deg array.

                Actually, we can:

                    graph = [[] for _ in range(N+1)]
                    for i in range(1, N+1):
                        u = i
                        v = A_i (from input)
                        graph[u].append(v)
                        graph[v].append(u)
                        deg[u] = len(graph[u])   -> but we can do: initially deg[u]=0, then we do deg[u]++ for each edge?
                    Actually, we can compute deg: 
                         deg = [0]*(N+1)
                    for i in range(1, N+1):
                        v = A_i
                        deg[i] += 1
                        deg[v] += 1

                But note: the edge (i, A_i) is counted: 
                    for i: we add one because we have an edge to A_i.
                    for A_i: we add one because we have an edge from i.

                Then:

                    q = deque()
                    for i in range(1, N+1):
                        if deg[i] == 1:
                            q.append(i)

                    non_cycle_edges = []  # list to collect edges that are non_cycle
                    in_cycle = [True] * (N+1)   # we mark nodes that are in the cycle? Then we remove leaves.

                    while q:
                         u = q.popleft()
                         in_cycle[u] = False
                         for v in graph[u]:
                             if deg[v] > 0:   # and the edge (u,v) is still present?
                                 # remove the edge (u,v)
                                 deg[u] -= 1
                                 deg[v] -= 1
                                 non_cycle_edges.append( (min(u,v), max(u,v)) )   # or store the edge in the original representation? 
                                 # But we need the material set, which we stored by (min(u,v), max(u,v))? 
                                 # Then we can store the edge as (min(u,v), max(u,v))

                                 # Then, if after removing the edge, deg[v] becomes 1, push v.
                                 if deg[v] == 1:
                                     q.append(v)

                    Then the cycle_edges: 
                         We can collect: for each edge (i, A_i), if the edge (min(i, A_i), max(i, A_i)) is not in non_cycle_edges, then it is a cycle edge.

                    But note: we might have collected the same edge multiple times? 

                Alternatively, we can mark the edges that we removed. But we stored non_cycle_edges as a list? Then we can create a set of non_cycle_edges (as (min(u,v), max(u,v))).

                Then cycle_edges = []
                for i from 1 to N:
                    u = i
                    v = A_i
                    key = (min(u,v), max(u,v))
                    if key not in non_cycle_edges_set:
                         cycle_edges.append(key)

                But note: we removed the edge (u,v) only once? 

        However, we removed each non_cycle edge once. Then the remaining edges are cycle_edges.

        But note: the graph might have multiple edges? The input has no multiple edges.

        Then non_cycle_edges_set = set(non_cycle_edges)

        Then cycle_edges = [ key for the edge (i, A_i) if (min(i, A_i), max(i, A_i)) not in non_cycle_edges_set ]

        But note: we have one edge per i. And we stored non_cycle_edges as the edges we removed. So it is consistent.

        Step2: Precomputation for worker lists for edges.

            We have a dictionary: materials_dict = {}
            For i from 1 to N:
                u = i
                v = A_i
                key = (min(u, v), max(u, v))
                materials_dict[key] = B_i   # the list of materials for that edge

            Then for each edge in non_cycle_edges and cycle_edges, we can get the materials.

            Then, we precomputed a dictionary: material_to_workers = {}
            For worker_index in range(K):
                c = C[worker_index]
                if c not in material_to_workers:
                    material_to_workers[c] = []
                material_to_workers[c].append(worker_index)

            Then for an edge e (with key) and material list = materials_dict[key]:
                worker_list = []
                for m in materials_dict[key]:
                    if m in material_to_workers:
                        for w in material_to_workers[m]:
                            worker_list.append(w)

                Then we store worker_list_by_edge[e] = worker_list   (and we use e as (min,max))

        Step3: Bipartite matching for non_cycle_edges.

            We'll create an array: match_non[edge_index] = worker_id   (for non_cycle_edges)

            We have a list of non_cycle_edges: non_cycle_edges_list.

            We'll do:

                match_worker = [-1] * K   # for each worker, the edge index they are matched to, or -1 if not matched.
                # But we don't need to output the match_worker? We need to know which worker is matched to which edge.

                Alternatively, we can do:

                    match_non = [-1] * len(non_cycle_edges_list)   # match_non[i] = worker_id for the i-th non_cycle_edge

                We use DFS for each edge.

                We'll create a graph: for edge_index i, the list of workers that can build it.

                Then:

                    def dfs(edge_index, seen):
                         for worker in worker_list_for_this_edge:
                             if not seen[worker]:
                                 seen[worker] = True
                                 if match_worker[worker] == -1 or dfs(match_worker[worker], seen) is True:
                                     match_worker[worker] = edge_index
                                     match_non[edge_index] = worker
                                     return True
                         return False

                But note: we want to match edges to workers? Actually, we can do:

                    We create an array: match_edge[edge_index] = worker_id, and match_worker[worker_id] = edge_index.

                We can do:

                    for edge_index in range(len(non_cycle_edges_list)):
                        seen = [False] * K   # but K can be 2000, and we have up to 2000 edges -> 2000*2000=4e6, which is acceptable.

                        if not dfs(edge_index, seen): 
                            return -1   # fail

                But we don't need to return, we break.

            However, we can use the standard matching algorithm.

        Step4: Similarly for cycle_edges.

        Step5: Then we know the two matchings.

        Then output as described.

   Note: we must store the original representation of the edge? We stored the edge as (min, max). But when we output, we can output the two numbers in any order? So we can output min then max? Or we can output as in the input? 

        The problem does not require the original direction. So we can output the two endpoints arbitrarily.

        But note: the sample output for the edge (4,2) is "4 2", which is not min first? min=2, max=4 -> then we would output "2 4". But the sample output "4 2".

        However, the problem says "in any order". So both are acceptable.

        But to match the sample output, we might output the endpoints as we stored them? We stored as (min, max). Then we output min first? 

        However, the sample output for the fifth worker is "4 2", which is not min first? 

        Therefore, we can output in any order. We can output the edge as (u, v) as we got it from the key? The key was (min, max). But we don't have to output min first. We can output the endpoints arbitrarily.

        To be consistent, we can store for each edge the two endpoints? Then when we output, we output the two endpoints? We can output in the order (u, v) as stored in the key? Or we can output the first endpoint as the one that proposed the edge? 

        But we don't store that. 

        Since the problem allows any order, we can output min then max? Or we can output the endpoints as we stored in the key: (min, max) and output min first? 

        But the sample output for the edge (4,2) is "4 2", which is (max, min)? 

        How did we store the key for (4,2)? min=2, max=4. So the key is (2,4). Then if we output "2 4", that is acceptable? But the sample output is "4 2".

        The problem does not require a particular order. So we can output the edge as (2,4) or (4,2). 

        We can choose: output the key as (min, max) and then output min and then max? 

        But to match the sample, we might output arbitrarily? 

        Alternatively, we can output the edge as it was proposed: the original proposal for (4,2) is by city4, so we output "4 2"? 

        How to recover that? 

            We stored the key by (min, max). But we also know: the edge (min, max) was proposed by the city that is either min or max? Specifically, the city that is i such that the other endpoint is A_i. 

            But we don't store that.

        Since the problem allows any order, we can output the endpoints in any order. So we can choose to output the edge as (min, max) and then output min then max? 

        But the sample output for the edge (4,2) is "4 2", which is not min then max. So we must be allowed to output in any order.

        We can simply store the edge as a tuple (u, v) without sorting? Then when we output, we output u and then v? 

        How did we store the edge? In the BFS we stored the edge as (min(u,v), max(u,v))? Then we don't know the original order.

        But we can avoid that: in the BFS, when we remove an edge (u,v), we store the edge as (u,v) and (v,u) are the same. But we don't care. 

        Then when we output, we can output the endpoints in the order we stored in the key? But the key is (min, max). Then we output min then max? 

        Or we can output max then min? 

        The problem: we are free.

        We decide: output the edge as (min, max) and then output min and then max.

        Then for (4,2): we output "2 4", which is different from the sample. But the problem allows.

        But the sample output uses "4 2". 

        How can we output "4 2"? 

            We stored the edge as (2,4). Then we can output the two endpoints in any order. So we can also output in reverse: max then min? 

        We can do: for an edge (u,v) (with u<v), output u and v in the order we choose arbitrarily? 

        But we want to match the sample? 

        Actually, the problem does not require the original order. So we can output arbitrarily.

        However, the sample input #1 output is:

            1 2
            2 3
            3 4
            0 0
            4 2   -> this is the edge (4,2) and they output "4 2", so they did not sort.

        How did they get that? 

            The edge (4,2) is stored in the input for city4: so they output the endpoints as the city that proposed it and the one it likes? So (4,2) for the proposal by city4.

        We can store for each edge the representation (i, A_i) for the city i that proposed it? 

            Then for an edge, we know the two endpoints: (i, A_i). Then we can output either "i A_i" or "A_i i".

        The problem: we stored the edge by the key (min, max). But we also stored the material set? But we did not store the original (i, A_i) for the edge.

        How to recover? 

            We have the key = (min, max). And we know that the edge was proposed by one of the endpoints. Specifically, the one for which the input said A_i = the other endpoint.

            We can store:

                original_edge_representation = {}   # key -> (u, v) as in the proposal: u is the proposer, v is the liked city.

            For i from 1 to N:
                u = i
                v = A_i
                key = (min(u,v), max(u,v))
                original_edge_representation[key] = (u, v)   # but if we get the same key from two different proposals, it shouldn't happen.

            Then when we output an edge, we can output the original representation: 

                (u, v) = original_edge_representation[key]

                then output u and v? 

            But the problem allows any order? So we can output u then v, or v then u. 

            But the sample output for (4,2) is "4 2", which is the representation from city4: (4,2). 

            If we output the representation as (u, v) for the proposer u, then we output u and then v? 

            Then for the edge (4,2) (key (2,4)): we have stored (4,2) as the representation? 

            How: 
                For city4: u=4, v=2 -> key = (2,4) -> store (4,2) as the representation? 

            Then we output "4 2" for that edge.

            For the edge (1,2) from city1: we store (1,2) and output "1 2".

            Then the sample assignment:

                worker0: edge (1,2) -> output "1 2"
                worker1: edge (2,3) -> from city2: stored (2,3) -> output "2 3"
                worker2: edge (3,4) -> from city3: stored (3,4) -> output "3 4"
                worker4: edge (4,2) -> from city4: stored (4,2) -> output "4 2"

            This matches the sample.

            Therefore, we can store for each edge (by key) the original representation from the proposer.

            Steps:

                For i from 1 to N:
                    u = i
                    v = A_i
                    key = (min(u,v), max(u,v))
                    original_rep[key] = (u, v)   # we store (u,v) as the representation.

                Then when we output the edge, we output the two numbers: u and v (from the representation) in the order of the representation.

            But note: what if we output (v, u)? The problem allows any order. But the representation (u, v) is arbitrary? 

            We choose to output the representation as (u, v) from the proposer.

        Then we are done.

   Summary of the algorithm:

        Read N, K.
        For i in range(1, N+1):
            read A_i, M_i, and the list B_i of M_i integers.

        Read the list C of K integers.

        Step1: Build graph and get non_cycle_edges and cycle_edges.

            graph = [[] for _ in range(N+1)]
            edges = []   # list of all edges in the original order? 
            We will store: 
                for i in range(1, N+1):
                    u = i
                    v = A_i
                    graph[u].append(v)
                    graph[v].append(u)
                    # record the edge: and also store the original representation and the material set by key.

            Then compute deg = [0]*(N+1)
            for i in range(1, N+1):
                deg[i] = len(graph[i])

            q = deque()
            for i in range(1, N+1):
                if deg[i] == 1:
                    q.append(i)

            non_cycle_edges_set = set()   # set of keys: (min(u,v), max(u,v))
            while q:
                u = q.popleft()
                # find the only neighbor v that is still connected? 
                for v in graph[u]:
                    if deg[v] > 0:   # the edge (u,v) is present?
                        # remove the edge
                        deg[u] -= 1
                        deg[v] -= 1
                        key = (min(u,v), max(u,v))
                        non_cycle_edges_set.add(key)
                        if deg[v] == 1:
                            q.append(v)

            Then, cycle_edges_set = set()
            For i in range(1, N+1):
                u = i
                v = A_i
                key = (min(u,v), max(u,v))
                if key not in non_cycle_edges_set:
                    cycle_edges_set.add(key)

            But we need lists for the matching? 

            non_cycle_edges_list = list(non_cycle_edges_set)   # but note: the set of keys, and each key is an edge.
            cycle_edges_list = list(cycle_edges_set)

            Also, we need to store the material set and the original representation for each edge (by key).

        Step2: Precomputation:

            material_to_workers = {}
            for worker_index in range(K):
                c = C[worker_index]
                if c not in material_to_workers:
                    material_to_workers[c] = []
                material_to_workers[c].append(worker_index)

            Also, build:

                original_rep = {}   # key -> (u, v) from the proposal
                materials_dict = {}  # key -> list of materials (B_i)

            For i from 1 to N:
                u = i
                v = A_i
                key = (min(u,v), max(u,v))
                if key not in original_rep:   # it will be added once? because no mutual, so each edge is represented once.
                    original_rep[key] = (u, v)
                    materials_dict[key] = B_i   # the list of materials

            Then, for each edge in non_cycle_edges_list and cycle_edges_list, we compute worker_list:

                worker_list_non = []   # for non_cycle_edges: list for each edge? we store in a list for the edges in non_cycle_edges_list.
                worker_list_cycle = []

            Actually, we can create:

                worker_list_by_key = {}
                for key in non_cycle_edges_list + cycle_edges_list:
                    worker_list = []
                    for m in materials_dict[key]:
                        if m in material_to_workers:
                            for w in material_to_workers[m]:
                                worker_list.append(w)
                    worker_list_by_key[key] = worker_list

        Step3: Matching for non_cycle_edges.

            Let non_cycle_edges_list = list of keys for non_cycle_edges.

            We will create:

                match_non = [-1] * len(non_cycle_edges_list)   # match_non[i] = worker_id for the i-th edge in non_cycle_edges_list
                match_worker = [-1] * K   # match_worker[worker_id] = index in non_cycle_edges_list, or -1 if not matched.

            Then we do DFS for each edge:

                def dfs(i, seen):   # i: index in non_cycle_edges_list
                    for worker in worker_list_by_key[non_cycle_edges_list[i]]:
                        if not seen[worker]:
                            seen[worker] = True
                            if match_worker[worker] == -1 or dfs(match_worker[worker], seen):
                                match_worker[worker] = i
                                match_non[i] = worker
                                return True
                    return False

                Then for each i in range(len(non_cycle_edges_list)):
                    seen = [False] * K
                    if not dfs(i, seen): 
                         print(-1) and exit(0)

            Then we know the matching for non_cycle_edges.

            available_workers = [w for w in range(K) if match_worker[w] == -1]

            But we don't need the list, we will do the next matching for cycle_edges with the entire set of workers, but skipping the matched workers.

            How: we will create a new array for the next matching that only considers available workers.

        Step4: Matching for cycle_edges.

            We will create a new array for the cycle_edges matching: we don't use the workers that are matched in non_cycle_edges.

            We do:

                match_cycle = [-1] * len(cycle_edges_list)   # match_cycle[i] = worker_id for the i-th cycle edge
                match_worker_cycle = [-1] * K   # for available workers? Actually, we can reuse the match_worker array? Or we can create a new one.

            But we already have match_worker for non_cycle_edges? We want to match cycle_edges only to workers that are not matched in non_cycle_edges.

            We can do:

                We'll create a new graph: for cycle_edges, and for each worker that is available.

            Actually, we can run the same DFS style, but for each cycle edge, we only consider workers that are not matched in non_cycle_edges? 

            How: we can create an array: used_worker = [False]*K, but we know: a worker is available if match_worker[worker] == -1.

            Then in the DFS for cycle_edges, we only consider workers that are available (i.e., match_worker[worker] == -1) and also that are not used in the current DFS? 

            However, in the matching for cycle_edges, we are allowed to use any available worker.

            We can do:

                match_worker_cycle = [-1] * K   # for cycle_edges: this will be the matching for cycle_edges, but note: we only consider available workers.

                Actually, we can do:

                    Let available = a set of workers: those with match_worker[worker] == -1.

                But we can do the DFS without explicitly creating a set, because we can check: 

                    if match_worker[worker] != -1: skip.

            Then:

                def dfs_cycle(i, seen): 
                    for worker in worker_list_by_key[cycle_edges_list[i]]:
                        # if this worker is not available (because matched in non_cycle), skip.
                        if match_worker[worker] != -1: 
                            continue
                        if not seen[worker]:
                            seen[worker] = True
                            # match_worker_cycle[worker] is the edge index that worker is matched to in cycle_edges? We don't have a global match_worker_cycle? 
                            # Actually, we are using a separate array for the matching in cycle_edges: match_worker_cycle[worker] = i or -1.
                            # But we are building the matching: we have an array match_cycle for edges and we can have an auxiliary array for workers.

                            if match_worker_cycle[worker] == -1 or dfs_cycle(match_worker_cycle[worker], seen):
                                match_worker_cycle[worker] = i
                                match_cycle[i] = worker
                                return True
                    return False

                Then for i in range(len(cycle_edges_list)):
                    seen = [False] * K
                    if not dfs_cycle(i, seen):
                         # we don't break immediately? We are computing maximum matching.
                         # Actually, we want maximum matching? 
                         pass   # we do nothing: we'll compute the maximum matching.

                Then M = number of edges matched = number of i such that match_cycle[i] != -1.

            But we need the maximum matching, and we record the matching.

            Alternatively, we can run a standard matching that doesn't break on one failure.

            Actually, we run for all edges and then count the number of matched edges.

        But note: we are not requiring a perfect matching for cycle_edges in the spanning tree option? We only require at least L-1. 

        However, we want to know the maximum matching. Then we can do:

            M = 0
            for i in range(len(cycle_edges_list)):
                seen = [False] * K
                if dfs_cycle(i, seen):
                    M += 1

        Then we have M = size of the matching for cycle_edges.

        Then:

            if K>=N and M == len(cycle_edges_list):   # which is L
                skip_edge = None   # skip no edge
                skip_worker = None   # no worker to skip

            else if M >= L-1:
                # skip one edge: 
                if M == L:
                    # we choose an arbitrary edge to skip: say the first cycle edge in cycle_edges_list.
                    skip_edge_index = 0   # the first edge
                    skip_edge = cycle_edges_list[0]
                    # and if this edge was matched to a worker, then we remove the assignment.
                    if match_cycle[0] != -1:
                        worker_skip = match_cycle[0]
                        # remove the assignment: set match_cycle[0] = -1, and also set match_worker_cycle[worker_skip] = -1.
                        # But we are going to output, so we can simply not output this assignment.
                    # else: it wasn't matched, so we skip it and do nothing.
                else: # M == L-1
                    # we skip the edge that is not matched.
                    # find an edge index i in [0, L-1] such that match_cycle[i] == -1.
                    skip_edge_index = None
                    for i in range(L):
                        if match_cycle[i] == -1:
                            skip_edge_index = i
                            break
                    skip_edge = cycle_edges_list[skip_edge_index]
            else:
                print(-1)
                exit(0)

        Step5: Output assignment.

            We create an array res of K strings, each "0 0".

            # For non_cycle_edges: 
            for i in range(len(non_cycle_edges_list)):
                worker_id = match_non[i]   # worker assigned to the i-th non_cycle_edge
                if worker_id != -1:   # should be assigned
                    key = non_cycle_edges_list[i]
                    u, v = original_rep[key]
                    res[worker_id] = f"{u} {v}"

            # For cycle_edges: 
            for i in range(len(cycle_edges_list)):
                if i == skip_edge_index:   # this edge is skipped, so we don't output it for the worker that was matched to it? 
                    # but if it was matched, we leave that worker as idle? 
                    continue
                worker_id = match_cycle[i]
                if worker_id == -1:
                    # This edge was not matched? But in the entire graph we skipped no edge and we had a full matching, so this should not happen.
                    # And in the spanning tree, we skipped one unmatched edge, so we skip that one and the rest are matched? 
                    # Actually, in the matching for cycle_edges, we did not match this edge? But in the entire graph we require full matching, so we skip if not full? 
                    # But we are in the branch that we have a solution, so in the entire graph we skip only if M==L, so every edge is matched. 
                    # In the spanning tree, we skipped the unmatched edge and the rest are matched? 
                    # But wait: we only matched M edges? In the DFS for cycle_edges, we matched M edges. Then for the edges that are matched, we output. For the ones that are not matched and not skipped, we don't output? 
                    # But we are skipping only one edge. The rest should be matched? 
                    # Actually, we skip one edge and we require the rest to be built? But we only built the ones that are matched. 
                    # But we did a matching for cycle_edges and we only assigned workers to the matched edges. 
                    # And we skipped one edge. The other edges must be matched? 
                    # But we have M = the number of matched cycle_edges. In the entire graph, we skip no edge and require M==L, so every edge is matched. 
                    # In the spanning tree, we skip one edge and we require M>=L-1, and we skip one edge (either matched or unmatched). Then the edges that we build are the matched ones? 
                    # But we only built the edges that are matched. And we skipped one edge. 
                    # But note: we only have L-1 edges to build in the cycle? And we have matched M edges, and we skipped one edge, so we are building L-1 edges. But we might have matched only L-1 edges? Then every cycle edge that is built is matched. 
                    # So we skip one edge (either matched or unmatched) and then the edges that we output are the matched ones? 
                    # But if we skip a matched edge, then the worker that was matched to it is not used? 
                    # And if we skip an unmatched edge, then we build the other L-1 edges and they are matched. 
                    # So we should not have an unmatched edge that is built? 
                    # Therefore, we only output the matched edges that are not skipped. 
                    # So we skip this edge (which is not skipped? we are in the loop for i not skipped) and worker_id is -1? That should not happen.
                else:
                    key = cycle_edges_list[i]
                    u, v = original_rep[key]
                    res[worker_id] = f"{u} {v}"

            # Then output res[0] to res[K-1] in separate lines.

        But note: in the entire graph, we don't skip any edge, so we output every cycle edge that is matched (which should be all).

        And in the spanning tree, we skip one edge (skip_edge_index) and we output the other matched edges.

        However, what if in the spanning tree we skipped a matched edge? Then the worker that was matched to it is not used? And we output "0 0" for that worker? 

            But we have not assigned that worker to any edge? So in the res array, that worker is initially "0 0", and we don't assign it in non_cycle_edges or in the other cycle_edges.

        Therefore, we are done.

   However, note: what if a worker is matched to a non_cycle_edge and then also to a cycle_edge? That cannot happen because the matching for non_cycle_edges uses the worker, and then the matching for cycle_edges only considers available workers.

   So we are safe.

   Let's run the sample input #1 in the algorithm for the entire graph:

        non_cycle_edges_list = [ (1,2) ]

        Step3: match non_cycle_edges: 
            edge (1,2): worker_list = [0,1] (workers with material1 and material2)

            We run DFS for i=0: try worker0 -> available? yes. Then match_non[0]=0 (worker0) and match_worker[0]=0.

        Then available workers: [1,2,3,4]

        Step4: cycle_edges_list = [ (2,3), (3,4), (4,2) ]   [but stored as keys: (min,max) so (2,3), (3,4), (2,4) for (4,2) -> but (4,2) is (2,4) in key]

        But wait: the edge (4,2) is stored as (2,4). 

        Then worker_list for:
            (2,3): [1,2]   (workers1: material2, worker2: material3)
            (3,4): [2,3]   (worker2: material3, worker3: material4)
            (2,4): [3,4]   (worker3: material4, worker4: material5)

        Then we run matching for cycle_edges:

            edge0: (2,3) -> try worker1: available -> match to worker1.
            edge1: (3,4) -> try worker2: available -> match to worker2.
            edge2: (2,4) -> try worker3: available -> match to worker3.

        Then M=3 -> we can build the entire graph.

        Then output:

            non_cycle: 
                worker0: edge (1,2): original_rep for (1,2) is (1,2) -> output "1 2"

            cycle_edges: 
                (2,3): worker1: output "2 3"   [because original_rep for (2,3) is (2,3) from city2? 
                    How did we store: for key (2,3): 
                         city2: A_2=3 -> so we stored (2,3) as the representation.
                (3,4): worker2: output "3 4"
                (2,4): worker3: output "4 2"   [because for key (2,4): we stored from city4: (4,2) -> so output "4 2" ? 
                    But wait: the original_rep for key (2,4) is (4,2) (from city4) -> so we output "4 2"

            worker4: not assigned -> "0 0"

        Then:

            worker0: "1 2"
            worker1: "2 3"
            worker2: "3 4"
            worker3: "4 2"
            worker4: "0 0"

        But the sample output has worker4 (the fifth worker) output as "4 2", and worker3 (the fourth worker) as "0 0". 

        Why the difference? 

            The workers:

                worker0: material1 -> we assigned to (1,2)
                worker1: material2 -> we assigned to (2,3)
                worker2: material3 -> we assigned to (3,4)
                worker3: material4 -> we assigned to (4,2)
                worker4: material5 -> not assigned.

            And we output:

                worker0: "1 2"
                worker1: "2 3"
                worker2: "3 4"
                worker3: "4 2"
                worker4: "0 0"

            But the sample output:

                1 2   -> worker0
                2 3   -> worker1
                3 4   -> worker2
                0 0   -> worker3? 
                4 2   -> worker4

            So they have worker3 (material4) idle and worker4 (material5) building (4,2).

            How did they assign worker4 to (4,2)? 

            We could have assigned:

                non_cycle_edge (1,2) to worker1 (material2) -> then available workers: 0,2,3,4.

                Then cycle_edges:

                    (2,3): can be assigned to worker0? no, because worker0 has material1 -> not in [2,3]? 
                            but worker0: material1 is not in the materials for (2,3) (which are [2,3]). 
                    so (2,3) must be assigned to worker1? but worker1 is used? 

                Alternatively, non_cycle_edge (1,2) to worker0: that's the only one available? 

                Then cycle_edges:

                    (2,3): we can assign worker1 (material2) -> works.
                    (3,4): we can assign worker2 (material3) -> works.
                    (2,4): we can assign worker4 (material5) -> works.

            Then worker3 (material4) is idle.

            So we could have an alternative matching.

            Our DFS for non_cycle_edges: we tried worker0 first and succeeded. Then we used worker0.

            Then for cycle_edges, we used workers1,2,3.

            But if we try a different order in the DFS for non_cycle_edges: we try worker1 first for (1,2), then we can use worker0 for a cycle edge? 

            But worker0 (material1) cannot build any cycle edge? 

            So the only possibility for non_cycle_edge (1,2) is worker0 or worker1.

            Then in cycle_edges, if we used worker1 for non_cycle, then we have workers0,2,3,4 available.

            Then:

                (2,3): can be worker0? no (material1 not in [2,3]); worker2 (material3) -> in [2,3]? -> yes, 3 is in the list? 
                    so assign worker2 to (2,3)
                (3,4): available workers:0,3,4. 
                    materials: [3,4]: worker3 (material4) -> assign worker3 to (3,4)
                (2,4): available workers:0,4.
                    worker4 (material5) -> in [4,5]? yes, 5 is in the list? -> no, the materials for (2,4) are [4,5]? so 5 is in the list? 
                    then assign worker4 to (2,4)

            Then worker0 remains idle.

            Then output:

                non_cycle: worker1: (1,2) -> "1 2"
                cycle: 
                    (2,3): worker2: "2 3"
                    (3,4): worker3: "3 4"
                    (2,4): worker4: "4 2"

                worker0: idle -> "0 0"

            This matches the sample.

            How to get this? 

                In the DFS for non_cycle_edges, if we try workers in the order [1,0] for edge (1,2), then we would pick worker1.

            Therefore, to get the sample, we need to try worker1 first for the edge (1,2).

            How did we store the worker list for (1,2)? [0,1] -> so we try worker0 first.

            We can sort the worker list for an edge arbitrarily? 

            The sample input for workers: [1,2,3,4,5] -> worker0:1, worker1:2, etc.

            For edge (1,2): materials [1,2] -> workers: material1: worker0, material2: worker1 -> so we stored [0,1].

            Then we try in the order 0 then 1.

            To get worker1, we can sort the worker list in descending order? 

            Or we can sort by worker index descending? 

            The problem: any valid assignment is acceptable. 

            We can choose the order arbitrarily. 

            But the sample output is one valid assignment.

        Since the problem allows any assignment, we can leave the worker list in the order we built (which is by the order of materials and then by the order of workers in the material). 

        And then try in that order.

        But the sample expects the assignment that matches their output? 

        The problem does not require that.

        Therefore, we can output the assignment we got.

        However, if we want to match the sample, we could try to sort the worker list by worker index in descending order? Then for (1,2): we try worker1 first? 

            Then we get the assignment: non_cycle_edge (1,2) to worker1.

        Then we get the sample output.

        But the problem does not require it.

        We decide: we do not sort the worker list arbitrarily. We use the list in the order we built (which is: for each material in the list, and for each worker in the list of that material, in the order of worker index? Because when we iterated the workers for a material, we appended in increasing worker index? 

        But we iterate the materials in the set S_e? And the set S_e is given as a list? So we iterate the materials in increasing order? Then for each material, we iterate the workers in the order we stored in material_to_workers? 

        How did we store the workers for a material? We appended in increasing worker index? 

            For material1: we first found worker0? 
            For material2: we then found worker1? 

        So the worker list for (1,2) is [0,1]. 

        Then we try worker0 first.

        To get the sample, we would need to try worker1 first.

        We can reverse the worker list for each edge? 

        Or we can sort the worker list for each edge by worker index in descending order? 

        But the problem: we want to get the sample output? 

        Since the problem does not require, we output the assignment we get.

        If the judge is using the sample to test, they might accept any valid assignment.

   Therefore, we can do as above.

   Note: This solution runs in O(total_work_precomputation + (N-L)*K + L*K) = O(20e6 + 4e6 + 4e6) = about 28e6, which is acceptable for N, K <= 2000.

   Let's code accordingly.

   However, note: the problem statement: the sum of M_i <= 10000.

   We are doing for each edge: we iterate over the materials in S_e and then for each material we iterate over the list of workers with that material. 

   The total work: as discussed, bounded by 10000 * (max frequency of a material in the workers). In worst-case, if one material appears in 2000 workers and it appears in 10000/1 = 10000 edges? But the total |S_e| is 10000, so one material cannot appear in 10000 edges? 

   Actually, the total |S_e| is 10000, so the total work is the sum over materials m of (freq(m) * (number of edges that contain m)). This is bounded by 10000 * (max freq(m)), and max freq(m) is at most 2000, so 20e6.

   We assume we can do 20e6 iterations.

   We'll implement accordingly.

   One more note: the problem says the materials in B_i are sorted and distinct.

   We are good.

   Let's hope.

   We'll write the code accordingly.

   But note: the problem asks for an editorial without code. So we have described the solution.

   Why is it correct? 

        We must build a connected graph. We know the graph is unicyclic. The necessary condition: we must build all non_cycle_edges (bridges) and at least (L-1) cycle edges. 

        The conditions we check:

          Condition 1: K >= N-1 (if not, -1)

          Condition 2: we can match all non_cycle_edges (if not, -1)

          Condition 3: we can match at least (L-1) cycle edges (if not, -1)

        Then we have two ways:

          - If we can match all L cycle edges and K>=N, we build the entire graph.

          - Else, we build a spanning tree: by skipping one cycle edge (and we use the matching for the remaining L-1 cycle edges).

        And we output the assignment.

   Therefore, the solution is complete.