We are given an N x N grid, but note that the grid is defined by two arrays R and C: the cell (i, j) has value A[i][j] = R[i] + C[j].
We are only allowed to move to adjacent cells (up, down, left, right) and we require that every cell along the path must be even.

It is guaranteed that the start and end cells of each query are even.

Note: The grid is huge (N up to 100,000) so we cannot iterate over the grid.

Observation:

1. The condition for a cell (i, j) to be even is:
      R[i] + C[j] is even.

   This can be rewritten as:
      R[i] mod 2 = - (C[j] mod 2) mod 2.

   But note that in mod 2, -1 ≡ 1, so:
      R[i] mod 2 = (C[j] mod 2)   is not the condition.

   Actually, we require:
      (R[i] mod 2) = ( - C[j] mod 2) mod 2.

   Since we are in mod2, we can write:
      R[i] mod 2 = (C[j] mod 2)   if and only if (R[i] + C[j]) mod 2 = 0 mod 2? Actually, no.

   Let me check: 
        (R[i] + C[j]) mod 2 = (R[i] mod 2 + C[j] mod 2) mod 2.

   So we require: 
        R[i] mod 2 + C[j] mod 2 ≡ 0 (mod 2)
   which means R[i] mod 2 must equal the negative of C[j] mod 2 mod 2. But in mod2, the negative of 0 is 0 and the negative of 1 is 1 (because 1+1=0 mod2). Actually, we have:
        R[i] mod 2 = C[j] mod 2   is not correct because 0+0=0 (even) and 1+1=2≡0 (even) -> so when both are even or both are odd, the sum is even.

   Therefore, the condition for cell (i, j) to be even is:
        R[i] mod 2 = C[j] mod 2.

   So we can say: the cell (i, j) is even if and only if R[i] and C[j] have the same parity.

2. Now, note that the entire grid is partitioned by the parity of R[i] and C[j]. Let:
        row_parity[i] = R[i] % 2   (which is either 0 or 1)
        col_parity[j] = C[j] % 2   (which is either 0 or 1)

   Then a cell (i, j) is even if and only if row_parity[i] == col_parity[j].

   However, note that the grid has two types of even cells:
        Type 0: where row_parity[i] = 0 and col_parity[j] = 0.
        Type 1: where row_parity[i] = 1 and col_parity[j] = 1.

   Now, consider an adjacent move. 
        Moving horizontally: from (i, j) to (i, j+1). 
            The row parity remains the same. The column parity changes from col_parity[j] to col_parity[j+1].
            For the move to be valid, both cells must be even. So:
                (i, j): must have row_parity[i] == col_parity[j]
                (i, j+1): must have row_parity[i] == col_parity[j+1]

            Therefore, we can move if col_parity[j] == col_parity[j+1]? 
            But note: the row parity is fixed. So if col_parity[j] and col_parity[j+1] are the same, then both conditions hold. 
            If they are different, then we cannot have both conditions: 
                Suppose col_parity[j] = a and col_parity[j+1] = b, then we require a = row_parity[i] and b = row_parity[i] -> so a must equal b.

        Similarly, moving vertically: from (i, j) to (i+1, j). 
            The column parity remains the same. The row parity changes from row_parity[i] to row_parity[i+1].
            For the move to be valid, we require:
                row_parity[i] == col_parity[j] and row_parity[i+1] == col_parity[j].
            This forces row_parity[i] = row_parity[i+1].

   Therefore, we can only move to an adjacent cell if the parity of the row (for vertical moves) or the column (for horizontal moves) is the same as the next.

   This suggests that the grid is broken into connected components. However, note that the grid has two types of even cells: Type0 and Type1.

   But observe: a Type0 cell (i, j) has row_parity[i]=0 and col_parity[j]=0.
        From a Type0 cell, can we move to a Type1 cell? 
            Consider moving to (i, j+1): we require col_parity[j+1] to be 0? Then the new cell would be Type0. 
            Similarly, if we move to (i+1, j): we require row_parity[i+1] to be 0? Then the new cell is Type0.

        So we can only move within the same type? 

        However, note: if we have a row i that has row_parity[i]=0, then we can only be in columns j that have col_parity[j]=0 (Type0). Similarly, if a row i has row_parity[i]=1, then we can only be in columns j that have col_parity[j]=1 (Type1). 

        Therefore, the entire grid has two separate sets: Type0 and Type1. And there is no edge connecting a Type0 cell to a Type1 cell? 

        Why? 
          - In a horizontal move: the row doesn't change, so the row_parity remains the same. The column changes. But for the next cell to be even, the new column must have the same parity as the row_parity (which is fixed). So if we start in Type0 (row_parity=0) then the next column must be 0 -> so it's Type0. Similarly, if we start in Type1, the next column must be 1 -> Type1.

        Therefore, the two types are disconnected. 

   So the first necessary condition: 
        The start and end must be of the same type? 
        Indeed, because if the start is Type0 and the end is Type1, then there is no path (they are in different connected components). 

   But wait: what if the start and end are both Type0? Then they are in the same component? Not necessarily. 

   How do we determine connectivity within one type?

   Consider the Type0 component: 
        We can only move between cells that have row_parity[i] = 0 and col_parity[j] = 0.

        Moreover, we can move horizontally between two columns j and j' only if the entire contiguous segment of columns from j to j' has col_parity = 0? 
          Actually, no: we can move from (i, j) to (i, j+1) if col_parity[j] = col_parity[j+1] = 0? But note: the condition for the horizontal move is that the row_parity[i] must equal col_parity[j] and col_parity[j+1]. Since row_parity[i]=0, we require col_parity[j]=0 and col_parity[j+1]=0. 

        Similarly, for vertical moves: we require row_parity[i]=0 and row_parity[i+1]=0.

        Therefore, the Type0 component is connected if and only if we can traverse the rows and columns that have the same parity? Actually, the Type0 component is the entire grid of rows that are even and columns that are even? But note: we cannot jump arbitrarily. 

        The connectivity: 
          - Within a row i (which has row_parity[i]=0), we can traverse any consecutive set of columns that have col_parity=0. 
          - Similarly, within a column j (which has col_parity[j]=0), we can traverse any consecutive set of rows that have row_parity=0.

        Therefore, the Type0 component is actually a grid graph on the rows that have row_parity=0 and the columns that have col_parity=0? But note: we are not restricted to only the rows with row_parity=0 and columns with col_parity=0? Actually, we are: because we can only be in a row that has row_parity=0 and a column that has col_parity=0.

        So the Type0 component is the entire set of cells (i, j) such that row_parity[i]=0 and col_parity[j]=0. 

        But how is the connectivity? 
          - We can move from (i, j) to (i, j') if j and j' are in the same contiguous segment of columns with col_parity=0? Actually, no: we can move step by step only through adjacent columns that are 0. 

        Therefore, the Type0 component is a bipartite graph? Actually, it is a grid graph. 

        However, note that the grid graph of Type0 is connected if the set of rows with row_parity=0 is contiguous? and the set of columns with col_parity=0 is contiguous? 

        That is not true. Consider:

          R = [0, 1, 0]   -> row_parity: [0,1,0]
          C = [0, 1, 0]   -> col_parity: [0,1,0]

          The Type0 cells: 
             (0,0): (0,0) -> row0, col0 -> 0+0=0 -> even -> included.
             (0,1): row0 (0) and col1 (1) -> 0+1=1 -> odd -> not included.
             (0,2): row0 and col2 (0) -> 0 -> included.

             (1,0): row1 (1) and col0 (0) -> 1 -> odd -> skip.
             (1,1): 1+1=2 -> even? -> but wait: row1=1, col1=1 -> same -> even? Actually, it's Type1! -> so not in Type0.

             (2,0): row2 (0) and col0 (0) -> included.
             (2,1): skip.
             (2,2): included.

          So the Type0 cells: 
                (0,0), (0,2), (2,0), (2,2)

          Now, can we go from (0,0) to (0,2)? 
                (0,0) -> (0,1) is not allowed (because (0,1) is not even? Actually, (0,1) is odd, so we cannot step there. 
                Similarly, we cannot move horizontally from (0,0) to (0,2) because we are blocked at (0,1).

          How about vertically? 
                (0,0) -> (1,0) is not allowed because (1,0) is odd? Actually, (1,0): row1=1, col0=0 -> 1+0=1 -> odd -> not allowed.

          Similarly, we cannot go from (0,0) to (2,0) because (1,0) is odd. 

          Therefore, the Type0 component is disconnected: (0,0) is isolated, (0,2) is isolated, (2,0) is isolated, (2,2) is isolated.

        But wait, what about diagonal? We cannot move diagonally.

        Actually, we can only move to adjacent. So the Type0 component is not necessarily connected.

        How to determine connectivity in Type0?

        We have:
          - The Type0 component is a grid graph where we have nodes at (i, j) for every row i with row_parity[i]=0 and every column j with col_parity[j]=0, but we can only move to adjacent nodes if the adjacent node is also present? 

        However, the problem is: we cannot build the grid because N is up to 100,000.

        Alternative approach:

        We can view the connectivity in the entire grid of even cells as:

          The even cells are the union of two independent sets: Type0 and Type1. And the two sets are disconnected from each other.

        Within Type0, we have:

          Two cells (i, j) and (i', j') are connected if:

            - The rows i and i' are connected by a path that stays entirely in rows that have row_parity=0? Not exactly: we can also use columns to jump.

          Actually, the connectivity in Type0 is determined by:

            We can move from (i, j) to (i, j') if all columns between j and j' have col_parity=0? 
            But note: we don't need the entire segment to be 0? We only need that for every step we move to an adjacent column that is 0. So if there is a contiguous block of columns with col_parity=0 that includes j and j', then we can move horizontally.

            Similarly, we can move vertically from (i, j) to (i', j) if all rows between i and i' have row_parity=0.

          However, we can also do:

            (i, j) -> (i, j1) [horizontal] -> (i2, j1) [vertical] -> ... 

          So the entire Type0 component is connected if and only if the set of rows with row_parity=0 is connected? and the set of columns with col_parity=0 is connected? 

          Actually, no. Consider:

            R = [0,0,0] -> three rows of 0.
            C = [0,1,0] -> columns: [0,1,0]

          The Type0 cells: 
            row0: col0 and col2 -> present.
            row1: col0 and col2 -> present.
            row2: col0 and col2 -> present.

          Now, can we go from (0,0) to (0,2)? 
                We cannot move horizontally from (0,0) to (0,1) because (0,1) is not even? Actually, (0,1): row0=0, col1=1 -> 1 -> odd -> not allowed. 
          But we can go vertically? 
                (0,0) -> (1,0) -> (2,0) -> (2,1) is not allowed -> so how to get to (2,2)? 
                Actually, from (2,0) we can move to (2,2) if we can skip (2,1)? But we can't: we have to go through adjacent.

          So we can do: (0,0) -> (1,0) -> (2,0) -> (2,1) is blocked -> so we cannot get to (2,2). 

          How about: (0,0) -> (0,1) is blocked, (0,0)->(1,0) -> (1,1) is not Type0 (it's Type1) -> not allowed.

          Therefore, the Type0 component is disconnected: the cell (0,0) is connected to (1,0) and (2,0) but not to (0,2), (1,2), (2,2). Similarly, the right part is separate.

        How to connect the two sides? We need a column that is 0 that spans the entire rows? 

        Actually, if we have at least one column j0 that has col_parity[j0]=0 that is present for all rows? That is, if we have a column j0 that is 0, then we can use that column to move from any row to any other row? Then we can go from (i, j) to (i, j0) (if the segment from j to j0 is contiguous 0) and then to (i', j0) and then to (i', j').

        Similarly, we need the rows to be connected by a contiguous block? 

        Therefore, we can define:

          For Type0:
            Let the rows that are 0: we can represent them as a set of indices. The rows that are 0 might not be contiguous. 
            Similarly, the columns that are 0.

          Now, the entire Type0 component is connected if and only if:

            (a) The set of rows that are 0 is connected? -> Actually, we don't require the rows to be contiguous. We can use a column to jump. 

          But note: to move from row i to row i' (both 0), we require that there is a column j (with col_parity[j]=0) that is present and that we can traverse vertically from row i to row i' without leaving the even cells. However, to traverse vertically from row i to row i' at column j, we require that every row between i and i' has row_parity=0? Why? Because if there is a row k between i and i' that is 1, then the cell (k, j) would be 1 (if col_parity[j]=0) -> then 0+1=1 -> odd -> blocked.

          Similarly, to move horizontally from column j to j' (both 0), we require that every column between j and j' has col_parity=0? Why? Because if there is a column k between j and j' that is 1, then the cell (i, k) (if row_parity[i]=0) would be 0+1=1 -> odd -> blocked.

          Therefore, the Type0 component is connected if and only if:

            (1) The set of rows with row_parity=0 is contiguous? -> Actually, no: we don't require contiguous, but we require that the entire segment of rows between any two rows that are 0 must be 0? 

            Actually, if there is a gap in the rows that are 0? Then we cannot traverse through that gap. Therefore, the rows that are 0 must form a contiguous interval? 

            But note: we don't necessarily need to traverse every row. We only need to traverse from row i to row i' via a column j. The vertical movement at column j requires that every row between i and i' is 0. Therefore, if there is a row k between i and i' that is not 0 (i.e., row_parity[k]=1), then we cannot use that column j to go from i to i'. 

            However, what if we avoid the gap by going around? But we cannot: because we are stuck in rows that are 0 and columns that are 0. The gap in rows (a row with 1) breaks the vertical movement.

            Similarly, for columns: if there is a gap in the columns that are 0 (a column with 1) then it breaks horizontal movement.

          Therefore, the Type0 component is connected if and only if:

            - The set of rows that are 0 is contiguous? -> Actually, no: it must be that the entire range from the minimum row index that is 0 to the maximum row index that is 0 is filled with rows that are 0? Why? Because if we have two rows i and i' (with i < i') that are 0, then to go from i to i' we must pass through every row in between. And if any row k in between is 1, then we cannot go through that row. Therefore, we require that every row from min_row to max_row (where min_row and max_row are the minimum and maximum row indices that are 0) must be 0.

            Similarly, the set of columns that are 0 must be contiguous in the sense that every column between the minimum column index that is 0 and the maximum column index that is 0 must be 0.

          However, note: what if we don't need to traverse the entire set? For example, if we have two rows that are 0: row0 and row2 (and row1 is 1) and two columns: col0 and col2 (and col1 is 1). Then we have four cells: (0,0), (0,2), (2,0), (2,2). How to get from (0,0) to (2,2)? 

          We cannot: because to go from (0,0) to (0,2) we are blocked at col1 (which is 1). Similarly, we cannot go vertically from (0,0) to (2,0) because row1 is 1. 

          Therefore, we require:

            Condition for Type0 connectivity: 
                The set of rows that are 0 must be contiguous? Actually, we require that the rows that are 0 form a contiguous interval? 
                And the set of columns that are 0 must form a contiguous interval? 

          But note: if the rows that are 0 are contiguous and the columns that are 0 are contiguous, then the Type0 component is a rectangular grid? Then it is connected? 

          Example: 
                R = [0,0,0] -> contiguous.
                C = [0,0,0] -> contiguous.
                Then the entire grid is a rectangle and we can traverse arbitrarily.

          However, what if the rows that are 0 are contiguous, but the columns that are 0 are not? 

          Actually, we require both to be contiguous? 

          But consider:

                R = [0,0,0] (contiguous)
                C = [0,1,0] (not contiguous: we have columns 0 and 2, but not 1)

          Then the Type0 component is: 
                row0: col0, col2 -> two separate columns? 
                row1: col0, col2 -> two separate columns? 
                row2: col0, col2 -> two separate columns? 

          Now, can we go from (0,0) to (0,2)? -> blocked at col1? -> no. 
          But we can go: (0,0) -> (1,0) -> (2,0) -> (2,1) is blocked -> so we cannot get to (2,2) from (0,0) via the right side? 

          However, note: we can also do: (0,0) -> (1,0) -> (1,1) is not allowed -> so we cannot get to (1,2) either.

          Therefore, the Type0 component is split into two parts: the left part (columns=0) and the right part (columns=2). 

          So we have two connected components: 
                Component1: all rows and column0 -> a rectangle? Actually, it's a rectangle because the rows are contiguous and the column is fixed? But we can move vertically arbitrarily within column0? 
                Component2: all rows and column2.

          So the entire Type0 component is disconnected. 

          How to characterize the connected components within Type0?

          Within Type0, we can move arbitrarily within a contiguous block of columns that are 0? Actually, we can move horizontally only if the columns are consecutive 0. Therefore, the columns that are 0 might be split into contiguous segments. Similarly, the rows that are 0 are contiguous? (we don't require that, but we argued that if there is a gap in the rows, then we break the vertical movement). 

          Actually, we have two independent conditions:

            - For vertical movement: we can move from row i to row i' (both in Type0) at a fixed column j (which is 0) only if every row between i and i' is 0. Therefore, if the rows that are 0 form a contiguous interval, then we can move vertically arbitrarily within that interval? 

            But what if the columns that are 0 are not contiguous? Then we have multiple contiguous segments of columns.

          Therefore, the Type0 component is composed of several connected components: each connected component corresponds to a contiguous segment of columns that are 0 and then for the entire contiguous set of rows that are 0? 

          Actually, no: because we can move vertically arbitrarily within the contiguous rows? Then we can connect all the rows that are contiguous. And then within a row, we can only move horizontally in contiguous segments of columns that are 0. 

          But note: if we have a contiguous segment of columns that are 0 (say from c1 to c2) and the rows that are 0 form a contiguous interval (from r1 to r2), then the entire rectangle [r1, r2] x [c1, c2] is connected? 

          Why? 
            - We can go from any (i, j) to (i, j') if j and j' are in [c1, c2] by moving horizontally (because the columns between j and j' are 0 and the row i is 0) -> so the row is connected.
            - And we can go from (i, j) to (i', j) if i and i' are in [r1, r2] by moving vertically (because the rows between i and i' are 0 and the column j is 0) -> so the column is connected.

          Then the entire rectangle is connected.

          However, what if the rows that are 0 are not contiguous? Then we have gaps. Then we break the vertical movement. Similarly, if the columns that are 0 are not contiguous, then we have gaps that break horizontal movement.

          Therefore, the Type0 component is partitioned into connected components: each connected component is a maximal rectangle defined by:

            - A contiguous interval of rows [r1, r2] such that for every row i in [r1, r2], row_parity[i]=0, and 
            - A contiguous interval of columns [c1, c2] such that for every column j in [c1, c2], col_parity[j]=0.

          But note: we might have multiple disjoint contiguous intervals of rows and columns? 

          Actually, the entire set of rows that are 0 might be split into multiple contiguous intervals? Similarly for columns.

          Then a connected component is the Cartesian product of a contiguous interval of rows (that are 0) and a contiguous interval of columns (that are 0)? 

          However, that would be disconnected: because if we have two contiguous intervals of rows: [1,2] and [4,5] and one contiguous interval of columns [1,3], then the cells (1,1) and (4,1) are in the same column? But we cannot go from row2 to row4 because row3 is missing (and it's 1) -> so we cannot traverse vertically from row2 to row4. 

          Therefore, we require that the entire contiguous interval of rows and the entire contiguous interval of columns must be such that they form a rectangle? 

          Actually, the connected component is the entire set of rows in a contiguous interval I of rows (that are 0) and the entire set of columns in a contiguous interval J of columns (that are 0). Then the entire rectangle I x J is connected? 

          But then if the rows that are 0 are split into two intervals: [1,2] and [4,5] and the columns that are 0 are [1,3], then we have two rectangles: [1,2]x[1,3] and [4,5]x[1,3]. These are two connected components.

          Therefore, we can assign each Type0 cell (i, j) to the connected component identified by:

            - The contiguous interval of rows that are 0 that contains i. 
            - The contiguous interval of columns that are 0 that contains j.

          Then two cells are in the same connected component if and only if the row i falls in the same contiguous row-interval and the column j falls in the same contiguous column-interval.

        Similarly for Type1.

        But wait: what if we have:

            R = [0,0,1,1,0,0]   -> rows: 0,0,1,1,0,0 -> the rows that are 0: [0,1] and [4,5] (two intervals)
            C = [0,0,1,1,0,0]   -> columns: [0,1] and [4,5] (two intervals)

          Then the Type0 cells: 
            row0: columns0,1,4,5 -> but actually, we require col_parity=0? The columns that are 0: [0,1] and [4,5]. 
            So row0: columns0,1 -> one rectangle, and columns4,5 -> another rectangle? 
            Similarly, row1: columns0,1 and columns4,5 -> two rectangles.
            row4: columns0,1 and columns4,5 -> two rectangles.
            row5: two rectangles.

          Then we have 4 connected components? 

          Actually, no: the row0 and row1 are contiguous? So the contiguous row interval for rows that are 0 is [0,1] and [4,5]. The contiguous column intervals: [0,1] and [4,5]. Then the connected components are:

            [0,1] x [0,1] -> a rectangle of rows0-1 and columns0-1.
            [0,1] x [4,5] -> a rectangle of rows0-1 and columns4-5.
            [4,5] x [0,1]
            [4,5] x [4,5]

          So 4 connected components.

        Therefore, we can do:

          Precomputation:

            Step1: Precompute the contiguous intervals for rows that are 0 and rows that are 1? Actually, we only care about Type0 and Type1 separately.

          But note: the problem says the start and end are even, so they are either Type0 or Type1. 

          For a query (r_a, c_a, r_b, c_b):

            - If the two cells are of different types, output "NO".

            - If they are of the same type, then we need to check if they are in the same connected component (which is a rectangle defined by a contiguous row interval and a contiguous column interval).

          How to assign a cell (i, j) to a connected component?

            For Type0: 
                Let I0 be the contiguous interval of rows that are 0 that contains row i. (If row i is not 0, then it wouldn't be Type0, so we assume row_parity[i]=0.)
                Let J0 be the contiguous interval of columns that are 0 that contains column j.

                Then the connected component is (I0, J0). 

                Two cells (i, j) and (i', j') are in the same connected component if and only if I0 == I0' and J0 == J0'. 

            Similarly, for Type1: 
                Let I1 be the contiguous interval of rows that are 1 that contains row i? Actually, for Type1, the row must have row_parity=1 and the column must have col_parity=1.
                Let J1 be the contiguous interval of columns that are 1 that contains column j.

          How to compute contiguous intervals? 

            We can precompute:

              For rows (for Type0): 
                  We want to break the array row_parity (which is an array of 0/1 of length N) into contiguous intervals of 0. Similarly for 1? Actually, for Type0 we only care about 0.

              Similarly for columns: contiguous intervals of 0 for Type0, and for Type1 we need contiguous intervals of 1? Actually, for Type0 we need columns that are 0, for Type1 we need columns that are 1.

          Steps:

            Precompute:
              row_parity[i] = R[i] % 2   for i in [0, N-1] (0-indexed)
              col_parity[j] = C[j] % 2   for j in [0, N-1]

            Then:

              Type0_row_intervals: 
                  Traverse the row_parity and merge consecutive 0's into intervals.

              Type0_col_intervals: 
                  Similarly for col_parity: merge consecutive 0's.

              Type1_row_intervals: 
                  Actually, for Type1 we need rows that are 1? So merge consecutive 1's in row_parity.

              Type1_col_intervals:
                  Merge consecutive 1's in col_parity.

          Then for a query:

            Let r1 = r_a-1, c1 = c_a-1, r2 = r_b-1, c2 = c_b-1 (convert to 0-indexed)

            Check the type of (r_a, c_a): 
                type1 = (R[r_a-1] % 2)   but note: we have stored row_parity? Actually, we can compute:
                type_a = (R[r_a-1] % 2 == C[c_a-1] % 2) -> but we know it's even, so they are equal.

                Actually, the type is given by row_parity[r_a-1] (which should equal col_parity[c_a-1]).

            Similarly for (r_b, c_b): same type? If not, output "NO".

            Then:

              If type_a == 0 (meaning the cell is Type0), then:
                 Find the contiguous interval for rows that are 0 that contains row index = r_a-1. Similarly for r_b-1.
                 Find the contiguous interval for columns that are 0 that contains column index = c_a-1. Similarly for c_b-1.

                 Then if the row interval for r_a-1 is the same as for r_b-1 AND the column interval for c_a-1 is the same as for c_b-1, then output "YES", else "NO".

              If type_a == 1, then do the same with the intervals for 1.

          However, note: the contiguous intervals are stored as [l, r] (the start and end indices). We can store:

            For Type0 for rows: we can create an array row0_comp[0..N-1] that for each row i, if row_parity[i] is 0, then we assign an identifier for the contiguous interval that contains i. Similarly for columns.

            How to assign an identifier? We can assign an interval by its starting index? or by a unique id (like the starting index and the length, but we don't care about the length). But note: we only care about whether two rows are in the same interval.

            We can do:

                Precompute an array for rows (for Type0): 
                  comp_row0[i] = 
                      if row_parity[i] != 0 -> not used, but we don't care because the cell is Type0 so we only consider rows that are 0.
                      else: 
                         if i==0 or row_parity[i-1] != 0, then we start a new interval. 
                         else: same as the previous.

            But we want to check: for two rows i and j, are they in the same contiguous interval? 

            We can precompute:

                parent_row0[i] = the start of the contiguous interval that contains row i? 

            Actually, we can precompute an array that for each row i (if it is 0) we store the leftmost index of the contiguous interval? But if the interval is [l, r], then for all i in [l, r] we store l? 

            Similarly, we can store:

                row0_group[i] = 
                    if row_parity[i] == 0:
                         if i==0 or row_parity[i-1] != 0: then group = i   (the start of the interval)
                         else: group = row0_group[i-1]   (same as the previous row)

            Then for two rows i and j (that are 0), they are in the same contiguous interval if and only if row0_group[i] == row0_group[j]? 

            But note: what if i and j are in the same contiguous interval? Then they must have the same group (the starting index of the interval). However, if they are in different intervals, they have different starting indices? 

            Actually, the starting index uniquely identifies the interval? But note: two intervals cannot have the same start.

            Similarly for columns.

          However, what if we have two intervals that start at the same index in rows and columns? That doesn't happen because the intervals are in the same array.

          Therefore, we can do:

            Precomputation:

              // For Type0 rows: 
              row0_group = vector of size N, uninitialized.
              current_start = -1
              for i from 0 to N-1:
                 if row_parity[i] == 0:
                    if i==0 or row_parity[i-1] != 0:
                         current_start = i
                    row0_group[i] = current_start
                 else:
                    // skip

              Similarly for Type0 columns: col0_group[j] for j in [0, N-1].

              For Type1 rows and columns: similarly.

          Then for a query:

            Let r1 = r_a-1, c1 = c_a-1, r2 = r_b-1, c2 = c_b-1.

            type = row_parity[r1]   // because we know row_parity[r1] = col_parity[c1] and the same for the other.

            if type == 0:
                 if (row0_group[r1] == row0_group[r2] and col0_group[c1] == col0_group[c2]) -> YES
                 else -> NO

            if type == 1:
                 if (row1_group[r1] == row1_group[r2] and col1_group[c1] == col1_group[c2]) -> YES
                 else -> NO

        But wait: what if the row0_group[r1] is defined? Yes, because the cell is Type0 so row_parity[r1]=0.

        However, what if the row_parity[r1] is 0 but the row0_group[r1] is not defined? How we defined it: we did define for every i with row_parity[i]=0.

        But note: our loop defined row0_group for every i that has row_parity[i]=0? Yes.

        Similarly for columns.

        However, note: the condition for the columns: we require that the column intervals for c1 and c2 are the same? 

        Why do we require the same row interval and the same column interval? 

          The connected component is the rectangle: [l_row, r_row] x [l_col, r_col]. 

          The cell (r1, c1) is in the rectangle that has row interval starting at row0_group[r1] and column interval starting at col0_group[c1]. 
          Similarly, (r2, c2) is in the rectangle that has row interval starting at row0_group[r2] and column interval starting at col0_group[c2]. 

          They are in the same connected component if and only if the row interval is the same and the column interval is the same? 

          Actually, the connected component is defined by the row interval and the column interval. So if the row interval is the same and the column interval is the same, then they are in the same rectangle -> connected.

          But what if the row intervals are the same but the column intervals are different? Then they are in the same row interval but different column intervals -> then they are in different rectangles? -> not connected.

          Similarly, if the row intervals are different, then they are in different row sets -> not connected.

        Therefore, the above condition is correct.

        Let's test with the sample: 
            Sample Input #2:
                3 2
                30 40 49   -> R = [30,40,49] -> parities: [0,0,1]   (30%2=0,40%2=0,49%2=1)
                15 20 25   -> C = [15,20,25] -> parities: [1,0,1]   (15%2=1,20%2=0,25%2=1)

            Query1: ⟨2,2,3,3⟩ -> (r_a=2, c_a=2, r_b=3, c_b=3) -> 0-indexed: (1,1) to (2,2)

            Check (1,1): 
                row_parity[1] = 0, col_parity[1] = 0 -> same -> Type0? 
                But wait: 0 and 0 -> same -> even -> Type0? Actually, yes.

            (2,2): 
                row_parity[2]=1, col_parity[2]=1 -> same -> Type1? 

            So they are different types -> "NO" -> matches sample output.

            Query2: ⟨1,2,2,2⟩ -> (0,1) to (1,1)

            (0,1): row_parity[0]=0, col_parity[1]=0 -> Type0.
            (1,1): row_parity[1]=0, col_parity[1]=0 -> Type0.

            Now, for Type0 rows: 
                row0: index0: row_parity[0]=0 -> current_start=0 -> row0_group[0]=0.
                row1: row_parity[1]=0 -> since row_parity[0]=0, then we are contiguous? 
                    But wait: row_parity[0] is 0 -> so row_parity[0] is 0 -> then at row1: we see row0 is 0 -> so we set row0_group[1]=0? (the same as the start of the contiguous block that started at row0).

                row2: skip.

                So row0_group[0]=0, row0_group[1]=0 -> same row interval.

            Type0 columns:
                col0: col_parity[0]=1 -> skip.
                col1: col_parity[1]=0 -> so current_start=1 -> col0_group[1]=1.
                col2: col_parity[2]=1 -> skip.

            Then for (0,1): row0_group[0]=0, col0_group[1]=1 -> (0,1) is in the rectangle starting at row0 and col1? 
            For (1,1): row0_group[1]=0, col0_group[1]=1 -> same.

            Therefore, same row interval (0) and same column interval (1) -> "YES".

        However, let me verify the grid:

          R = [30,40,49], C = [15,20,25]

          Grid (0-indexed):

             (0,0): 30+15=45 -> odd -> skip.
             (0,1): 30+20=50 -> even -> Type0? row0:0, col1:0 -> yes.
             (0,2): 30+25=55 -> odd.

             (1,0): 40+15=55 -> odd.
             (1,1): 40+20=60 -> even -> Type0.
             (1,2): 40+25=65 -> odd.

             (2,0): 49+15=64 -> even? -> row2:1, col0:1 -> Type1 -> but wait, 64 is even? -> 49+15=64 -> even -> but Type1? 
             (2,1): 49+20=69 -> odd.
             (2,2): 49+25=74 -> even -> Type1.

          Now, can we go from (0,1) to (1,1)? 
                (0,1) -> (1,1): vertical move. 
                The row0:0 -> row1:0 -> contiguous? yes. The column1:0 -> remains 0. 
                So we can move vertically? 

          Therefore, the answer for query2 is YES.

        But note: our condition for the column: the column interval for column1 is [1,1] (only column1). 
          Then (0,1) and (1,1) are in the same row interval (rows0 and rows1 are contiguous: [0,1]) and the same column interval (column1). 

        So the condition holds.

        However, what if we have:

            R = [0,0] -> Type0 rows: [0,1] (if we have two rows) -> row0_group[0]=0, row0_group[1]=0.
            C = [0,1] -> Type0 columns: only column0? So col0_group[0]=0, and col0_group[1] is undefined? 

          Then a cell (0,0): row0_group[0]=0, col0_group[0]=0 -> (0,0) in rectangle (0,0)
          cell (1,0): row0_group[1]=0, col0_group[0]=0 -> same.

          So they are connected? 

          But the grid:

             (0,0): 0+0=0 -> even -> Type0.
             (0,1): 0+1=1 -> odd.
             (1,0): 0+0=0 -> even -> Type0.
             (1,1): 0+1=1 -> odd.

          We can go from (0,0) to (1,0) by a vertical move? 
                (0,0) -> (1,0): 
                    The row0:0 -> row1:0: the row_parity[0] and row_parity[1] are 0, so the vertical move is allowed? 
                    But note: the cell in between? Actually, we move directly from (0,0) to (1,0). 

          Therefore, they are connected.

        But what if we have:

            R = [0,0] 
            C = [0,0]   -> then Type0: entire grid? 
            Then the row interval: [0,1] -> row0_group[0]=0, row0_group[1]=0.
            col0_group[0]=0, col0_group[1]=0.

          Then (0,0) and (1,1) are in the same row interval and same column interval? 
            row0_group[0]=0, col0_group[0]=0 -> (0,0) -> (0,0)
            row0_group[1]=0, col0_group[1]=0 -> (0,0) -> same.

          Therefore, they are connected? 

          How to get from (0,0) to (1,1)? 
                (0,0) -> (0,1) -> (1,1): 
                    (0,1): 0+0=0 -> even -> allowed.
                    (0,0) to (0,1): horizontal: row0=0, column0=0 and column1=0 -> same -> allowed.

          So it is connected.

        Therefore, the solution:

          Steps:

            Precomputation:
                Read N, Q.
                Read R[0..N-1], C[0..N-1].

                // Precompute row_parity and col_parity
                For i in range(N):
                    r_parity[i] = R[i] % 2
                    c_parity[i] = C[i] % 2

                // Precompute for Type0: rows and columns that are 0.
                row0_group = [-1] * N   // -1 means not set or not Type0
                col0_group = [-1] * N

                // For rows (Type0): 
                current_start = -1
                for i in range(N):
                    if r_parity[i] == 0:
                         if i==0 or r_parity[i-1] != 0:
                             current_start = i
                         row0_group[i] = current_start
                    // else: leave as -1

                Similarly for columns (Type0): 
                    current_start = -1
                    for j in range(N):
                         if c_parity[j] == 0:
                             if j==0 or c_parity[j-1] != 0:
                                 current_start = j
                             col0_group[j] = current_start
                         // else: -1

                // For Type1: rows and columns that are 1.
                row1_group = [-1] * N
                col1_group = [-1] * N

                // For Type1 rows: we want rows that are 1.
                current_start = -1
                for i in range(N):
                    if r_parity[i] == 1:
                         if i==0 or r_parity[i-1] != 1:
                             current_start = i
                         row1_group[i] = current_start
                    // else: -1

                Similarly for Type1 columns.

            Then for each query:

                r_a, c_a, r_b, c_b (1-indexed)

                // convert to 0-indexed indices: 
                ra0 = r_a-1; ca0 = c_a-1; rb0 = r_b-1; cb0 = c_b-1.

                // Check the type of (r_a, c_a): 
                if r_parity[ra0] != c_parity[ca0]:
                    // This should not happen because the problem guarantees both are even? 
                    // But the problem says: "it is guaranteed that both cell (r_a, c_a) and cell (r_b, c_b) contain even numbers"
                    // So they are the same. 
                    // But let's be safe: we know even => same parity, so this should not happen.

                type_a = r_parity[ra0]   // and we know it equals c_parity[ca0]

                Similarly, for (r_b, c_b): 
                if r_parity[rb0] != c_parity[cb0]:
                    // same, should not happen.

                type_b = r_parity[rb0]

                If type_a != type_b: 
                    print("NO")
                else:
                    if type_a == 0:
                         if row0_group[ra0] == row0_group[rb0] and col0_group[ca0] == col0_group[cb0]:
                             print("YES")
                         else:
                             print("NO")
                    else:  // type_a == 1
                         if row1_group[ra0] == row1_group[rb0] and col1_group[ca0] == col1_group[cb0]:
                             print("YES")
                         else:
                             print("NO")

        Time complexity: 
            Precomputation: O(N) for rows and columns for both types -> O(4N) = O(N)
            Each query: O(1)

            Total: O(N + Q) -> acceptable for N, Q up to 100,000.

        Let me test with the provided examples.

        Example 1: 
            Input: 
                5 3
                6 2 7 8 3   -> R: [6,2,7,8,3] -> parities: [0,0,1,0,1]   (6%2=0, 2%2=0, 7%2=1, 8%2=0, 3%2=1)
                3 4 8 5 1   -> C: [3,4,8,5,1] -> parities: [1,0,0,1,1]   (3%2=1,4%2=0,8%2=0,5%2=1,1%2=1)

            Query1: ⟨2,2,1,3⟩ -> (1,1) to (0,2)  0-indexed.

            Check (1,1): 
                row_parity[1]=0, col_parity[1]=0 -> Type0.
            (0,2): 
                row_parity[0]=0, col_parity[2]=0 -> Type0.

            Now, for Type0 rows:
                row0: 0 -> current_start=0 -> row0_group[0]=0.
                row1: 0 -> because row0 is 0, so we set row0_group[1]=0? 
                row2: 1 -> skip.
                row3: 0 -> since row2 is 1, so current_start=3 -> row0_group[3]=3.
                row4: 1 -> skip.

                So row0_group[0]=0, row0_group[1]=0, row0_group[3]=3.

            Type0 columns:
                col0: 1 -> skip.
                col1: 0 -> current_start=1 -> col0_group[1]=1.
                col2: 0 -> because col1 is 0 -> col0_group[2]=1? 
                col3: 1 -> skip.
                col4: 1 -> skip.

                So col0_group[1]=1, col0_group[2]=1.

            Then for (1,1): row0_group[1]=0, col0_group[1]=1 -> (0,1)   [meaning the row interval starts at 0, column interval starts at 1]
            for (0,2): row0_group[0]=0, col0_group[2]=1 -> same.

            So output YES.

            Query2: ⟨4,2,4,3⟩ -> (3,1) to (3,2)  0-indexed.

            (3,1): row_parity[3]=0, col_parity[1]=0 -> Type0.
            (3,2): row_parity[3]=0, col_parity[2]=0 -> Type0.

            For (3,1): row0_group[3]=3, col0_group[1]=1.
            For (3,2): row0_group[3]=3, col0_group[2]=1 -> same.

            Output YES.

            Query3: ⟨5,1,3,4⟩ -> (4,0) to (2,3)  0-indexed.

            (4,0): row_parity[4]=1, col_parity[0]=1 -> Type1.
            (2,3): row_parity[2]=1, col_parity[3]=1 -> Type1.

            Now, for Type1 rows:
                row0:0->skip, row1:0->skip, row2:1->current_start=2->row1_group[2]=2.
                row3:0->skip, row4:1->current_start=4->row1_group[4]=4.

            Type1 columns:
                col0:1->current_start=0->col1_group[0]=0.
                col1:0->skip, col2:0->skip, col3:1->since col2 was 0, so we start new: col1_group[3]=3.
                col4:1->col1_group[4]=3? -> no: 
                    Actually: 
                      j=0: 1 -> current_start=0 -> col1_group[0]=0.
                      j=1:0 -> skip.
                      j=2:0->skip.
                      j=3:1 -> current_start=3 -> col1_group[3]=3.
                      j=4:1 -> because j-1=3 is 1? -> no, j-1=3 is 1 -> so contiguous? Then we set col1_group[4]=3? 
                      But wait: we do:
                         if j==0 or c_parity[j-1] != 1: then new current_start=j.
                         else: current_start remains.

                      At j=4: 
                         j>0 and c_parity[3]=1 -> so we don't reset -> current_start remains 3.
                         so col1_group[4]=3.

            Then for (4,0): row1_group[4]=4, col1_group[0]=0 -> (4,0) in rectangle (4,0) -> which is row4 and col0? 
            For (2,3): row1_group[2]=2, col1_group[3]=3 -> (2,3) in rectangle (2,3) -> different.

            Therefore, output NO.

        It matches.

        But wait: in the sample explanation, the third query: ⟨5,1,3,4⟩ -> (5,1) to (3,4) is NO. 
          Our conversion: 
              (5,1) -> row4, col0 -> Type1 -> row1_group[4]=4, col1_group[0]=0 -> (4,0)
              (3,4) -> row2, col3 -> Type1? 
                  row2: row_parity[2]=1, col3: col_parity[3]=1 -> Type1 -> row1_group[2]=2, col1_group[3]=3 -> (2,3)

          They are different.

        However, note: the grid for Type1: 
            The rows that are 1: row2 (index2) and row4 (index4). 
            The columns that are 1: col0, col3, col4.

            But note: the contiguous intervals for rows that are 1: 
                row2: [2,2] -> group id=2.
                row4: [4,4] -> group id=4.

            Columns that are 1: 
                col0: [0,0] -> group id=0? 
                col3: [3,4] -> group id=3? 

            Actually, we stored the starting index. 
                For columns: 
                  col0: starts at 0 -> group id=0.
                  col3: starts at 3 -> group id=3.
                  col4: starts at 3? -> because at j=3 we started a new interval? and then at j=4: we set col1_group[4]=3.

            Therefore, the connected components for Type1 are:

                Component1: row2 and col0 -> only cell (2,0): 7+3=10 -> even? 
                Component2: row2 and col3: cell (2,3): 7+5=12 -> even? 
                Component3: row2 and col4: cell (2,4): 7+1=8 -> even? 
                Component4: row4 and col0: (4,0): 3+3=6 -> even.
                Component5: row4 and col3: (4,3): 3+5=8 -> even.
                Component6: row4 and col4: (4,4): 3+1=4 -> even.

            But note: the contiguous intervals for columns: 
                The contiguous intervals for columns that are 1: 
                    [0,0] and [3,4] -> two intervals.

            So we have two column intervals: 
                interval0: [0,0] -> id0=0
                interval1: [3,4] -> id0=3

            And two row intervals: 
                interval0: [2,2] -> id0=2
                interval1: [4,4] -> id0=4

            Therefore, the connected components are:
                (2,0): (2,0)
                (2,3) and (2,4): same row interval and same column interval? (row2: id=2, col3: id=3, col4: id=3) -> so (2,3) and (2,4) are in the same? 
                (4,0): (4,0)
                (4,3) and (4,4): same.

            But note: (2,3) and (2,4) are adjacent? 
                (2,3) and (2,4): horizontal move. 
                The row_parity[2]=1 (so row is 1) and the columns: 
                    col3:1, col4:1 -> so the move is allowed? 
                Why? The condition: we can move horizontally if the columns are contiguous? 
                    Actually, they are consecutive? 
                But the columns 3 and 4 are consecutive and both are 1? -> so the move is allowed.

            Therefore, the entire contiguous column interval [3,4] is connected? 

            So the connected components are:
                (2,0) -> one component.
                (2,3) and (2,4) -> one component.
                (4,0) -> one component.
                (4,3) and (4,4) -> one component.

            Then (5,1) is (4,0) -> component (4,0)
            (3,4) is (2,4) -> component (2,3) and (2,4) -> so they are different components.

            Therefore, the answer is NO.

        This matches.

        However, note: in the grid, can we go from (4,0) to (4,3)? 
            (4,0) to (4,1): 
                (4,1): row4=1, col1=0 -> 1+0=1 -> odd -> not allowed.
            So we cannot.

        Therefore, the solution is as described.

        One more sample: 
            Sample Input #2: 
                3 2
                30 40 49   -> R_parity: [0,0,1]
                15 20 25   -> C_parity: [1,0,1]

            Query1: ⟨2,2,3,3⟩ -> (1,1) to (2,2) -> Type0 and Type1 -> NO -> correct.
            Query2: ⟨1,2,2,2⟩ -> (0,1) to (1,1) -> Type0 and Type0.

            Type0 rows: 
                row0:0 -> group0=0
                row1:0 -> group0=0 (because row0 is 0) 
                row2: skip.

            Type0 columns:
                col0:1 -> skip
                col1:0 -> group0=1   (because j=1: and j==0 is false -> but j-1=0: which is 1 (so not 0) -> so we set current_start=1 -> col0_group[1]=1.
                col2:1 -> skip.

            Then (0,1): row0_group[0]=0, col0_group[1]=1 -> (0,1)
            (1,1): row0_group[1]=0, col0_group[1]=1 -> same.

            Output YES.

        Therefore, we write the code accordingly.

        However, note: the problem says the start and end are even. We have precomputed the parities. 

        We must be cautious: our arrays for row0_group and col0_group are defined only for indices that are 0 (for rows) and 0 (for columns). For a Type0 cell, the row must be 0 and the column must be 0? 
            But we have stored row0_group only for rows that are 0? and col0_group only for columns that are 0? 

        In the query, we are accessing row0_group[ra0] only when the row_parity[ra0] is 0? So it's defined? 

        Similarly for columns.

        But what if the row_parity[ra0] is 0 but the column_parity[ca0] is 1? Then the cell is odd? But the problem guarantees the start is even. So that won't happen.

        Similarly, the end.

        So we are safe.

        Implementation note: we use 0-indexed arrays.

        Let's code accordingly.

        However, note: the problem says the grid has size N x N, and the arrays R and C have N elements.

        We'll do:

          Read N, Q.
          R = list of N integers.
          C = list of N integers.

          r_parity = [0]*N
          c_parity = [0]*N

          for i in range(N):
              r_parity[i] = R[i] % 2
          for j in range(N):
              c_parity[j] = C[j] % 2

          Then precompute the groups.

        But note: the modulus operation: 
            Since the numbers are nonnegative, %2 is safe.

        We'll then process the queries.

        Let's write the editorial accordingly.

        Summary:

          The key idea is that the grid of even cells is partitioned into two types: Type0 (where both row and column have even parity) and Type1 (where both row and column have odd parity). The two types are disconnected.

          Within a type, the connectivity is determined by contiguous intervals of rows and columns of that parity. Specifically, the even cells form a grid that is the Cartesian product of contiguous row intervals and contiguous column intervals of the same parity. 

          Therefore, two cells of the same type are connected if and only if they lie in the same contiguous row interval and the same contiguous column interval (for that parity).

          We precompute:
            - The parity for each row and column.
            - For Type0: 
                  row0_group[i] = the starting index of the contiguous interval of rows (with parity 0) that contains row i, if row i is 0; otherwise, undefined (but we don't use for even cells).
                  col0_group[j] = the starting index of the contiguous interval of columns (with parity 0) that contains column j, if column j is 0.
            - For Type1: similarly for parity 1.

          Then for each query, we check the type of the start and end. If they are different, output "NO". If the same, then we check that the row groups (for the appropriate type) and column groups (for the appropriate type) of the start and end are the same.

        This solution runs in O(N+Q) and meets the constraints.

        Note: The starting index of the contiguous interval is a unique identifier for the interval? Because two contiguous intervals cannot start at the same index.

        Therefore, we can use the starting index as the group identifier.

        We are done.

        Let me run through the example: 
            Sample Input #1: 
                N=5, R = [6,2,7,8,3] -> [0,0,1,0,1]
                C = [3,4,8,5,1] -> [1,0,0,1,1]

            Type0 rows: 
                i=0: 0 -> current_start=0 -> group0[0]=0.
                i=1: 0 -> then group0[1]=0.
                i=2: 1 -> skip.
                i=3: 0 -> current_start=3 -> group0[3]=3.
                i=4: 1 -> skip.

            Type0 columns:
                j=0: 1 -> skip.
                j=1: 0 -> current_start=1 -> group0[1]=1.
                j=2: 0 -> since j-1 is 0? Actually, j-1=1: which is 0? -> so we don't reset -> group0[2]=1.
                j=3: 1 -> skip.
                j=4: 1 -> skip.

            Then for the queries:

                Query1: (2,2) -> (1,1): 
                    row index=1 -> group0_row[1]=0, col index=1 -> group0_col[1]=1 -> key=(0,1)
                (1,3) -> (0,2): 
                    row index=0 -> group0_row[0]=0, col index=2 -> group0_col[2]=1 -> key=(0,1) -> same.

                Query2: (4,2) -> (3,1): 
                    row index=3 -> group0_row[3]=3, col index=1 -> group0_col[1]=1 -> key=(3,1)
                (4,3) -> (3,2): 
                    row index=3 -> group0_row[3]=3, col index=2 -> group0_col[2]=1 -> key=(3,1) -> same.

                Query3: (5,1) -> (4,0): 
                    Type1: 
                      Type1 rows: 
                         i=0:0->skip, i=1:0->skip, i=2:1->current_start=2->group1[2]=2.
                         i=3:0->skip, i=4:1->current_start=4->group1[4]=4.
                      Type1 cols:
                         j=0:1->current_start=0->group1[0]=0.
                         j=1:0->skip, j=2:0->skip, j=3:1->current_start=3->group1[3]=3.
                         j=4:1-> then group1[4]=3? 
                             Actually: at j=4: j>0 and the previous j=3 is 1 -> so we don't reset -> group1[4]=3.

                    (4,0): row index=4 -> group1[4]=4, col index=0 -> group1[0]=0 -> key=(4,0)
                    (3,4): row index=2 -> group1[2]=2, col index=3 -> group1[3]=3 -> key=(2,3) -> different.

        Therefore, we output:
            YES
            YES
            NO

        Correct.

        We are ready to code accordingly.

        However, note: the problem says the start and end are different cells and both even. So we don't have to worry about same cell? 

        But if they are the same cell? 
            The problem says "two different cells".

        So we are safe.

        Let me write the editorial.

        Editorial:

          The maze is defined by an N x N grid where the cell (i, j) has value R[i] + C[j]. We are to answer Q queries: for each query, we are given two distinct even cells (r_a, c_a) and (r_b, c_b) and we must decide if there is a path connecting them such that every cell in the path is even (and we can only move to adjacent cells).

          Key Observations:

          1. The condition for a cell (i, j) to be even is:
                  R[i] + C[j] is even
             which is equivalent to:
                  R[i] mod 2 = C[j] mod 2.

          2. Therefore, the grid of even cells is partitioned into two disjoint sets:
                - Type0: cells (i, j) such that R[i] is even and C[j] is even.
                - Type1: cells (i, j) such that R[i] is odd and C[j] is odd.

             Moreover, there is no edge connecting a Type0 cell to a Type1 cell. Why? 
                Consider an adjacent move: 
                  - If we move horizontally: the row i remains the same, so R[i] mod 2 remains the same. For the next cell (i, j+1) to be even, we require C[j+1] mod 2 = R[i] mod 2. Therefore, the next cell must be of the same type as the current.
                  - Similarly for a vertical move.

          3. Therefore, the start and end must be of the same type to be connected.

          4. Now, within one type (say Type0), we need to determine connectivity. 

             Consider a move from (i, j) to (i, j+1) in Type0. This move is valid only if:
                  - The current cell (i, j) is Type0: so R[i] is even and C[j] is even.
                  - The next cell (i, j+1) must be even: so R[i] is even (which it is) and C[j+1] is even.

             Therefore, the move is allowed only if C[j+1] is even. Similarly, a vertical move from (i, j) to (i+1, j) is allowed only if R[i+1] is even.

             This leads to the following:

                 - We can move horizontally from j to j' (within the same row i) only if every column between j and j' (inclusive) is even? Actually, we require that every adjacent step is even. But note: if there is a column k between j and j' that is odd, then the cell (i, k) would be R[i] (even) + C[k] (odd) = odd -> which blocks the path.

             Similarly, for vertical moves: we require that every row between the current and the next is even.

          5. Therefore, within Type0, the connected components are defined by:

                - The contiguous intervals of rows that are even: meaning a maximal contiguous segment of indices i such that R[i] is even.
                - The contiguous intervals of columns that are even: meaning a maximal contiguous segment of indices j such that C[j] is even.

             And the connected component corresponding to a contiguous row interval I and a contiguous column interval J is the set of cells (i, j) such that i is in I and j is in J.

             Why?
                - We can move freely within the rectangle I x J? 
                      * Horizontally: within a row i (which is even) we can move from j1 to j2 if the entire segment of columns from j1 to j2 is even? But note: the condition we deduced above: we require every column in between to be even. And by the definition of J being contiguous and entirely even, the segment from j1 to j2 is entirely in J and hence even. 
                      * Vertically: similarly.

                - Moreover, if a row i is in I, then it is even. Similarly, if a column j is in J, then it is even.

                - And there is no connection between two different rectangles? 
                      * To move from rectangle I1 x J1 to rectangle I2 x J2, we would have to pass through a row or column that is not even? Because the row intervals and column intervals are maximal contiguous.

          6. Similarly, for Type1, we have contiguous intervals of rows that are odd and contiguous intervals of columns that are odd.

          7. Algorithm:

                Precomputation:
                  a. Read N, Q, arrays R and C.
                  b. Precompute:
                         r_parity[i] = R[i] % 2 for each row i (0-indexed)
                         c_parity[j] = C[j] % 2 for each column j (0-indexed)

                  c. For Type0 (even rows and even columns):
                         - Compute an array row0_group[0..N-1]: 
                              Initialize current_start = -1.
                              For i from 0 to N-1:
                                  if r_parity[i] == 0:
                                      if i == 0 or r_parity[i-1] != 0:
                                          current_start = i
                                      row0_group[i] = current_start
                                  else:
                                      // We can leave it as an invalid value, but we won't use it for Type0 cells.

                         - Similarly, compute col0_group[0..N-1] for columns.

                  d. For Type1 (odd rows and odd columns):
                         - Similarly, compute row1_group[0..N-1] for rows that are 1.
                         - Similarly, compute col1_group[0..N-1] for columns that are 1.

                For each query (r_a, c_a, r_b, c_b) (1-indexed):

                  a. Convert to 0-indexed: 
                         ra0 = r_a - 1, ca0 = c_a - 1, rb0 = r_b - 1, cb0 = c_b - 1.

                  b. Check the type of the start cell (ra0, ca0): 
                         type_start = r_parity[ra0]   (which should equal c_parity[ca0] because the cell is even)

                  c. Check the type of the end cell: type_end = r_parity[rb0]

                  d. If type_start != type_end: output "NO"

                  e. Else, if type_start == 0:
                         if row0_group[ra0] == row0_group[rb0] and col0_group[ca0] == col0_group[cb0]:
                             output "YES"
                         else:
                             output "NO"

                  f. Else (type_start == 1):
                         if row1_group[ra0] == row1_group[rb0] and col1_group[ca0] == col1_group[cb0]:
                             output "YES"
                         else:
                             output "NO"

          8. Complexity: O(N+Q)

          9. Why is this correct?

                - The start and end must be in the same type to be connected, so if they are in different types we immediately say "NO".

                - For the same type, we note that the connected component of a Type0 cell (i, j) is uniquely determined by the contiguous interval of even rows that contains i and the contiguous interval of even columns that contains j. And two cells in the same rectangle are connected by a path (by moving horizontally and then vertically, or vice versa). 

                - Conversely, if the two cells are in different rectangles (either the row interval or the column interval differs), then there is no path: because any path would have to leave the rectangle and pass through a row or column that is not even (which would break the even condition).

          This solution efficiently handles the constraints by not building the grid explicitly and instead using the properties of contiguous intervals.

        Let's hope.

        We'll code accordingly.

        Note: We assume that the grid is 0-indexed internally.

        We are done.