We are given N lands, each of size (L_i, W_i). We wish to build two identical rectangular buildings of size A x B (with the same orientation for both) such that:
  Option 1: The two buildings are built on two different lands (one on each). For a land, the building can be placed in either of the two orientations: 
        (A<=L_i and B<=W_i) OR (A<=W_i and B<=L_i).

  Option 2: Both buildings are built on the same land. This requires the land to satisfy one of the following:
        (2A <= L_i and B <= W_i) OR (2A <= W_i and B <= L_i) OR
        (A <= L_i and 2B <= W_i) OR (A <= W_i and 2B <= L_i).

Our goal: maximize the area = A * B * 2 (for two buildings) but note the problem asks for the area of the two buildings together? 
Actually, the problem says: "output the largest possible for A × B" but then the sample outputs 12.5 for two buildings of 2.5x5 (which is 2.5*5*2 = 25? but 12.5 is the total area of both buildings: 2.5*5 * 2 = 25? -> Actually, wait: 
  Sample Input #1: two buildings of 2.5x5: one building area is 12.5, so two together is 25? but the output is 12.5.

But note: the problem says "output the largest possible for A × B". However, the sample output is 12.5. 
Looking at the explanations: 
  Sample Output #1: "12.5" -> and they say "Two buildings of 2.5 × 5" -> so the area of one building is 12.5, but the problem says "output the largest building" meaning the area of one building? 

But wait: the problem says: "output a number representing the largest building that ICPC Jakarta can build" and then in the sample input #1: 
  Two buildings of 2.5x5: each building has area 12.5. So the output is 12.5.

However, in sample #2: 
  Two buildings of 2x4: each building has area 8.0 -> output 8.0.

And sample #3: 
  Two buildings of 7x6: each building has area 42 -> but the output is 42.0? However, note: two buildings of 7x6: each building is 7x6 so area 42 per building -> output 42.0.

So we are outputting the area of one building? But then why in sample #1 we output 12.5? That's the area of one building (2.5*5=12.5). 

Therefore, we are to maximize the area of one building (which is A * B) and then output that area (with one decimal point). However, note that we are building two such buildings, but the problem is asking for the building size (A x B) as the product A*B? Actually, the output is a number: the area of one building (A * B) but for two buildings we build two of these.

But note: the problem says: "output the largest possible for A × B", meaning the area of one building.

So we are to maximize A * B such that we can build two buildings of size A x B (each) under the constraints.

How to solve?

We have two options: 
  Option 1: Use two different lands (say land i and land j). Then we require:
        For land i: (A <= L_i and B <= W_i) OR (A <= W_i and B <= L_i)
        For land j: (A <= L_j and B <= W_j) OR (A <= W_j and B <= L_j)

  Option 2: Use one land for both buildings: then the land must satisfy one of the four conditions.

We are to maximize A * B.

Note: the dimensions A and B can be any positive real numbers? However, the problem does not specify that they have to be integers. The sample #1 uses 2.5.

But note: the lands have integer dimensions, but we can use fractional dimensions for the buildings? 

Yes, because the problem does not require integers. So we can use real numbers.

However, note: we can always rotate arbitrarily? Actually, the buildings can be placed arbitrarily as long as the sides are parallel. So we can use fractional dimensions.

But how to maximize? The problem is challenging because of the two options and the large constraints (N up to 100000).

Approach:

We can consider the following:

  Let's denote a building by (A, B). Without loss of generality, we can assume that for each land we normalize the dimensions so that we always have the longer side as L_i and the shorter as W_i? Actually, we can define:

        For a land (L_i, W_i), we can consider:
            long_i = max(L_i, W_i)
            short_i = min(L_i, W_i)

  Why? Because we can always rotate the building arbitrarily. So a building (A, B) can be placed if:
        A <= long_i and B <= short_i   (if we assign the building's longer side to the land's longer side) 
        but note: what if the building has A and B arbitrary? Actually, we can also rotate the building. So we don't care about the building's orientation: we can always assign the building's longer side to the land's longer side? 

  However, note: we are allowed to assign independently: 
        Condition 1: A<=L_i and B<=W_i -> if we don't rotate the building relative to the land? 
        Condition 2: A<=W_i and B<=L_i -> if we rotate the building.

  But if we normalize the land to (long_i, short_i), then the condition becomes: 
        We can place the building if and only if:
            min(A, B) <= short_i and max(A, B) <= long_i.

  Why? 
        Condition 1: if we don't rotate: we assign the building's side A to L_i and B to W_i. But if L_i is the long_i and W_i is the short_i, then we require A<=long_i and B<=short_i. However, if A>B, then we might assign the longer building side to L_i and the shorter to W_i. But if A<=B, then we would assign the building's B to L_i and A to W_i? Actually, we can always rotate the building arbitrarily. 

  Therefore, we can re-state: 
        A building (A, B) can be placed on land (long_i, short_i) if:
            max(A, B) <= long_i and min(A, B) <= short_i.

  Similarly, for two buildings on one land (same land) we have conditions. Let the building be (A, B). Without loss of generality, we can assume that we assign the building's longer side to the land's longer side? Actually, we have four cases, but we can also consider:

        Case 1: Place both buildings side by side along the long side: then we need 2A <= long_i and B <= short_i (if we do not rotate the building) OR if we rotate one building? Actually, the problem states the same orientation for both. So both buildings have the same orientation. Therefore, we have two possibilities for orientation:

        Possibility 1: both buildings are placed with their first dimension A aligned to the land's long_i and B to the short_i. Then we can arrange them horizontally: then we require 2A <= long_i and B<= short_i.
        Possibility 2: both buildings are placed with their first dimension A aligned to the land's short_i and B to the long_i? Actually, that would be the rotated version? But note: if we rotate the building, then the building becomes (B, A). So we have:

        Actually, the four conditions in the problem are:

          (2A <= L_i and B <= W_i)   -> building as (A, B) and placed horizontally adjacent (along the L_i direction) -> so we use 2A in the long_i? 
          (2A <= W_i and B <= L_i)   -> building as (A, B) but we rotate the entire land? Actually no: the land is fixed. Alternatively, we can consider the land as (L_i, W_i) and we can use the building in two orientations.

          Actually, condition 1: without rotation: 2A <= L_i (so we use the land's length for two A's) and B<=W_i (the width for one B).
          condition 2: with rotation: 2A <= W_i and B<=L_i -> meaning we use the land's width as the length for the two A's and the land's length as the width for the one B.

          Similarly, condition 3: without rotation: A<=L_i and 2B<=W_i -> meaning we use the land's length for one A and the width for two B's (stacked vertically in the width direction).
          condition 4: with rotation: A<=W_i and 2B<=L_i.

        But note: we can also consider the building as (A, B) and the land as (long_i, short_i). Then the conditions become:

          Condition 1: 2A <= long_i and B <= short_i
          Condition 2: 2A <= short_i and B <= long_i -> but note: if 2A <= short_i, then since short_i <= long_i, then we have A <= short_i/2 and B <= long_i. However, condition 1 and 2 are both covered by the normalized land? Actually, no: because condition 2 uses the land's short_i for the double A and the land's long_i for the single B. 

        Alternatively, we can write for the same land:

          We require: 
            Either: 
                (2A <= long_i and B <= short_i) 
                OR 
                (A <= long_i and 2B <= short_i) 
                OR 
                (2A <= short_i and B <= long_i)   -> but note: since long_i>=short_i, then if 2A<=short_i, then 2A<=long_i is automatically satisfied? So condition (2A<=short_i and B<=long_i) is equivalent to (2A<=short_i and B<=long_i) but note: also we have B<=long_i is always satisfied if B<=short_i? because B<=short_i and short_i<=long_i -> then B<=long_i. So actually we can ignore this? 

          However, wait: what if we have a building that is very long in one dimension? 

        Actually, the four conditions in the normalized land (long_i, short_i) become:

          (2A <= long_i and B <= short_i)   -> [condition 1 and condition 2? Actually condition 1: without rotation: 2A<=L_i and B<=W_i. If we normalized the land, then L_i becomes long_i and W_i becomes short_i. Condition 2: 2A<=W_i and B<=L_i: but if we normalized, then W_i is short_i and L_i is long_i -> so 2A<=short_i and B<=long_i.

          Similarly, condition 3: A<=L_i and 2B<=W_i -> becomes A<=long_i and 2B<=short_i.
          condition 4: A<=W_i and 2B<=L_i -> becomes A<=short_i and 2B<=long_i.

        But note: because long_i>=short_i, then:
          Condition 1: 2A<=long_i and B<=short_i
          Condition 2: 2A<=short_i and B<=long_i   [but since short_i<=long_i, then 2A<=short_i implies 2A<=long_i, and B<=long_i is always true if B<=short_i? because if B<=short_i then B<=long_i. So condition 2 is actually a weaker version of condition 1? 

        Actually, no: condition 2 might allow a building that is very wide in the B dimension (if the land has a large long_i) even if the land's short_i is small? 

        Example: land (long_i=100, short_i=1). Then:
          Condition 1: 2A<=100 and B<=1 -> so A<=50, B<=1 -> area <=50.
          Condition 2: 2A<=1 and B<=100 -> so A<=0.5, B<=100 -> area <=50.

          Condition 3: A<=100 and 2B<=1 -> B<=0.5, A<=100 -> area <=50.
          Condition 4: A<=1 and 2B<=100 -> B<=50, A<=1 -> area <=50.

        So all conditions yield the same maximum area? 

        However, consider a building that is 0.5x100: 
          Condition 2: 2*0.5=1<=1 (the short_i) and 100<=100 -> valid. 
          But condition 1: 2*0.5=1<=100 and 100<=1 -> fails.

        So condition 2 is independent.

        Therefore, we have four conditions. But note: condition 3 and 4 are symmetric to condition 1 and 2 by swapping A and B? 

        So we can write for a single land i:

          Possibility 1: (2A <= long_i and B <= short_i) -> then area = A*B, and we can set A = long_i/2, B = short_i -> area = (long_i * short_i)/2, but note: we are constrained by both: we cannot set A arbitrarily to long_i/2 and B to short_i because then we require 2*(long_i/2)=long_i<=long_i and short_i<=short_i -> valid. So the maximum area we can get from this condition is (long_i * short_i)/2? Actually, no: because if we set A = long_i/2 and B = short_i, then the area is (long_i/2)*short_i = (long_i * short_i)/2.

          Possibility 2: (2A <= short_i and B <= long_i) -> then set A = short_i/2, B = long_i -> area = (short_i/2)*long_i = same as above.

          Possibility 3: (A<=long_i and 2B<=short_i) -> set A = long_i, B = short_i/2 -> area = long_i*(short_i/2) = same as above.
          Possibility 4: (A<=short_i and 2B<=long_i) -> set A = short_i, B = long_i/2 -> area = short_i*(long_i/2) = same.

        Therefore, for a single land, the maximum area we can get for one building is (long_i * short_i) / 2? 

        However, wait: we are not forced to use the entire land? We are only constrained by the inequalities. The maximum area we can get from one land is the maximum over:

          Possibility 1: A in [0, long_i/2] and B in [0, short_i] -> the maximum product A*B is achieved when A = long_i/2 and B = short_i -> area = (long_i/2)*short_i = long_i * short_i / 2.

          Possibility 2: A in [0, short_i/2] and B in [0, long_i] -> maximum at A=short_i/2, B = long_i -> area = (short_i/2)*long_i = same as above.

          Possibility 3: A in [0, long_i] and B in [0, short_i/2] -> maximum at A = long_i, B = short_i/2 -> area = long_i * short_i / 2.

          Possibility 4: same.

        Therefore, for a single land, the maximum area we can get for one building is (long_i * short_i) / 2.

        But note: we are building two buildings on the same land. So the total area for two buildings is 2 * (A * B) = long_i * short_i? which is the entire land? 

        Actually, if we use the entire land, then the entire land area is long_i * short_i, and we are building two buildings each of area (long_i * short_i)/2? Then total area is long_i * short_i -> which is the entire land. So that makes sense.

        Therefore, the same land option: for a land i, the maximum area for one building is (long_i * short_i) / 2.

Now, what about the two different lands?

  We have two lands: i and j. We want to assign a building (A, B) to each. The building must satisfy the constraints on each land.

  Without loss of generality, we can assume that we normalize the lands: (long_i, short_i) and (long_j, short_j).

  Then the building (A, B) must satisfy:
        max(A, B) <= min(long_i, long_j)   ??? -> not exactly.

  Actually, the building must be placed on land i: 
        max(A, B) <= long_i and min(A, B) <= short_i.

  And on land j:
        max(A, B) <= long_j and min(A, B) <= short_j.

  Therefore, the building must satisfy:
        max(A, B) <= min(long_i, long_j)   [because it must be <= long_i and <= long_j]
        min(A, B) <= min(short_i, short_j)   [because it must be <= short_i and <= short_j]

  Then the maximum area we can get is achieved when we set:
        Let X = min(long_i, long_j) and Y = min(short_i, short_j).
        Then we can set the building to (X, Y) -> but note: then min(X, Y) = min( min(long_i,long_j), min(short_i,short_j) ) and we require that min(A, B) <= min(short_i, short_j) -> but we set min(X, Y) which might be > min(short_i, short_j) if min(long_i,long_j) < min(short_i, short_j)? Actually, no: because we set Y = min(short_i, short_j). Then the building (X, Y) = (min(long_i,long_j), min(short_i,short_j)) -> then min(A,B) = min(X, Y) = min( min(long_i,long_j), min(short_i,short_j) ) which is <= min(short_i, short_j) -> okay.

        But also we require max(A,B) = max( min(long_i,long_j), min(short_i,short_j) ) <= min(long_i,long_j) -> which is true because min(short_i,short_j) <= min(long_i,long_j) (because in each land, short_i <= long_i, so min(short_i,short_j) <= min(long_i,long_j) might not hold? 

        Example: land1: (100, 10) -> long1=100, short1=10; land2: (50, 20) -> long2=50, short2=20.
        Then X = min(100,50)=50, Y = min(10,20)=10.
        Then building (50,10): 
            On land1: max(50,10)=50<=100, min(50,10)=10<=10 -> valid.
            On land2: max(50,10)=50<=50, min(50,10)=10<=20 -> valid.

        The area is 50*10=500.

        But what if we set the building to (min(long_i,long_j), min(short_i,short_j))? That is (50,10). 

        However, we can do better? 

        Consider: we are not forced to set the building to the entire available min(long_i,long_j) and min(short_i,short_j). But the constraints are independent? Actually, we can set the building arbitrarily as long as the longer side is at most min(long_i,long_j) and the shorter side is at most min(short_i,short_j). Then the maximum area is achieved when we set the building to be a square? Actually, no: because we have two constraints: the building's longer side must be <= min(long_i,long_j) and the shorter side must be <= min(short_i,short_j). 

        But note: the building can be oriented arbitrarily? Actually, the constraints for each land are normalized by the building's own max and min. So the building (A,B) must satisfy:
            max(A,B) <= min(long_i, long_j)   [because it must be <= long_i and <= long_j]
            min(A,B) <= min(short_i, short_j)

        Then the maximum area is achieved when we set:
            Let X = min(long_i, long_j) and Y = min(short_i, short_j).
            Then we can set the building to (X, Y) -> area = X * Y.

        But is that the maximum? 

        Consider: we could set the building to (min(long_i,long_j), min(short_i,short_j)) -> which is a rectangle of area X*Y. But we could also set it to (min(long_i,long_j), min(short_i,short_j)) and then that is fixed. However, note: we are allowed to set the building arbitrarily as long as the sides are at most the constraints. The area of a rectangle with sides a and b is a*b, and we have a<=X and b<=Y? Then the maximum area is X*Y? 

        But note: we have an additional constraint: the building's sides must satisfy: the longer side must be <= X and the shorter side must be <= Y. However, if we set a = X and b = Y, then the longer side is max(X,Y). What if X < Y? Then we cannot set a=X and b=Y because then the longer side would be Y which must be <= X (which is not if X<Y). 

        Therefore, we must ensure that the longer side of the building is at most X and the shorter side at most Y. But if X>=Y, then (X, Y) has longer side X and shorter side Y -> valid. If X<Y, then (X,Y) would have longer side Y which exceeds X -> invalid.

        How to handle?

        Actually, we have two constraints:

          constraint1: max(a,b) <= X
          constraint2: min(a,b) <= Y

        and we wish to maximize a*b.

        Without loss of generality, assume a>=b. Then the constraints become:
          a <= X, and b <= Y   [because a>=b -> min(a,b)=b and max(a,b)=a]

        Then the maximum area is achieved when a = X and b = min(Y, X) ??? but note: we require b<=Y and also b<=a? Actually, since we assumed a>=b, we can set b up to min(Y, a) but since a=X, then b up to min(Y, X). Then the area is X * min(Y, X). But note: if Y>=X, then we set b=X -> but then we have a=X, b=X -> but then we require a>=b -> valid? and the area is X^2.

        However, we can also set a and b arbitrarily? Actually, we are constrained by a<=X and b<=min(Y, a) (because b<=a by assumption). Then the maximum area is max_{a in [0,X], b in [0, min(Y,a)]} a*b.

        How to maximize? Fix a: then b should be min(Y, a). Then area = a * min(Y, a). Then:

          If a <= Y, then area = a^2.
          If a > Y, then area = a * Y.

        Then the maximum over a:

          For a in [0, Y]: area = a^2 -> maximum at a=Y: Y^2.
          For a in [Y, X]: area = a*Y -> increasing -> maximum at a=X: X*Y.

        Then the maximum area = max(Y^2, X*Y) = Y * max(Y, X).

        But note: we have two cases: 
          Case 1: X>=Y: then max(Y^2, X*Y) = X*Y (because X>=Y -> X*Y>=Y*Y).
          Case 2: X<Y: then we cannot have a>Y? because a<=X and X<Y, so a cannot exceed Y? Then the entire range of a is [0,X] and we are in the first case? Actually, if X<Y, then for a in [0,X] (which is entirely <=Y), then area = a^2, and the maximum is at a=X: X^2.

        Therefore, the maximum area for the building when using two lands i and j is:

          If min(long_i, long_j) >= min(short_i, short_j): 
                area = min(long_i, long_j) * min(short_i, short_j)
          Else: 
                area = min(long_i, long_j) * min(long_i, long_j)   ??? 

        But wait: in the case X<Y, we have area = X^2.

        Alternatively, we can write:

          Let X = min(long_i, long_j)
          Let Y = min(short_i, short_j)

          Then the maximum area for the building is min( X*Y, max(X^2, Y^2) )? 

        Actually, we have:

          area = max_{a,b} a*b, subject to a<=X, b<=Y, and with the building oriented so that the longer side is a and the shorter is b? Actually we assumed a>=b.

        Alternatively, we can drop the orientation and note that the constraints are:

          a <= X, b <= Y, and also a and b must satisfy: the longer side <= X and the shorter side <= Y. This is equivalent to:

          a <= X, b <= Y, and min(a,b) <= Y, and max(a,b) <= X.

        But note: if we set a and b arbitrarily without the a>=b, then we can swap them. So we can assume without loss of generality that a>=b. Then the constraints become: a<=X, b<=min(Y, a). 

        Then we have:

          area = max{ a * min(Y, a) for a in [0, X] }.

        As argued: 
          For a in [0, min(X, Y)]: the expression is a^2, which is maximized at a = min(X,Y) -> (min(X,Y))^2.
          For a in [min(X,Y), X]: the expression is a*Y, which is maximized at a=X -> X*Y.

        Therefore, the maximum area is max( min(X,Y)^2, X*Y ).

        But note: if X>=Y, then min(X,Y)=Y, then we have max(Y^2, X*Y) = X*Y (since X>=Y -> X*Y>=Y^2).
        If X<Y, then min(X,Y)=X, then we have max(X^2, X*Y) = X*Y? but wait: we are only allowed a in [0,X] and for a in [X, X] (only one point) and then for a in [0,X] we have two segments: [0,X] (which is entirely the first segment because X<Y) -> then the maximum is at a=X: X^2.

        Actually, in the case X<Y, the expression for a in [X, X] (if we extend to a>Y? but we don't have that) is not applicable. So we only have the first segment: the maximum is at a=X: X^2.

        Therefore, we can write:

          area = max( min(X,Y)^2, X*Y )  ??? but that doesn't match: in the X>=Y case: we get max(Y^2, X*Y)=X*Y -> which is correct.
          In the X<Y case: we get max(X^2, X*Y) = X*Y? but that is not what we have: we have only the first segment and the maximum is X^2.

        Actually, the expression we computed is:

          area = max( 
                   (min(X,Y))^2, 
                   (if X>=Y then X*Y else we don't have the second segment) 
                 )

        But in the case X<Y, the second segment (a*Y) does not occur because a cannot exceed X (which is <Y). So the maximum is (min(X,Y))^2 = X^2.

        Therefore:

          area = 
            if X>=Y: max(Y^2, X*Y) = X*Y   [because X*Y>=Y^2]
            if X<Y: then the maximum is X^2.

        But note: in the case X<Y, we have:

          a in [0,X] and for each a, b = a (because we set b to the maximum possible which is a, since we are in the segment a<=Y? and also we require b<=a) -> then area = a^2 -> maximum at a=X: X^2.

        However, we can set b up to Y? but we are constrained by the condition that the building's longer side must be <=X. Since we are assuming a>=b, then the longer side is a. Then the condition for the building's shorter side is b<=Y. But if we set a=X, then we can set b up to min(Y, a) = min(Y,X)=X (since X<Y). Then area = X * X.

        Therefore, the maximum area for the building from two lands i and j is:

          area = min( min(long_i, long_j) * min(short_i, short_j), 
                     min(long_i, long_j)^2 ) 
          ??? 

        Actually, we have two expressions:

          candidate1 = min(long_i, long_j) * min(short_i, short_j)   [if we set the building to (min(long_i,long_j), min(short_i,short_j)) but only if min(long_i,long_j)>=min(short_i,short_j) ? or in the X>=Y case we use this?]

          candidate2 = min(long_i, long_j)^2   [for the X<Y case]

        But note: the expression we derived is:

          area = 
             if min(long_i, long_j) >= min(short_i, short_j): 
                 area = min(long_i, long_j) * min(short_i, short_j)
             else:
                 area = min(long_i, long_j)^2

        Alternatively, we can write:

          area = min( min(long_i, long_j), min(short_i, short_j) ) * min(long_i, long_j)

          because: 
             if min(long_i, long_j) >= min(short_i, short_j): 
                 then min( min(long_i, long_j), min(short_i, short_j) ) = min(short_i, short_j)
                 so area = min(short_i, short_j) * min(long_i, long_j)
             else:
                 then min( min(long_i, long_j), min(short_i, short_j) ) = min(long_i, long_j)
                 so area = min(long_i, long_j) * min(long_i, long_j) = min(long_i, long_j)^2.

        But wait: is that always true? 

          Let X = min(long_i, long_j), Y = min(short_i, short_j).
          Then area = min(X, Y) * X.

        Then:
          if X>=Y: min(X,Y)=Y -> area = Y * X = X * Y.
          if X<Y: min(X,Y)=X -> area = X * X = X^2.

        So yes, we can write: area = min( min(long_i, long_j), min(short_i, short_j) ) * min(long_i, long_j)

        However, note: we might be able to get more by swapping the roles? 

        Actually, our derivation assumed that we set the building's longer side to min(long_i, long_j). But what if we set the building's longer side to min(short_i, short_j)? 

        Let me revisit: we defined:
          constraint: the building's longer side must be <= min(long_i, long_j)   [because it has to be <= long_i and <= long_j] 
          and the building's shorter side must be <= min(short_i, short_j).

        Then we set the building to (a, b) with a>=b. Then a <= min(long_i, long_j) and b<=min(short_i, short_j) and also b<=a.

        Then the maximum area is achieved by:

          candidate1: set a = min(long_i, long_j), and b = min( min(short_i, short_j), a ) = min( min(short_i, short_j), min(long_i, long_j) ) -> then area = min(long_i, long_j) * min( min(short_i, short_j), min(long_i, long_j) ) = min( min(long_i, long_j), min(short_i, short_j) ) * min(long_i, long_j)   -> as above.

        But note: we might get a bigger area by setting the building's longer side to min(short_i, short_j) and the shorter side to min(long_i, long_j)? 

        Actually, no: because the building's longer side must be at most min(long_i, long_j). And min(short_i, short_j) might be greater than min(long_i, long_j)? Then we cannot set the building's longer side to min(short_i, short_j) because it would exceed min(long_i, long_j). 

        Therefore, we are forced to have the building's longer side at most min(long_i, long_j).

        So the above candidate is the maximum.

        However, wait: what if we set the building's sides arbitrarily? We are constrained by two conditions:

          Condition for land i: the building must have max(a,b) <= long_i and min(a,b) <= short_i.
          Condition for land j: the building must have max(a,b) <= long_j and min(a,b) <= short_j.

        Then we have:
          max(a,b) <= min(long_i, long_j)   [because it must be <= long_i and <= long_j]
          min(a,b) <= min(short_i, short_j)

        Then the building (a,b) must satisfy:
          a <= min(long_i, long_j)   [if we let a>=b, then a = max(a,b) and b = min(a,b)]
          b <= min(short_i, short_j)
          and b<=a.

        Then the maximum area is achieved by setting a = min(long_i, long_j) and b = min( min(short_i, short_j), a ) -> as above.

        Therefore, the candidate for two lands i and j is:

          candidate = min( min(long_i, long_j), min(short_i, short_j) ) * min(long_i, long_j)

        But note: we could also set the building to (min(short_i, short_j), min(long_i, long_j))? Then the building has sides: 
            a = min(short_i, short_j), b = min(long_i, long_j)

        Then the building's longer side is max(a,b) = max( min(short_i, short_j), min(long_i, long_j) ). 
        We require that this is <= min(long_i, long_j) -> which is true only if min(short_i, short_j) <= min(long_i, long_j). 
        And the shorter side is min(a,b)=min( min(short_i, short_j), min(long_i, long_j) ) <= min(short_i, short_j) -> valid.

        Then the area for this candidate is min(short_i, short_j) * min(long_i, long_j) -> which is the same as above.

        So in summary, the candidate for two lands i and j is:

          candidate = min(long_i, long_j) * min( min(short_i, short_j), min(long_i, long_j) ) 
                   = min( min(long_i, long_j) * min(short_i, short_j), min(long_i, long_j)^2 )

        But we can also note:

          candidate = min(long_i, long_j) * min( min(short_i, short_j), min(long_i, long_j) ) 
                   = min( min(long_i, long_j) * min(short_i, short_j), min(long_i, long_j) * min(long_i, long_j) )
                   = min(long_i, long_j) * min( min(short_i, short_j), min(long_i, long_j) )

        However, we know that min( min(short_i, short_j), min(long_i, long_j) ) = min( long_i, long_j, short_i, short_j )? 

        Actually, no: it is min( min(short_i, short_j), min(long_i, long_j) ) = min( long_i, long_j, short_i, short_j )? yes, because min(a,b) for a=min(short_i,short_j) and b=min(long_i,long_j) is the min of all four.

        Therefore, candidate = min(long_i, long_j) * min( long_i, long_j, short_i, short_j )

        But note: we can also get a candidate by setting the building to (min( long_i, long_j, short_i, short_j ), min(long_i, long_j))? Then the area would be the same: min(long_i, long_j) * min( long_i, long_j, short_i, short_j ).

        So we have:

          candidate for two lands i and j: 
             area = min(long_i, long_j) * min( min(long_i, long_j, short_i, short_j) ) 

        But wait, is that the same as above? 

          We had: 
             candidate = min( min(long_i, long_j) * min(short_i, short_j), min(long_i, long_j)^2 )

          = min(long_i, long_j) * min( min(short_i, short_j), min(long_i, long_j) ) 
          = min(long_i, long_j) * min( long_i, long_j, short_i, short_j )   -> yes.

        Therefore, for two lands i and j, the candidate area is: 
             candidate_ij = min(long_i, long_j) * min( long_i, long_j, short_i, short_j )

        However, note: we must also consider that we might use the same land for both buildings. For a single land i, we have candidate_i = (long_i * short_i) / 2.

        Then the overall answer is the maximum over:

          Option 1: for each land i: candidate_i = (long_i * short_i) / 2.
          Option 2: for each pair (i, j) (i != j): candidate_ij = min(long_i, long_j) * min( long_i, long_j, short_i, short_j )

        But note: the problem has N up to 100000 -> we cannot iterate over all pairs.

        How to compute the maximum candidate_ij over all pairs i,j?

          We note: candidate_ij = min( long_i, long_j ) * min( long_i, long_j, short_i, short_j )

          = min( long_i, long_j ) * min( min(long_i, long_j), min(short_i, short_j) ) 
          = min( min(long_i, long_j)^2, min(long_i, long_j)*min(short_i, short_j) )

        But we already know that the expression is the same as above.

        Alternatively, we can reorganize the data.

        Idea:

          Since the expression involves min(long_i, long_j) and min(short_i, short_j) and min(long_i, long_j, short_i, short_j) is the min of the four, we can try to sort the lands.

          Note: for each land, we have normalized: (long_i, short_i) = (max(L_i,W_i), min(L_i,W_i))

        Then we have:

          candidate_ij = min(long_i, long_j) * min( long_i, long_j, short_i, short_j )

        Without loss of generality, assume we sort the lands by long_i in descending order? Or ascending?

        Alternatively, we can fix one land and then find the best partner.

        How about: we wish to maximize min(long_i, long_j) * min( long_i, long_j, short_i, short_j ). 

        Let M = min(long_i, long_j) and T = min( long_i, long_j, short_i, short_j ) = min(M, min(short_i, short_j))

        Then candidate_ij = M * min(M, min(short_i, short_j)).

        Now, if we fix land i, and consider land j:

          candidate_ij = 
            if long_j >= long_i: 
                then M = min(long_i, long_j) = long_i.
                T = min( long_i, long_j, short_i, short_j ) = min( long_i, short_i, short_j )   [because long_j>=long_i, so we can drop long_j?] 
                     = min( long_i, min(short_i, short_j) )
                candidate_ij = long_i * min( long_i, min(short_i, short_j) )

            else: long_j < long_i:
                then M = long_j.
                T = min( long_i, long_j, short_i, short_j ) = min( long_j, short_i, short_j ) 
                     = min( long_j, min(short_i, short_j) )
                candidate_ij = long_j * min( long_j, min(short_i, short_j) )

        Therefore, for a fixed land i, the candidate_ij for j such that long_j >= long_i is: 
            candidate_ij = long_i * min( long_i, min(short_i, short_j) )

        But note: we have min(short_i, short_j) is at most short_j. How to maximize this? 

        Actually, we are maximizing candidate_ij. The expression for j with long_j>=long_i:

            candidate_ij = long_i * min( long_i, min(short_i, short_j) ) 
                         = min( long_i^2, long_i * min(short_i, short_j) )

        To maximize this, we want min(short_i, short_j) to be as large as possible? 

        Similarly, for j with long_j < long_i:
            candidate_ij = long_j * min( long_j, min(short_i, short_j) )
                         = min( long_j^2, long_j * min(short_i, short_j) )

        And we want to maximize that.

        How to do it fast? 

        We can sort the lands by long_i (and also store short_i). Then we can iterate from large long_i to small.

        Alternatively, we can use a segment tree or a Fenwick tree? 

        However, note that we are dealing with two parts: 

          Part 1: j with long_j>=long_i -> we want to maximize min( long_i^2, long_i * min(short_i, short_j) ) -> but note: long_i is fixed. Then:

            candidate_ij = 
                if min(short_i, short_j) >= long_i: then = long_i * long_i
                else: = long_i * min(short_i, short_j)

            But note: min(short_i, short_j) = min( min(short_i, short_j) )? Actually, we have two terms: short_i and short_j. 

            Actually, we can write:

                candidate_ij = 
                    if min(short_i, short_j) >= long_i: long_i^2
                    else: long_i * min(short_i, short_j)

            But note: min(short_i, short_j) is at most min(short_i, short_j) -> and we want it to be as large as possible? 

            However, we are constrained by j such that long_j>=long_i.

            Then for fixed i, we wish to consider j such that long_j>=long_i and then:

                candidate_ij = min( long_i^2, long_i * min(short_i, short_j) )

            But note: if we have a j with short_j >= long_i and also short_i>=long_i? then min(short_i, short_j)>=long_i -> then we get long_i^2.

            But what if there is no such j? Then we get long_i * min(short_i, short_j). 

            How to maximize long_i * min(short_i, short_j)? 

                = long_i * min( min(short_i, short_j) ) = long_i * min( min(short_i, short_j) )

            Actually, we can break min(short_i, short_j) = min(short_i, short_j). 

            For fixed i, we wish to maximize min(short_i, short_j) over j with long_j>=long_i.

            Then the maximum value of min(short_i, short_j) is: 
                Let candidate_value = min(short_i, short_j) -> we wish to maximize that.

            But note: we can choose j arbitrarily. Then the maximum candidate_value is min(short_i, max_{j: long_j>=long_i} short_j) ?

            Why? because min(short_i, short_j) is at most short_i, and if we choose j with the largest short_j, then we get min(short_i, max_short_j).

            Therefore, for fixed i, the maximum candidate_ij for j with long_j>=long_i is:

                candidate_ij = 
                    if (max_short_j >= long_i) for some j (with long_j>=long_i) then long_i^2
                    else: long_i * min(short_i, max_short_j)

            However, note: we also require that the j we choose has long_j>=long_i. So we can precompute:

                Precomputation: 
                  Sort lands by long_i in descending order? Then for a fixed i, we consider all j that come after i in the sorted order? Actually, we want long_j>=long_i.

            We can do:

                Sort the lands by long_i in descending order. Then traverse the lands in that order, and we can maintain the maximum short_j seen so far.

                Then for land i (with long_i and short_i) we have:

                  candidate_ij (for j>i in the sorted order? but we are traversing from large long_i to small, then the j we have seen are those with long_j>=long_i) -> then we have max_short = max(short_j for all j we have seen).

                Then:

                  candidate_ij = 
                     if max_short >= long_i: then long_i^2
                     else: long_i * min(short_i, max_short)

            But note: we must also consider j with long_j>=long_i and we have included land i? Actually, we can use the maximum from the previously seen (excluding i? but we can include i) because if we include i, then max_short might be updated by short_i. Then:

                  candidate_ij (for land i and any j that we have seen, including i?) -> but note: we are iterating and we have seen lands that have long_j>=long_i (including the current i? we haven't added it yet). 

                We can do: 
                  We traverse from large long_i to small. For the current land i, we haven't included it. Then we update the candidate for land i using the current max_short (which is the maximum short_j for lands with long_j strictly greater than long_i? and then we update max_short to include short_i).

            However, note: we can also form a pair (i, i) for two lands? but the problem says two different lands. So we cannot use the same land twice? 

            Therefore, we must exclude the current land i? 

            How? Then we do:

                  We maintain a data structure that has all lands with long_j>long_i? and then we update after processing i.

            Alternatively, we can do:

                  Sort by long_i descending. Let max_short = 0 initially.

                  For i from 0 to n-1:
                      candidate_using_j_with_larger_long = 
                         if max_short >= long_i: then long_i^2
                         else: long_i * min(short_i, max_short)   [but note: if max_short==0 then it's 0? but we haven't seen any land?]

                  Then update max_short = max(max_short, short_i)

            But this misses: we are only considering j that are processed earlier (which have long_j>=long_i? actually in descending order, the ones we've processed have long_j>=long_i, because we start with the largest). However, we have not included the current land i in max_short. 

            But we are not allowed to use the same land twice. So we are only considering j that are not i. So we use the max_short from the previous lands (which have long_j>=long_i, and note: in descending order, if two lands have the same long_i, then we break arbitrarily? but we must consider all j with long_j>=long_i, including those with the same long_i? 

            How to handle same long_i? 

            We can do: sort by long_i descending, and for same long_i, sort by short_i descending? 

            Then:

                We traverse in descending order of long_i. For a fixed long_i value, we process all lands with that long_i together? 

                But note: we want to avoid using the same land, but we can use two different lands with the same long_i.

            Actually, we can update the candidate after processing a group.

            Alternatively, we can do:

                We maintain two data structures: 
                  one that stores the maximum short_i for lands with long_i >= X (for the current X) and we update as we go.

            However, we can also do:

                We traverse in descending order of long_i. We maintain a set or a Fenwick tree for the short_i values? 

            But note: we only need the maximum short_i so far (excluding the current land). 

            Therefore, we can do:

                sort lands by long_i descending, and if same, by short_i descending? 
                max_short = 0
                candidate_two_lands = 0
                for each land i in sorted order:
                    // candidate for the current land i with any land j that has been processed (long_j>=long_i, and j != i) 
                    if max_short > 0:  // meaning we have at least one j
                        if max_short >= long_i:
                            candidate = long_i * long_i
                        else:
                            candidate = long_i * min(short_i, max_short)   // note: min(short_i, max_short) might be short_i? or max_short? 
                        candidate_two_lands = max(candidate_two_lands, candidate)
                    // then update max_short to include the current land's short_i? but note: we want to include it for the next lands? 
                    max_short = max(max_short, short_i)

            But wait: why min(short_i, max_short)? 
                We are considering a pair (i, j) where j is a land we have already processed (so long_j>=long_i) and j != i. Then the candidate_ij = min(long_i, long_j) * min( long_i, long_j, short_i, short_j ) = long_i * min( long_i, min(short_i, short_j) ) 
                = long_i * min( long_i, min(short_i, short_j) )

                Now, we have stored max_short = max(short_j for j processed). Then the largest min(short_i, short_j) we can get for a fixed i and j processed is min(short_i, max_short). 

                Then if min(short_i, max_short) >= long_i: we use long_i^2? 
                But note: the expression: min( long_i, min(short_i, max_short) ) = 
                    if min(short_i, max_short) >= long_i: then = long_i -> then candidate = long_i * long_i = long_i^2.
                    else: = min(short_i, max_short) -> then candidate = long_i * min(short_i, max_short)

                So we can write:

                    candidate = long_i * min( long_i, min(short_i, max_short) )

            But note: we are using min(short_i, max_short) which is the best min(short_i, short_j) we can get from the processed lands? 

            However, we want the maximum candidate_ij over j processed. And we are using the best j (the one with the largest short_j) to get min(short_i, max_short). But is that the best? 

            Yes, because min(short_i, short_j) is increasing in short_j until short_j>=short_i, then it becomes constant. So the maximum min(short_i, short_j) is min(short_i, max_short).

            Therefore, the above works.

        But note: we have not considered the case where j has long_j < long_i? 

          We are only processing lands with long_i descending. Then for a land i, we consider j with long_j>=long_i (which are the ones we have processed) and we get candidate_ij.

          What about j with long_j < long_i? Then we would process that land j later? and then when we process land j, we consider land i which has long_i>long_j and then we process land j and then we consider land i (which has been processed) and then we compute candidate_ji? 

          But note: candidate_ij = candidate_ji: because the expression is symmetric? 

          candidate_ji = min(long_j, long_i) * min( long_i, long_j, short_i, short_j ) = min(long_j, long_i) * min( long_i, long_j, short_i, short_j ) = same as candidate_ij.

          So we cover the pair (i,j) when we process the land with the smaller long_i.

          Therefore, we can do:

            We traverse in descending order of long_i. For each land i, we consider all j that we have processed (which have long_j>=long_i) -> which gives candidate_ij.

            And when we process a land with long_j < long_i, we will consider it at that time? and then we consider the already processed lands that have long_i>=long_j? which we have processed (and stored) in the max_short.

          However, note: when we process a land j with long_j < long_i, then we are at j and we have processed all lands with long_i>=long_j (including the ones that have long_i>long_j, which are the ones we processed earlier). So then we compute:

            candidate_j = 
                if max_short (at j) >= long_j: then long_j^2
                else: long_j * min(short_j, max_short)

          And this candidate_j is the candidate for the pair (j, i) for any i processed earlier.

          Therefore, we cover both directions.

        Therefore, algorithm for Option 2 (two different lands) is:

          Step 1: For each land, normalize: (long_i, short_i) = (max(L_i, W_i), min(L_i, W_i))

          Step 2: Sort the lands by long_i descending (if the same long_i, we can sort arbitrarily, but we'll sort by short_i descending? actually we don't care for the same long_i, because we update max_short by the maximum short_i).

          Step 3: Initialize:
                   candidate_two = 0   (this will be the maximum candidate_ij over all pairs)
                   max_short = 0

          Step 4: For each land i in the sorted list:
                   if max_short > 0:   // we have at least one land j processed
                         temp = min(short_i, max_short)
                         candidate_ij = long_i * min(long_i, temp)
                         candidate_two = max(candidate_two, candidate_ij)

                   max_short = max(max_short, short_i)

          Then candidate_two is the maximum area we can get from two different lands.

        And for Option 1 (same land): 
                   candidate_one = 0
                   for each land i:
                         candidate_i = (long_i * short_i) / 2.0
                         candidate_one = max(candidate_one, candidate_i)

        Then the answer = max(candidate_one, candidate_two)

        But note: the problem might also allow using one land for one building and another land for the other building? But we already covered two different lands in candidate_two? 

        However, note: we have two options:

          Option 1: use one land for both buildings -> candidate_one = (long_i * short_i)/2 for that land.
          Option 2: use two different lands, one for each building -> candidate_two = candidate_ij (as computed above).

        Then the answer is the maximum of candidate_one and candidate_two.

        But note: in candidate_two, we computed the candidate_ij for a pair (i,j) and that candidate is the area for one building? Yes, because we defined candidate_ij as the area of the building (A x B) = A*B.

        And candidate_one is the area of one building (which is (long_i*short_i)/2).

        Therefore, we output: max( candidate_one, candidate_two )

        But note: the output must have exactly one decimal point? 

        Example: if the answer is an integer, we output "8.0", if fractional, "12.5".

        How to output? We can output in fixed format with one decimal.

        However, note: the problem says "output in a line a number representing the largest building that ICPC Jakarta can build with exactly one decimal point"

        So we must output:

          If the answer is an integer, we output X.0, if fractional, we output with one digit after decimal.

        We can do: 
          double ans = max(candidate_one, candidate_two);
          printf("%.1f\n", ans);

        But note: the problem constraints: long_i, short_i up to 10^9 -> then the area can be as large as 10^18 -> we must use double? or we can use long double? 

        However, the problem says output with one decimal point.

        But note: the area might be fractional? only in the same land option: (long_i * short_i) / 2 -> which might be fractional.

        In two lands option: candidate_ij = min(long_i, long_j) * min( long_i, long_j, short_i, short_j ) -> which is integer? because long_i, etc are integers? 

          But then we output it as an integer with one decimal? e.g., 8 -> 8.0.

        How to avoid floating point precision? 

        We can do:

          candidate_one = (long_i * short_i) / 2.0   -> but if long_i * short_i is even? then integer, else fractional.

        candidate_two = an integer.

        Then we have to output:

          If the maximum is an integer -> output as integer part and ".0", else output fractional with one digit.

        Alternatively, we can output in fixed one decimal: 
            printf("%.1f\n", ans);

        But note: the problem constraints: the area can be as large as 10^18 -> double has 52 bits of precision, which can represent integers exactly up to 2^53 (about 10^15) -> but 10^18 is too big? 

        Example: 10^9 * 10^9 = 10^18 -> then divided by 2 -> 5e17 -> which is within the exact representation of double? 

        Actually, double can represent integers exactly up to 2^53 ~ 9e15 -> so 5e17 is 5*10^17 > 9e15 -> so we lose precision.

        Therefore, we cannot use double. How about using integers for comparison and then output as string?

        We can compute:

          candidate_one = (long_i * short_i)  [then we know we have to divide by 2]
          candidate_two = an integer.

        Then the maximum area is:

          ans = max( candidate_one/2, candidate_two )

        How to compare candidate_one/2 and candidate_two without floating point?

          candidate_one/2 >= candidate_two   <=>  candidate_one >= 2 * candidate_two

        Then:

          if candidate_one >= 2 * candidate_two:
              then output candidate_one/2 -> which may be integer or half-integer.
          else:
              then output candidate_two.

        How to output candidate_one/2? 

          If candidate_one is even: then candidate_one/2 is an integer -> output (candidate_one/2).0
          If candidate_one is odd: then candidate_one/2 = k + 0.5 -> output k.5

        How to output candidate_two? as candidate_two.0

        Therefore, we can do:

          candidate_one = 0
          for each land: 
                candidate_one = max(candidate_one, long_i * short_i)   [we store the product]

          candidate_two = ... [an integer]

          Then:

            if candidate_one >= 2 * candidate_two:
                if candidate_one % 2 == 0:
                    ans = candidate_one // 2
                    output: ans + ".0"   -> but actually we output as integer and then ".0"?
                else:
                    ans = candidate_one // 2   (integer division) and then add 0.5? -> then output as: (candidate_one//2) + ".5"

            else:
                output: candidate_two + ".0"

        However, note: candidate_one = long_i * short_i might be huge? but we are storing as integers (using long long).

        candidate_two is also stored as integer.

        But note: the expression candidate_ij = min(long_i, long_j) * min( long_i, long_j, short_i, short_j ) might be as big as 10^18 -> so we use long long.

        Steps:

          Use long long for candidate_one and candidate_two.

          candidate_one = max_i (long_i * short_i)   -> then we store max_product = candidate_one.

          Then:

            if max_product >= 2 * candidate_two:
                if max_product % 2 == 0:
                    printf("%lld.0\n", max_product/2);
                else:
                    printf("%lld.5\n", max_product/2);   // but note: integer division truncates? for positive: max_product//2 is floor, then we want to output floor and then .5? 
            else:
                printf("%lld.0\n", candidate_two);

        However, note: we might have candidate_two that is fractional? But candidate_two is computed as an integer? 

        But wait: candidate_two is computed as min(long_i, long_j) * min( long_i, long_j, short_i, short_j ) -> which is integer.

        But candidate_one = long_i * short_i is integer, and then divided by 2 might be fractional.

        Therefore, we have:

          candidate_one = max_i (long_i * short_i)   -> integer, then candidate_one/2 might be integer or half-integer.

        candidate_two = integer.

        Then:

          if candidate_one >= 2 * candidate_two:
             then we output candidate_one/2 as either integer or half-integer.
          else:
             output candidate_two as integer.

        How to output?

          We can also avoid the if by:

            if candidate_one >= 2 * candidate_two:
                if candidate_one % 2 == 0:
                    printf("%lld.0\n", candidate_one/2);
                else:
                    printf("%lld.5\n", candidate_one/2);
            else:
                printf("%lld.0\n", candidate_two);

        Example: candidate_one=25 -> then 25/2=12.5 -> we output 12.5? 
            candidate_one/2 = 12.5 -> but we are outputting: 
                25%2==1 -> then we output "12.5"

        But note: candidate_one/2 = 12.5 -> we can do:

            integer_part = candidate_one // 2   (which is 12)
            then if candidate_one % 2 == 1 -> then output "12.5"

        How to do:

            if candidate_one % 2 == 0:
                printf("%lld.0", candidate_one/2);
            else:
                printf("%lld.5", candidate_one/2);   // but candidate_one/2 is integer? we want to output 12.5: 
                // we have integer_part = candidate_one/2 (which is 12) and then output "12.5"

        Actually, we can do:

            if candidate_one % 2 == 0:
                printf("%lld.0\n", candidate_one/2);
            else:
                printf("%lld.5\n", candidate_one/2);   // but candidate_one/2 in integer division is 12, then we output "12.5"

        This works.

        But note: candidate_one might be negative? no, because long_i, short_i>=1.

        Therefore, the algorithm:

          Step 1: Read N.
          Step 2: For i in range(N):
                   read L_i, W_i.
                   long_i = max(L_i, W_i)
                   short_i = min(L_i, W_i)

          Step 3: candidate_one = 0
                   for i in range(N):
                         candidate_one = max(candidate_one, long_i * short_i)

          Step 4: candidate_two = 0
                   Sort the lands by long_i descending (if two lands have the same long_i, then we break by short_i descending? not necessary, but we update max_short by the maximum short_i seen so far).

                   max_short = 0
                   for each land in the sorted list (from high long_i to low):
                         if max_short>0: 
                              temp = min(short_i, max_short)
                              candidate_ij = long_i * min(long_i, temp)   // integer
                              candidate_two = max(candidate_two, candidate_ij)

                         max_short = max(max_short, short_i)

          Step 5: 
                   if candidate_one >= 2 * candidate_two:
                         if candidate_one % 2 == 0:
                             output = candidate_one//2 + ".0"   -> but we need to format: 
                             printf("%lld.0\n", candidate_one/2);   // but candidate_one/2 might be fractional? we are using integer arithmetic: candidate_one is even, so candidate_one/2 is integer.

                         else:
                             printf("%lld.5\n", candidate_one/2);   // but candidate_one/2 is integer division? then we get the integer part. However, we have candidate_one//2 is the integer part.

                   else:
                         printf("%lld.0\n", candidate_two);

        However, note: candidate_one is a long long, so we can do:

          if (candidate_one >= 2 * candidate_two) {
            if (candidate_one % 2 == 0) {
                printf("%lld.0\n", candidate_one/2);
            } else {
                printf("%lld.5\n", candidate_one/2);   // e.g., 25: 25/2=12 (in integer) then we output 12.5 -> so we output the integer part and then .5
            }
          } else {
                printf("%lld.0\n", candidate_two);
          }

        But note: candidate_one/2 in integer division for an odd candidate_one truncates. But we want the floor? and then we output the floor value and then ".5". 

        Example: candidate_one=25 -> 25/2 in integer is 12 -> then we output "12.5" -> that is correct.

        However, we can also do:

          We can output as double? but we are concerned about precision. But candidate_one is at most 10^18 -> and we are dividing by 2 -> which is 5e17 -> which is beyond the exact representation of double? 

        Therefore, we do the integer output.

        But note: candidate_two might be fractional? no, it is integer.

        However, wait: what about the same land option: candidate_one = long_i * short_i (integer) and then we output either integer.0 or half integer.

        And two lands: candidate_two is integer -> we output integer.0.

        Therefore, we can do:

          ans = max( (double)candidate_one/2, (double)candidate_two )   -> but we are concerned about precision for large numbers.

        Alternatively, we can do:

          if candidate_one >= 2 * candidate_two:
              // then candidate_one/2 is the answer, and we output it with one decimal
              if candidate_one % 2 == 0:
                  printf("%.1f\n", (double)candidate_one/2);   // but for large candidate_one, we lose precision? 
              else:
                  // we can output: 
                  printf("%lld.5\n", candidate_one/2);
          else:
              printf("%lld.0\n", candidate_two);

        But the problem says "exactly one decimal point", so for candidate_one even: we must output "X.0", for candidate_two: "X.0", and for candidate_one odd: "X.5"

        Therefore, we do:

          if (candidate_one >= 2 * candidate_two) {
            if (candidate_one % 2 == 0) {
                printf("%lld.0\n", candidate_one/2);
            } else {
                printf("%lld.5\n", candidate_one/2);
            }
          } else {
                printf("%lld.0\n", candidate_two);
          }

        But wait: candidate_one might be 0? then 0.0 -> but candidate_one = long_i * short_i >=1.

        This should be safe.

        Let's test with the samples:

        Sample Input #1: 
            2
            5 5
            3 4

          Normalize: 
            land1: (5,5) -> long1=5, short1=5 -> product=25
            land2: (4,3) -> long2=4, short2=3 -> product=12

          candidate_one = max(25,12)=25.

          Then for candidate_two: 
            Sort lands by long_i descending: 
                land1: (5,5)
                land2: (4,3)

            Process land1: 
                max_short=0 -> skip candidate_ij for land1 (no land processed)
                then update max_short = max(0,5)=5.

            Process land2:
                max_short=5 -> 
                    temp = min(land2.short_i=3, 5)=3
                    candidate_ij = long2 * min(long2, temp) = 4 * min(4,3) = 4*3=12
                candidate_two = max(0,12)=12.

          Then: candidate_one=25, 2*candidate_two=24 -> 25>=24 -> then output candidate_one/2: 
                25 is odd -> output 25//2 = 12 and then ".5" -> "12.5"

          Matches.

        Sample Input #2:
            2
            2 5
            4 3

          Normalize:
            land1: (5,2) -> long1=5, short1=2 -> product=10
            land2: (4,3) -> long2=4, short2=3 -> product=12

          candidate_one = max(10,12)=12.

          candidate_two: 
            Sort by long_i descending: 
                land1: (5,2)
                land2: (4,3)

            Process land1: 
                skip (no land processed), then max_short=2.

            Process land2:
                temp = min(3,2)=2
                candidate_ij = 4 * min(4,2) = 4*2=8.

            candidate_two=8.

          Then: candidate_one=12, 2*candidate_two=16 -> 12<16 -> then output candidate_two.0 -> 8.0.

          Matches.

        Sample Input #3:
            3
            10 1
            9 8
            7 6

          Normalize:
            land1: (10,1) -> product=10
            land2: (9,8) -> product=72
            land3: (7,6) -> product=42

          candidate_one = max(10,72,42)=72.

          candidate_two: 
            Sort by long_i: [ (10,1), (9,8), (7,6) ]

            Process land1 (10,1): 
                skip, then max_short=1.

            Process land2 (9,8):
                temp = min(8,1)=1
                candidate_ij = 9 * min(9,1)=9*1=9.

                candidate_two=9 (so far)

                then update max_short = max(1,8)=8.

            Process land3 (7,6):
                temp = min(6,8)=6
                candidate_ij = 7 * min(7,6)=7*6=42.

                candidate_two = max(9,42)=42.

          Then: candidate_one=72, 2*candidate_two=84 -> 72<84 -> output candidate_two.0 -> 42.0.

          Matches.

        However, wait: the sample output is 42.0.

        But note: the sample input #3 explanation: two buildings of 7x6 -> area per building is 42 -> so 42.0.

        Therefore, the algorithm works.

        But note: we must be cautious: when we compute candidate_ij for land i, we use min(short_i, max_short) -> but note: the max_short we have is the maximum short_i among the lands processed so far (which have long_j>=long_i). This is correct.

        However, consider: 
          Land i: (long_i, short_i) = (100, 10)
          Processed lands: 
               (200, 200) -> then max_short=200
          Then: 
               temp = min(10,200)=10
               candidate_ij = 100 * min(100,10)=100*10=1000.

          But what if we have a land j: (100, 100) that we have processed? 
          Then: 
               candidate_ij for (100,10) and (100,100) = 
                   min(long_i, long_j)=100
                   min( long_i, long_j, short_i, short_j ) = min(100,100,10,100)=10
               then candidate_ij=100*10=1000.

          But what if we use land j: (200,200) and land i: (100,10) -> we get the same.

          However, what if we have a land j: (100, 50) -> then min(short_i, short_j)=min(10,50)=10 -> same.

          So we are always taking the min with the current land's short_i? 

          But note: the expression: min( long_i, min(short_i, max_short) ) = min(100, min(10,200)) = min(100,10)=10.

          Therefore, we are constrained by the current land's short_i? 

          This matches the constraint: the building must have min(a,b) <= min(short_i, short_j) for the two lands -> and the current land i has short_i=10, so the building's min(a,b) must be <=10.

          Therefore, the candidate_ij for land i and any land j is limited by the current land i's short_i? 

          Correct.

        One more corner: two lands with very different dimensions.

        Example: 
          land1: (100, 1) -> long1=100, short1=1
          land2: (100, 100) -> long2=100, short2=100

          candidate_one = max(100*1, 100*100)=10000.

          candidate_two: 
            Sort: by long_i descending: same, then we process arbitrarily. Let's process land2 first:

              land2: update max_short=100.
              land1: 
                  temp = min(1,100)=1
                  candidate_ij = 100 * min(100,1)=100*1=100.

          Then candidate_one=10000, 2*candidate_two=200 -> then we output candidate_one/2=5000.0? 

          But wait: candidate_one/2 = 10000/2=5000.

          However, can we build two buildings of 5000? 

          For the same land: land2: (100,100) -> candidate_one for land2 is 100*100/2=5000 -> so we can build two buildings of 100x100/2? Actually, we can build two buildings of 50x100? 

          But note: the same land condition: 
                Condition: (2A<=100 and B<=100) -> set A=50, B=100 -> area=50*100=5000 -> valid.

          So the building size is 5000? 

          But then we output 5000.0.

          However, what if we use two lands? 
                candidate_two=100 -> then we output 5000.0.

          This is the maximum.

        Therefore, the algorithm is:

          Steps:

            for i in range(N):
                L, W = map(int, input().split())
                long_i = max(L, W)
                short_i = min(L, W)
                # store in list: lands.append( (long_i, short_i) )

            candidate_one = 0
            for (long_i, short_i) in lands:
                product = long_i * short_i
                if product > candidate_one:
                    candidate_one = product

            # candidate_one is the maximum product for the same land (then divided by 2)

            # Now compute candidate_two for two different lands.

            # Sort lands by long_i descending
            lands.sort(key=lambda x: x[0], reverse=True)

            candidate_two = 0
            max_short = 0   # will store the maximum short_i encountered so far

            for (long_i, short_i) in lands:
                if max_short != 0:   # we have at least one land processed
                    # temp = min(short_i, max_short)
                    temp = short_i
                    if max_short < temp:
                        temp = max_short
                    # Now T = min(long_i, temp)
                    T = long_i
                    if temp < T:
                        T = temp
                    candidate_ij = long_i * T
                    if candidate_ij > candidate_two:
                        candidate_two = candidate_ij

                if short_i > max_short:
                    max_short = short_i

            # Then compare:
            if candidate_one >= 2 * candidate_two:
                if candidate_one % 2 == 0:
                    print("%lld.0" % (candidate_one // 2))
                else:
                    print("%lld.5" % (candidate_one // 2))
            else:
                print("%lld.0" % candidate_two)

        But note: in the inner loop, we did:

            temp = min(short_i, max_short)

            T = min(long_i, temp)

            candidate_ij = long_i * T

          We can also write:

            candidate_ij = long_i * min( long_i, min(short_i, max_short) )

        This is the same as above.

        Let's test with the sample: land1: (5,5) and land2: (4,3) -> 
            lands sorted: [ (5,5), (4,3) ]

            land1: skip candidate_ij, then max_short=5.
            land2: 
                temp = min(3,5)=3
                T = min(4,3)=3
                candidate_ij=4*3=12.

        Correct.

        We'll run the sample: two lands: (2,5) and (4,3) -> normalized: (5,2) and (4,3)

            lands sorted: (5,2) and then (4,3)

            land1: skip, max_short=2.
            land2: 
                temp = min(3,2)=2
                T = min(4,2)=2
                candidate_ij=4*2=8.

        Correct.

        Therefore, we are done.

        However, note: the problem has 100000 lands -> the sort is O(n log n) and the loop is O(n). 

        This is acceptable.

        Code in C++? But the problem asks for an editorial without code. But we have the plan.

        Summary:

          The solution involves two options: building both on one land or one building per land.

          Option 1: For each land i, the maximum building area we can build (for one building) is (long_i * short_i) / 2.

          Option 2: For two different lands i and j, the maximum building area we can build (for one building) is: 
                    candidate_ij = min(long_i, long_j) * min( long_i, long_j, short_i, short_j )

          To compute the maximum candidate_ij over all pairs, we sort the lands by long_i in descending order and then traverse, maintaining the maximum short_i seen so far. For each land i, we compute:

                candidate_ij = long_i * min( long_i, min(short_i, max_short) )

          and update the global candidate_two as the maximum candidate_ij.

          Then the answer is the maximum between candidate_one (which is the maximum (long_i*short_i)/2) and candidate_two (the maximum candidate_ij).

          But note: we compare candidate_one and candidate_two by: 
                if candidate_one (which is the product) >= 2 * candidate_two, then we output candidate_one/2 (with one decimal: either integer.0 or half-integer.5), 
                else we output candidate_two (as integer.0).

        This solution runs in O(n log n) and uses O(n) memory.

        Why is it correct? 

          Option 1: For one land, we can build a building of area up to (long_i*short_i)/2, as shown by setting the building to use the entire land (with one dimension doubled).

          Option 2: For two lands, we derived the constraint and the maximum building area. And we computed the maximum over all pairs by a sweep that efficiently finds the best partner for each land.

        We have tested with the sample cases.

        Therefore, the editorial is as above.