 We are given: 
   N, Q: size of grid and number of queries
   Array R of N integers, and array C of N integers.
   The grid cell (i, j) = R[i] + C[j] (0-indexed).

 Important: 
   The cell (i, j) is even if and only if (R[i] % 2) == (C[j] % 2). 
   Therefore, we can partition the grid into two types:
      Type0: (even, even) -> even number
      Type1: (odd, odd)   -> even number (because odd+odd = even)

   Note: The problem states that the start and end cells are even, so they must be either Type0 or Type1.

 However, note that there are two other cases: (even, odd) and (odd, even) which are odd. 
   But the problem guarantees that the start and end are even, so we don't have to worry about those.

 How to determine connectivity?
   We can move from (i, j) to adjacent cells (up, down, left, right) only if the adjacent cell is even and of the same type? 
   Actually, note: 
        Adjacent cell (i+1, j): 
          value = R[i+1] + C[j]
          This is even if and only if (R[i+1] % 2) == (C[j] % 2).

   But our current cell (i, j) is even: so (R[i] % 2) == (C[j] % 2). 
        Therefore, for (i+1, j) to be even: 
          we require (R[i+1] % 2) == (C[j] % 2) = (R[i] % 2)   [if our current is Type0: then R[i] is even, so we require R[i+1] even?]

   Actually, let the current cell (i, j) be Type0: then R[i] even and C[j] even.
        Then the cell (i+1, j) is even if and only if R[i+1] is even (so that R[i+1] % 2 == 0 == C[j] % 2) -> Type0.

        Similarly, if the current cell is Type1: then R[i] odd and C[j] odd.
        Then the cell (i+1, j) is even if and only if R[i+1] is odd (so that R[i+1] % 2 == 1 == C[j] % 2) -> Type1.

   Therefore, we can only move to adjacent cells that are of the same type as the current cell.

   Thus, the entire grid is partitioned into two disconnected graphs: one for Type0 and one for Type1.

   But are all Type0 cells connected? Not necessarily. Consider:

        R: [0, 2, 1, 3] -> parities: [0,0,1,1] for rows
        C: [0, 2, 1, 3] -> parities: [0,0,1,1] for columns

        The Type0 cells: rows 0 and 1 (even rows) and columns 0 and 1 (even columns) -> this forms a connected block?
        Actually, we can move: 
          (0,0) -> (0,1) -> (1,1) -> (1,0) -> ... so yes, within the rectangle [rows0] x [cols0] we can move arbitrarily.

        However, what if the even rows are not consecutive? 
        Example: R: [0, 1, 0] -> parities: [0,1,0]
                 C: [0, 1, 0] -> parities: [0,1,0]

        Then Type0 cells: 
            row0: (0,0), (0,2) -> but (0,0) cannot go to (0,2) because the middle (0,1) is odd? Actually no: (0,0) can go to (0,1) only if (0,1) is even -> but (0,1) = R[0] + C[1] = 0+1 = 1 (odd) -> not allowed.

        Therefore, we can only move within the same contiguous block of even rows and even columns? 

        Actually, note that movement is only allowed to adjacent cells. So we require that both the row and the column must be in a contiguous segment of the same parity.

        How do we form connected components?

        Consider: 
          We can move from (i, j) to (i, j+1) only if:
            - The current cell is even (so we are in Type0 or Type1) and the next cell must be even and of the same type.
            - For a horizontal move: 
                  current: (i, j) -> Type0: R[i] even, C[j] even.
                  next: (i, j+1): R[i] + C[j+1] -> even only if C[j+1] is even (so same type as current row i?).
            So if the row i is even (Type0 row) then we can only move to columns that are even. Similarly, if the row i is odd (Type1 row) then we can only move to columns that are odd.

        But note: the entire row i must have the same row parity. So in row i, we can only traverse the columns that are of the same parity as the row? And that parity must be the same as the row's parity.

        Therefore, the connectivity for Type0:
          We can travel from (i, j) to (i', j') if:
            - The rows i and i' are in the same contiguous segment of even rows? 
            - The columns j and j' are in the same contiguous segment of even columns?
          Why? Because if we have two consecutive even rows, then we can move vertically: 
                (i, j) -> (i+1, j) is allowed because row i is even and row i+1 is even? 
                But what if row i+1 is even? Then the vertical move: 
                   (i, j): R[i] even, C[j] even -> (i+1, j): R[i+1] even and C[j] even -> even and same type? Actually same type? 
                   Type0: (even, even) -> Type0.

          However, what if there is a gap? 
          Example: 
              R: [0, 0, 1, 0] -> so the even rows are at indices 0,1,3. But rows 1 and 3 are not consecutive. 
              Then we cannot move from row1 to row3? Because we have to go through row2 which is odd -> which would break the even path.

        Similarly for columns.

        Therefore, we can define a connected component for Type0 as:
          It is the set of all cells (i, j) such that:
            - i is in a contiguous segment of even rows that are connected? Actually, we need contiguous even rows that are adjacent? 
            - j is in a contiguous segment of even columns that are adjacent?

        However, note: we can move arbitrarily within a contiguous block of even rows and even columns? 
          How? 
            In a contiguous block of even rows (say rows from a to b, all consecutive) and contiguous block of even columns (columns from c to d, consecutive) we can traverse the entire rectangle? 
          Why? 
            Because we can move freely up/down within the same column (as long as the column is even) and then left/right within the same row (as long as the row is even). 

        But what if the even rows are not consecutive? Then we cannot jump over an odd row. Similarly for columns.

        So the connected component for Type0 is defined by two independent factors:
          - The row must lie in a contiguous segment of even rows? Actually, not exactly: 
            Consider: 
               R: [0, 1, 0] -> rows0: [0,2] -> not contiguous -> so we have two separate row segments: [0] and [2]. 
               Similarly, columns: [0, 1, 0] -> two segments: [0] and [2].
            Then the Type0 cells form two connected components: 
               one for row0 and columns0: { (0,0), (0,2) } -> but wait, (0,0) and (0,2) are in the same row? Then we can move horizontally? 
               However, to move from (0,0) to (0,2) we must pass (0,1) which is not even -> so we cannot. 

            Actually, the row being the same (row0) is contiguous? But the columns are not contiguous: we have columns0 and columns2 -> but they are not adjacent. So we cannot move from (0,0) to (0,2) because the adjacent cell (0,1) is odd? 

        Therefore, we break the row into contiguous segments of consecutive indices that are even? Similarly for columns. Then the connected component is defined by a contiguous segment of rows (even) and a contiguous segment of columns (even) that are connected? Actually, no: we can only move within a fixed contiguous block of rows and a fixed contiguous block of columns? 

        How do we assign a connected component for a cell (i, j) of Type0?
          We need to know:
            - The contiguous segment of even rows that contains row i: meaning we group consecutive even rows? 
            - The contiguous segment of even columns that contains column j.

          Then the entire set of cells in that row segment and that column segment is connected? 
          Actually, no: consider we have a row segment [a, b] and a column segment [c, d]. Then we can travel from any (i, j) to (i', j') if i and i' are in [a,b] and j and j' are in [c,d]? 

          Why? 
            We can move along a row from j to any other column in [c,d] (if they are contiguous? but note: within a contiguous segment of even columns, we can traverse horizontally without leaving the segment). Similarly for rows. And vertically: we can move from row i to row i+1 if they are consecutive and both even -> which they are because the row segment is contiguous.

        But note: what if the row segment [a, b] is contiguous (so consecutive indices) and the column segment [c, d] is contiguous? Then the entire rectangle [a,b] x [c,d] is connected.

        Similarly for Type1: we break rows and columns into contiguous segments of odd rows and odd columns.

        Then, two cells (ra, ca) and (rb, cb) of Type0 are connected if and only if:
          - ra and rb belong to the same contiguous segment of even rows (so the starting index of the segment is the same?).
          - ca and cb belong to the same contiguous segment of even columns.

        Similarly for Type1: same contiguous segment of odd rows and same contiguous segment of odd columns.

 Implementation:

   Precomputation:
     1. Precompute the parities for R and C: r_parity[i] = R[i] % 2, c_parity[j] = C[j] % 2.

     2. For rows (for Type0):
          We want to assign for each row i that is even (r_parity[i]==0) a representative for the contiguous segment it belongs to. We can use the starting index of the segment.

          How: 
            Create an array for row0_group (for even rows) of size n, initialized to -1.
            Traverse i from 0 to n-1:
              if r_parity[i] == 0:
                 if i==0 or r_parity[i-1] != 0: then start a new segment at i, so set row0_group[i] = i, and then for all consecutive even rows, we set row0_group[i] = the start index of the segment.
                 else: row0_group[i] = row0_group[i-1]   (so same segment)

          Similarly for odd rows (Type1) we do the same: row1_group.

     3. For columns: similarly compute col0_group for even columns and col1_group for odd columns.

   For a query (ra, ca, rb, cb) (converted to 0-indexed):

        - If the type of (ra, ca) is not the same as (rb, cb): output "NO".
        - Also, note: the problem guarantees both start and end are even, but we have two types. So we check:
             typeA = (r_parity[ra] == c_parity[ca])? Actually, we know they are even so they must be same. But we can compute the type as r_parity[ra] (which must equal c_parity[ca] because the cell is even). Similarly for (rb, cb): r_parity[rb] must equal c_parity[cb]. 
          However, we must check: if the type of (ra,ca) is not the same as (rb, cb) then "NO". But note: type is defined by the row parity? 
          Actually, the type is the same as the row parity (because the column parity must equal the row parity). So we can use the row parity as the type.

        - Then:
            if type is 0 (even row and even column):
                check if:
                   row0_group[ra] == row0_group[rb]   and   col0_group[ca] == col0_group[cb]
            if type is 1 (odd row and odd column):
                check if:
                   row1_group[ra] == row1_group[rb]   and   col1_group[ca] == col1_group[cb]

        - If both conditions hold, output "YES", else "NO".

   Note: We must ensure that the start and end are of the same type? Actually, if they are both even (as per problem) then they must be either both Type0 or both Type1. But what if one is Type0 and the other Type1? 
          Example: 
            Start: Type0: (ra, ca) -> row even, column even -> even cell.
            End: Type1: (rb, cb) -> row odd, column odd -> even cell.
          Then we output "NO".

        So we do:
          if (r_parity[ra] != r_parity[rb]) OR (r_parity[ra] != c_parity[ca]) OR (r_parity[rb] != c_parity[cb]):
            "NO"

        Actually, we can simplify: 
          The type of the start is defined by r_parity[ra] (which must equal c_parity[ca] because the cell is even). Similarly, the type of the end is r_parity[rb] (which must equal c_parity[cb]).
          Therefore, if the type of the start (r_parity[ra]) is not equal to the type of the end (r_parity[rb]), then we output "NO".

        But note: what if the start cell is not even? The problem guarantees that both start and end are even, so we don't have to check that? However, the problem says: "it is guaranteed that both cell (ra,ca) and (rb,cb) contain even numbers". So we can rely on that.

        Therefore, we can do:

          if r_parity[ra] != r_parity[rb] OR (r_parity[ra] != c_parity[ca]) OR (r_parity[rb] != c_parity[cb]): 
            Actually, the last two conditions are guaranteed? So we don't need to check? But let's be safe: the problem says both cells are even, so we know:

             For (ra, ca): 
                 (R[ra] + C[ca]) % 2 == 0 -> so R[ra] % 2 == C[ca] % 2.
             Similarly for (rb, cb): R[rb] % 2 == C[cb] % 2.

          Therefore, the type of (ra, ca) is r_parity[ra] (which equals c_parity[ca]) and the type of (rb, cb) is r_parity[rb] (which equals c_parity[cb]).

          So if the types (r_parity[ra] and r_parity[rb]) are different, we output "NO".

        Alternatively, we can just check:

          if r_parity[ra] != r_parity[rb]:
             "NO"

          But note: what if the start and end are both Type0 or both Type1? Then we proceed.

        However, what if the start is Type0 and the end is Type0? Then they have the same type? 

        But wait: what if the start is Type0 and the end is Type0? Then r_parity[ra] = 0 and r_parity[rb] = 0 -> same.

        So we only need:

          if r_parity[ra] != r_parity[rb]:
             "NO"

        However, there is a catch: what if the start is Type0 and the end is Type1? Then we output "NO".

        But note: the problem guarantees that both are even, but they can be different types? 
          Actually, the problem does not guarantee they are the same type? 

          Example: 
            Start: (0,0): R[0]=0 (even), C[0]=0 (even) -> even -> Type0.
            End: (1,1): R[1]=1 (odd), C[1]=1 (odd) -> even -> Type1.

          Then we output "NO", which is correct because we cannot traverse from Type0 to Type1.

        Therefore, we must check the types.

        Alternatively, we can also check:

          if (r_parity[ra] != c_parity[ca]) or (r_parity[rb] != c_parity[cb]):
             This should not happen by the guarantee, but if it does, then we output "NO". However, the problem guarantees even numbers so we can skip? But the problem says "both contain even numbers", so we assume they are same parity.

        So in code:

          typeA = r_parity[ra]   (which must equal c_parity[ca])
          typeB = r_parity[rb]   (which must equal c_parity[cb])

          if typeA != typeB:
              out "NO"

          else:
             if typeA == 0:
                 if (row0_group[ra] == row0_group[rb] and col0_group[ca] == col0_group[cb]):
                     "YES"
                 else: "NO"
             else:
                 if (row1_group[ra] == row1_group[rb] and col1_group[ca] == col1_group[cb]):
                     "YES"
                 else: "NO"

   However, note: what if the row segment for ra and rb are the same, but the column segment for ca and cb are different? Then we output "NO".

   This matches our reasoning.

   Let's test with sample input #2:

        Input: 
           3 2
           30 40 49
           15 20 25
           2 2 3 3   -> (1,1) to (2,2)   [0-indexed: ra=1, ca=1; rb=2, cb=2]
           1 2 2 2   -> (0,1) to (1,2)

        Step 1: Compute parities:

          R: [30, 40, 49] -> [30%2=0, 40%2=0, 49%2=1]
          C: [15,20,25] -> [15%2=1, 20%2=0, 25%2=1]

        Step 2: Build the grid:

          (0,0): 30+15=45 -> odd -> not considered? but we only care about even? 
          (0,1): 30+20=50 -> even -> Type0? because row0: 0, col1: 0? -> actually: row0: 0 (even), col1: 20 -> 20%2=0 -> even -> Type0.
          (0,2): 30+25=55 -> odd.

          (1,0): 40+15=55 -> odd.
          (1,1): 40+20=60 -> even -> Type0? row1: 40%2=0 -> even, col1:20%2=0 -> even -> Type0.
          (1,2): 40+25=65 -> odd.

          (2,0): 49+15=64 -> even -> Type1? because row2:49%2=1 (odd), col0:15%2=1 (odd) -> Type1.
          (2,1): 49+20=69 -> odd.
          (2,2): 49+25=74 -> even -> Type1: row2:1, col2:25%2=1 -> Type1.

        Query1: ⟨2,2,3,3⟩ -> 0-indexed: (1,1) to (2,2): 
            (1,1): Type0 -> because row1 (index1) is even -> type0? 
            (2,2): Type1 -> because row2 (index2) is odd -> type1.

            So type0 != type1 -> "NO"

        Query2: ⟨1,2,2,2⟩ -> (0,1) to (1,2): 
            (0,1): Type0? -> row0:0 (even), col1:0 (even) -> Type0.
            (1,2): (1,2) -> row1:0 (even), col2:25%2=1 -> so (0+1) mod2=1 -> odd -> but wait: the value is 65 -> odd -> so not even? 
            Actually, the problem states: "it is guaranteed that both cell (ra,ca) and cell (rb,cb) contain even numbers". 
            But (1,2) is 65 -> odd? 

            However, the input says: 
                 1 2 2 2 -> meaning:
                    ra=1, ca=2 -> row1 (index0: row0, row1, row2) -> so row1 is index1? and ca=2 -> index2? 
                So (1,2) in 0-indexed is (1,2): which is 40+25=65 -> odd -> but the problem guarantees even.

            Let me check the sample input #2 again: 
                 3 2
                 30 40 49
                 15 20 25
                 2 2 3 3   -> this is the first query: which is (2,2) to (3,3) -> in 1-indexed: 
                     row2: R[1] = 40 -> even? 
                     col2: C[1] = 20 -> even -> so (2,2) in 1-indexed is (1,1) in 0-indexed? -> no.

            Actually, the problem says: 
                "Given a tuple ⟨r_a, c_a, r_b, c_b⟩"

            And the input: 
                2 2 3 3: meaning 
                  r_a=2, c_a=2, r_b=3, c_b=3.

            In 0-indexed: 
                  (2,2): becomes (1,1) -> which we computed as (40+20)=60 -> even -> Type0.
                  (3,3): becomes (2,2) -> 49+25=74 -> even -> Type1.

            So the problem guarantee holds: both are even. But they are different types.

            Then the second query: 
                 1 2 2 2: 
                    (1,2) in 1-indexed: row1, col2 -> 0-indexed: (0,1): 30+20=50 -> even -> Type0.
                    (2,2) in 1-indexed: row2, col2 -> 0-indexed: (1,1): 40+20=60 -> even -> Type0.

            So the second query: both Type0.

            Now, we need to check the connectivity for Type0:

            Precompute row0_group for rows (Type0: even rows):
                R: [30,40,49] -> parities: [0,0,1]
                row0_group[0] = 0 (since i=0 and it's even -> new segment at 0)
                row0_group[1] = ? 
                   i=1: r_parity[1]=0 -> and previous r_parity[0]=0 -> so same segment -> row0_group[1]=0 (the start of the segment for row0 is 0)
                row0_group[2] = not even -> skip.

                So for row0: 
                    row0_group[0]=0, row0_group[1]=0.

            Precompute col0_group for columns (Type0: even columns):
                C: [15,20,25] -> parities: [1,0,1]
                col0_group[0]: odd -> skip.
                col0_group[1]: even -> new segment at 1? 
                col0_group[2]: odd -> skip.

                So col0_group: 
                    index0: skipped -> we don't care? Actually, we only store for even columns? 
                    index1: col0_group[1]=1 (since it starts at 1).

            Now, for the second query: 
                (0,1) -> row0:0 -> row0_group[0]=0, col1:1 -> col0_group[1]=1.
                (1,1) -> row1:1 -> row0_group[1]=0, col1:1 -> col0_group[1]=1.

                Therefore, row0_group[0] == row0_group[1] (0==0) and col0_group[1] for both is 1 -> same -> "YES".

            But the sample output for the second query is "YES", and the first query is "NO", which matches.

        Therefore, we code accordingly.

        However, note: in the column grouping, we only group the even columns. But in the grid, a column might be even at index j, but we don't care about the odd ones. And we assign for each even column j the starting index of the contiguous segment of even columns that contains j.

        How to compute contiguous segments for columns? 
          We traverse j from 0 to n-1:
            if c_parity[j] == 0: 
               if j==0 or c_parity[j-1]!=0: then current_start = j, and set col0_group[j]=j.
               else: col0_group[j] = current_start   (which is the same as col0_group[j-1]? but we stored the start at j-1? Actually, we can do:

          We can do:

            current_start = -1
            for j in range(n):
               if c_parity[j] == 0:
                  if j==0 or c_parity[j-1]!=0:
                     current_start = j
                  col0_group[j] = current_start
               # else: we don't set for odd? we don't care.

        Similarly for row1_group and col1_group.

        We note: the arrays row0_group, row1_group, col0_group, col1_group are only defined for indices that are of that parity? Actually, we set for even rows and odd rows? But we are going to use them only for the rows that are even (for Type0) and for Type1 we use the odd ones? 

        However, in the query we are only looking at the row and column if they are of the correct type. But what if we try to access row0_group for an odd row? Then we did not set it? 

        In our precomputation, we set:
          For row0_group: for even rows we set the group start, and for odd rows we leave it as -1 (or uninitialized). But we initialize the entire array to -1.

        Then when we get a row that is odd and we try to use it for Type0? We don't. Because if the cell is Type0, then the row must be even -> so we will use row0_group for that row. Similarly, for Type1 we use row1_group.

        But what if we have a row that is even, but we did not set row0_group? We set it. Similarly for odd.

        However, note: we are traversing the row array and setting for every even row. So every even row will have a non -1 value? 

        But what if the row is even? Then we set row0_group[i] to the start of the segment. Similarly for odd rows: we set row1_group[i] for every odd row.

        So we are safe.

        Code structure:

          Read n, q
          R = list of n integers
          C = list of n integers

          r_parity = [x%2 for x in R]
          c_parity = [x%2 for x in C]

          row0_group = [-1] * n   # for even rows: we will set the start index of the contiguous segment for each even row.
          row1_group = [-1] * n   # for odd rows

          # for rows: 
          current_start = -1
          for i in range(n):
             if r_parity[i] == 0:
                 if i==0 or r_parity[i-1] != 0:
                     current_start = i
                 row0_group[i] = current_start
             else:
                 if i==0 or r_parity[i-1] != 1:
                     current_start = i
                 row1_group[i] = current_start

          Similarly for columns: 
          col0_group = [-1] * n
          col1_group = [-1] * n
          current_start = -1
          for j in range(n):
             if c_parity[j] == 0:
                 if j==0 or c_parity[j-1] != 0:
                     current_start = j
                 col0_group[j] = current_start
             else:
                 if j==0 or c_parity[j-1] != 1:
                     current_start = j
                 col1_group[j] = current_start

        Then process queries.

        Complexity: O(n) for precomputation and O(q) for queries -> total O(n+q).

        This fits the constraints: n, q up to 100,000.

        Let's code accordingly.

        Note: the problem uses 1-indexed indices for input. We convert to 0-indexed.

        Edge: 
          We assume the contiguous segment grouping: 
             For even rows: [0,1] as one segment? 
                 indices: i0:0 -> even -> start=0 -> row0_group[0]=0
                         i1:1 -> even and previous was even -> so row0_group[1]=0.

          Then two rows in the same segment: row0_group[0]==row0_group[1] -> 0==0 -> same.

        So it works.

        Let's test with the sample input #1:

          Input: 
             5 3
             6 2 7 8 3
             3 4 8 5 1

          Compute parities:

            R: [6,2,7,8,3] -> 
                6%2=0, 2%2=0, 7%2=1, 8%2=0, 3%2=1.
            C: [3,4,8,5,1] -> 
                3%2=1, 4%2=0, 8%2=0, 5%2=1, 1%2=1.

          Precompute row0_group (even rows):
            i0: 0 -> r_parity[0]=0 -> new segment? (i==0) -> current_start=0 -> row0_group[0]=0.
            i1: 1 -> r_parity[1]=0 -> and previous was 0 -> so current_start remains 0 -> row0_group[1]=0.
            i2: 2 -> odd -> set row1_group: 
                  if i2==0? no, and previous (i1) was 0 (which is not 1) -> so new segment? 
                  Actually, condition: if i==0 or r_parity[i-1] != 1 -> here i=2: r_parity[1]=0 !=1 -> so new segment: current_start=2 -> row1_group[2]=2.
            i3: 3 -> r_parity[3]=0 -> even -> 
                  condition: i3==0? no, and r_parity[2]=1 !=0 -> so new segment: current_start=3 -> row0_group[3]=3.
            i4: 4 -> odd -> 
                  condition: if i==0? no, and r_parity[3]=0 !=1 -> so new segment: current_start=4 -> row1_group[4]=4.

          Precompute col0_group (even columns) and col1_group (odd columns) for columns:

            j0: 3%2=1 -> odd -> 
                  condition for odd: 
                     j0==0 -> true: so current_start=0 -> col1_group[0]=0.
            j1: 4%2=0 -> even -> 
                  condition: j1==0? no, and c_parity[0]=1 !=0 -> so new segment: col0_group[1]=1.
            j2: 8%2=0 -> even -> 
                  previous was even? j1 was even -> so col0_group[2]=1 (the start of the segment at j1).
            j3: 5%2=1 -> odd -> 
                  condition: j3==0? no, and c_parity[2]=0 !=1 -> so new segment: col1_group[3]=3.
            j4: 1%2=1 -> odd -> 
                  previous was odd? j3 was odd -> so col1_group[4]=3.

          Now, queries:

            Query1: "2 2 1 3" -> (1,1) to (0,2) in 0-indexed.

                (1,1): 
                  row1: index1 -> r_parity[1]=0 -> Type0.
                  col1: index1 -> c_parity[1]=0 -> even -> so Type0? yes.
                  row0_group[1]=0, col0_group[1]=1.

                (0,2): 
                  row0: index0 -> r_parity[0]=0 -> Type0.
                  col2: index2 -> c_parity[2]=0 -> even -> Type0.
                  row0_group[0]=0, col0_group[2]=1.

                So both have row0_group = 0 and col0_group = 1 -> "YES".

            Query2: "4 2 4 3" -> (3,1) to (3,2) in 0-indexed.

                (3,1): 
                   row3: r_parity[3]=0 -> Type0.
                   col1: c_parity[1]=0 -> Type0.
                   row0_group[3]=3, col0_group[1]=1.

                (3,2): 
                   row3: 0 -> row0_group[3]=3
                   col2: 0 -> col0_group[2]=1.

                So same row group (3) and same column group (1) -> "YES".

            Query3: "5 1 3 4" -> (4,0) to (2,3) in 0-indexed.

                (4,0): 
                   row4: r_parity[4]=1 -> Type1.
                   col0: c_parity[0]=1 -> Type1.
                   row1_group[4]=4, col1_group[0]=0.

                (2,3): 
                   row2: r_parity[2]=1 -> Type1.
                   col3: c_parity[3]=1 -> Type1.
                   row1_group[2]=2, col1_group[3]=3.

                So row groups: 4 vs 2 -> different -> "NO".

          This matches the sample.

        Therefore, we code accordingly.

        Note: The problem guarantees the start and end are even, so we don't have to worry about the cell being even? But we are using the row and column parities to determine the type, and we know the cell is even so the row and column parities must be equal.

        However, we might get a row that is even and a column that is odd? Then the cell would be odd? But the problem guarantees even. So we can assume that for the start and end:
             r_parity[ra] == c_parity[ca] 
             and 
             r_parity[rb] == c_parity[cb]

        But if the problem guarantee holds, then we don't need to check. However, to be safe, we can check:

          if (r_parity[ra] != c_parity[ca]) or (r_parity[rb] != c_parity[cb]):
             then "NO"

        However, the problem says: "it is guaranteed that both cell (ra,ca) and (rb,cb) contain even numbers", so we can skip? 

        But what if the input violates that? Then we output "NO". It's safe.

        Alternatively, we can do:

          if r_parity[ra] != c_parity[ca] or r_parity[rb] != c_parity[cb] or r_parity[ra] != r_parity[rb]:
             "NO"

        But note: if the start cell is not even, then we output "NO", which is acceptable.

        However, the problem guarantee says they are even, so we might skip the extra checks to save time? 

        But the problem says: "it is guaranteed", so we can assume they are even. 

        But let me check: the problem says: 
            "It is guaranteed that (ra, ca) and (rb, cb) are two different cells in the maze and both of them contain even numbers."

        So we can skip the extra checks? 

        However, the sample input #2 query1: we have to output "NO" because the types are different? and we do that by comparing r_parity[ra] and r_parity[rb]. 

        But if we skip the check for the cell being even, we might miss a case where the start is even but the end is not? But the guarantee says both are even.

        Therefore, we can just compare the types of the two cells by their row parities? 

        Actually, the problem says: 
            "both of them contain even numbers"

        So we know: 
            r_parity[ra] == c_parity[ca]   and   r_parity[rb] == c_parity[cb]

        Then if the row parities of ra and rb are the same, then the entire type is the same. 

        Therefore, we can do:

          if r_parity[ra] != r_parity[rb]:
             "NO"

          else:
             if r_parity[ra] == 0:
                 check row0_group and col0_group
             else:
                 check row1_group and col1_group

        But note: what if the start cell has r_parity[ra] != c_parity[ca]? Then the problem guarantee is broken. 

        Since the problem guarantee says both cells are even, we assume they are. 

        However, in competitive programming, we should not trust the input? But the problem says guaranteed. 

        But if we want to be safe, we can do:

          if r_parity[ra] != c_parity[ca] or r_parity[rb] != c_parity[cb]:
             "NO"

          else if r_parity[ra] != r_parity[rb]:
             "NO"

          else:
             ... 

        It's two extra comparisons per query, which is acceptable.

        Alternatively, we can skip the two extra comparisons and rely on the guarantee? 

        Since the problem says guaranteed, we skip.

        So we do:

          if r_parity[ra] != r_parity[rb]:
             out_lines.append("NO")
          else:
             if r_parity[ra] == 0:
                 if row0_group[ra] == row0_group[rb] and col0_group[ca] == col0_group[cb]:
                     "YES"
                 else:
                     "NO"
             else:
                 if row1_group[ra] == row1_group[rb] and col1_group[ca] == col1_group[cb]:
                     "YES"
                 else:
                     "NO"

        This is acceptable.

        Let's code accordingly.

        Important: We use 0-indexed arrays.

        We note: the arrays for groups (row0_group, etc) are computed for all indices, but we only use the groups for the rows and columns that are of the correct type? 

        But if the row is even, we have set row0_group for that row? Yes. Similarly for odd.

        However, what if a row is even? Then row0_group[i] is set to the start of the contiguous segment. Similarly for odd: row1_group[i] is set.

        But what if we use row0_group for an odd row? Then we get -1? 

        In the query, if the cell is Type0, then the row must be even -> so we use row0_group[ra] and that row index was set (to the segment start). Similarly, if Type1, we use row1_group.

        So we are safe.

        Code:

          We'll use C++ for speed.

          Steps:

            Read n, q.
            Read R[0..n-1] and C[0..n-1].

            Precompute r_parity: for i in range(n): r_parity[i] = R[i] % 2;
            Similarly for c_parity.

            Precompute row0_group, row1_group: arrays of integers of size n, initialized to -1.
            Precompute col0_group, col1_group: same.

            Then preprocess rows:

              int current_start = -1;
              for (int i=0; i<n; i++) {
                 if (r_parity[i] == 0) {
                    if (i==0 || r_parity[i-1] != 0) {
                         current_start = i;
                    }
                    row0_group[i] = current_start;
                 } else {
                    if (i==0 || r_parity[i-1] != 1) {
                         current_start = i;
                    }
                    row1_group[i] = current_start;
                 }
              }

            Similarly for columns:

              current_start = -1;
              for (int j=0; j<n; j++) {
                 if (c_parity[j] == 0) {
                    if (j==0 || c_parity[j-1] != 0) {
                         current_start = j;
                    }
                    col0_group[j] = current_start;
                 } else {
                    if (j==0 || c_parity[j-1] != 1) {
                         current_start = j;
                    }
                    col1_group[j] = current_start;
                 }
              }

            Then for each query:

               int ra, ca, rb, cb;
               // read and convert to 0-indexed: 
               ra--; ca--; rb--; cb--;

               if (r_parity[ra] != r_parity[rb]) {
                   cout << "NO\n";
               } else {
                   if (r_parity[ra] == 0) {
                       if (row0_group[ra] == row0_group[rb] && col0_group[ca] == col0_group[cb]) {
                           cout << "YES\n";
                       } else {
                           cout << "NO\n";
                       }
                   } else {
                       if (row1_group[ra] == row1_group[rb] && col1_group[ca] == col1_group[cb]) {
                           cout << "YES\n";
                       } else {
                           cout << "NO\n";
                       }
                   }
               }

        We use fast I/O for C++ since n,q can be 100,000.

        Let me write the complete C++ code accordingly.

        Note: We must be cautious with the grouping: 
            In the row grouping, we set the group for even rows to the starting index of the contiguous even segment? 
            And similarly for odd.

        This approach should be correct.

        Let me run the sample input #2 again:

          R: [30,40,49] -> parities: [0,0,1]
          C: [15,20,25] -> parities: [1,0,1]

          row0_group: 
             i0:0 -> even -> current_start=0 -> row0_group[0]=0.
             i1:0 -> even -> current_start unchanged -> row0_group[1]=0.
             i2:1 -> odd -> current_start=2 -> row1_group[2]=2.

          row1_group: for i0: skipped? for i1: skipped? for i2: set to 2.

          col0_group:
             j0: odd -> set col1_group[0]=0? 
                 Actually: 
                    j0: odd -> condition: j0==0 -> true -> set col1_group[0]=0.
             j1: even -> condition: j1==0? no, and j0 was odd -> so set col0_group[1]=1.
             j2: odd -> condition: j2==0? no, and j1 was even -> so set col1_group[2]=2? 
                 But condition for odd: if (j==0 || c_parity[j-1]!=1) -> 
                    j2: j-1=j1 -> c_parity[1]=0 !=1 -> so set current_start=2 -> col1_group[2]=2.

          Then query1: (1,1) to (2,2) -> 0-indexed: (1,1) and (2,2)
            ra=1: r_parity[1]=0 -> Type0 -> but wait, (1,1) in 0-indexed: 
                row1: r_parity[1]=0 -> Type0? 
                col1: c_parity[1]=0 -> even -> so Type0 -> correct? 
                But the problem query1: "2 2 3 3" -> 0-indexed: 
                    ra=2-1=1, ca=2-1=1 -> (1,1) -> Type0? 
                    rb=3-1=2, cb=3-1=2 -> (2,2): 
                         row2: r_parity[2]=1 -> Type1 -> so we compare: 
                         r_parity[1] (0) vs r_parity[2] (1) -> different -> "NO".

          Query2: "1 2 2 2" -> 0-indexed: 
               ra=0, ca=1 -> (0,1): 
                  r_parity[0]=0 -> Type0? 
                  col1: c_parity[1]=0 -> even -> Type0 -> so row0_group[0]=0, col0_group[1]=1.
               rb=1, cb=1 -> (1,1): 
                  r_parity[1]=0 -> Type0? 
                  row0_group[1]=0, col0_group[1]=1.
               -> same -> "YES".

          So it matches.

        We are good.

        Code in C++:

          We use scanf/printf for fast I/O.

          Steps:

            #include <cstdio>
            #include <vector>
            using namespace std;

            int main() {
                int n, q;
                scanf("%d %d", &n, &q);
                vector<int> R(n);
                vector<int> C(n);
                for (int i=0; i<n; i++) {
                    scanf("%d", &R[i]);
                }
                for (int i=0; i<n; i++) {
                    scanf("%d", &C[i]);
                }

                vector<int> r_parity(n);
                vector<int> c_parity(n);
                for (int i=0; i<n; i++) {
                    r_parity[i] = R[i] % 2;
                    c_parity[i] = C[i] % 2;
                }

                vector<int> row0_group(n, -1);
                vector<int> row1_group(n, -1);
                vector<int> col0_group(n, -1);
                vector<int> col1_group(n, -1);

                int current_start = -1;
                for (int i=0; i<n; i++) {
                    if (r_parity[i] == 0) {
                        if (i == 0 || r_parity[i-1] != 0) {
                            current_start = i;
                        }
                        row0_group[i] = current_start;
                    } else {
                        if (i == 0 || r_parity[i-1] != 1) {
                            current_start = i;
                        }
                        row1_group[i] = current_start;
                    }
                }

                current_start = -1;
                for (int j=0; j<n; j++) {
                    if (c_parity[j] == 0) {
                        if (j == 0 || c_parity[j-1] != 0) {
                            current_start = j;
                        }
                        col0_group[j] = current_start;
                    } else {
                        if (j == 0 || c_parity[j-1] != 1) {
                            current_start = j;
                        }
                        col1_group[j] = current_start;
                    }
                }

                while (q--) {
                    int ra, ca, rb, cb;
                    scanf("%d %d %d %d", &ra, &ca, &rb, &cb);
                    ra--; ca--; rb--; cb--;

                    if (r_parity[ra] != r_parity[rb]) {
                        printf("NO\n");
                    } else {
                        if (r_parity[ra] == 0) {
                            if (row0_group[ra] == row0_group[rb] && col0_group[ca] == col0_group[cb]) {
                                printf("YES\n");
                            } else {
                                printf("NO\n");
                            }
                        } else {
                            if (row1_group[ra] == row1_group[rb] && col1_group[ca] == col1_group[cb]) {
                                printf("YES\n");
                            } else {
                                printf("NO\n");
                            }
                        }
                    }
                }

                return 0;
            }

        Let's hope.

        Note: We are using modulo 2: 
            r_parity[i] = R[i] % 2 -> this gives 0 or 1.

        This is the solution.

        We run the provided examples.

        But note: the problem has large constraints: n,q up to 100,000 -> we use vectors and scanf/printf -> it should be efficient.

        Submit.