 We are going to implement the cyclic shift: 
   B[0] = A[1]
   B[1] = A[2]
   ...
   B[N-2] = A[N-1]
   B[N-1] = A[0]

 However, note the sample input: 
   Input:  [1, 3, 2, 4] -> Output: [3, 2, 4, 1] but the sample output is [4,2,3,1] which is different.

 But wait: the sample output provided is [4,2,3,1]. How does that relate?

 Actually, the sample input A = [1,3,2,4] and output B = [4,2,3,1] does not look like a cyclic shift.

 Let's check the difference:

  |1-4| = 3
  |3-2| = 1
  |2-3| = 1
  |4-1| = 3 -> total = 8.

 How can we achieve at least N (which is 4) with a cyclic shift?

 If we do a cyclic shift to the left: 
   B = [3,2,4,1]
   |1-3| = 2
   |3-2| = 1
   |2-4| = 2
   |4-1| = 3 -> total = 8 -> same.

 So both cyclic shifts (to left) and the sample output [4,2,3,1] yield 8.

 However, the sample output is [4,2,3,1] which is actually the reverse of A? Not exactly: 
   A = [1,3,2,4] -> reversing gives [4,2,3,1]. 

 So we can also do: 
   Option 1: Cyclic shift to the left: [A[1], A[2], ..., A[N-1], A[0]]
   Option 2: Reverse the array: [A[N-1], A[N-2], ..., A[0]]

 But note: the problem says any permutation B such that diff(A,B)>=N is acceptable.

 However, we must be cautious: 
   For the sample input [2,1] (N=2):
        Cyclic shift to left: [1,2] -> 
            |2-1| + |1-2| = 1+1 = 2 >= 2 -> valid.
        Reverse: [1,2] -> same.

   But what if we reverse? For A = [1,3,2,4]:
        Reverse: [4,2,3,1] -> which is the sample output.

 How do we compute the difference for reverse?
   For A = [a0, a1, a2, ..., a_{n-1}], reverse is [a_{n-1}, a_{n-2}, ..., a0]
   The difference: 
        |a0 - a_{n-1}| + |a1 - a_{n-2}| + ... 

 However, the problem does not require the maximum difference, only at least N.

 But note: we must be cautious that the reverse might not always work? Actually, the condition is that the sum of absolute differences must be at least N.

 Consider the case when N is even and the array is symmetric? For example, N=4: [1,2,3,4] 
        Reverse: [4,3,2,1]
        diff = |1-4|+|2-3|+|3-2|+|4-1| = 3+1+1+3 = 8 >=4 -> valid.

 Another example: [1,2] -> [2,1]: |1-2|+|2-1| = 1+1 = 2 >=2 -> valid.

 But what about [1,2,3] (N=3)? 
        Reverse: [3,2,1]
        diff = |1-3|+|2-2|+|3-1| = 2+0+2 = 4 >=3 -> valid.

 So both cyclic shift and reverse work.

 However, the problem says: "you can output any of them".

 But note: the problem also says that the maximum difference permutation exists and we can output it. 
 However, we are not required to find the maximum, only at least N.

 We have two simple options: 
   Option 1: Cyclic shift (left by one): 
        B[i] = A[(i+1) % n]

   Option 2: Reverse the array: 
        B[i] = A[n-1-i]

 Why choose one over the other?
   The cyclic shift is very simple and linear.

 However, note the sample input: 
        Input: 4
                1 3 2 4

        Cyclic shift (left): [3,2,4,1] -> which gives 8 as shown above.
        Reverse: [4,2,3,1] -> which is the sample output.

 The problem sample output uses reverse. But the problem also says: "If there is more than one valid solution, you can output any of them."

 But note: the problem also provides a sample input "2" and output "1 2" which is the reverse of [2,1]? Actually the reverse of [2,1] is [1,2] and that is the sample output.

 Therefore, the sample outputs are using the reverse.

 However, the problem statement for the first sample input: 
        Input: 4
                1 3 2 4
        Output: 4 2 3 1

 So to match the sample output, we can do the reverse.

 But wait: the second sample input is:
        Input: 2
                2 1
        Output: 1 2 -> which is the reverse.

 Therefore, we choose to output the reverse of A.

 Why reverse works?
   The sum of absolute differences for the reversed array is:
        S = |A[0] - A[n-1]| + |A[1] - A[n-2]| + ... 

   Since the array A is a permutation, the reversed array is also a permutation.

   We know that for any two distinct numbers x and y, |x-y|>=1. However, the entire sum might be small? Actually, the minimum possible value for the entire sum is not 1 per term? 

   But note: the entire array is a permutation of [1,2,...,n]. The reverse pairs the first element with the last, which are at least (n-1) apart? Not necessarily: for example, if the array is sorted, then the first is 1 and the last is n, so |1-n| = n-1. The next: second and second last: |2 - (n-1)| = n-3? 

   Actually, for a sorted array A = [1,2,...,n]:
        Reverse: [n, n-1, ..., 1]
        Then the differences: 
            |1 - n| = n-1
            |2 - (n-1)| = n-3
            ... 

        The entire sum: 
            = (n-1) + (n-3) + ... 

        How many terms? n/2 terms? Actually, we have n terms? 

        Actually: 
            i from 0 to n-1: term_i = |A[i] - A[n-1-i]| = | (i+1) - (n-i) | = |2*i+1 - n|

        But note: the pairs are independent? Actually, we are breaking the array into pairs? 

        However, if n is even: 
            The sum = (n-1) + (n-3) + ... + 1   [n/2 terms] and then doubled? Actually, each term is the absolute difference for a pair? 

        Actually, the sum is: 
            = (n-1) + (n-3) + ... + (n - (2k-1)) ... until we have n/2 terms? 

        The sequence: n-1, n-3, ... is an arithmetic progression with first term n-1 and last term 1? and number of terms n/2.

        Sum = (n/2) * ( (n-1) + 1 ) / 2? Actually, no: because we are adding n/2 terms? 

        Actually: 
            For n even: 
                Sum = (n-1) + (n-3) + ... + 1 = (n/2) * (n) / 2 = n^2/4.

            For n odd: 
                The middle term becomes |A[mid] - A[mid]| = 0, and the rest form pairs: 
                Sum = (n-1) + (n-3) + ... + 2   (there are (n-1)/2 terms) and then doubled? Actually, the pairs are symmetric? 

        Actually, we don't need the exact maximum. We only need to know that the sum >= n.

        For n>=2: 
            The smallest value of the sum for the reversed array of a sorted array: 
                n=2: 1+? Actually: 
                    A = [1,2] -> reverse=[2,1]: 
                    |1-2| = 1, |2-1| = 1 -> total=2 >=2 -> valid.
                n=3: 
                    A = [1,2,3] -> reverse=[3,2,1]: 
                    |1-3|=2, |2-2|=0, |3-1|=2 -> total=4>=3 -> valid.

        But what if the array is not sorted? 
            The reverse of A is independent of the order? 

        Actually, the array A is arbitrary. The reverse of A is just the array in reverse order.

        The sum: 
            S = sum_{i=0}^{n-1} |A[i] - A[n-1-i]|

        How to bound S? 

        Note: The triangle inequality doesn't give a lower bound? 

        However, we can note that the set of pairs (A[i], A[n-1-i]) for i=0 to floor((n-1)/2) are disjoint and cover all numbers. 

        The minimal absolute difference for any pair is at least 1? Actually, no: if the two numbers are consecutive then the difference is 1. 

        But we have n numbers. The entire sum is the sum of n absolute differences? Actually, we have n terms. However, the pairs are the same as the pairs (i, n-1-i) so we are counting each pair once? 

        Actually, the entire sum is the sum for i from 0 to n-1 of |A[i] - A[n-1-i]|. 

        How to relate this to the condition? 

        Consider: 
          For i=0: |A[0]-A[n-1]| 
          For i=1: |A[1]-A[n-2]|
          ...

        But note that each element appears exactly twice? Actually, each element appears in two terms? No: each element appears exactly once in the entire sum. 

        Actually, each element is subtracted once? The entire expression is a sum of n terms, each term being the absolute difference of two elements. 

        However, we cannot directly bound each term. But note: we know that the array is a permutation of distinct numbers. 

        The key is that the reverse operation is known to be one of the permutations that maximize the difference? Actually, the problem says we don't need the maximum. 

        We only need the condition: S>=n.

        We can argue: 
          The minimal value of S for the reverse of an arbitrary permutation A? 

          Actually, we can have a worst-case: 
            Consider A = [1,2,3,...,n] (sorted) and we have shown that the sum for even n is n^2/4, and for odd n is (n^2-1)/4.

          Since for n>=2, n^2/4 >= n? 
            n^2/4 >= n  => n/4>=1 => n>=4 -> holds for n>=4.
          For n=2: 2^2/4 = 1 -> but wait we computed 2 for n=2? Actually we computed 2 for the entire sum? 

          Actually, for the sorted array:
            n=2: [1,2] -> reverse [2,1]: |1-2|+|2-1|=1+1=2 -> which is 2, and 2>=2 -> holds.
            n=3: 4>=3 -> holds.

          So for sorted array, the reverse gives at least n.

          What about an arbitrary permutation? 

          The reverse operation does not depend on the order of A. The set of pairs is fixed: the pairs are (A[0], A[n-1]), (A[1], A[n-2]), ... 

          The sum is the same as if we had taken the array and then reversed it? 

          Actually, we are taking the array as given and reversing it. The sum is fixed for a given A and its reverse.

          But note: the condition that the array is a permutation of distinct integers from 1 to n. 

          The minimal possible value of the entire sum for the reverse of an arbitrary permutation A might be as low as? 

          Consider: A = [1,2,3,...,n] -> we know the sum is about n^2/4.

          But what if A is arranged in a way that adjacent elements in the original array are adjacent in the reversed array? 

          Actually, we can have a permutation that is a palindrome? 
            Example: A = [1,2,2] -> but distinct, so not possible.

          Since distinct, the minimal absolute difference for a pair might be 1? 

          How many pairs? floor(n/2) pairs? Actually, we have n terms? 

          Actually, the entire sum is the sum over n terms, but the pairs are symmetric: the term for i and the term for n-1-i are the same? 

          Actually, we are summing each pair twice? Not exactly: the pair (i, n-1-i) is the same as (n-1-i, i) and the absolute value is symmetric. 

          But note: the entire sum is defined as the sum over i from 0 to n-1, so each pair (i, j) with j=n-1-i is counted once. 

          So we have exactly n terms? 

          Actually, we have n terms. 

          Now, the minimal possible value of the entire sum for the reverse of a permutation? 

          Example: 
            n=4: 
                A permutation: [1,2,4,3] -> reverse: [3,4,2,1]
                |1-3| = 2
                |2-4| = 2
                |4-2| = 2 -> wait, no: 
                Actually, the array: 
                    i0: A[0]=1, A[3]=3 -> |1-3|=2
                    i1: A[1]=2, A[2]=4 -> |2-4|=2
                    i2: A[2]=4, A[1]=2 -> |4-2|=2   -> but wait, we have already used the pair (1,3) and (2,4). 

          Actually, the reversed array is [3,4,2,1] and we are computing:
                |1-3| = 2
                |2-4| = 2
                |4-2| = 2 -> but then what about the last? 
                |3-1| = 2? 

          But that is not how we defined the reverse: 
                We defined the reverse as: 
                    B[0] = A[3] = 3
                    B[1] = A[2] = 4
                    B[2] = A[1] = 2
                    B[3] = A[0] = 1

          Then the differences: 
                |A[0]-B[0]| = |1-3| = 2
                |A[1]-B[1]| = |2-4| = 2
                |A[2]-B[2]| = |4-2| = 2
                |A[3]-B[3]| = |3-1| = 2
          Total = 8.

          But note: the reversed array is [3,4,2,1] and the original is [1,2,4,3]. 

          Alternatively, we can define the reverse as: 
                B = reverse(A) = [A[n-1], A[n-2], ..., A[0]]

          Then the difference: 
                |A_i - B_i| = |A_i - A_{n-1-i}|

          Now, what if we have a permutation that is symmetric? 
                Example: n=4, A = [1,4,4,1] -> not distinct. 

          Since distinct, the minimal absolute difference between A[i] and A[n-1-i] for each i must be at least 1? 

          However, we have n terms. Then the total sum would be at least n? 

          But note: the same element might appear in two different pairs? 

          Actually, each element appears exactly once as A[i] and once as part of the reverse in the term for the symmetric index? 

          Specifically, for index i, we use A[i] and A[n-1-i]. The entire array is partitioned into pairs? 

          For even n: 
                The array is partitioned into n/2 pairs: (A[0], A[n-1]), (A[1], A[n-2]), ... (A[n/2-1], A[n/2])
          For odd n: 
                The middle element is paired with itself? 

          Then the entire sum is the sum over the pairs? 

          Actually, the term for the middle index in odd n: 
                i = (n-1)/2, then n-1-i = (n-1)/2, so |A[mid]-A[mid]|=0.

          So for odd n, we have (n-1)/2 pairs and one zero. 

          Therefore, the entire sum is the sum of the absolute differences of n/2 pairs (if n even) and (n-1)/2 pairs (if n odd). 

          Since each pair has absolute difference at least 1 (because the numbers are distinct), then:
            If n even: total sum >= (n/2) * 1 * 2? -> wait, no: each pair contributes one absolute difference? Actually, each pair (x,y) gives one term |x-y|, and we have n/2 such terms? 

          But note: the entire expression is the sum of n terms? Actually, no: we have n indices, but each pair is used for two indices? 

          Actually, the entire expression is the sum over i from 0 to n-1 of |A[i]-A[n-1-i]|. 
          For a given pair (i, j) where j = n-1-i, we have two indices: i and j? 
          But note: when we compute for i and for j, we get the same |x-y|? 
          Actually: 
            For index i: |A[i] - A[n-1-i]| = |x-y|
            For index j: |A[j] - A[n-1-j]| = |A[j] - A[i]| = |y-x| = |x-y|
          So each pair is counted twice? 

          Therefore, the entire sum = 2 * (sum over pairs (i, j) with i<j and i+j=n-1 of |A[i]-A[j]|).

          How many pairs? For even n: n/2 pairs? Actually, we have n/2 pairs? 
          Actually, the pairs are: 
            (0, n-1), (1, n-2), ... (n/2-1, n-n/2) = (n/2-1, n/2) -> n/2 pairs.

          Then the entire sum = 2 * (each pair's absolute difference). 

          The minimal absolute difference for a pair is 1? Then the entire sum >= 2 * (n/2) * 1 = n? 

          For odd n: 
            The pairs: (0, n-1), (1, n-2), ... ( (n-3)/2, (n+1)/2 ) -> (n-1)/2 pairs, and the middle term is 0 (so we can ignore).
            Then the entire sum = 2 * (sum of absolute differences for the pairs) >= 2 * ( (n-1)/2 * 1 ) = n-1.

          But we require >=n. For odd n, if n>=2 then n-1 might be less than n? 

          Example: n=3: 
            Minimal possible? 
            We need 2 pairs? Actually, we have (n-1)/2 = 1 pair? and then the entire sum = 2 * (that pair's absolute difference). 
            We require total>=3 -> so 2 * |x|>=3 -> |x|>=1.5 -> so at least 2? 

          But in our example: 
            A = [1,2,3] -> the reverse: [3,2,1] -> 
                |1-3| = 2 (for index0) 
                |2-2| = 0 (for index1)
                |3-1| = 2 (for index2) -> total=4>=3 -> okay.

          But what if we have a permutation for n=3 that minimizes the reverse sum? 
            We want to minimize the entire sum: 
                We have two pairs: (0,2) and (1,1). The term for (1,1) is 0. The term for (0,2) is |A[0]-A[2]|, and then we have to account for both indices? 

          Actually, the entire sum is: 
                index0: |A[0]-A[2]| 
                index1: |A[1]-A[1]| = 0
                index2: |A[2]-A[0]| = |A[0]-A[2]|
                So total = 2 * |A[0]-A[2]|

          Since the array is a permutation of distinct integers from 1 to 3, the pair (A[0],A[2]) must be two distinct numbers. The minimal absolute difference is 1? 
          But if we set A[0]=1, A[2]=2, then |1-2|=1, and the entire sum=2. But 2<3 -> which fails the condition.

          However, we cannot choose A arbitrarily: A is given. 

          The problem: we are given A and we are constructing B as the reverse of A. 

          The condition must hold for every permutation A? 

          So for the given A, we output B = reverse(A). 

          Now, if A = [1,2,3] then we get 4 which is>=3. 

          But if A = [1,2,3] we are forced to use that A. 

          What if A = [1,3,2] for n=3? 
            Reverse: [2,3,1]
            Differences: 
                |1-2|=1
                |3-3|=0
                |2-1|=1
                total = 2 -> which is less than 3 -> not valid.

          Therefore, the reverse does not work for A=[1,3,2]? 

          Let me compute: 
            A = [1,3,2] 
            reverse = [2,3,1] -> 
                |1-2|=1
                |3-3|=0
                |2-1|=1 -> total=2.

          But 2 < 3 -> condition fails.

          Therefore, we cannot simply reverse for any arbitrary permutation? 

          We must reconsider.

          Let me try with the cyclic shift: 
            A = [1,3,2] -> cyclic shift left: [3,2,1]
            Differences: 
                |1-3|=2
                |3-2|=1
                |2-1|=1 -> total=4>=3 -> valid.

          So the cyclic shift works for A=[1,3,2]? 

          And for the sorted array: 
            A = [1,2,3] -> cyclic shift left: [2,3,1]
            Differences: 
                |1-2|=1
                |2-3|=1
                |3-1|=2 -> total=4>=3 -> valid.

          And for n=2: 
            A=[2,1] -> cyclic shift left: [1,2] -> 
                |2-1|=1, |1-2|=1 -> total=2>=2 -> valid.

          How about the sample: 
            A=[1,3,2,4] -> cyclic shift left: [3,2,4,1] -> 
                |1-3|=2
                |3-2|=1
                |2-4|=2
                |4-1|=3 -> total=8>=4 -> valid.

          So cyclic shift left works for the examples.

          Why does cyclic shift work? 
            The entire sum = |A[0]-A[1]| + |A[1]-A[2]| + ... + |A[n-2]-A[n-1]| + |A[n-1]-A[0]|

          This is the total variation of a cycle. Since the array is a permutation of distinct integers, the minimal edge in the cycle (in terms of absolute difference) is at least 1? 

          But the entire sum is the sum of n edges. 

          However, note: the cycle might have small edges? 

          Actually, the entire sum is at least 2*(max - min) because the cycle must go from min to max and then back? 

          More formally, let M = max(A), m = min(A). 
          In the cycle, the maximum element M must have two neighbors: one that is at most M-1 and one that is at most M-1? 

          Actually, the entire cycle must cover the entire range. The sum of absolute differences in a cycle that covers all points is at least 2*(M-m). 

          Since M-m = n-1, then the entire sum is at least 2*(n-1). 

          And for n>=2, 2*(n-1) >= n? 
            2n-2>=n -> n>=2 -> which holds.

          Therefore, the cyclic shift (which forms a cycle: A0->A1, A1->A2, ... A_{n-1}->A0) has total absolute difference at least 2*(n-1) which is >=n for n>=2.

          Therefore, the cyclic shift works for any n>=2.

          And it is easy to compute: 
            B[0] = A[1]
            B[1] = A[2]
            ...
            B[n-2] = A[n-1]
            B[n-1] = A[0]

          This is O(n).

          So we choose cyclic shift.

          But note: the problem sample output for the first sample is [4,2,3,1] which is not the cyclic shift? 
          However, the problem says "any permutation B such that diff(A,B)>=N".

          We can output cyclic shift: [3,2,4,1] for the first sample? 

          But the sample output is [4,2,3,1] and the problem expects that? 

          Actually, the problem states: 
            Sample Input #1: 4
                             1 3 2 4
            Sample Output #1: 4 2 3 1

          So if we output [3,2,4,1] for the first sample, is that acceptable? 
            The problem: "If there is more than one valid solution, you can output any of them."

          However, the sample input #2: 
            2
            2 1
            Output: 1 2

          Our cyclic shift for [2,1] is [1,2] -> which matches.

          But the problem sample output for the first sample is [4,2,3,1]. 

          We must check: does the cyclic shift for the first sample yield [3,2,4,1]? 

          But the problem sample output is [4,2,3,1]. 

          How can we produce [4,2,3,1]? 
            That is the reverse of A? 
            A = [1,3,2,4] -> reverse = [4,2,3,1] -> which is the sample output.

          But we just saw that the reverse of [1,3,2] didn't work? 

          Actually, the reverse of [1,3,2] for n=3: 
                A=[1,3,2] -> reverse = [2,3,1] -> 
                diff = |1-2|+|3-3|+|2-1| = 1+0+1=2 -> which is not >=3.

          Therefore, the reverse does not work in general.

          But note: the problem says the array A is distinct and a permutation. The example [1,3,2] is a permutation. 

          Therefore, we must use the cyclic shift.

          However, the problem sample output for the first sample is the reverse. 

          How did the sample output achieve 8? 
            A = [1,3,2,4] -> B = [4,2,3,1] -> 
                |1-4| = 3
                |3-2| = 1
                |2-3| = 1
                |4-1| = 3 -> total=8.

          And our cyclic shift: 
            [3,2,4,1] -> 
                |1-3| = 2
                |3-2| = 1
                |2-4| = 2
                |4-1| = 3 -> total=8 -> same.

          So both are valid. 

          The problem says: "any permutation". 

          Therefore, we can choose either. But we must be sure that our method works for every permutation.

          Since the cyclic shift has been proven to work for every permutation (because the total sum is at least 2*(n-1) which is >=n for n>=2), we choose cyclic shift.

          However, the problem sample output for the first sample is the reverse. 

          To match the sample output, we might do: 
            For the first sample, we output the reverse? 
            But then for [1,3,2] we must not output the reverse.

          Alternatively, we can output the cyclic shift and hope the judge accepts. 

          The problem: "If there is more than one valid solution, you can output any of them."

          Therefore, we can output the cyclic shift.

          But note: the problem also says: "Darto wants to copy Danangâ€™s homework, but Danang asks Darto to change it up a bit" and then the condition is only diff>=N. 

          So we can output the cyclic shift.

          However, the problem sample input #1 and #2 have specific outputs. 

          Since the problem says "any", we can output the cyclic shift and it will be correct.

          But the sample input #1: 
            Input: 4
                    1 3 2 4
            Our cyclic shift: [3,2,4,1] -> which is not [4,2,3,1]. 

          How about we do a cyclic shift to the right? 
            Then: 
                B[0] = A[n-1] = 4
                B[1] = A[0] = 1
                B[2] = A[1] = 3
                B[3] = A[2] = 2 -> [4,1,3,2] -> 
                |1-4|=3, |3-1|=2, |2-3|=1, |4-2|=2 -> total=8.

          But [4,1,3,2] is not [4,2,3,1].

          Alternatively, we can do: 
            B = [A[n-1]] + [A[0]] then ...? 

          Actually, we can do a cyclic shift to the left for all indices except the last one? 

          How about we swap adjacent elements? 

          Actually, we can do a derangement that maximizes the difference? 

          We are overcomplicating. 

          Since the problem says "any", we output cyclic shift to the left: 
            B[0] = A[1]
            B[1] = A[2]
            ...
            B[n-2] = A[n-1]
            B[n-1] = A[0]

          And for the sample input [1,3,2,4]:
            B = [3,2,4,1] -> which is different from the sample output [4,2,3,1] but still valid.

          The problem sample input #2: 
            Input: 2
                    2 1
            Our cyclic shift: [1,2] -> which matches.

          Therefore, we'll output the cyclic shift to the left.

          But note: the problem sample output for the first sample is [4,2,3,1]. 

          The judge might have multiple outputs. We can output [3,2,4,1] for the first sample and it is acceptable.

          However, the problem statement says: 
            "Sample Output #1: 4 2 3 1"

          And then:

            "Sample Input #1
             2
             2 1
            Sample Output #1
             1 2"

          So the second sample is labeled "Sample Input #1" again? That seems like a typo.

          Actually, the problem says:

            # Sample Input #1
            4
            1 3 2 4

            # Sample Output #1
            4 2 3 1

            # Sample Input #1
            2
            2 1

            # Sample Output #1
            1 2

          This labeling is confusing. But we see two samples.

          We'll do:

            For the first sample: 
                Input: 4
                        1 3 2 4 -> output: [3,2,4,1] -> which is valid.

            For the second sample: 
                Input: 2
                        2 1 -> output: [1,2] -> which matches.

          Therefore, we write the code for cyclic shift to the left.

          However, note: the problem has constraints n up to 100,000.

          Code:

            n = int(input().strip())
            A = list(map(int, input().split()))

            if n == 1:
                print(A[0])
            else:
                # Create B: 
                #   B[0] = A[1]
                #   B[1] = A[2]
                #   ...
                #   B[n-2] = A[n-1]
                #   B[n-1] = A[0]
                B = A[1:]   # from index1 to the end
                B.append(A[0])
                print(" ".join(map(str, B)))

          But wait, the problem sample input #1 (n=4, A=[1,3,2,4]) gives:
                A[1:] = [3,2,4]
                then append A[0]=1 -> [3,2,4,1] -> which is as expected.

          However, the problem sample output is [4,2,3,1] for the first sample. 

          We are not matching the sample output. 

          But the problem says "any permutation" with diff>=N is acceptable.

          But the problem sample outputs are fixed. 

          How do we know the judge isn't checking by matching the sample output? 

          The problem: "If there is more than one valid solution, you can output any of them."

          Therefore, the judge must accept [3,2,4,1] for the first sample.

          However, to be safe, we can try to output the reverse when the reverse is valid? But we saw that the reverse is not always valid.

          Alternatively, we can output the cyclic shift to the right? 
            That is: 
                B[0] = A[n-1]
                B[1] = A[0]
                B[2] = A[1]
                ... 
                B[n-1] = A[n-2]

          Then for the first sample: 
                A = [1,3,2,4] -> 
                B = [4, 1, 3, 2] -> 
                |1-4|=3, |3-1|=2, |2-3|=1, |4-2|=2 -> total=8 -> valid.

          But still not [4,2,3,1].

          How is [4,2,3,1] built? 
            It swaps the first and last, and also swaps the second and third? Actually, it is the reverse: 
                Reverse of [1,3,2,4] is [4,2,3,1].

          But we saw that the reverse for [1,3,2] (n=3) fails. 

          However, for the first sample (n=4) the reverse works. 

          How about we do: 
            If n is even, we can reverse? 
            But the reverse for n=3 (odd) failed in the example [1,3,2]. 

          Actually, the reverse for n=3: 
            We proved that the entire sum = 2 * |A[0]-A[2]|. 
            For A=[1,3,2]: |1-2|=1 -> so the entire sum=2, which is less than 3.

          Therefore, the reverse fails for some permutations when n is odd.

          But note: the reverse of A=[1,2,3] for n=3: 
                |1-3| = 2 (at index0) 
                |2-2| = 0 (index1)
                |3-1| = 2 (index2) -> total=4>=3 -> works.

          Why did [1,3,2] fail? 
            Because the two ends were 1 and 2, which are adjacent? 

          The minimal entire sum for the reverse of an odd-length permutation is 2 * (minimal absolute difference for the pair (A[0],A[n-1])). 

          The minimal absolute difference for distinct integers is 1, so the entire sum is 2. For n=3, 2<3 -> fails.

          Therefore, we cannot use reverse for odd n? 

          But we can use reverse for even n? 
            For even n: the entire sum = 2 * (sum of absolute differences for each pair) and the minimal entire sum is 2 * (number of pairs) = 2*(n/2) = n? 
            Actually, each pair must have absolute difference at least 1, so the sum of the absolute differences for the pairs is at least n/2? 
            Then the entire sum = 2 * (that sum) is at least 2*(n/2)=n.

          Therefore, for even n, the reverse has entire sum at least n.

          For odd n: 
            entire sum = 2 * (sum of absolute differences for the pairs) -> and there are (n-1)/2 pairs, so the entire sum >= 2 * ( (n-1)/2 ) = n-1, which is not >=n for n>1? 

          Actually, n-1 is not >=n? 

          But wait: we have n-1 pairs? No: for odd n, we have (n-1)/2 pairs? 
            entire sum = 2 * (sum of absolute differences of the pairs) 
            and there are (n-1)/2 pairs, each at least 1 -> entire sum >= 2 * ( (n-1)/2 ) = n-1.

          And n-1 >= n is false for n>1.

          Therefore, we can only use reverse for even n? 

          But what if we have an odd n and a permutation that yields a larger entire sum? 
            The minimal is n-1, which is not enough. So we cannot guarantee that the reverse works for odd n.

          Therefore, we must not use reverse for odd n.

          How about we do: 
            if n is even: output reverse
            if n is odd: output cyclic shift

          Then:
            For the first sample (n=4, even): reverse of [1,3,2,4] = [4,2,3,1] -> matches sample output.
            For the second sample (n=2, even): reverse of [2,1] = [1,2] -> matches.

          For an odd n: 
            Example n=3: 
                A = [1,3,2] -> we output cyclic shift: [3,2,1] -> which is valid (diff=4>=3).
            Example n=3, sorted: [1,2,3] -> cyclic shift: [2,3,1] -> diff: |1-2|+|2-3|+|3-1| = 1+1+2=4>=3 -> valid.

          Therefore, we can do:

            if n % 2 == 0:
                B = reverse of A
            else:
                B = cyclic shift left of A

          But note: the problem says: "any permutation" and both are acceptable.

          However, the sample outputs for even n are the reverse.

          But what if the judge provides an even n and the reverse fails? 
            We proved that for even n, the reverse has entire sum>=n, so it is always valid.

          Why? 
            entire sum = 2 * (sum_{i=0}^{n/2-1} |A[i]-A[n-1-i]|)
            and each term |A[i]-A[n-1-i]|>=1? -> then the entire sum>=2*(n/2)=n.

          But wait: the entire sum is defined as the sum over i from 0 to n-1 of |A[i]-B[i]|, and when we set B=reverse(A), then 
                |A[i]-B[i]| = |A[i]-A[n-1-i]|.

          And then we argued that the entire sum = 2 * (sum of the pairs for i=0 to n/2-1 of |A[i]-A[n-1-i]|) because each pair is counted twice? 

          Actually, that is correct. And each pair has absolute difference>=1? -> the entire sum>=2*(number of pairs) = 2*(n/2)=n.

          Therefore, it is valid.

          But note: the pairs are not independent? We are not summing the pairs once but each element index produces a term. 

          Actually, the entire sum is the sum over i from 0 to n-1 of |A[i]-A[n-1-i]|, and this is exactly twice the sum of the absolute differences for the pairs (for even n) because the array is symmetric: 
                term_i = |A[i]-A[n-1-i]|
                term_{n-1-i} = |A[n-1-i]-A[i]| = |A[i]-A[n-1-i]| = term_i.

          So the entire sum = 2 * (sum_{i=0}^{n/2-1} |A[i]-A[n-1-i]|).

          And since |A[i]-A[n-1-i]|>=1 for each i in [0, n/2-1] (because distinct), then entire sum>=2*(n/2)=n.

          Therefore, for even n, reverse is valid.

          For odd n: we use cyclic shift, which is valid (as proven: entire sum>=2*(n-1)>=n for n>=2).

          Therefore, the code:

            read n and A
            if n==1: output A[0]
            else if n % 2 == 0:
                B = reverse of A
            else:
                B = cyclic shift left of A

          Let's test:

            Sample 1: n=4, even: 
                A = [1,3,2,4] -> reverse = [4,2,3,1] -> matches.

            Sample 2: n=2, even: 
                A = [2,1] -> reverse = [1,2] -> matches.

            n=3, odd: 
                A = [1,3,2] -> cyclic shift left = [3,2,1] -> 
                    diff = |1-3|+|3-2|+|2-1| = 2+1+1 = 4>=3 -> valid.

            n=3, sorted: 
                A=[1,2,3] -> cyclic shift left = [2,3,1] -> 
                    diff = |1-2|+|2-3|+|3-1| = 1+1+2=4>=3 -> valid.

          This meets the requirements.

          But note: the problem says n>=2, so we don't need to worry about n=1? 
            However, we included n=1 for safety.

          However, the problem states: 
            "It is guaranteed that all elements in A are distinct."

          And for n=1, the permutation is [1] (if the element is 1) or [x]. 
          Then the only permutation B is [x]. 
          Then diff = |x-x|=0, and we require 0>=1? -> fails.

          But the problem says: 
            "it can be proven that diff(A, B_{max}) >= N for any permutation A and N > 1"

          So n=1 is excluded? 

          The input constraint: "2<=N<=100000", so n>=2.

          Therefore, we can skip the n==1 case.

          Code for C++:

            #include <iostream>
            #include <vector>
            #include <algorithm>
            using namespace std;

            int main() {
                int n;
                cin >> n;
                vector<int> A(n);
                for (int i = 0; i < n; i++) {
                    cin >> A[i];
                }

                if (n % 2 == 0) {
                    reverse(A.begin(), A.end());
                    for (int i = 0; i < n; i++) {
                        cout << A[i];
                        if (i < n-1) cout << " ";
                    }
                } else {
                    // Cyclic shift to the left: 
                    // B[0] = A[1], B[1]=A[2], ... B[n-2]=A[n-1], B[n-1]=A[0]
                    for (int i = 1; i < n; i++) {
                        cout << A[i] << " ";
                    }
                    cout << A[0];
                }
                cout << endl;
                return 0;
            }

          However, we can also write without condition for the loop? 

          Alternatively, we can do:

            if (n % 2 == 0) {
                for (int i = n-1; i>=0; i--) {
                    cout << A[i] << (i>0 ? " " : "");
                }
            } else {
                for (int i = 1; i < n; i++) {
                    cout << A[i] << " ";
                }
                cout << A[0];
            }

          But note: the problem n can be 100,000, so we must be careful with output speed.

          We can build a string? But n is 100,000 and integers can be up to 100,000 -> 6 digits per number -> 600,000 characters, which is acceptable.

          However, the problem time is 1s, so we can output directly.

          Alternatively, we can avoid condition in the loop by building a vector B and then output.

          Let me do:

            vector<int> B;
            if (n % 2 == 0) {
                B = vector<int>(A.rbegin(), A.rend());
            } else {
                B.reserve(n);
                for (int i = 1; i < n; i++) {
                    B.push_back(A[i]);
                }
                B.push_back(A[0]);
            }

            for (int i = 0; i < n; i++) {
                cout << B[i];
                if (i < n-1) cout << " ";
            }

          This is clean.

          But note: the reverse for even n: we can simply do:

            reverse(A.begin(), A.end());
            B = A;

          Then output B.

          However, we are modifying A? But we don't need A later.

          So we can do:

            if (n % 2 == 0) {
                reverse(A.begin(), A.end());
            } else {
                // We want to create the shifted vector without using extra space? 
                // We can do: store A[0], then move all the rest down, then put A[0] at the end?
                // But that is O(n). 
                // However, we are going to output anyway, so we can avoid modifying A for the odd case? 

                // Alternatively, we can do:
                //   int first = A[0];
                //   for (int i = 1; i < n; i++) {
                //       cout << A[i] << " ";
                //   }
                //   cout << first;
                // and then return, without building a new vector.

                // Similarly for even: we output in reverse.

                // We do:

                for (int i = n-1; i>=0; i--) {
                    cout << A[i];
                    if (i>0) cout << " ";
                }
                cout << endl;
                return 0;
            }

          Then we output the even case as above? 

          But then the odd case we break the flow.

          Alternatively, we do:

            if (n % 2 == 0) {
                for (int i = n-1; i>=0; i--) {
                    cout << A[i];
                    if (i>0) cout << " ";
                }
            } else {
                for (int i = 1; i < n; i++) {
                    cout << A[i] << " ";
                }
                cout << A[0];
            }

          This avoids building a new vector.

          But note: the problem n=100,000, and we are doing a single loop -> efficient.

          Code:

            #include <iostream>
            #include <vector>
            using namespace std;

            int main() {
                ios::sync_with_stdio(false);
                cin.tie(0);

                int n;
                cin >> n;
                vector<int> A(n);
                for (int i = 0; i < n; i++) {
                    cin >> A[i];
                }

                if (n % 2 == 0) {
                    for (int i = n-1; i >= 0; i--) {
                        cout << A[i];
                        if (i > 0) {
                            cout << " ";
                        }
                    }
                } else {
                    for (int i = 1; i < n; i++) {
                        cout << A[i] << " ";
                    }
                    cout << A[0];
                }
                cout << endl;

                return 0;
            }

          Let's test:

            Even: 
                n=2, A=[2,1] -> output: 
                    i=1: A[1]=1, then output space? no because i>0 -> then next i=0: output A[0]=2, then no space -> "1 2" -> but we want "1 2" -> actually we are outputting from last to first: 
                    i=1: output "1" then space? no because condition: i>0 -> true -> output space? 
                    Then i=0: output "2", then no space.

                So the output is: "1 2" -> correct.

            Odd: 
                n=3, A=[1,3,2] -> 
                    i from 1 to 2: 
                        i=1: output A[1]=3 and a space -> "3 "
                        i=2: output A[2]=2 and a space? -> but then we break the loop and output A[0] -> so "3 2 1" -> but wait, we output: 
                            "3 2" (from the for loop) and then " 1" -> but the for loop at i=2: 
                                we output A[2] = 2 and then a space? -> because i=2>1 -> then we output space? 
                            Then we output A[0]=1 -> so the string is "3 2 1" -> which is correct.

          However, we output a space after the last element of the for loop? 
            In the odd case: 
                for (int i=1; i<n; i++) {
                    cout << A[i] << " ";
                }
                then cout << A[0];

            So for n=3: 
                i=1: output "3 " (with space)
                i=2: output "2 " (with space) -> then we output "1" -> so the entire string: "3 2 1" -> but that has a space between 2 and 1? 

            Actually, no: the for loop runs for i=1 and i=2. 
            After i=2, we output A[0] -> so the output is "3 2 1", meaning there is a space between 2 and 1? 
                Actually: 
                  first: "3 " -> then "2 " -> then "1" -> so the output is "3 2 1", which has two spaces: one between 3 and 2, and one between 2 and 1? 

            But we want: "3 2 1" with spaces only between numbers.

            The problem: "Output in a line N integers (each separated by a single space)"

            So we have: 
                "3<space>2<space>1" -> but the last character is '1', so we have an extra space at the end? 

            Actually, the for loop outputs for i=1: "3 " (with space) and for i=2: "2 " (with space) -> then we output "1", so the entire string: "3 2 1" -> which is "3" space "2" space "1" -> but that has two spaces? 
            Actually, the output: 
                i=1: we output "3" and then a space.
                i=2: we output "2" and then a space.
                then we output "1".

            So the output is: "3 2 1" -> which is three tokens? 
            Actually, the string is: 
                '3', ' ', '2', ' ', '1'

            This is acceptable: the problem says "each separated by a single space". 

            But the problem sample output: 
                Sample Input #1: 4
                                 1 3 2 4
                Sample Output #1: 4 2 3 1

            This output has no trailing space.

            Our output for even: 
                for (int i = n-1; i>=0; i--) {
                    cout << A[i];
                    if (i>0) cout << " ";
                }

            This outputs: 
                for n=4: 
                    i=3: output A[3]=4, and since i>0 -> output space -> "4 "
                    i=2: output A[2]=2, and space -> "4 2 "
                    i=1: output A[1]=3, and space -> "4 2 3 "
                    i=0: output A[0]=1, and then no space -> "4 2 3 1"

            This is correct.

          Therefore, the code is:

            #include <iostream>
            #include <vector>
            using namespace std;

            int main() {
                ios::sync_with_stdio(false);
                cin.tie(0);

                int n;
                cin >> n;
                vector<int> A(n);
                for (int i = 0; i < n; i++) {
                    cin >> A[i];
                }

                if (n % 2 == 0) {
                    for (int i = n-1; i >= 0; i--) {
                        cout << A[i];
                        if (i > 0) {
                            cout << " ";
                        }
                    }
                } else {
                    for (int i = 1; i < n; i++) {
                        cout << A[i] << " ";
                    }
                    cout << A[0];
                }
                cout << endl;
                return 0;
            }

          We'll run the sample inputs:

            Sample1 (even): 
                n=4, A = [1,3,2,4]
                Output: 
                    i=3: A[3]=4 -> output "4" and then space? (i=3>0 -> true) -> output space -> "4 "
                    i=2: A[2]=2 -> "4 2" and space -> "4 2 "
                    i=1: A[1]=3 -> "4 2 3" and space -> "4 2 3 "
                    i=0: A[0]=1 -> "4 2 3 1" and then no space -> "4 2 3 1" -> which matches.

            Sample2 (even): 
                n=2, A=[2,1]
                Output:
                    i=1: A[1]=1 -> output "1" and space? (i=1>0 -> true) -> "1 "
                    i=0: A[0]=2 -> output "2", no space -> "1 2" -> matches.

            Sample3 (odd): 
                n=3, A=[1,3,2]
                Output: 
                    for i=1: A[1]=3 -> output "3 "
                    for i=2: A[2]=2 -> output "2 "
                    then A[0]=1 -> output "1" -> total: "3 2 1"

          This is acceptable.

          However, note: the problem sample output for the first sample (n=4) is "4 2 3 1", which matches.

          Therefore, we submit this.

          But note: what if n=100000? 
            The for loop for even: we traverse from n-1 down to 0 -> 100000 iterations -> acceptable.
            The for loop for odd: we traverse from 1 to n-1 -> 99999 iterations -> acceptable.

          Memory: we only store the vector A -> O(n) -> 100000 integers -> 400,000 bytes -> acceptable.

          Time: O(n) -> acceptable.

          Therefore, the final code.

          One more note: we assume that the vector A is stored and we are only reading.

          We'll write accordingly.

          Let me run the code for the sample that failed with reverse: 
            n=3, A=[1,3,2] -> output: "3 2 1", and the difference is:
                |1-3| = 2
                |3-2| = 1
                |2-1| = 1 -> total=4>=3 -> valid.

          All set.