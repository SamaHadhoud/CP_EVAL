 Okay, let's implement the solution as described in the editorial.

 Steps:
 1. Read n, k, l and the list of happiness ratings.
 2. Sort the array in descending order. But note: we are going to consider the largest k first.
 3. Compute the base sum: the sum of the first k elements (which are the largest k).

 4. We are going to use a max-heap (priority_queue) that holds tuples of:
    (current_sum, i, j, depth)
    However, note: we are going to represent the state as:
        current_sum: the current sum of the configuration.
        i: the index in the initial top k that we are replacing. We start from the last one (so we traverse backwards). Actually, we consider that we have selected indices [0, k-1] initially. Then we consider swapping an element at position `i` (which is in [0, k-1]) with an element at position `j` (which is >= k).
        j: the next unselected element we are going to use (starting from k, then k+1, ...)
        depth: the number of swaps we have done? Actually, the editorial uses depth to represent the number of swaps? But note: the state generation:

        We start by considering swapping each element in the initial set (from the highest index downward) with the first unselected element (at k). Then from a state (s, i, j, depth=1) we can:
          Option 1: replace the same element (that we swapped at i) with the next unselected element (j+1) -> same depth? Actually, depth remains 1? But the editorial says "without increasing the number of swaps". However, the depth in the state is used to know which element we swapped last? Actually, we don't need depth per se.

    Alternative representation (from known similar problems: k-th largest sum of subsequence, or k-th largest sum of combinations):

    Actually, we can use the following:

        We consider the initial set: indices [0, k-1]. Then the next states are generated by swapping one element: for each index i in [0, k-1] and for each j in [k, n-1], we swap H[i] with H[j]. But note: we can do multiple swaps? Actually, the state might represent multiple swaps.

    However, the editorial says: 
        - Option 1: Extend the last swap: from state (s, i, j, depth) we can swap the element at j (which was swapped in) with j+1? Actually, we are replacing the element that we previously swapped at position i? But we want to replace the element that we added at j with j+1? 

    Actually, let's reframe:

        We have an initial set: S0 = {0,1,...,k-1}. The base sum is S = sum(S0).

        Then we consider states (i, j) meaning: we have swapped the element at position i (originally in the set) with the element at position j (originally not in the set). Then the sum becomes: base_sum - H[i] + H[j].

        Then, from a state (i, j), we can generate two moves:
          Move 1: swap the same element i with the next unselected element: (i, j+1) -> if j+1 exists.
          Move 2: swap the next element (i-1) with the same j? Actually, but note: we want to avoid duplicates and ensure we generate all possibilities.

        Actually, we can do:

          From (i, j):
            - If j+1 < n, we can generate (i, j+1)
            - If i-1 >= 0 and j+1 < n, we can generate (i-1, j+1) ??? 

        But wait: the editorial says:

          Option 1: Replace the last added element (which is at j) with j+1 -> that would be (i, j+1) (same i, then j becomes j+1).

          Option 2: If we have swapped only one element so far (depth=1), we can also swap the next element in the initial selection? Actually, the editorial says: "replace the next highest element in the initial selection (i-1) with the next unselected element (j+1)"? 

        Actually, we can do:

          From (i, j), we can generate:
            - (i, j+1): same swap chain? 
            - (i-1, j): but wait, that might be already considered? 

        Alternatively, we can use the following known method:

          We define:
            - The initial state: we start from the base set (the top k). Then we consider swapping the smallest element in the set (which is at position k-1) with the largest element not in the set (which is at position k). But to generate the next largest, we need to consider:

          Actually, a known solution for "k-th largest subsequence sum" is to use:

            Let A be the array sorted in descending order.

            The base state: (0, k, 0) meaning we have taken [0, k-1] and we are going to consider swapping from the last index we swapped? 

          Alternatively, we can use the method from "k-th largest sum of pairs" but extended to k elements.

        Known solution for top l largest k-sums:

          We use a max-heap that stores (current_sum, i, j) where:
            - i: the last index in the initial set that we swapped? Actually, we can represent by (i, j) meaning we have swapped the element at position i (in the initial set) with the element at j (from the unselected) and then we have also swapped all the elements from i+1 to k-1? Actually, no.

        Another known solution: 

          Step 1: sort descending: A[0] >= A[1] >= ... >= A[n-1].

          Base sum: base = sum(A[0:k])

          Then, we consider the following:

          We will have a state: (s, i, j) meaning:
            - We have taken the set: 
                [0, i-1] from the initial top k (without swapping) 
                then we have swapped the element at position i (which was originally in the set) with the element at position j (which is the first unselected element we are adding) 
                and then we have taken the next consecutive unselected elements from j to j + (k - i - 1) ??? 

          Actually, that is complicated.

        Instead, we can use the following method (from known problems: "Kth largest subset sum" or "Kth largest sum of k elements"):

          We note that the top l sums can be generated by a BFS on the state (i, j) meaning that we are considering the set that includes the first i elements (from the sorted array) and we have the last element we took is at position j? 

        However, the known efficient solution for this problem is:

          We sort in descending order.

          We define:
            base = sum of A[0:k]
          Then the next candidate is generated by swapping one element: for each index i in [0, k-1] and j in [k, n-1]:
            candidate = base - A[i] + A[j]

          But then the next candidate after that can be swapping two elements? 

          Actually, we can use:

            We have a state: (i, j) meaning we have swapped the element at position i (in the initial set) with the element at j (from the unselected), and then we can do:

            - Swap another element? 

          How to generate states with multiple swaps? 

          We can represent the state as: (i, j) meaning that we have swapped the element at the initial set at position i (where i is the index in the initial set) and we are now at the unselected element j. Then:

            We can swap the next element in the initial set (i+1) with the next unselected element (j+1) -> but note: we want to avoid duplicates.

          Actually, we can use the following known solution (similar to "Eating Plan" problem):

            Let's define:

              base = sum(A[0:k])

            We push the candidate: base - A[k-1] + A[k]   (swapping the last element in the set with the first unselected)

            Then, we can push:

              candidate1: base - A[i] + A[j] for each i in [0, k-1] and j in [k, n-1]? But that is too many.

          Instead, we use a heap and avoid duplicates.

          Standard solution (from known problems) for k-th largest sum of k elements:

            Sort descending.

            We use a priority queue that holds (sum, i, j) where:
                i: the index in the initial set that we are going to swap next? Actually, we have a fixed set of swaps. 

          Actually, we can use:

            We start by the base state.

            Then we generate:

              For each state, we consider swapping the element that we last swapped with the next unselected element? 

          Known solution:

            We define:

              We have two pointers: the initial set is [0, k-1].

              We consider the following moves:

                We can remove an element from the set and add an element from the unselected? But which ones?

            We can use:

              Let F(i, j) = base - A[i] + A[j] for i in [0, k-1] and j in [k, n-1]. Then the next largest sum after base is the maximum of F(i,j). Then the next is the next maximum.

            But we cannot generate all F(i,j) because there are k*(n-k) which is O(n^2) and n=10^6 -> worst-case 10^12.

          So we use a heap to generate the next largest F(i,j) without enumerating all.

          How?

            We can do:

              For each i in [0, k-1]:
                 candidate_i = base - A[i] + A[k]   (because A[k] is the largest unselected)

              Then we push these k candidates into a max-heap.

              Then we pop the largest candidate. Suppose we pop candidate from index i0. Then we can push the next candidate for that i0: base - A[i0] + A[k+1] (if k+1 exists).

          But then we get the top l sums from this? However, note: we can also swap two elements? 

          Actually, the state (i, j) represents one swap. But what about two swaps? 

          Example: we swap two elements: we remove two from the initial set and add two from the unselected. Then the sum becomes base - A[i] - A[i'] + A[j] + A[j'].

          How to generate states with two swaps? 

          We can do:

            We start by the base.

            Then we generate all one-swap states: (i, k) for i in [0, k-1].

            Then from a one-swap state (i, j) (with j=k, k+1, ...) we can generate a two-swap state by swapping another element? 

          However, the editorial suggests:

            We represent a state by (current_sum, i, j, depth) meaning that we have performed 'depth' swaps? Actually, the depth is the number of swaps? Then:

              depth=1: one swap -> state (base - A[i] + A[j], i, j, 1)

              Then from this state we can:

                Option 1: (depth remains 1) we swap the same element i with the next unselected: so we do: current_sum - A[j] + A[j+1] -> then state (current_sum - A[j] + A[j+1], i, j+1, 1)

                Option 2: (depth becomes 2) we swap the next element (i-1) with the same j? Actually, the editorial says: replace the next element (i-1) with the next unselected element (j+1) -> meaning we do:

                    current_sum - A[i-1] + A[j+1]   -> but note: we have already swapped i? so the set now does not include A[i] but includes A[j]. And we are now swapping A[i-1] (which is still in the set) with A[j+1]? 

          However, we must note: the initial set is sorted descending. After swapping, the set is still sorted? Not necessarily, because we swapped an element at i (which is in the initial set) with an element at j (which is unselected and smaller than A[i]? Actually, we sorted descending: so A[j] <= A[i] (because j>=k and i<k). 

          The editorial representation:

            We have a state: (s, i, j, depth) meaning:

              We have swapped the elements at positions i, i+1, ..., i+depth-1? 

            Actually, no. The editorial says:

              - i: the highest index in the initial selection that was removed? 

              - j: the last added element's index.

            Then from (s, i, j, depth):

              Option 1: replace the element we last added (at j) with the next unselected (j+1): so we get (s - A[j] + A[j+1], i, j+1, depth)

              Option 2: if we have depth swaps, we can also swap the next element (i-1) in the initial selection (which we haven't swapped yet) with the next unselected element (j+1). Then we get (s - A[i-1] + A[j+1], i-1, j+1, depth+1)

          Why is this correct? 

          Example: n=5, k=2, A=[5,4,3,2,1]

          Base: 5+4 = 9.

          Then we push states for swapping the element at index0 (5) with the first unselected (3): state1 = (9-5+3=7, 0, 2, 1)
          and swapping the element at index1 (4) with 3: state2 = (9-4+3=8, 1, 2, 1)

          Then we pop the largest: 8 -> state2. Then from state2:

            Option1: replace the added 3 with the next unselected 2: new state: (8 - 3 + 2 = 7, 1, 3, 1)
            Option2: swap the next element (index0, since the next highest is index0) with the next unselected (which is 2? but we are at j=2, so next unselected is 3? Actually, we are at j=2, so next unselected is j+1=3 -> element 2) -> but wait: the next unselected after j=2 is j+1=3? Then we swap element at index0 (which is still 5) with element at index3? Then we get: 8 - 5 (which is still in the set?) + 2 = 5? 

          But wait: the current set after state2: we swapped index1 (4) with 3 -> the set is {5,3}. Then swapping index0 (5) with 2: we get {2,3} -> sum=5.

          How do we represent this? 

          Actually, the state (8, 1, 2, 1) means:
            - We swapped the element at index1 (which was 4) with the element at index2 (3). Now we have the set: {5,3}. 
            - Then we can swap the element that was originally at index0 (5) with the next unselected (which is index3:2) -> that would be a new swap? So we have two swaps: we swapped index1 and then index0? Then the state should be (8 - 5 + 2 = 5, 0, 3, 2) because we are now swapping the element at index0? 

          But note: the editorial says: "replace the next highest element in the initial selection (i-1)" -> so if we are at state (8,1,2,1), the next element to swap is i-1=0? 

          So the two new states:

            Option1: (7, 1, 3, 1)   -> swap the element we last swapped (which was at index2) with index3: so we remove 3 and add 2 -> set becomes {5,2} -> sum=7.
            Option2: (5, 0, 3, 2)   -> swap the element at index0 (which is 5) with the element at index3 (2) -> set becomes {2,3} -> sum=5.

          Then we also have state1: (7,0,2,1) which we haven't popped. Then we pop the next largest: 7? but which one? 

          Actually, we have two states with 7: (7,1,3,1) and (7,0,2,1). Then we pop one of them.

          From (7,0,2,1): 
            Option1: swap the element we last swapped (index2:3) with next unselected (index3:2) -> (7-3+2=6, 0,3,1)
            Option2: swap the next element (i-1: which is index0-1? but i=0, so i-1=-1 -> invalid) -> so only one option.

          Then from (7,1,3,1) we get:
            Option1: swap element at index3 (2) with index4 (1): (7-2+1=6, 1,4,1)
            Option2: swap the next element (index0) with index4? -> (7 - 5 + 1 = 3, 0,4,2) -> but wait: the current set is {5,2}? then swapping 5 with 1 gives {1,2} -> sum=3.

          Then we have two states with 6: (6,0,3,1) and (6,1,4,1). Then we pop them.

          So the top sums: 9, 8, 7, 7, 6, 6, 5, 3.

          But the sample input: n=4, k=2, [3,2,3,3] -> sorted: [3,3,3,2] -> base=6.

          Then we push:
            state1: swap index0 (3) with index2 (3): sum=6-3+3=6 -> (6,0,2,1)
            state2: swap index1 (3) with index2 (3): sum=6-3+3=6 -> (6,1,2,1)

          Then we pop 6 (state1) -> then we generate:
            Option1: swap index2 (3) with index3 (2): (6-3+2=5, 0,3,1)
            Option2: swap the next element (index0-1 -> index-1? invalid) -> so only one.

          Then we pop 6 (state2) -> then generate:
            Option1: swap index2 (3) with index3 (2): (6-3+2=5, 1,3,1)
            Option2: swap the next element (index0) with index3 (2): (6 - 3 (the one at index0) + 2 = 5, 0,3,2)

          Then we have three states: (5,0,3,1), (5,1,3,1), (5,0,3,2). Then we pop the 5's.

          So the top 6: 6,6,6 (the base and the two swaps that yield 6) and then the three 5's? 

          But the base is 6, and then we popped two 6's? So we output 6 three times? 

          How do we account for the base?

          Actually, the base is the first one. Then we push two states that are 6. Then we pop the base? 

          We must push the base first? 

          Algorithm:

            We start by pushing the base.

            Then we push the initial states: for each i from k-1 down to 0: push (base - A[i] + A[k], i, k, 1)   [note: k is the first unselected index]

            Then we have a heap that initially has the base and then the k states? Actually, we don't push the base as a state? 

          Alternatively:

            We output the base first.

            Then we push the k states (each swapping one element).

            Then we pop the largest from the heap and output it. Then we generate the next states from that popped state.

          But note: the base is the largest. Then the next largest is the maximum of the initial states? So we can do:

            Step1: output base.
            Step2: push the initial states: for i in [0, k-1]: push (base - A[i] + A[k], i, k)

            Then, for the next l-1 outputs, we pop the heap and push the next states.

          However, in the sample: 
            base = 6 -> output 6.
            Then we push two states: (6,0,2) and (6,1,2). Then we pop the next: 6 -> output 6. Then from (6,0,2) we generate:
                Option1: (5,0,3)   -> push
                Option2: (if possible) swap the next element? -> but we don't have depth? 

          How do we avoid duplicates? And how do we represent the state without depth? 

          Actually, the known solution for "k-th largest sum with k elements" (with one swap at a time) is:

            We sort descending: A[0..n-1]
            base = sum(A[0:k])

            We use a max-heap: priority_queue<tuple<sum, i, j>>.

            We also use a visited set? but we cannot use set because l is 10^6.

          Alternatively, we can avoid duplicates by the way we generate states.

          Known solution from other problems (like UVA 11997) is:

            We define:

              Let B[i] = the array of differences: for each j from k to n-1: A[j] - A[i] for a fixed i? 

            Then the problem becomes: find the top l sums from the k arrays: each array i has elements: (A[j] - A[i]) for j from k to n-1. And we are to add base to each? 

          Actually, the candidate for swapping element i with j is: base - A[i] + A[j] = base + (A[j]-A[i])

          Then the problem becomes: we have k sorted arrays (each array for i in [0,k-1] is: [A[k]-A[i], A[k+1]-A[i], ...] and we want the top l values of the form: base + (one element from array0) or base + (one element from array1) ... 

          Then we can use: 

            For each array i, we take the first element: A[k]-A[i] and push (base + (A[k]-A[i]), i, k) into the heap.

            Then we pop the largest. Then from the array i that we popped, we push the next element: base + (A[k+1]-A[i]), i, k+1.

          But note: we can also have two swaps? 

          Actually, this only considers one swap. The problem requires multiple swaps? 

          However, the problem says: the configuration is exactly k objects. We can swap multiple elements? 

          But note: swapping two elements is the same as two independent swaps? 

          Example: swapping element i and i' with j and j'? Then the sum becomes base - A[i] - A[i'] + A[j] + A[j'].

          Then we need to consider two swaps? 

          How do we generate two swaps? 

          We can think of:

            The state with two swaps: we have two independent swaps: one in array i and one in array i'. Then the total difference is (A[j]-A[i]) + (A[j']-A[i']). Then we are looking for the top l values of the form base + (sum of one element from each of the k arrays? but we are not taking one element per array arbitrarily, because we cannot swap the same element twice? 

          Actually, we can swap multiple elements arbitrarily? 

          However, the known solution for this problem (from known contests) is:

            We use a state that is represented by a multiset of swaps? 

          Alternatively, we note that the top l largest sums are generated by at most a few swaps? But l can be 10^6.

          Actually, the known solution (from similar problems) is to use the following:

            We note that the entire set of sums is generated by:

              base + (any linear combination of swaps? but each swap is independent) 

          But the swaps are independent? Actually, no: we cannot swap the same element twice? 

          Actually, we can swap as many as we want? But we must end up with k elements. The initial set is the top k. Then we can swap any subset of the initial set with the unselected set? 

          So the set of chosen indices is:

            Let I be the initial set: [0, k-1].
            Then we choose a subset S of I to swap out, and a subset T of [k, n-1] of the same size to swap in. Then the sum = base - sum_{i in S} A[i] + sum_{j in T} A[j].

          Then the problem becomes: the top l values of base + (sum_T - sum_S) for all pairs of subsets (S,T) with |S|=|T| and S is a subset of [0,k-1] and T is a subset of [k, n-1].

          This is a very general problem and is known to be solved by iterative swapping? 

          However, the editorial says: we use a state (s, i, j, depth) and depth is the number of swaps.

          And the known solution for this problem in C++ (from past problems) is:

            #include <bits/stdc++.h>
            using namespace std;
            typedef long long ll;
            struct State {
                ll sum;
                int i, j;
                bool last; // whether the last operation was a new swap or an extension of the previous swap
                // or we can avoid last? 
            };

            // Alternatively, without last: we use the following generation:

            // We have a state: we have swapped the elements at positions i, i-1, ... down to some point? 
            // Actually, we can use:

            //   We push states: (base - A[i] + A[k], i, k) for each i in [0, k-1]

            //   Then from a state (s, i, j), we can:
            //      - if j+1 < n, push (s - A[j] + A[j+1], i, j+1)   // extend the swap at i to the next unselected
            //      - if i-1>=0, push (s - A[i-1] + A[j], i-1, j)   // but this might be duplicate? 

          Actually, the editorial's method with depth is implemented as:

            struct State {
                ll sum;
                int i, j, depth;
            };

            Then:

              State1: (sum - A[j] + A[j+1], i, j+1, depth)
              State2: (sum - A[i-1] + A[j+1], i-1, j+1, depth+1)

          But note: in state2, we are replacing A[i-1] with A[j+1]. But what is the current set? 

          The current set has already swapped the element at i with j. Then we are swapping the element at i-1 with j+1? 

          How do we know that the element at i-1 is still in the set? 

          We ensure that we only consider i from high to low? 

          Conditions:

            - In the initial state: we consider i from k-1 down to 0? 

          Steps:

            Sort A in descending order.

            base = accumulate(A, A+k, 0LL)

            We push: 
               for i from k-1 down to 0:
                   push (base - A[i] + A[k], i, k, 1)

            Then, we output base as the first largest.

            Then, we have a heap (max-heap by sum).

            Then for l-1 times:

                pop the largest state.

                output its sum.

                Then generate two new states:

                  state1: (s - A[j] + A[j+1], i, j+1, depth)   -> only if j+1 < n
                  state2: (s - A[i-1] + A[j+1], i-1, j+1, depth+1)   -> only if i-1 >= 0 and j+1 < n

            But wait: in state2, we are not using the current j? We are using j+1? 

          Why state2 uses j+1? Because we are adding a new swap: we swap the element at i-1 with the element at j+1? 

          But what about the element at j? It is still in the set? 

          Actually, the set after the current state (s, i, j, depth) is:

            We have swapped the elements at positions: i, i+1, ... ? -> no, only the element at i has been swapped? 

          Actually, the depth=1: only one swap: element i with j.

          Then state2: we want to swap another element: i-1 with j+1? 

          But note: we cannot swap the same j again? We are not removing the element j we added? 

          So the new set: we remove A[i] and A[i-1] and add A[j] and A[j+1]. Then the sum change: 

            current sum = base - A[i] + A[j]
            then we remove A[i-1] and add A[j+1] -> becomes base - A[i] - A[i-1] + A[j] + A[j+1]

            = (base - A[i] + A[j]) - A[i-1] + A[j+1] = s - A[i-1] + A[j+1]

          So it is correct.

          However, we must avoid duplicates? 

          How about two different paths to the same set? 

          Example: swapping i then i-1 vs swapping i-1 then i? 

          But in our state representation, we require that we swap in decreasing order of i? 

          Actually, we are only allowing swaps in decreasing order of i? 

          How: 

            We start by swapping i (from high to low). Then from a state (i, j, depth), we generate:

              state1: (i, j+1) -> same depth: we extend the last swap.

              state2: (i-1, j+1) -> depth+1: we start a new swap at i-1.

          In state2, we are swapping i-1 and j+1? But note: we haven't swapped i-1 before? 

          And we are swapping in decreasing order: we only swap at indices <= i. 

          But is there a possibility to swap i-1 first and then i? 

          In our algorithm, we start with swaps at i (which is from k-1 down to 0). Then from a swap at i, we generate a swap at i-1? But we never go up? 

          So we are only generating states where the swaps are done in decreasing order of i? 

          Therefore, we avoid duplicates: each set of swaps is uniquely represented by the set of indices swapped out? 

          But note: the state (i, j) does not record the entire history, but only the last swap's index and the last added element? 

          Actually, the state (i, j, depth) does not record the entire set of swaps? 

          How do we know which elements have been swapped? 

          We assume that the swaps are done at indices i and then at i-1, etc? 

          But in the state, we only store the last swap's index i and the last added element j? 

          How can we generate state1: extending the last swap? 

          Actually, the state (i, j) represents: we have swapped the element at i with j? And then we can extend by replacing j with j+1? 

          And state2: we have swapped i with j, and then we swap i-1 with j+1? 

          But what if we want to swap i-1 with j first? 

          That state would be generated from the state (i, j) by: we cannot swap i-1 with j? because we are at j and then we are only allowed to swap i-1 with j+1? 

          Actually, the state (i, j) does not allow swapping i-1 with j? because we have already used j? 

          But wait: swapping i-1 with j would require that we have not swapped i with j? 

          How do we generate the state where we swap i-1 with j? 

          We would have generated it from the initial state for i-1: we would have pushed (base - A[i-1] + A[k], i-1, k, 1) at the beginning? 

          Then from that state, we extend j from k to j? 

          So we will eventually get to (i-1, j) by extending? 

          Therefore, our initial push for every i from k-1 down to 0 covers every single swap. Then from a single swap (i, j) we extend to (i, j+1) and also generate a new swap at i-1 with j+1? 

          But the state for (i-1, j) is generated independently from the initial push for i-1? 

          So the algorithm:

            sort(A, A+n, greater<ll>());
            base = accumulate(A, A+k, 0LL);

            // We'll use a max-heap by sum.
            // State: (sum, i, j, depth) but note: depth might be redundant? Actually, we don't use depth in state generation? 
            // But the generation rules depend on depth? Actually, we don't: we always generate two states: one for extending the last swap and one for a new swap? 

            // Actually, depth is not used in the rules? The rules are:
            //   state1: (s - A[j] + A[j+1], i, j+1, ...) -> same depth? But we don't care about depth? 
            //   state2: (s - A[i-1] + A[j+1], i-1, j+1, ...) -> depth+1? 

            // We don't need depth for the state. We only need i and j to generate new states.

            // But we must avoid generating the same state twice? 

            // We can represent state by (i, j) -> but note: two different paths might lead to the same (i, j) with different sums? 

            // Actually, no: the sum is determined: base - (the sum of the A[i]'s swapped out) + (the sum of the A[j]'s swapped in). 

            // But how do we know the entire history? 

            // Actually, we don't: the state (i, j) in the heap might represent different sets of swaps? 

            // Example: we could have swapped i and then i-1 and then extended the swap at i-1 to j, or we could have swapped i-1 and then i and then extended the swap at i to j? 

            // But note: we are always swapping in decreasing order of i? So the only way to have a swap at i-1 is if we have swapped at i first? 

            // Actually, no: we initially push state for i-1: (base - A[i-1] + A[k], i-1, k, 1). Then we extend that state to j? 

            // And the state for swapping i and then i-1 is represented by (i-1, j) but with a different history? 

            // Actually, the state (i-1, j) can be reached by two paths:

            //   Path1: start with i-1 swap at k, then extend to j.
            //   Path2: start with i swap at k, then extend to j, and then do a new swap at i-1? 

            // But wait: in path2, we do:

            //   state0: base
            //   state_i: (base - A[i] + A[k], i, k, 1)
            //   then extend: (base - A[i] + A[k+1], i, k+1, 1) ... until (base - A[i] + A[j], i, j, 1)
            //   then from (i, j, 1): we generate state2: (base - A[i] + A[j] - A[i-1] + A[j+1], i-1, j+1, 2)   -> but then we have not reached (i-1, j) by path2.

            // Actually, we never generate (i-1, j) from a state that started with i? 

            // How would we get (i-1, j) from the state (i, j, 1)? We cannot: because to get (i-1, j) we would need to swap i-1 with j without changing the swap at i? 

            // But that is a single swap: and we have already pushed it initially.

            // Therefore, we don't have duplicates.

            // So we can represent state by (sum, i, j) and we don't need depth? 

            // But the generation rule for state2: we need to know that we are allowed to swap i-1? 

            // Actually, the generation rule:

            //   From a state (i, j): 
            //      Option1: (i, j+1)
            //      Option2: (i-1, j+1)

            // Why do we need depth? 

            // The editorial mentioned depth to control the number of swaps? Actually, we are not controlling by depth, we are using the index i to know the next available swap? 

            // But what if we have swapped more than one element? How do we know which elements have been swapped? 

            // We don't: we rely on the fact that the state (i, j) implies that we have swapped all indices from i to i+depth-1? 

            // Actually, no: the state (i, j) might be the result of one swap? or multiple? 

            // How do we compute the sum? 

            // We are storing the current sum. We don't need to know the entire history to compute the next state? 

            // For Option1: we know we are replacing the last added element j with j+1: so we subtract A[j] and add A[j+1].

            // For Option2: we are swapping a new element at i-1: we subtract A[i-1] and add A[j+1]? 

            // But wait: is A[i-1] still in the set? 

            // In the state (i, j), we have swapped the element at i. The element at i-1 has not been swapped? 

            // Why? Because we only swap in decreasing order of indices? And we start from high indices? 

            // We initially push only swaps at indices i (from k-1 down to 0). Then from a state (i, j) we only generate swaps at i-1? 

            // And we never swap an element that has been swapped? 

            // Therefore, the element at i-1 is still in the set? 

            // But what if we have already swapped i-1? 

            // Actually, we haven't: because we are only swapping indices in decreasing order? We start with the largest index? Then we swap at i, then at i-1? 

            // So if we are at state (i, j), we have swapped at i, but not at i-1? 

            // Therefore, it is safe.

            // However, note: when we do Option2, we are swapping i-1 with j+1, and we are leaving the swap at i as is? 

            // Then the next state will be (i-1, j+1) and we will still have the swap at i? 

            // How do we represent that? 

            // Actually, we don't: we are storing only one swap? 

            // We are storing the last swap's index and the last added element? 

            // But the state (i, j) does not represent the entire set of swaps? 

            // How do we compute the sum for Option2? 

            // The current sum is base - (all the swapped out elements) + (all the swapped in elements). 

            // But we are storing the current sum. Then for Option2, we subtract A[i-1] and add A[j+1] -> that is correct.

            // So we don't need to know the entire history? 

            // Therefore, we can drop the depth.

            // But then how do we know which indices have been swapped? We don't: we rely on the fact that the state (i, j) has been generated by swapping the element at i and then possibly extending to j? and the element at i-1 is still available to swap? 

            // And we ensure that we only generate new swaps at indices less than i? 

            // So the algorithm:

              sort(A, A+n, greater<ll>());
              base = accumulate(A, A+k, 0LL);
              priority_queue<tuple<ll, int, int>> heap; // (sum, i, j) and we use negative for min-heap? -> no, we want max: so we can use (sum) as positive.

              // But the priority_queue in C++ is max-heap by default? and the tuple compares lexicographically: so we want the largest sum first.

              // We push: for i from k-1 down to 0: 
                  heap.push({base - A[i] + A[k], i, k});

              vector<ll> ans;
              ans.push_back(base);   // the largest

              // But note: we are going to output l lines. The first line is base.

              // Then we need to output l-1 more.

              // We also need to avoid duplicates? 

              // We'll use a set to avoid duplicate states? But the state is (i, j). We might get the same state from different paths? 

              // But we argued above: we don't? 

              // However, we can get the same sum from different swaps? 

              // But the state (i,j) is unique: because i and j are indices.

              // So we can avoid duplicates by storing (i,j) in a set? But l can be 10^6, so we can use an unordered_set? But we have to avoid TLE.

              // Alternatively, we note that we generate each state at most once? 

              // How: 

                We start by pushing states for (i, k) for i from k-1 down to 0.

                Then from (i, j) we generate (i, j+1) and (i-1, j+1). 

                And we never push the same (i,j) twice? 

              // So we don't need a visited set? 

              // However, we might generate (i, j) from two different paths? 

              // Example: 
                Path1: from (i, j-1) by Option1 -> (i, j)
                Path2: from (i+1, j-1) by Option2 -> (i, j)

              // But note: we require j-1 and then j, and we generate (i, j) from (i, j-1) and also from (i+1, j-1)? 

              // But the state (i+1, j-1) is a state that we pushed earlier? Then we pop it and generate (i, j) from it? 

              // And then we also generate (i, j) from (i, j-1)? 

              // So we might push (i, j) twice? 

              // We need to avoid duplicate pushes? 

              // How? We can use a visited array? But the state: i in [0, k-1] and j in [k, n-1] -> total states: k*(n-k) which is about 10^6 * 10^6 -> 10^12 -> too many.

              // But we are only generating the top l states? and l<=10^6, so we won't generate more than l states? 

              // Actually, we are going to generate at most l states? 

              // But from each state we generate two new states? So the total states we generate is O(l) -> but we start with k states, then each state we pop we push up to 2? So total states in the heap is at most k + 2*l, which is about 10^6 + 2*10^6 = 3e6? 

              // But wait: we are generating states that might be the same? 

              // We need to avoid pushing the same state twice? 

              // We'll use a visited set? But we cannot store 10^12 states? 

              // Alternatively, we can avoid duplicates by the following:

                The state (i, j) can be generated in two ways? 

                Actually, we generate:

                  (i, j) can only be generated from:

                    Option1: (i, j-1) -> if j>k
                    Option2: (i+1, j-1) -> if j>k and i+1<=k-1

                But we start from (i, k) for each i. Then to get (i, j) for j>k, we have two ways? 

                So we might push (i, j) twice? 

              // We must avoid pushing duplicates to the heap? 

              // We can use a set to mark states? But the state is (i, j). The total distinct states we generate is at most k*(n-k) which is 10^12 -> too many.

              // Therefore, we cannot store a visited set for all states.

          But note: we are only going to generate l states (l<=10^6). However, we generate two children for each state, so the total states we generate might be much more than l? 

          Actually, we only generate at most l states (because we pop l states). But the heap might grow to O(l) states? 

          However, we generate two children for each popped state, so the heap size is at most O(l) and we do l pops -> total operations O(l log l). 

          But the problem: if we push the same state twice, then the heap might have duplicates? 

          Then we might output the same sum twice? 

          How? 

            The state (i, j) has a fixed sum: base - A[i] + A[j]? 

            Actually, no: the state (i, j) might have a different sum if we have multiple swaps? 

          Actually, we are storing the current sum in the state. The state (i, j) in the heap has the current sum as the first element. 

          But if we have two different paths to the same (i,j), they would have the same sum? 

          Why? 

            Path1: we start with swapping i at k: then extend to j: 
                sum1 = base - A[i] + A[k] -> then extend: sum1 - A[k] + A[k+1] -> ... -> base - A[i] + A[j]

            Path2: we start with swapping i+1 at k, then extend to k+1, then swap i with k+1? 
                state0: base
                state1: base - A[i+1] + A[k]   (state (i+1, k))
                state2: base - A[i+1] + A[k+1]   (extend: (i+1, k+1))
                state3: base - A[i+1] + A[k+1] - A[i] + A[k+2] = base - A[i] - A[i+1] + A[k+1] + A[k+2]   (state (i, k+2))

            But that is not the same as (i, j) with j=k+2? 

          Actually, the state (i, j) for a single swap is base - A[i] + A[j]. The state (i, j) for two swaps is base - A[i] - A[i+1] + A[k] + A[j]? 

          How do we represent two swaps? 

          We are representing a state by (i, j) and the current sum. But the state (i, j) does not record the entire history? 

          Therefore, the state (i, j) might appear in two different contexts: with one swap or with two swaps? 

          But we are not. The state (i, j) we push initially is for one swap. Then from a state (i+1, j0) we generate a state (i, j0+1) which is a two-swap state? 

          How do we distinguish? 

          We cannot. Therefore, we must include the entire set of swaps in the state? 

          This is a flaw.

          Let me read the editorial again: 

            "We represent the state as (current_sum, i, j, depth) ..."

          The depth is the number of swaps? 

          Then the state (i, j, depth=1) has one swap: base - A[i] + A[j]
          The state (i, j, depth=2) has two swaps: base - A[i] - A[i-1] + A[j0] + A[j] for some j0? 

          But note: the editorial says: 

            "Option 1: ... same depth"
            "Option 2: ... depth+1"

          So the state has depth. 

          And the sum is not just base - A[i] + A[j] but base - (all the swapped out) + (all the swapped in). 

          How do we know the entire set of swaps? We don't: we store the current sum.

          So the state is (sum, i, j, depth) but we don't use depth to compute the sum, we only use depth to know how many swaps have been done? 

          But the editorial does not use depth to compute the next state? 

          They use:

            Option1: sum_new = sum - A[j] + A[j+1]   -> and depth remains the same? 
            Option2: sum_new = sum - A[i-1] + A[j+1] -> and depth increases by 1.

          And they also change i to i-1 and j to j+1.

          But what if depth>1? In Option2, we are swapping a new element? 

          However, the editorial says: "if we have depth swaps" -> actually, the depth in the state is the number of swaps? 

          But in the state (current_sum, i, j, depth), the depth is the number of swaps that have been done? 

          Then from a state with depth=d, we can generate:

            Option1: depth remains d.
            Option2: depth becomes d+1.

          But note: the editorial does not restrict by the current depth? It says:

            - Option 1: without increasing the number of swaps? 
            - Option 2: increasing the swap count.

          So we must store depth? 

          However, we don't use depth in the sum computation, only in the generation rules? 

          And the state (i, j, depth) might be the same as (i, j, depth') for depth'!=depth? 

          We are not. The depth is part of the state? 

          Actually, the state is defined by (i, j, depth) and the sum? 

          But the sum is determined by the set of swaps, so if the set of swaps is different, the sum is different? 

          However, we don't store the entire set, so two different sets might have the same sum? 

          But the problem is to output the sum, not the configuration.

          But the heap will then have the same sum twice? That is acceptable? 

          But the problem: we might output the same sum twice as two distinct configurations? 

          Example: two different configurations can have the same sum.

          Then we might output the same sum twice? 

          And the problem: the top l largest sums might include duplicates.

          In sample1: 6 appears three times.

          So we are expected to output the same sum multiple times.

          Therefore, we don't care about duplicate sums.

          But we care about duplicate states? We don't want to push the same state twice.

          How to avoid duplicate states? 

          The state is (i, j, depth). The depth is the number of swaps? 

          Then the state (i, j, depth) might appear twice? 

          How? 

            Path1: 
               start at (i0, k, 1)
               then extend: (i0, k+1, 1)
               then new swap: (i0-1, k+1, 2)
            Path2:
               start at (i0-1, k, 1)
               then new swap from (i0-1, k, 1)? -> no, we extend to (i0-1, k+1, 1) and then swap to (i0-2, k+1, 2)

          So we might not have duplicates in (i, j, depth). 

          But the state (i, j, depth) is uniquely defined by (i, j, depth). 

          And the total states: depth can be up to k, i in [0, k-1] (but depth swaps require that we have swapped depth elements, so i we start from k-1 and go down to depth-1? not necessarily) and j in [k, n-1]. 

          The total states: k * (n-k) * k? -> depth up to k, i about k, j about n-k -> total states k^2 * (n-k) which is 10^18, too many.

          But we only generate l states (l<=10^6). 

          However, the heap might grow to 2*l, but the states (i, j, depth) we generate are at most O(l). 

          But we must avoid pushing the same (i, j, depth) twice? 

          We can use a set of tuples (i, j, depth) to avoid duplicates. But the number of states is l (<=10^6) so we can do it.

          Steps:

            We'll use a set visited: that stores (i, j, depth).

            When we generate a state (sum, i, j, depth), we check if (i, j, depth) has been visited. If not, we push it and mark visited.

            But note: we generate two states from one popped state, and we check if they are visited.

          How much memory: 10^6 states, each state: 3 integers -> 12 MB? 

          But worst-case, the heap might grow to 10^6 states and we store 10^6 in the visited set? 

          So it is acceptable.

          However, the depth is the number of swaps? But note: the editorial says depth is the number of swaps? 

          In the state representation, we store depth. And the depth in the initial states is 1.

          But then Option1: depth remains the same -> same depth.
          Option2: depth+1.

          And depth can be at most k? 

          But k can be up to 10^6, so depth up to 10^6? 

          Then the state (i, j, depth) has depth in [1, k]? 

          Then the total distinct states: i in [0, k-1], j in [k, n-1], depth in [1, k] -> k*(n-k)*k which is 10^18, too many for a set.

          But we are only generating at most l states (10^6) -> so the set will have at most 10^6 states.

          So we can do it.

          Implementation:

            Let's define a state as:

               struct State {
                   ll sum;
                   int i, j;
                   int depth;
               };

            And we want a max-heap by sum.

            We also have:

               set<tuple<int, int, int>> visited;   // (i, j, depth)

            Steps:

               sort(A, A+n, greater<ll>());
               base = accumulate(A, A+k, 0LL);

               priority_queue<State> heap;
               // How to compare: 
               //   We can use: 
               //      bool operator<(const State& other) const { return sum < other.sum; }
               //   But priority_queue is max-heap by default? and it uses the operator< ? But by default it's less, so the largest element is not at top.

               // We can do:

                  auto cmp = [](const State& a, const State& b) { return a.sum < b.sum; };
                  priority_queue<State, vector<State>, decltype(cmp)> heap(cmp);

               // Or we can use negative: but not.

            Alternatively, we can use:

               priority_queue<State> heap; 
               and define operator< for State: 
                  bool operator<(const State& other) const { return sum < other.sum; }   // then the largest sum is the highest.

            But note: priority_queue is a max-heap by default? and it uses `operator<`? Actually, the largest element is when a<b means a is less than b, then the top is the largest? 

            Let me check: 
               priority_queue<int> q; 
               q.push(2); q.push(3); then top is 3.

            And the default uses `less` by default? which is `a < b` -> then the largest is at the top.

            So if we define:

               bool operator<(const State& other) const {
                   return sum < other.sum;
               }

            Then the heap will be a max-heap by sum.

            But we also have to consider: if two states have the same sum, then we break ties arbitrarily.

          Steps:

            ans = vector with base.

            visited set.

            for i from k-1 down to 0:
                state = { base - A[i] + A[k], i, k, 1 }
                if we haven't visited (i, k, 1), then push and mark visited.

            Then for l-1 times:

                if heap is empty: break and output -1 for the remaining.

                pop the top state: s = heap.top(); heap.pop();
                append s.sum to ans.

                Then generate two states:

                   state1: { s.sum - A[s.j] + A[s.j+1], s.i, s.j+1, s.depth }   // same depth
                   if s.j+1 < n and (s.i, s.j+1, s.depth) not visited -> then push and mark.

                   state2: { s.sum - A[s.i-1] + A[s.j+1], s.i-1, s.j+1, s.depth+1 }   // new swap
                   if s.i-1>=0 and s.j+1 < n and (s.i-1, s.j+1, s.depth+1) not visited -> push and mark.

            Then output the vector ans (the first l: if we break early, then the rest are -1).

          But note: the base is the first one. Then we output l-1 from the heap.

          However, the heap might contain states that are the base? 

          No: we pushed states that are base - A[i] + A[k] (which is <= base? but since A[i] >= A[k] in sorted array, so it might be <= base).

          But in the sample: base=6, then the states we push: base - A[i] + A[k] = 6 - 3 + 3 = 6.

          So the heap initially has two 6's.

          Then we output the base (6) as the first.

          Then we pop the heap: the largest is 6 -> we output 6.

          Then we generate two states from (6, i, k, 1): 

            state1: (6 - A[k] + A[k+1], i, k+1, 1) -> in sample: k=2, so A[k]=A[2]=3, A[k+1]=A[3]=2 -> 6-3+2=5, state (i,3,1)

            state2: (6 - A[i-1] + A[k+1], i-1, 3, 2) -> but for i=0: i-1=-1 -> skip.

          But we have two initial states: for i=0 and i=1.

          So we pop the next state: which is the other 6.

          Then we generate state1: 5 and state2: for i=1: i-1=0, so 6 - A[0] + A[3] = 6 - 3 + 2 = 5, state (0,3,2)

          Then we have two states: (0,3,1) and (0,3,2) -> both have sum 5.

          Then we pop the 5's.

          So the output: 
            6 (base)
            6 (from heap)
            6 (from heap)
            5
            5
            5

          But the sample output: 
            6
            6
            6
            5
            5
            5

          So it matches.

          Therefore, we implement with:

            struct State {
                ll sum;
                int i, j, depth;
                // for set and priority_queue: we don't use in set? 
            };

            We don't need to define operator< for the set? we are using a set of tuples (i, j, depth) for visited.

          However, we need to define operator< for the heap? 

          We define:

            bool operator<(const State& other) const {
                return sum < other.sum;
            }

          But note: if two states have the same sum, we don't care which comes first.

          But we must be cautious: the heap might not be stable? but it doesn't matter.

          Steps:

            Read n,k,l and the array.

            Sort the array in descending order.

            Compute base.

            Output base as the first line.

            If l==1, then we break.

            Then, we create:

               priority_queue<State> heap;
               set<tuple<int,int,int>> visited;   // (i, j, depth)

            Then for i from k-1 down to 0:

                if k < n:  // because if k==n, then there is no unselected element -> skip
                    State st = { base - A[i] + A[k], i, k, 1 };
                    if (visited.find({i, k, 1}) == visited.end()) {
                        visited.insert({i, k, 1});
                        heap.push(st);
                    }

            Then for cnt = 1 to l-1:

                if heap is empty: then we break and output -1 for the rest.

                pop the top: State cur = heap.top(); heap.pop();

                output cur.sum.

                Then generate two states:

                   Option1: j_next = cur.j+1
                            if j_next < n:
                                State st1 = { cur.sum - A[cur.j] + A[j_next], cur.i, j_next, cur.depth };
                                if (visited.find({cur.i, j_next, cur.depth}) == visited.end()) {
                                    visited.insert({cur.i, j_next, cur.depth});
                                    heap.push(st1);
                                }

                   Option2: i_prev = cur.i-1
                            j_next = cur.j+1
                            if i_prev >=0 and j_next < n:
                                State st2 = { cur.sum - A[i_prev] + A[j_next], i_prev, j_next, cur.depth+1 };
                                if (visited.find({i_prev, j_next, cur.depth+1}) == visited.end()) {
                                    visited.insert({i_prev, j_next, cur.depth+1});
                                    heap.push(st2);
                                }

            Then if we haven't output l-1 states (because heap was empty) then the remaining are -1.

          Important: the array A is 0-indexed.

          But note: the initial state: we start from i from k-1 down to 0? 

          Why down to 0? Because we want to be able to do Option2: swap the next element (i-1) and we go down to 0.

          But we start with i=k-1, then i=k-2, ... i=0.

          However, we can also do from 0 to k-1? 

          The editorial says: from the highest index (which is k-1) down to 0.

          But it doesn't matter as long as we push all i in [0, k-1].

          But we must push from high i to low? Because in Option2 we do i-1, which is lower? 

          Actually, we push all initial states. The order of pushing doesn't matter because the heap sorts by sum.

          However, the initial states: base - A[i] + A[k] -> since A[i] is the same for all i? not necessarily: A[i] for i in [0, k-1] might be different. But we sorted descending, so A[0]>=A[1]>=...>=A[k-1]. Therefore, the state with i=0: base - A[0] + A[k] might be the smallest initial state? 

          But we push them all and the heap will have the largest sum at top.

          Example: base = 10, A[0]=5, A[1]=4, A[k]=3.

          Then state for i=0: 10-5+3=8
          state for i=1: 10-4+3=9

          Then the heap will pop 9 first.

          So it's fine.

          Let me test with the sample input2: n=5, k=1, l=10, A=[1,1,1,1,1] (all ones)

            sorted: [1,1,1,1,1]

            base = A[0] = 1.

            Then we output 1.

            Then we push: for i from k-1=0 down to 0: only i=0.

                state0: { base - A[0] + A[k] = 1 - 1 + 1 = 1, i=0, j=k=1, depth=1 }

            Then we do for cnt=1 to 9:

                cnt=1: pop state0: sum=1 -> output 1.
                generate:
                  Option1: j_next=2: state1: {1 - A[1] + A[2] = 1 - 1 + 1 = 1, i=0, j=2, depth=1} -> push.
                  Option2: i_prev=-1 -> skip.

                cnt=2: pop state1: output 1.
                  generate: j_next=3: state2: (1,0,3,1) -> push.

                cnt=3: pop state2: output 1, generate state3: (1,0,4,1) -> push.

                cnt=4: pop state3: output 1, generate: j_next=5 -> invalid (j_next=4+1=5>=5) -> skip.

                Then the heap becomes empty for the next pops? 

                cnt=5: heap empty -> break.

            Then we output 1 (base) and then 4 ones: total 5 ones, then the next 5 are -1.

          But the sample output: 
            1
            1
            1
            1
            1
            -1 (5 times)

          So we output 5 ones? but we only output base and then 4 from the heap? total 5.

          Then for the next 5 (l=10, we need 10 lines) we break at the 5th output? Then we output 5 ones and then 5 -1.

          But the sample output is 5 ones and 5 -1.

          So it matches.

          Edge: k=0? but k>=1.

          Also, n=1, k=1, l=1: then base = A[0], then we output base and then we don't push any state (because k-1=0, then i=0: then j = k = 1? but n=1, so k=1 is out of bounds? 

          We have j = k, so k must be < n? 

          Condition: we only push if k < n? 

          Actually, if k==n, then there is no unselected element. Then we cannot swap. Then the heap remains empty.

          Then we output base, and then for the next l-1, we break and output -1.

          Example: n=2, k=2, l=3: 
            base = A[0]+A[1] = 3+? 
            then output base.
            then we don't push any state? 
            then for l-1=2: we break -> output -1 twice.

          But the total configurations: only one. So the next two should be -1.

          Therefore, we add:

            if (k < n) for the initial push.

          Also, in generating Option1 and Option2, we check j_next < n.

          Code:

            #include <iostream>
            #include <vector>
            #include <queue>
            #include <algorithm>
            #include <set>
            #include <cctype>
            #include <climits>
            #include <cmath>
            #include <unordered_set>
            using namespace std;
            using ll = long long;

            struct State {
                ll sum;
                int i, j;
                int depth;
                // For the priority_queue: we want max-heap by sum.
                bool operator<(const State& other) const {
                    return sum < other.sum;
                }
            };

            int main() {
                ios_base::sync_with_stdio(false);
                cin.tie(nullptr);

                int n, k, l;
                cin >> n >> k >> l;
                vector<ll> A(n);
                for (int i = 0; i < n; i++) {
                    cin >> A[i];
                }

                // Sort in descending order
                sort(A.rbegin(), A.rend());

                // If k==0? but k>=1, so we assume k>=1.
                ll base = 0;
                for (int i = 0; i < k; i++) {
                    base += A[i];
                }

                // We'll output the base first.
                vector<ll> ans;
                ans.push_back(base);

                // If l==1, we are done after base.
                if (l == 1) {
                    // output base and then we are done? but we have to output l lines.
                    // already pushed base.
                } else {
                    // We'll use a max-heap for State.
                    priority_queue<State> heap;
                    set<tuple<int, int, int>> visited;  // (i, j, depth)

                    // Push initial states: for i from k-1 down to 0, if k < n.
                    if (k < n) {
                        for (int i = k-1; i>=0; i--) {
                            // We are going to swap A[i] with A[k]
                            ll new_sum = base - A[i] + A[k];
                            State st = {new_sum, i, k, 1};
                            tuple<int,int,int> key = {i, k, 1};
                            if (visited.find(key) == visited.end()) {
                                visited.insert(key);
                                heap.push(st);
                            }
                        }
                    }

                    // Now we want to pop l-1 times.
                    int count = 1;  // we have already output 1 (base)
                    while (count < l && !heap.empty()) {
                        State cur = heap.top();
                        heap.pop();
                        ans.push_back(cur.sum);
                        count++;

                        // Generate state1: extend the last swap: same i, depth; j = j+1.
                        int j_next = cur.j + 1;
                        if (j_next < n) {
                            ll sum1 = cur.sum - A[cur.j] + A[j_next];
                            State st1 = {sum1, cur.i, j_next, cur.depth};
                            tuple<int,int,int> key1 = {cur.i, j_next, cur.depth};
                            if (visited.find(key1) == visited.end()) {
                                visited.insert(key1);
                                heap.push(st1);
                            }
                        }

                        // Generate state2: new swap: i_prev = cur.i-1, j_next = cur.j+1, depth=cur.depth+1.
                        int i_prev = cur.i - 1;
                        if (i_prev >= 0 && j_next < n) {
                            ll sum2 = cur.sum - A[i_prev] + A[j_next];
                            State st2 = {sum2, i_prev, j_next, cur.depth+1};
                            tuple<int,int,int> key2 = {i_prev, j_next, cur.depth+1};
                            if (visited.find(key2) == visited.end()) {
                                visited.insert(key2);
                                heap.push(st2);
                            }
                        }
                    }

                    // If we broke because heap is empty and count<l, then we need to fill the rest with -1.
                    while (count < l) {
                        ans.push_back(-1);
                        count++;
                    }
                }

                // Output: l lines.
                for (ll a : ans) {
                    cout << a << '\n';
                }
            }

          Let me test with the sample input3: 
            "20 10 20
             3 1 4 1 5 9 2 6 5 3 5 8 9 7 9 3 2 3 8 4"

          Expected output: 
            71
            70
            70
            70
            70
            70
            70
            69
            69
            69
            69
            69
            69
            69
            69
            69
            69
            69
            69
            69

          But note: the sample input has 20 numbers, k=10, l=20.

          We'll run the code on the sample input3 to see if it matches.

          However, we can run locally.

          But note: the array: 
            [3,1,4,1,5,9,2,6,5,3,5,8,9,7,9,3,2,3,8,4]

          Sort descending: 
            [9,9,9,8,8,7,6,5,5,5,4,4,3,3,3,3,2,2,1,1]  -> but wait, we must sort the given array in descending.

          Given array: 
            Original: 3 1 4 1 5 9 2 6 5 3 5 8 9 7 9 3 2 3 8 4

          Sorted descending: 
            9,9,9,8,8,7,6,5,5,5,4,4,3,3,3,3,2,2,1,1

          Then base = sum of first 10: 
            9+9+9+8+8+7+6+5+5+5 = 
             9*3 = 27
             8*2=16
             7=7
             6=6
             5*3=15
             total = 27+16=43, +7=50, +6=56, +15=71.

          Then the base is 71.

          Then the next states: 
            We push for i=9,8,...,0 (from 9 down to 0) and j=k=10? A[10]=4 (the first unselected) -> the new sum = 71 - A[i] + 4.

          The first 10 elements: 
            index0:9 -> 71-9+4 = 66
            index1:9 -> 66
            index2:9 -> 66
            index3:8 -> 71-8+4=67
            index4:8 -> 67
            index5:7 -> 71-7+4=68
            index6:6 -> 71-6+4=69
            index7:5 -> 71-5+4=70
            index8:5 -> 70
            index9:5 -> 70

          Then the heap will have:

            states: 
             70 (from i=7,8,9) -> three times
             69 (from i=6)
             68 (from i=5)
             67 (from i=3,4) -> twice
             66 (from i=0,1,2) -> three times

          Then the next largest is 70.

          Then we pop 70 (from i=7, j=10, depth=1). Then we generate:

            state1: extend j to 11: 
                j_next=11: A[11]=4 -> new_sum = 70 - A[10] + A[11] = 70 -4+4=70 -> state (7,11,1) -> push.
            state2: new swap: i_prev=6, j_next=11: 
                new_sum = 70 - A[6] + A[11] = 70 -6 +4 = 68? -> but wait, the element at index6 is 6? 

          But in the state: we have swapped the element at i=7 (which was 5) with A[10] (4). Then the set now has: 
            [9,9,9,8,8,7,6,5,5,4]  -> but we swapped the last 5 (at index7) with 4? 
          Then we want to swap the next element: at index6 (which is 6) with A[11] (4) -> then we remove 6 and add 4 -> so the sum becomes 70 -6 +4 = 68.

          Then we push state (68,6,11,2).

          Then we have the next largest: 70 (from the other two 70's we pushed initially: i=8 and i=9) and then the 70 we just pushed? 

          Then we pop 70 (from i=8, j=10): 
            state1: (8,11,1): 70 -4+4=70 -> push.
            state2: (7,11,2): 70 - A[7] (which is 5) + A[11] (4) = 70-5+4=69 -> push.

          Then we pop 70 (from i=9, j=10): 
            state1: (9,11,1): 70-4+4=70 -> push.
            state2: (8,11,2): 70 - A[8] (5) + A[11] (4)=69 -> push.

          Then we have the heap: 
            states: 
              70: from (7,11,1), (8,11,1), (9,11,1) -> three
              70: already popped? 
              69: from the initial state for i=6? and then the two 69's from state2? 
              68: from state2 of the first 70? 
              67,66...

          Then we pop 70 (from i=7, j=11, depth=1): 
            state1: (7,12,1): 70 - A[11] (4) + A[12] (3) = 70-4+3=69 -> push.
            state2: (6,12,2): 70 - A[6] (6) + A[12] (3) = 70-6+3=67 -> push.

          Then we pop 70 (from i=8, j=11,1): 
            state1: (8,12,1): 70-4+3=69
            state2: (7,12,2): 70 - A[7] (5) + A[12] (3) = 70-5+3=68

          Then we pop 70 (from i=9, j=11,1): 
            state1: (9,12,1): 69
            state2: (8,12,2): 70-5+3=68

          Then we have popped 4 states: 70,70,70,70 -> and we have the base (71) and then 4 times 70 -> 5 outputs so far.

          The expected output: 
            71, then 70,70,70,70,70,70 -> 6 times 70? 

          But we only pushed 3 initial 70's? 

          Then after popping the three initial 70's and the one 70 we generated (from the first 70 by extending to j=11) we have 4 outputs of 70? 

          Then we generated more 70's: from the other two initial 70's we generated two more 70's? 

          So we have 3 initial 70's and then we generated 3 more 70's? 

          Then we have 6 states of 70.

          Then we output: 
            71 (base)
            then 70 (first initial: i=7) -> output 1st 70
            then 70 (second initial: i=8) -> output 2nd 70
            then 70 (third initial: i=9) -> output 3rd 70
            then 70 (from i=7 extended to 11) -> output 4th 70
            then 70 (from i=8 extended to 11) -> output 5th 70
            then 70 (from i=9 extended to 11) -> output 6th 70

          Then the next state: we have a 70 from i=7 extended to 11 popped? and then we generated 69 and 67? 

          Then we have 69 states: the initial state for i=6:69, and the state2 from i=8 and i=9:69.

          Then we pop the 69? 

          But the expected output has 70 seven times? 

          Actually, the sample output:

            71
            70
            70
            70
            70
            70
            70
            then 69

          How do we get 7 times 70?

          We have the base:71, then 6 times 70? 

          But the sample output has 70 repeated 7 times? 

          Let me count: the sample output:

            71
            70
            70
            70
            70
            70
            70  -> that's 7 outputs: 71 and 6 times 70? -> no, 71 and then 6 times 70 -> total 7 numbers.

          Then the 8th is 69.

          But we only output 6 times 70? 

          How to get the 7th 70?

          Note: we might get a 70 by a two-swap? 

          Example: 

            We swap two elements: 
              Initially: base = 71.
              Swap index9 (which is 5) with the element at k=10 (4) -> then the set becomes: 9,9,9,8,8,7,6,5,5,4 -> sum=70.
              Then swap the element at index8 (5) with the element at index11 (4) -> but that would be 70 -5+4=69? 

            Alternatively, we swap one element and then extend? 

          How about: 

            Swap index7 (5) with index10 (4) -> state: (70,7,10,1)
            Then extend: swap index10 (4) with index11 (4) -> 70 -4+4=70.

            Then we have one 70 from the initial, and one from extending.

          But we also have:

            Swap index8 (5) with index10 (4) -> 70
            Then extend: 70 -4+4=70

            Swap index9 (5) with index10 (4) -> 70, then extend: 70

          Then we have:

            initial: 3 states of 70 (i=7,8,9 at j=10)

            then from each we extend to j=11: 3 states of 70

            then from each of the j=11 states we extend to j=12: 3 states of 69? 

          But we are popping the 70's in order? 

          After the three initial 70's, we have three extended 70's (at j=11). Then we pop them and then we get 69's? 

          Then we have output: 71, then 70 (initial i=7), 70 (initial i=8), 70 (initial i=9), 70 (extended i=7 to j=11), 70 (extended i=8 to j=11), 70 (extended i=9 to j=11) -> 6 times 70.

          Then we need a 7th 70? 

          How? 

          We also have the possibility: 

            Swap index7 (5) with index10 (4) -> 70
            Then swap a new element: index6 (6) with index11 (4) -> 70 -6+4=68? 

          Or:

            Swap index6 (6) with index10 (4) -> 69
            Then swap index7 (5) with index11 (4) -> 69 -5+4=68? 

          How to get a 70 with two swaps? 

          We start with base=71.

          Swap two elements: 
            Swap index9 (5) with index10 (4) -> 70
            Swap index8 (5) with index11 (4) -> 70 -5+4=69? 

          Or:

            Swap index9 (5) and index10 (4) -> 70
            Swap index8 (5) and index10 (4) -> but wait, we already swapped index10? 

          Alternatively, swap two elements at once: 

            We remove two 5's (at index7 and index8) and add two 4's (at index10 and index11) -> 71 -5-5+4+4=71-10+8=69.

          How to get 70? 

          We remove one 5 and one 6? 

            Remove 5 (at index7) and 6 (at index6), and add 4 and 4: 71-5-6+4+4=71-11+8=68.

          How about remove one 5 and one 5? 

            71-5-5+4+? -> we need +6 to get 71? -> no.

          Actually, we want 70: 71 - a - b + c + d = 70 -> a+b - (c+d) = 1.

          Since a,b are from the initial set (>=5) and c,d from the unselected (<=4), so a+b>=10, c+d<=8 -> then a+b - (c+d) >=2, so cannot be 1.

          Therefore, we cannot get 70 with two swaps? 

          Then the 7th 70 must be from a three-swap? -> not possible.

          But the sample output has 7 times 70? 

          There must be 7 configurations with sum 70.

          How?

            The base set: the top 10: [9,9,9,8,8,7,6,5,5,5] = 71.

            Configurations with sum 70: 
              Remove one 5 and add one 4: we have 3 choices for the 5 (any of the last three) and 2 choices for the 4 (there are two 4's: at index10 and 11? but actually the array has two 4's: the first unselected are the two 4's at positions 10 and 11? 

            Then we have 3*2=6 configurations with one swap: 70.

            Then one more? 

            How about remove a 6 and add a 5? 

              But we cannot: because the unselected has no 5? the next unselected are 4,4,3,3,3,3,2,2,1,1.

            Or remove a 5 and add a 5? -> same as before? 

            Or remove a 5 and then add the same 5? -> no.

          Actually, we missed:

            Remove a 5 (at index7) and add a 4? -> 70
            Remove a 5 (at index8) and add a 4? -> 70
            Remove a 5 (at index9) and add a 4? -> 70

            Then we can also remove a 5 (at index7) and add a 4 at index10 -> 70
            Then remove a 5 (at index7) and add a 4 at index11 -> 70? 

          But that is two configurations for the same 5? 

          So for each 5 we have two 4's? so 3*2=6.

          Then where is the 7th? 

          How about: remove a 6 and add a 5? -> but we don't have a 5 in the unselected? 

          Or remove a 7 and add a 6? -> 71-7+6=70? 

          And the unselected has a 6? 

          The unselected: after the top10, the next are [4,4,3,3,3,3,2,2,1,1] -> no 6.

          How about remove a 8 and add a 7? -> 71-8+7=70? 

          The unselected has a 7? -> no, the top10 includes the only 7? 

          So only the 6 configurations.

          But the sample output has 70 repeated 7 times? 

          Actually, the sample output has:

            71
            70
            70
            70
            70
            70
            70   -> that's 7 outputs: 71 and then 6 times 70? 

          So 71 is the first, and then 6 times 70 -> total 7 outputs.

          But our program outputs:

            base:71
            then the initial three 70's (from i=7,8,9 at j=10) -> 3 times
            then the extended states: from i=7,8,9 at j=11 -> 3 times: total 6 times 70.

          Then we have 7 outputs: 71 and 6 times 70 -> 7 outputs.

          But the sample output has 70 repeated 6 times? 

          The problem: the sample output has 71 and then 70 repeated 6 times -> 7 outputs.

          Then our program outputs 71 and 6 times 70 -> that matches the first 7.

          Then the next is 69.

          So we are good.

          Therefore, we output:

            71
            70
            70
            70
            70
            70
            70
            then 69 (which is the next largest: from the initial state i=6:69? and then we have more 69's)

          We'll trust the code.

          However, note: the sample output has 70 repeated 6 times (after 71) and then 69 repeated 13 times? 

          But the sample output:

            71
            70
            70
            70
            70
            70
            70
            69
            69
            69
            69
            69
            69
            69
            69
            69
            69
            69
            69
            69

          So 7th output is 69? 

          Our code: we output 71 and 6 times 70 -> 7 outputs, then the 8th output should be the next largest: 69.

          Why 69? 

            The initial state for i=6:69 -> and then we also generated some 69's from state2? 

          The heap after the 6 times 70: 
            We have:

              The initial state for i=6:69 (at j=10) 
              The state2 from the first 70 (i=7): 68? 
              The state2 from the second 70 (i=8):69
              The state2 from the third 70 (i=9):69
              The state1 from the first 70 extended to j=11:69? -> no: when we extended the first 70 (i=7) to j=11, we generated 70 (so we popped it) and then we generated state2: 68.

              Then from the second 70 (i=8) we generated: 
                 state1:70 (which we popped) and state2:69 (from 70 - A[7] (5) + A[11] (4) = 70-5+4=69) -> so we pushed (69,7,11,2) -> but wait, we did state2: i_prev = i-1 = 6? so we pushed (69,6,11,2) -> and we also have the initial state (69,6,10,1) -> so we have two states: (69,6,10,1) and (69,6,11,2) and (69,7,11,2) from the third 70? 

          Then the heap has several 69's.

          Then we pop the 69's: the largest is 69.

          We'll pop the initial state for i=6:69 -> then we generate:

            state1: extend j to 11: 69 - A[10] (4) + A[11] (4) = 69 -> push (6,11,1)
            state2: new swap: i_prev=5, j_next=11: 69 - A[5] (7) + A[11] (4) = 69-7+4=66 -> push.

          Then we pop the next 69: which is from the state (69,6,11,2) or (69,7,11,2) -> they are both 69.

          And we have multiple 69's.

          We'll get 13 times 69? 

          We'll trust the code.

          Therefore, we output the code as below.

          Note: The problem says: if i>binom(n,k) then output -1.

          We are using the heap to generate at most l states. And we break when the heap is empty and we haven't output l.

          We also mark visited states to avoid duplicates.

          Let me run the sample input3: but it's too long to do by hand.

          We'll run the code on the sample input3.

          But note: the sample input3 has n=20, k=10, l=20.

          The total binom(20,10) is 184756, which is >20, so we should output 20 values.

          We output base and then 19 from the heap? 

          We are confident.

          Code:

            We use a struct State and a visited set.

          Note: The State struct: we have to be careful with the indices.

          Let me code accordingly.

          One more note: the array A is 0-indexed.

          We assume j starts at k (which is 10) and goes to n-1=19.

          We are careful: j_next = cur.j+1, and check j_next < n.

          We'll submit.

          But note: the constraints: n,l up to 10^6, and we are storing at most 10^6 states in the heap and the set? 

          The set stores tuples (i, j, depth). The depth is the number of swaps? but we only generate l states? so the set has at most l states.

          The heap operations: O(l log l) which is acceptable.

          We'll run.

          But note: the initial push: we push k states, which is up to 10^6, so the heap initialization is O(k) = 10^6.

          Then each pop: O(log(heap_size)) and each push: O(log(heap_size)).

          Total: O(l * log(l)) which is 10^6 * log2(10^6) ~ 10^6 * 20 = 20e6, acceptable.

          Let me code accordingly.

          We'll use:

            struct State {
                ll sum;
                int i, j;
                int depth;
                bool operator<(const State& other) const {
                    return sum < other.sum;   // max-heap: the largest sum is at top.
                }
            };

          And note: the sample input2: all ones, we must not generate duplicate states? 

          We use the visited set.

          We'll submit.

          However, note: the problem says: if i>binom(n,k) then output -1.

          We are breaking when the heap is empty and we haven't output l values, then we output -1 for the remaining.

          This matches.

          We hope it passes.

          But note: the array A: the values are up to 10^9, so use long long.

          We do.

          Let me run the sample inputs.

          Sample1: n=4, k=2, l=6, A=[3,2,3,3] -> sorted: [3,3,3,2]

          base = 3+3 = 6.

          Then we push for i=0 and i=1 (k-1=1 down to 0) and j=k=2 (which is the third element: 3) -> 
             i=1: 6 - A[1] (3) + A[2] (3) = 6
             i=0: 6 - A[0] (3) + A[2] (3) = 6

          Then we output base:6.

          Then we pop: 6 (from i=1) -> output 6.
            generate: 
               state1: j_next=3: 6 - A[2] (3) + A[3] (2) = 5 -> push (1,3,1)
               state2: i_prev=0: 6 - A[0] (3) + A[3] (2) = 5 -> push (0,3,2)

          Then we pop: 6 (from i=0) -> output 6.
            generate:
               state1: (0,3,1): 6 - A[2] (3) + A[3] (2) = 5 -> push (0,3,1)
               state2: i_prev=-1: skip.

          Then we pop: 5 (from state (1,3,1)) -> output 5.
            generate:
               state1: j_next=4: skip (n=4, j_next=4>=4 -> skip)
               state2: i_prev=0: 5 - A[0] (3) + A[4] -> but A[4] doesn't exist -> skip.

          Then we pop: 5 (from state (0,3,2)) -> output 5.
            generate:
               state1: j_next=4: skip
               state2: i_prev=-1: skip

          Then we pop: 5 (from state (0,3,1)) -> output 5.
            generate: skip

          Then we have output: 6,6,6,5,5,5 -> 6 outputs.

          So the output:

            6
            6
            6
            5
            5
            5

          But the base was output first? 

          Actually, we output:

            ans: [6]  (base)
            then we push two 6's.

            Then we output the next 5:

                base:6
                then heap: 6,6 -> then we pop 6 -> output 6 -> then we push 5,5
                then pop 6 -> output 6 -> then push 5
                then pop 5 -> output 5
                then pop 5 -> output 5
                then pop 5 -> output 5

          So the output:

            6
            6
            6
            5
            5
            5

          But the sample expected:

            6
            6
            6
            5
            5
            5

          So the order is:

            Line1: 6 (base)
            Line2: 6 (from heap: the first pop)
            Line3: 6 (from heap: the second pop)
            Line4: 5
            Line5: 5
            Line6: 5

          It matches.

          We'll submit.