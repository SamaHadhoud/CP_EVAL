 We are going to follow the editorial guidelines exactly.
 Steps:
 1. Read input and compute min_x, max_x, min_y, max_y.
 2. Compute s1 = max_x - min_x, s2 = max_y - min_y, s0 = max(s1, s2).
 3. Generate 8 candidate squares as described.
    Candidates 1-4: using s0 and the extreme corners.
    Candidates 5-6: if s1>=s2, then we can have two candidates: one with bottom at min_y and top at min_y+s1, and one with top at max_y and bottom at max_y-s1. The sides are fixed at min_x and max_x.
    Candidates 7-8: if s2>=s1, then we can have two candidates: one with left at min_x and right at min_x+s2, and one with right at max_x and left at max_x-s2. The vertical sides are fixed at min_y and max_y.

 However, note: the problem allows degenerate squares (single point) and the square must have sides either horizontal or vertical.

 Important: The candidate squares must be defined by two opposite corners (x1, x2, y1, y2) with x1<=x2 and y1<=y2.

 But note: our candidate generation already ensures that? 
   For candidate 1: (min_x, min_x+s0, min_y, min_y+s0) -> x1=min_x, x2=min_x+s0, y1=min_y, y2=min_y+s0 -> and since s0>=0, then x1<=x2 and y1<=y2.

 4. For each candidate, check if every point (x,y) lies on at least one border: 
        x == x1 OR x == x2 OR y == y1 OR y == y2.

 5. If we find one candidate that satisfies, output it and return. Otherwise, output "Impossible".

 However, note: the sample input #1: 
     3
     7 6
     2 4
     4 0

    The sample output is "2 8 0 6".

 How does that relate to our candidate generation?
   min_x = 2, max_x=7, min_y=0, max_y=6.
   s1 = 5, s2=6 -> s0 = 6.

   Candidate 1: (2, 2+6=8, 0, 0+6=6) -> (2,8,0,6) -> which is the sample output.

   Then we check the points:
      (7,6): x=7 is not 2 or 8? -> wait, 8 is the right border? Actually, the square is from x=2 to x=8, so 8 is included. Similarly, y=6 is the top border? 
          Actually, the borders: left: x=2, right: x=8, bottom: y=0, top: y=6.
          (7,6): 
             x=7 -> not 2 or 8 -> but y=6 -> which is the top border? So yes.

      (2,4): x=2 (left border) -> valid.
      (4,0): y=0 (bottom border) -> valid.

   So candidate 1 works.

 Implementation:

   We note: the candidate squares we generate:

    cand1: (min_x, min_x+s0, min_y, min_y+s0)
    cand2: (min_x, min_x+s0, max_y-s0, max_y)
    cand3: (max_x-s0, max_x, min_y, min_y+s0)
    cand4: (max_x-s0, max_x, max_y-s0, max_y)

    if s1>=s2:
        cand5: (min_x, max_x, min_y, min_y+s1)   -> note: s1 = max_x-min_x, so the side length is s1, but the square requires side = (max_x-min_x) = s1, and the vertical side must be s1. But here the vertical side is s1, which is >= s2 (so it covers the y range? min_y to min_y+s1: note that min_y+s1 >= min_y+s2? and s2<=s1 so min_y+s1 >= max_y? because max_y-min_y = s2 <= s1 -> so min_y+s1 >= min_y+s2 = max_y? so the top border min_y+s1 is at least max_y -> so it covers the y points. Similarly for cand6: (min_x, max_x, max_y-s1, max_y): the bottom border is max_y-s1, and since s1>=s2, we have max_y-s1 <= min_y (because s1>=s2 => max_y-s1 <= max_y - s2 = min_y). So the square covers the y points.

    Similarly for cand7 and cand8: when s2>=s1, we fix the y borders to min_y and max_y, and then set the x borders to either [min_x, min_x+s2] or [max_x-s2, max_x]. The side length is s2, which is at least s1, so it covers the x points.

 But note: we must check that the square has equal side lengths? Actually, the square must be a square: so the side length must be (x2-x1) = (y2-y1). 

   In cand1: side = s0 and s0, so equal? yes.

   In cand5: the side in x: max_x-min_x = s1, and in y: (min_y+s1) - min_y = s1 -> so it's a square.

   Similarly, cand7: x side: (min_x+s2) - min_x = s2, y side: max_y - min_y = s2 -> so it's a square.

 6. We must also note: the candidate squares might have negative coordinates? But the constraints say: we can output from -10^9 to 10^9. Our computed candidates are integers and within the constraints? 
      The inputs are in [-10^8, 10^8]. 
      s0 = max(s1, s2) <= 200000000, so the coordinates of the candidate square can be as low as min_x (>= -10^8) - s0? Actually in cand2: min_x is at least -10^8, and min_x+s0 is at most 10^8 + 200000000 = 300000000 which is <= 10^9? Similarly, we might have negative: for example, min_x is -100000000, then min_x+s0 can be 100000000 (if s0=200000000) -> which is within -10^9 to 10^9.

 7. However, note: the problem does not require the square to be minimal? Any square that satisfies the condition is acceptable.

 Implementation in C++:

   Steps:
     - Read N, then N points.
     - Find min_x, max_x, min_y, max_y.
     - Compute s1 = max_x-min_x, s2 = max_y-min_y, s0 = max(s1,s2).
     - Create a vector of candidate squares: each candidate is (x1, x2, y1, y2). We generate 8 candidates as above, but note: we generate candidate5 and candidate6 only if s1>=s2? Actually, we generate when s1>=s2, and similarly for s2>=s1. But note: if s1==s2, then we generate both? Actually, we can avoid duplication? But we are generating two more for each condition. However, if s1==s2, then candidate5 and candidate7 would be the same? Not exactly: 
          candidate5: (min_x, max_x, min_y, min_y+s1) -> and since s1==s2, then min_y+s1 = min_y+s2 = max_y? -> so candidate5: (min_x, max_x, min_y, max_y) -> which is a square? because max_x-min_x = s1 = s2 = max_y-min_y -> so it is a square. Similarly, candidate7: (min_x, min_x+s2, min_y, max_y) -> and s2=s1, so min_x+s2 = min_x+s1 = min_x + (max_x-min_x) = max_x -> so candidate7 becomes (min_x, max_x, min_y, max_y) -> same as candidate5.

        So we might get duplicates? But that's okay: we can avoid by using a set? But the problem says we can output any, and we break at the first candidate that works. Alternatively, we can avoid generating duplicates? But it's only 8 candidates.

     However, note: we have 4 base candidates and then conditionally 2 or 4 more? Actually, if s1>=s2, we add two, and if s2>=s1 we add two. If s1==s2, we add 4? Actually, no: if s1>=s2, we add two; and if s2>=s1, we add two. But if s1==s2, both conditions are true -> so we add two from s1>=s2 and two from s2>=s1 -> total 4+2+2=8.

     But wait: the two from s1>=s2: candidate5 and candidate6 -> which are (min_x, max_x, min_y, min_y+s1) and (min_x, max_x, max_y-s1, max_y). Since s1==s2, then min_y+s1 = min_y+s2 = max_y -> so candidate5: (min_x, max_x, min_y, max_y). candidate6: (min_x, max_x, max_y-s1, max_y) = (min_x, max_x, min_y, max_y) because max_y-s1 = max_y-s2 = min_y. So candidate5 and candidate6 are the same square? Actually: 
          candidate5: (min_x, max_x, min_y, min_y+s1) -> becomes (min_x, max_x, min_y, max_y).
          candidate6: (min_x, max_x, max_y-s1, max_y) -> becomes (min_x, max_x, min_y, max_y) as well.

     Similarly, candidate7 and candidate8: 
          candidate7: (min_x, min_x+s2, min_y, max_y) -> becomes (min_x, min_x+s1, min_y, max_y) = (min_x, max_x, min_y, max_y).
          candidate8: (max_x-s2, max_x, min_y, max_y) -> becomes (max_x-s1, max_x, min_y, max_y) = (min_x, max_x, min_y, max_y).

     So when s1==s2, we generate the same square (min_x, max_x, min_y, max_y) multiple times? That's okay because we break at the first valid candidate. And we already have candidate1? 
          candidate1: (min_x, min_x+s0, min_y, min_y+s0) -> s0 = s1 (because s0=max(s1,s2)=s1). So (min_x, min_x+s1, min_y, min_y+s1) -> but min_x+s1 = max_x? Not necessarily: because s1 = max_x-min_x -> so min_x+s1 = max_x, and min_y+s1 = min_y+s2 = max_y? -> so candidate1: (min_x, max_x, min_y, max_y) as well.

     So we have multiple duplicates? But we only have 8 candidates and we break at the first valid one. Since the square (min_x, max_x, min_y, max_y) is always candidate1? and then we generate duplicates? We can avoid by checking the condition? But it's negligible.

 8. Implementation: we will generate all 8 candidates and then check in order? But note: we must not generate duplicates? Actually, we can avoid generating duplicates by checking if the candidate is the same? But it's easier to just generate and check. Since N can be up to 10^5 and we have 8 candidates, we do 8 * 10^5 checks -> 800000, which is acceptable.

 9. However, we must be cautious: we are generating 8 candidates, but if the conditions are not met, we generate less? Actually, we generate:
        always 4 candidates (cand1 to cand4)
        then if s1>=s2, we generate 2 more (cand5 and cand6)
        then if s2>=s1, we generate 2 more (cand7 and cand8)

     So total: 4 + 2*(if s1>=s2) + 2*(if s2>=s1) -> if s1==s2, then we generate 8 candidates? Actually, 4+2+2=8.

 10. How to represent a candidate: a tuple of (x1, x2, y1, y2). We assume x1<=x2 and y1<=y2.

 11. We then check each candidate: for every point (x,y), we check if x==x1 OR x==x2 OR y==y1 OR y==y2.

 12. Edge: degenerate square: when s0==0, then the square is a single point. Then all points must be that point? So we check: all points must be (min_x,min_y) and min_x==max_x and min_y==max_y? Then the candidate will be (min_x, min_x, min_y, min_y). Then for each point: x==min_x and y==min_y -> so it will be on the border? Actually, the border is a single point? Then it is on the border.

 13. Let's test with a degenerate case: 
        Input: 
            1
            0 0
        Then min_x=max_x=0, min_y=max_y=0, s0=0.
        Candidate1: (0,0,0,0) -> then check: (0,0): x==0 (which is x1 and x2) -> so valid.

 14. Another degenerate: 
        Input: 
            2
            0 0
            0 0
        -> same.

 15. But what if we have two distinct points? 
        Example: 
            N=2: (0,0) and (1,1)
        min_x=0, max_x=1, min_y=0, max_y=1 -> s1=1, s2=1 -> s0=1.
        Candidate1: (0,1,0,1) -> then we check:
            (0,0): x==0 -> valid.
            (1,1): x==1 -> valid.

        But is the square (0,1,0,1) a square? The side length is 1, so it's a square. The borders are the four lines: x=0, x=1, y=0, y=1. The point (0,0) is at the corner (so on two borders) and (1,1) is at the opposite corner.

        However, note: the problem says "connect all the points such that the resulting shape is a square". The square has four sides. The two points are on the borders? Yes.

        But what about the entire border? The problem does not require to cover the entire border? It only requires that every given point is on the border. So it's okay.

 16. But what if we have two points: (0,0) and (1,0)? 
        min_x=0, max_x=1, min_y=0, max_y=0 -> s1=1, s2=0 -> s0=1.
        Candidates:
          cand1: (0,1,0,1) -> then (0,0): y=0 -> valid; (1,0): y=0 -> valid? But also note: the square has top border at y=1 and bottom at y=0. The points are on the bottom border? yes.

        However, is the square (0,1,0,1) a square? Side length 1 -> yes.

        But note: the problem says the square must have sides horizontal or vertical. This square does.

        However, the two points are on the bottom side, which is horizontal.

 17. But what if the points are not on the border of a square? 
        Example: Input #2: 
            4
            2 6
            8 8
            10 2
            3 3

        We output "Impossible".

        Why? 
          min_x=2, max_x=10, min_y=2, max_y=8 -> s1=8, s2=6 -> s0=8.

          Candidate1: (2, 10, 2, 10) -> because min_x=2, min_x+s0=10, min_y=2, min_y+s0=10 -> so (2,10,2,10). Then we check:
             (2,6): x==2 -> valid.
             (8,8): in this square: we require the point to be on one of the borders: 
                    x=2? no. x=10? no. y=2? no. y=10? no. -> invalid.

          Then we try candidate2: (2,10,8-8=0,8) -> (2,10,0,8). Check:
             (2,6): x=2 -> valid.
             (8,8): y=8 -> valid.
             (10,2): x=10 -> valid.
             (3,3): must be on border: 
                   x=2? no. x=10? no. y=0? no. y=8? no. -> invalid.

          Similarly, candidate3: (10-8=2,10,2,2+8=10) -> same as candidate1? Actually: (2,10,2,10) -> same.

          candidate4: (2,10,0,8) -> same as candidate2.

          Then candidate5: since s1>=s2, we generate: 
                cand5: (2,10,2,2+8=10) -> same as candidate1.
                cand6: (2,10,8-8=0,8) -> same as candidate2.

          candidate7: since s2>=s1? no, because s2=6 < s1=8 -> so we skip.

          candidate8: skip.

          So all candidates fail -> output "Impossible".

 18. Implementation: we will generate the candidates in a list.

 19. However, note: we must avoid generating the same candidate multiple times? It's okay to check the same candidate multiple times? But we break at the first valid candidate. And if the candidate fails, we don't care. But worst-case we check 8 times the same candidate? Actually, we don't: the duplicates only occur when s1==s2? and then we generate the same candidate multiple times? But we can avoid by using a set? But 8 is small, so we can use a set to avoid duplicate checks? Or we can avoid generating duplicates by checking if we are about to generate the same candidate? 

     Alternatively, we can generate the candidates and then use a set to remove duplicates? But the problem says: output any candidate that works. And we break at the first valid candidate. So if we check the same candidate multiple times, we break at the first time we check it? But we have duplicates? Then we might check the same candidate again? It's inefficient? But 8 candidates and 10^5 points: worst-case 800000 checks, which is acceptable in C++.

     However, we can avoid duplicates by storing the candidate as a tuple and using a set? But the problem says we can output any candidate. Alternatively, we can break when we find one candidate that works. So if we check the same candidate twice, we do the same check twice? We can avoid by storing the candidates in a vector and then remove duplicates? 

     Since 8 is small, we can use:

        vector<tuple<long long, long long, long long, long long>> cands;
        then push without duplicates? Or we can use a set of tuples? But we break at the first valid candidate, so even if we check the same candidate twice, we do the same check twice? It's negligible.

     But to be safe: we can avoid generating duplicates by not generating the same candidate multiple times.

     How? We note that duplicates occur only when s1==s2? Then the candidate (min_x, max_x, min_y, max_y) appears in candidate1, candidate5, candidate7? 

        candidate1: (min_x, min_x+s0, min_y, min_y+s0) -> when s0=s1 and s1=s2, then min_x+s0 = max_x, min_y+s0 = max_y -> so (min_x, max_x, min_y, max_y).

        candidate5: (min_x, max_x, min_y, min_y+s1) -> becomes (min_x, max_x, min_y, max_y) because min_y+s1 = min_y+s2 = max_y.
        candidate7: (min_x, min_x+s2, min_y, max_y) -> becomes (min_x, max_x, min_y, max_y).

        So we can check: if we have already generated (min_x, max_x, min_y, max_y) then skip? But we are generating in a fixed order. Alternatively, we can generate:

          cands.push_back({min_x, min_x+s0, min_y, min_y+s0});
          cands.push_back({min_x, min_x+s0, max_y-s0, max_y});
          cands.push_back({max_x-s0, max_x, min_y, min_y+s0});
          cands.push_back({max_x-s0, max_x, max_y-s0, max_y});

          if (s1 >= s2) {
              cands.push_back({min_x, max_x, min_y, min_y+s1});
              cands.push_back({min_x, max_x, max_y-s1, max_y});
          }
          if (s2 >= s1) {
              cands.push_back({min_x, min_x+s2, min_y, max_y});
              cands.push_back({max_x-s2, max_x, min_y, max_y});
          }

        Then we iterate over cands: and check.

        However, when s1==s2, we generate two more candidates that are the same as candidate1? Actually, candidate5: (min_x, max_x, min_y, min_y+s1) -> which is (min_x, max_x, min_y, max_y) -> and candidate1 was (min_x, min_x+s0, min_y, min_y+s0) = (min_x, max_x, min_y, max_y) -> so we push two identical candidates? 

        Then we check candidate1: it fails? Then we check candidate2, then candidate3, candidate4, then candidate5: which is the same as candidate1 -> we check again? 

        We can avoid by storing the candidates in a set? But 8 is small, so we can do:

          set<tuple<long long, long long, long long, long long>> seen;
          vector<tuple<...>> cands;
          for each candidate we generate, if we haven't seen it, then push and insert into seen.

        Alternatively, we can do without because 800000 checks is acceptable? But worst-case we might check the same candidate 8 times? Actually, we have 8 distinct candidates? Or not? 

        Actually, when s1==s2, we have duplicates? 

          candidate1: (min_x, max_x, min_y, max_y)
          candidate2: (min_x, min_x+s0, max_y-s0, max_y) -> (min_x, max_x, min_y, max_y) because max_y-s0 = max_y - s2 = min_y? and then min_y+s0 = max_y? -> so candidate2 becomes (min_x, max_x, min_y, max_y) as well? 

          Similarly, candidate3: (max_x-s0, max_x, min_y, min_y+s0) -> (min_x, max_x, min_y, max_y) because max_x-s0 = min_x? and min_y+s0 = max_y.

          candidate4: (max_x-s0, max_x, max_y-s0, max_y) -> (min_x, max_x, min_y, max_y).

          So all 4 base candidates become the same candidate? 

        Then we generate candidate5 and candidate6: both become (min_x, max_x, min_y, max_y). candidate7 and candidate8: both become (min_x, max_x, min_y, max_y).

        So we have 8 duplicates? Then we check the same candidate 8 times? That's 8 * n -> 800000, which is acceptable.

        However, we can avoid by using a set to remove duplicates? 

        We'll do:

          set<tuple<LL,LL,LL,LL>> candSet;
          Then we insert the candidates.

          Then we iterate over the set.

        But the problem says: if there is a solution, we can output any candidate that works. And we break at the first one. So if we remove duplicates, we check each candidate only once.

        Alternatively, we can break early: if we check candidate1 and it fails, then candidate2 to candidate8 are the same? Then we break immediately? But we don't know if there is another candidate that might be different? Actually, in the case s1==s2, all candidates become the same? Then we only need to check one candidate? 

        But if s1 != s2, then we don't have duplicates? 

        So to be safe: we'll use a set to remove duplicates.

        Steps:

          set<tuple<LL,LL,LL,LL>> candSet;
          candSet.insert(make_tuple(min_x, min_x+s0, min_y, min_y+s0));
          candSet.insert(make_tuple(min_x, min_x+s0, max_y-s0, max_y));
          candSet.insert(make_tuple(max_x-s0, max_x, min_y, min_y+s0));
          candSet.insert(make_tuple(max_x-s0, max_x, max_y-s0, max_y));

          if (s1 >= s2) {
              candSet.insert(make_tuple(min_x, max_x, min_y, min_y+s1));
              candSet.insert(make_tuple(min_x, max_x, max_y-s1, max_y));
          }
          if (s2 >= s1) {
              candSet.insert(make_tuple(min_x, min_x+s2, min_y, max_y));
              candSet.insert(make_tuple(max_x-s2, max_x, min_y, max_y));
          }

        Then we iterate over the set.

        However, note: the problem constraints: the square must satisfy: -10^9<=x1<=x2<=10^9, and same for y. Our generated candidates satisfy that? 

        But what if s0 is negative? It cannot be: because s0 = max(s1, s2) and s1 = max_x-min_x (nonnegative), s2 similarly.

        But if n==0? but n>=1.

        Also, what if s0 is very large? We are storing long long.

 20. Code:

        #include <iostream>
        #include <vector>
        #include <set>
        #include <cctype>
        #include <algorithm>
        #include <climits>
        #include <tuple>
        #include <cmath>
        #include <cstdlib>
        using namespace std;

        typedef long long LL;

        int main() {
            ios::sync_with_stdio(false);
            cin.tie(0);

            int n;
            cin >> n;
            vector<LL> xs, ys;
            vector<pair<LL,LL>> points;
            for (int i=0; i<n; i++) {
                LL x, y;
                cin >> x >> y;
                xs.push_back(x);
                ys.push_back(y);
                points.push_back({x,y});
            }

            LL min_x = *min_element(xs.begin(), xs.end());
            LL max_x = *max_element(xs.begin(), xs.end());
            LL min_y = *min_element(ys.begin(), ys.end());
            LL max_y = *max_element(ys.end(), ys.end());

            LL s1 = max_x - min_x;
            LL s2 = max_y - min_y;
            LL s0 = max(s1, s2);

            set<tuple<LL,LL,LL,LL>> candSet;

            // Candidate 1: bottom-left to top-right with side s0 starting at (min_x, min_y)
            candSet.insert(make_tuple(min_x, min_x+s0, min_y, min_y+s0));
            // Candidate 2: bottom-left to top-right but shifted vertically: (min_x, min_x+s0, max_y-s0, max_y)
            candSet.insert(make_tuple(min_x, min_x+s0, max_y-s0, max_y));
            // Candidate 3: (max_x-s0, max_x, min_y, min_y+s0)
            candSet.insert(make_tuple(max_x-s0, max_x, min_y, min_y+s0));
            // Candidate 4: (max_x-s0, max_x, max_y-s0, max_y)
            candSet.insert(make_tuple(max_x-s0, max_x, max_y-s0, max_y));

            if (s1 >= s2) {
                candSet.insert(make_tuple(min_x, max_x, min_y, min_y+s1));
                candSet.insert(make_tuple(min_x, max_x, max_y-s1, max_y));
            }
            if (s2 >= s1) {
                candSet.insert(make_tuple(min_x, min_x+s2, min_y, max_y));
                candSet.insert(make_tuple(max_x-s2, max_x, min_y, max_y));
            }

            // Now iterate over the candidate set
            for (auto cand : candSet) {
                LL x1, x2, y1, y2;
                tie(x1, x2, y1, y2) = cand;

                // Check if the candidate is within the bounds? The problem allows from -10^9 to 10^9, and we have ensured that? 
                // But we must check the condition: x1<=x2 and y1<=y2? Our generation ensures that? 
                //   because s0>=0, s1>=0, s2>=0 -> so we add nonnegative to min_x? and subtract nonnegative from max_x? so x1<=x2 and y1<=y2.

                bool valid = true;
                for (int i=0; i<n; i++) {
                    LL x = points[i].first;
                    LL y = points[i].second;
                    if (x == x1 || x == x2 || y == y1 || y == y2) {
                        continue;
                    }
                    valid = false;
                    break;
                }
                if (valid) {
                    cout << x1 << " " << x2 << " " << y1 << " " << y2 << endl;
                    return 0;
                }
            }

            cout << "Impossible" << endl;
            return 0;
        }

 21. But note: the problem says: the square must be defined by two opposite corners? And our candidate is (x1,x2,y1,y2) meaning the square has corners (x1,y1) and (x2,y2) and the other two corners are (x1,y2) and (x2,y1). This is correct.

 22. However, we must be cautious: the candidate set might be empty? But we always generate at least 4 candidates? Then conditionally more.

 23. Test with sample1: 
        n=3, points: (7,6), (2,4), (4,0)
        min_x=2, max_x=7, min_y=0, max_y=6 -> s1=5, s2=6, s0=6.

        Candidates:
          cand1: (2,2+6=8,0,0+6=6) -> (2,8,0,6)
          cand2: (2,8,6-6=0,6) -> (2,8,0,6) -> duplicate? 
          cand3: (7-6=1,7,0,6) -> (1,7,0,6)
          cand4: (1,7,0,6) -> duplicate? Actually: (1,7,0,6) is distinct from (2,8,0,6) -> so we have two distinct.

        Then condition: s1>=s2? 5>=6 -> false -> so no candidate5,6.
        s2>=s1? 6>=5 -> true -> so we generate:
          cand7: (2,2+6=8,0,6) -> (2,8,0,6) -> duplicate
          cand8: (7-6=1,7,0,6) -> duplicate.

        So the set has two candidates: (2,8,0,6) and (1,7,0,6).

        Then we check the candidate (2,8,0,6) first? 
            (7,6): x=7 -> not 2 or 8? -> wait, 8 is the right border? So we have x1=2, x2=8 -> so x=7 is not 2 or 8? but y=6 is the top border? so valid? 
            (2,4): x=2 -> valid.
            (4,0): y=0 -> valid.

        So we output (2,8,0,6) and return.

        But note: the sample output is "2 8 0 6".

 24. However, we have candidate (1,7,0,6): 
        (7,6): x=7 -> valid? because x2=7 -> so x=7 is the right border? and y=6 is the top border? valid.
        (2,4): x=2 -> not 1 or 7? y=4 -> not 0 or 6? -> invalid.

        So we skip.

 25. Therefore, we output the first candidate that is valid? But the set is unordered? We don't care which one we output? The problem says: output any.

        But note: the set will iterate in increasing order? Actually, set of tuples: (x1,x2,y1,y2) -> lex order? 

        We don't care as long as we output one valid candidate.

 26. But what if the set iterates (1,7,0,6) first? Then we check it and it fails, then we check (2,8,0,6) and it passes? That's acceptable.

 27. We'll use the above code.

 28. Edge: if the candidate has negative side? But s0, s1, s2 are nonnegative.

 29. However, what if s0 is so large that we exceed the integer bounds? The problem says the coordinates of the candidate must be between -10^9 and 10^9.

        Example: min_x = -10^8, s0=200000000 -> then min_x+s0 = 100000000 -> which is <= 10^9? 
        But worst-case: min_x = -10^8, s0 = 200000000 -> then min_x+s0 = 100000000 -> within bounds.

        But what if min_x = -10^9? Actually, the input constraints: X_i in [-10^8,10^8] -> so min_x >= -10^8. Similarly, s0 <= 200000000. So min_x+s0 <= 10^8 + 200000000 = 300000000, which is < 10^9? 

        Actually, 10^9 is 1000000000 -> 300000000 < 1000000000 -> so it's safe.

        Similarly, min_x = -10^8, then min_x+s0 = -10^8+200000000 = 100000000 -> which is positive and within bounds.

        Also, subtracting: max_x-s0: max_x<=10^8, s0=200000000 -> then max_x-s0 <= 10^8 - 200000000 = -100000000 -> which is negative? But that's okay because we are allowed down to -10^9.

        So we are safe.

 30. But note: when we do max_y-s0: if s0 is very large, then max_y-s0 might be very negative? But we have the constraint that the candidate must have y1<=y2? and we are storing as (y1,y2) in the tuple? Actually, we generate:

        For candidate2: (min_x, min_x+s0, max_y-s0, max_y) -> we require max_y-s0 <= max_y? yes, because s0>=0. But what if max_y-s0 < min_y? Then the square extends below the min_y? But that's acceptable because the square can be larger than the bounding box? 

        The condition for the square: the borders must cover all the points? The points have y in [min_y, max_y]. The candidate square has bottom border at max_y-s0. We require that the bottom border is at most min_y? Actually, no: the condition is that every point must lie on one of the borders. The square's borders are at x=min_x, x=min_x+s0, y=max_y-s0, y=max_y. 

        But the point at min_y: if min_y is greater than max_y-s0? Then the point at min_y is above the bottom border? But we require the point to be on one of the borders? 

        Actually, the point at min_y: we have a point at (x, min_y). We require that either x is one of the vertical borders OR y=min_y is one of the horizontal borders? But the horizontal borders are at y=max_y-s0 and y=max_y. 

        So unless min_y equals max_y-s0 or max_y, the point at min_y would not be on the border? 

        Therefore, the candidate generation must be such that the square covers the bounding box? Actually, the square must cover the bounding box? 

        How do we know? The square must enclose the points? Actually, the problem does not require that the square is the minimal one? It can extend arbitrarily? 

        But the condition: the point must lie on the border. So if the square extends below min_y, then the point at min_y is not on the border? Unless min_y is the bottom border? 

        Actually, the candidate2: the bottom border is max_y-s0. We require that the point at min_y must be on one of the borders? But min_y might be greater than max_y-s0? Then the point at min_y is above the bottom border? and not equal to the top border? unless min_y==max_y? 

        But then the point at min_y must lie on the top border? because max_y is the top border? and min_y==max_y? Then it is on the top border? 

        So the candidate2 is defined as: 
            x1 = min_x, x2 = min_x+s0, 
            y1 = max_y-s0, y2 = max_y.

        The condition for a point (x,y) to be on the border: 
            x==x1 or x==x2 or y==y1 or y==y2.

        Now, the point (x, min_y) must be in the set? and min_y must be either y1 or y2? 
            y2 = max_y -> and min_y <= max_y, but if min_y != max_y and min_y != max_y-s0, then the point (x,min_y) is not on the border? 

        Therefore, the candidate2 might not be valid? 

        But in our candidate generation, we are generating candidate2 unconditionally? Then we check? So if the point at min_y is not on the border, candidate2 fails? 

        Similarly, candidate1: the bottom border is min_y? so the point at min_y is on the bottom border? 

        Why do we generate candidate2? Because we want to consider a square that has the top border aligned at max_y? Then we set the bottom border to max_y-s0? But if s0 = max(s1,s2) and s2 = max_y-min_y, then max_y-s0 <= min_y? 
            s0 = max(s1, s2) >= s2 -> so max_y-s0 <= max_y-s2 = min_y? 
            Therefore, the bottom border is at most min_y? 

            Actually: max_y - s0 <= max_y - s2 = min_y? because s0>=s2 -> so max_y-s0 <= min_y.

        So the point at min_y: it lies on the top border? no, because the top border is max_y. On the bottom border? the bottom border is max_y-s0, which is <= min_y. But the point at min_y: if max_y-s0 < min_y, then the bottom border is below min_y? and the point at min_y is not on the bottom border? 

        However, note: the square must cover the entire set? The condition is that the point must lie on the border. The border of the square is the four lines. The point at min_y: if min_y is strictly greater than the bottom border? then the point is between the bottom and top? so not on the border? 

        Therefore, candidate2 is only valid if max_y-s0 == min_y? 

        Actually, we don't require that? We require that every point is on one of the borders. The point at min_y must be on one of the borders. In candidate2, the borders are the two vertical sides and the two horizontal sides: y=max_y-s0 and y=max_y. The point at min_y: if min_y is not equal to max_y-s0 and not max_y, then it fails? 

        But we know: the points have y in [min_y, max_y]. The square's vertical range is [max_y-s0, max_y]. We require min_y to be in that interval? Actually, the square must cover the points? The point at min_y must lie within the square? But the problem does not require that? It requires the point to be on the border? 

        Actually, the point must lie on the border? So the point at min_y must be either at the bottom border (y=max_y-s0) or the top border (y=max_y). 

        Since min_y is the minimum y, and the top border is max_y (which is >=min_y), the only possibility for the point at min_y to be on the border is if min_y == max_y-s0? 

        But note: the square might extend below min_y? Then the point at min_y is above the bottom border? and not on the border? 

        Therefore, candidate2 is only valid if min_y == max_y-s0? 

        But in our generation, we set s0 = max(s1, s2). And s2 = max_y-min_y. 
          Then min_y = max_y - s0? 
          => s0 = max_y - min_y = s2? 
          => so we require s0 = s2? and also s0>=s1? 

        So if s0 = s2, then min_y = max_y-s0? then the bottom border is min_y? Then the point at min_y is on the bottom border? 

        Therefore, candidate2 is only valid when s0==s2? 

        Similarly, candidate4: (max_x-s0, max_x, max_y-s0, max_y) -> the bottom border is max_y-s0? then the point at min_y must be on the border? which requires min_y==max_y-s0? -> so s0==s2.

        candidate3: the bottom border is min_y? so the point at min_y is on the bottom border? so no problem? 

        Actually, candidate1: bottom border is min_y? so the point at min_y is on the border? 
        candidate3: bottom border is min_y? so the point at min_y is on the border? 
        candidate2: requires s0==s2 to have the bottom border at min_y? 
        candidate4: same.

        But wait: in candidate2, we set the bottom border to max_y-s0. If s0>s2, then max_y-s0 < min_y? Then the square does not even cover the point at min_y? because the square's bottom border is below min_y? and the point at min_y is above the bottom border? 

        Actually, the square must cover the point? The point at min_y must lie within the square? Or is it only required to be on the border? 

        The problem: "All of the points must lie on the border of the square (inclusive of its vertices)."

        But if the square extends below min_y, then the point at min_y is inside the square? but not on the border? 

        Therefore, the candidate2 must have the bottom border at min_y? which requires s0=s2? 

        So why do we generate candidate2 unconditionally? 

        We must adjust: the candidate2 is only valid if the bottom border is min_y? But we generated it unconditionally? 

        Actually, we have no choice: the square must have the top border at max_y? Then the bottom border must be max_y - s0. And for the point at min_y to be on the border, we require min_y = max_y - s0? 

        Therefore, candidate2 is only valid when s0 = s2? 

        Similarly, candidate4: only valid when s0 = s2? 

        candidate1 and candidate3: require that the top border is min_y+s0? and we require that the top border is at least max_y? so min_y+s0>=max_y -> s0>=max_y-min_y=s2 -> which is true by definition of s0? 

        But the point at max_y: must be on the border? In candidate1: the top border is min_y+s0? and we require max_y <= min_y+s0? and we have min_y+s0>=min_y+s2 = max_y? so max_y<=min_y+s0? and we require the point at max_y to be on the top border? which requires max_y = min_y+s0? 

        So candidate1 is only valid when min_y+s0 = max_y? -> s0 = s2? 

        Similarly, candidate3: same condition? 

        Therefore, the only candidates that are valid are when s0 = s2? 

        But what if s0 = s1? Then candidate1: we require min_y+s0 = max_y? -> s0 = s2? so if s0 = s1 and s0 != s2, candidate1 fails? 

        Then how did sample1 work? 
          sample1: s0 = 6, s2 = 6 -> so s0=s2 -> candidate1: min_y+s0 = 0+6=6 = max_y -> so the top border is max_y? so candidate1 is valid.

        Then candidate2: also requires s0=s2 -> so candidate2 is also valid? 

        But candidate2: (min_x, min_x+s0, max_y-s0, max_y) = (2,8,6-6=0,6) -> which is (2,8,0,6) -> same as candidate1? 

        Actually: candidate1: (2,8,0,6) and candidate2: (2,8,0,6) -> same candidate.

        So the condition for candidate1 and candidate2 to be valid is s0=s2? 

        Similarly, candidate5: (min_x, max_x, min_y, min_y+s1) -> requires min_y+s1>=max_y? and we require the top border to be min_y+s1? and the point at max_y must be on the top border? so min_y+s1 = max_y? -> s1 = s2? 
        candidate6: (min_x, max_x, max_y-s1, max_y) -> requires max_y-s1 = min_y? -> s1 = s2? 

        candidate7: (min_x, min_x+s2, min_y, max_y) -> the right border is min_x+s2? and we require that the point at max_x is on the right border? so min_x+s2 = max_x? -> s2 = s1? 
        candidate8: (max_x-s2, max_x, min_y, max_y) -> requires max_x-s2 = min_x? -> s2 = s1? 

        Therefore, we have:

          candidate1: requires s0 = s2? 
          candidate2: requires s0 = s2? 
          candidate3: requires s0 = s2? 
          candidate4: requires s0 = s2? 
          candidate5: requires s1 = s2? 
          candidate6: requires s1 = s2? 
          candidate7: requires s1 = s2? 
          candidate8: requires s1 = s2? 

        But note: s0 = max(s1,s2). 
          If s0 = s2, then s2>=s1? so s0 = s2>=s1.
          If s0 = s1, then s1>=s2.

        So:

          candidate1 to candidate4: valid only when s0 = s2? (i.e., s2>=s1) 
          candidate5 to candidate8: valid only when s1 = s2? (which implies s0 = s1 = s2) 

        But wait: candidate5: we generate when s1>=s2? and candidate5 requires s1=s2? 
          candidate6: same.

        candidate7: we generate when s2>=s1? and candidate7 requires s1=s2? 
          candidate8: same.

        Therefore, the candidate generation is:

          candidate1 to candidate4: generated unconditionally? but they are only valid when s0=s2? 
          candidate5 and candidate6: generated when s1>=s2? and they are only valid when s1=s2? 
          candidate7 and candidate8: generated when s2>=s1? and they are only valid when s1=s2? 

        So the only candidates that are valid are those that satisfy the condition? 

        How do we check? 

        We can precompute the conditions and then generate only the candidates that satisfy the condition? 

        Alternatively, we can generate all 8 candidates and then check the condition during the candidate validation? 

        But we are going to check every candidate by iterating over the points? 

        However, if we generate a candidate that we know is invalid by the condition (for example, candidate1 when s0 != s2), then we will iterate over the points and it will fail? 

        But the point at max_y: in candidate1: the top border is min_y+s0? and if s0 != s2, then min_y+s0 != max_y? and the point at max_y is not on the border? so we break quickly.

        So it's acceptable.

        Therefore, we keep the generation as is.

 31. Final code: as above.

 32. But note: the candidate set might include duplicates? and we are using a set to remove them? 

        We'll run the sample1: we generated 6 candidates? but the set had 2? 

        But the sample1: s0=6, s1=5, s2=6 -> s0=s2 -> so candidate1 and candidate2 are the same? and candidate5 and candidate6 are not generated? candidate7 and candidate8 are generated? and candidate7 is the same as candidate1? candidate8 is the same as candidate3? 

        Actually: 
          candidate1: (2,8,0,6)
          candidate2: (2,8,0,6) -> same as candidate1 -> so set has one: (2,8,0,6)
          candidate3: (1,7,0,6)
          candidate4: (1,7,0,6) -> same as candidate3 -> set has two: (2,8,0,6) and (1,7,0,6)

          Then condition: s1>=s2? 5>=6? false -> skip candidate5,6.
          s2>=s1? true -> so generate:
             candidate7: (2,2+6=8,0,6) -> (2,8,0,6) -> already in set.
             candidate8: (7-6=1,7,0,6) -> (1,7,0,6) -> already in set.

        So the set size is 2.

        Then we check (1,7,0,6) first? fails at (2,4) -> then check (2,8,0,6) -> passes.

        So we output (2,8,0,6).

 33. Final code with set to remove duplicates.

 34. However, we note: the candidate set might be up to 8? but duplicates reduce the size.

 35. Run the degenerate case: 
        n=1: (0,0)
        min_x=0, max_x=0, min_y=0, max_y=0 -> s1=0, s2=0, s0=0.

        Candidates:
          cand1: (0,0,0,0)
          cand2: (0,0,0-0=0,0) -> (0,0,0,0) -> same
          cand3: (0-0=0,0,0,0) -> same
          cand4: same.

          Then: s1>=s2? 0>=0 -> true -> generate:
                 cand5: (0,0,0,0) -> same
                 cand6: (0,0,0-0=0,0) -> same
          s2>=s1? true -> generate:
                 cand7: (0,0,0,0) -> same
                 cand8: same.

        So the set has one candidate: (0,0,0,0). Then we check: the point (0,0) -> valid.

 36. Another test: two points (0,0) and (1,0) -> 
        min_x=0, max_x=1, min_y=0, max_y=0 -> s1=1, s2=0, s0=1.
        Candidates:
          cand1: (0,1,0,1) -> (0,1,0,1)
          cand2: (0,1,0-1=-1,0) -> (0,1,-1,0)
          cand3: (1-1=0,1,0,1) -> (0,1,0,1) -> duplicate
          cand4: (0,1,-1,0) -> duplicate

          Then: s1>=s2? true -> generate:
                 cand5: (0,1,0,0+1=1) -> (0,1,0,1) -> duplicate
                 cand6: (0,1,0-1=-1,0) -> duplicate
          s2>=s1? false -> skip.

        So set: two candidates: (0,1,0,1) and (0,1,-1,0)

        Check candidate1: (0,1,0,1):
            (0,0): y=0 -> valid.
            (1,0): y=0 -> valid? but wait: the square has borders: x=0, x=1, y=0, y=1. The point (1,0) is at the bottom-right corner? so it is on the border? valid.

        Then output candidate1? 

        But what about candidate2: (0,1,-1,0):
            (0,0): y=0 -> valid? because the top border is y=0? and the bottom border is y=-1? so the point (0,0) is on the top border? 
            (1,0): same? valid.

        So both are valid? We output the first one? 

        The problem: output any.

        But note: the problem requires the output to have: -10^9<=X1<=X2<=10^9 and -10^9<=Y1<=Y2<=10^9. Both candidates satisfy.

        However, the problem does not specify which one? So we output the first one we check? 

        The set: how is it ordered? 
          (0,1,0,1) and (0,1,-1,0) -> 
          The tuple (0,1,0,1) and (0,1,-1,0) -> 
          The first two numbers are the same? then compare the third: 0 vs -1 -> so (0,1,-1,0) < (0,1,0,1) -> so the set will iterate (0,1,-1,0) first? 

        Then we output (0,1,-1,0)? 

        But the problem sample output format? 

        Alternatively, we can output the candidate that has the smallest lex order? 

        But the problem says: output any.

        So we output (0,1,-1,0) first? 

        However, we can change the candidate generation to output the candidate that we prefer? 

        But the problem does not specify.

        We'll output the candidate that the set gives first? 

        The set is sorted by the tuple: (x1, x2, y1, y2). 

        For (0,1,-1,0): (0,1,-1,0)
        For (0,1,0,1): (0,1,0,1) -> which is greater? because -1<0.

        So we output (0,1,-1,0).

        But the problem sample output #1 was "2 8 0 6", which has y1=0 and y2=6? which is the candidate that has y1=min_y? 

        We don't care? 

        However, note: the problem statement says: "If there are multiple valid answers, you may output any of them."

        So we are safe.

 37. Therefore, we write the code as described.

 38. One more test: 
        Input: 
            4
            0 0
            0 1
            1 0
            1 1

        min_x=0, max_x=1, min_y=0, max_y=1 -> s1=1, s2=1, s0=1.

        Candidates:
          cand1: (0,1,0,1) -> (0,1,0,1)
          cand2: (0,1,1-1=0,1) -> same as cand1.
          cand3: (1-1=0,1,0,1) -> same.
          cand4: same.

          Then: s1>=s2? true -> generate:
                  cand5: (0,1,0,0+1=1) -> same.
                  cand6: same.
          s2>=s1? true -> generate:
                  cand7: (0,0+1=1,0,1) -> same.
                  cand8: same.

        Set: one candidate: (0,1,0,1).

        Check: 
            (0,0): on border? x=0 -> valid.
            (0,1): x=0 -> valid? Actually, also y=1? valid.
            (1,0): x=1 -> valid? and (1,1): x=1 or y=1 -> valid.

        So output (0,1,0,1).

 39. Code:

        Note: We use long long for all.

        We read the points, compute the min/max, then generate the candidates.

        We use a set of tuples (x1,x2,y1,y2). Then iterate over the set and check.

        If we find a valid candidate, output and return.

        Otherwise, output "Impossible".

 40. Let's code accordingly.

 41. But note: the candidate generation: 
        candSet.insert(make_tuple(min_x, min_x+s0, min_y, min_y+s0));
        ... etc.

        But note: the tuple is (x1, x2, y1, y2) -> we must output as: x1, x2, y1, y2.

 42. We output: 
        cout << x1 << " " << x2 << " " << y1 << " " << y2 << endl;

 43. Submit.

 44. However, note: the problem constraints: n up to 10^5, and we are doing for each candidate: a loop of n? and we have at most 8 distinct candidates? so worst-case 800000, which is acceptable in C++ (1s).

 45. We'll run the worst-case: 10^5 points and 8 candidates -> 800000 comparisons? which is acceptable.

 46. Final code: