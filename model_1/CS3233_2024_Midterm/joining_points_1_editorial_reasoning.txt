We are given N points (up to 10^5) and we need to form a square with sides parallel to the axes such that every point lies on the border of the square.

Note: The square can be degenerate (i.e., side length 0, which would be a single point).

The square is defined by two opposite corners (x1, y1) and (x2, y2) with x1 <= x2 and y1 <= y2. However, note that the square has sides that are horizontal and vertical. Therefore, the square's sides are determined by:
  - Left vertical: x = x1
  - Right vertical: x = x2
  - Bottom horizontal: y = y1
  - Top horizontal: y = y2

But note: the side length of the square must be the same for all sides. However, the square defined by opposite corners (x1, y1) and (x2, y2) would have side length = (x2 - x1) and height (y2 - y1). For a square, we require x2 - x1 = y2 - y1.

However, the problem does not require the two opposite corners to be adjacent? Actually, in a square with axis-aligned sides, two opposite corners are sufficient to define the square. But note: the two opposite corners must be such that the square they form is axis-aligned. Specifically, the square will have:
  - Corners: (x1, y1), (x1, y2), (x2, y1), (x2, y2)
But for this to be a square, we require that the side length (x2 - x1) equals the height (y2 - y1). So we require s = x2 - x1 = y2 - y1.

However, the problem says: "output four integers X1, X2, Y1, and Y2, the coordinates of two opposite corners of the square" and note that the constraints say X1<=X2 and Y1<=Y2. This implies that the two opposite corners are the bottom-left and top-right? But actually, two opposite corners could also be bottom-right and top-left? However, the constraints require X1<=X2 and Y1<=Y2, so we are forced to output the bottom-left (x1,y1) and top-right (x2,y2). Therefore, the square must be defined by the bottom-left (x1,y1) and top-right (x2,y2) with side length s = x2-x1 = y2-y1.

But note: the problem says "any two opposite corners", and with the constraints on ordering, we are outputting the two that form the bottom-left and top-right. However, if we had chosen the top-left and bottom-right, we would have to output (x1,y2) and (x2,y1) but then we cannot satisfy both x1<=x2 and y1<=y2? Because if we take top-left (x1,y2) and bottom-right (x2,y1), then to have x1<=x2 and y1<=y2 we would have to output (x1, y1) and (x2, y2) but that would be the same as the bottom-left and top-right? Actually, no. The top-left is (x1, y2) and bottom-right is (x2, y1). We cannot output (x1,y2) and (x2,y1) because then we require x1<=x2 and y2<=y1? which is not the same as the constraints. So the problem specifies we output (X1,X2,Y1,Y2) meaning the first corner is (X1,Y1) and the second is (X2,Y2) and we have the constraints on ordering. Therefore, we are forced to represent the square by the bottom-left (x1,y1) and top-right (x2,y2) and the side length s = x2-x1 = y2-y1.

However, note: the problem does not require the square to be non-degenerate. So s=0 is allowed.

What does it mean for a point to lie on the border?
A point (x, y) must lie on one of the four sides. That is:
  - x = x1 and y in [y1, y2]
  - x = x2 and y in [y1, y2]
  - y = y1 and x in [x1, x2]
  - y = y2 and x in [x1, x2]

But note: the square has side length s = x2-x1 = y2-y1. Therefore, the border is the union of these four segments.

How do we approach the problem?

Let the square be defined by (x1, y1) and (x2, y2) with s = x2 - x1 = y2 - y1.

We require that every point (X_i, Y_i) satisfies at least one of:
  (a) X_i == x1 and y1 <= Y_i <= y2
  (b) X_i == x2 and y1 <= Y_i <= y2
  (c) Y_i == y1 and x1 <= X_i <= x2
  (d) Y_i == y2 and x1 <= X_i <= x2

But note: the corners (x1,y1), (x1,y2), (x2,y1), (x2,y2) are included in two sides, but that's okay.

Constraints: We have up to 10^5 points, and coordinates as large as 10^8.

We cannot iterate over all possible squares. So we must use the properties of the points.

Observation:

In such a square, the border consists of four segments. The extreme values of x and y among the points must be the boundaries of the square. Why?

Consider the entire set of points. The square must cover the x and y ranges of the points. Therefore, we must have:
  x1 <= min_x <= max_x <= x2
  y1 <= min_y <= max_y <= y2

Moreover, the square's boundaries must be at least as wide as the bounding box of the points. But note: the square must have equal side lengths. Therefore, the side length s must be at least max(max_x - min_x, max_y - min_y). Why? Because the square must cover the entire spread in both x and y.

But actually, the square must have side length s = (x2-x1) = (y2-y1). And the entire set of points must be contained in the rectangle [x1, x2] x [y1, y2]. Therefore, we must have:
  x1 <= min_x and x2 >= max_x
  y1 <= min_y and y2 >= max_y

and s = x2-x1 = y2-y1.

Moreover, the border condition: every point must lie on one of the four borders. Therefore, any point that is strictly inside the square (i.e., with x1 < x < x2 and y1 < y < y2) would be invalid.

So the square must have boundaries that are the extreme values? Not necessarily: the boundaries could extend beyond the extremes? Why? Because we might need to cover points that are on the border but the extreme points might not form a square of equal sides.

But note: if we have a point that is not at the extreme, we can only put it on the border by having the border at that coordinate. However, the square must be contiguous. Therefore, the boundaries must be at least the min and max in x and y? Actually, no: consider a point that is not at the extreme in x but at the extreme in y: we can put it on the top or bottom border without extending the x-boundaries? But the problem is that the square has fixed side length s. So the x boundaries must be exactly s apart and the y boundaries must be exactly s apart. Therefore, we have two degrees of freedom: the left boundary (x1) and the bottom boundary (y1), and then the side length s. Then x2 = x1+s and y2 = y1+s.

But note: the square might be defined such that the boundaries are not exactly the min and max of the points? For example, the entire set of points might be contained in [x1, x2] and [y1, y2] and the border condition must hold.

However, we can deduce the necessary boundaries. The square must have:
  x1 = min_x? Not necessarily. We could set x1 to be less than min_x? Then we would require that all points are at least at x = x1? But then the left border would be at x1 and there would be no point on that border? How can we have a point on the border at x1? Then we must have at least one point at x1. Similarly, we must have at least one point at x2 (for the right border) and at least one at y1 and at y2.

Therefore, we must have:
  x1 = min_x of the points? Actually, no: because we might have a point that is the leftmost, but we could set x1 to be even more left? Then that leftmost point would be the only one at x1? But then the left border would be covered. Similarly, we might set x2 to be larger than the rightmost point? Then the right border must have a point? But we don't have a point at x2? Then that border is not covered by any point? But the condition requires that every point is on the border, but it does not require that the entire border must have points. However, the problem says "All of the points must lie on the border", meaning that we don't care if the border extends beyond the points. But we cannot have a border that does not cover a point that is in the interior? Actually, we are free to choose the square arbitrarily as long as the points lie on the border.

But note: if we set x1 to be less than the min_x, then the entire set of points would lie to the right of x1. But then the left border (x=x1) would have no point? That is acceptable? Actually, no: because the problem says "connect all the points" such that the resulting shape is a square. The square is defined by its borders. The points must lie on the border, but we are not required to have every border segment covered by a point? The problem does not say that the border must be entirely covered by the points. It only says that every given point must lie on the border.

So it is acceptable to have a border that extends beyond the points? Then we can set:
  x1 = min_x? Or we can set x1 to be less than min_x? But then we must also set x2 = x1 + s, and similarly for y.

However, if we set x1 arbitrarily, then the side length s must be at least (max_x - x1) and similarly, for the right border: we must have x2 >= max_x. Also, the side length s must be the same in y. So s = x2 - x1 = y2 - y1.

But now, we have many choices? How to choose x1 and y1? Actually, we are constrained by the requirement that the entire set of points must lie on the border. That is, for every point (x, y):
  x must be either x1 or x2, OR y must be either y1 or y2.

But note: we also have the freedom to choose s arbitrarily? However, s must be at least the maximum of (max_x - x1, max_y - y1) and also at least the maximum of (x2 - min_x, y2 - min_y) but actually we have x2 = x1+s and y2 = y1+s.

Alternatively, we can think: the entire set of points must be contained in the square [x1, x1+s] x [y1, y1+s]. And every point must be on the border. Therefore, no point can be strictly inside: x1 < x < x1+s and y1 < y < y1+s.

Now, let us define:
  L = min_x (the smallest x-coordinate in the set)
  R = max_x
  B = min_y
  T = max_y

But note: we might not use L as x1? However, if we set x1 < L, then we must set x2 = x1+s >= R. Then the condition for a point (x,y) to be on the border: either x==x1 (which is not true for any point, because L is the minimum and we set x1 < L) or x==x2 (which would be the right border) or y==y1 or y==y2. So the points that are not on the right border must be on the top or bottom. But the left border is not covered by any point? That is acceptable.

Similarly, we can set y1 < B and y2 = y1+s >= T.

So we have:
  x1 = any value <= L
  x2 = x1 + s >= R
  y1 = any value <= B
  y2 = y1 + s >= T

But then the side length s must be at least max(R - x1, T - y1). However, we also have the constraint that s = x2-x1 = y2-y1. Therefore, we have:
  s >= max(R - x1, T - y1)

But note: we can also set x1 to be greater than L? Then we would require that the left border (x1) must be covered by at least one point? Actually, we don't require that every border segment has a point, but we require that every point is on the border. So if we set x1 > L, then the point at L would not be on the left border? But the left border is at x1, and L < x1? Then the point at L is not on the border? That is invalid.

Therefore, we must have x1 <= L. Similarly, we must have x2 >= R, y1 <= B, y2 >= T.

Moreover, for the interior: no point can have x1 < x < x2 and y1 < y < y2.

Now, what should s be? We have s = x2 - x1 = y2 - y1.

We also know that:
  x1 <= L, x2 = x1+s >= R  => s >= R - x1
  y1 <= B, y2 = y1+s >= T  => s >= T - y1

But we can choose x1 and y1 arbitrarily as long as x1<=L and y1<=B? However, we have the constraint that every point must lie on the border. Therefore, for a point (x,y) that is not on the left/right and not on the bottom/top, we must avoid having it in the interior.

But note: the interior is (x1, x2) x (y1, y2) without the borders. So we require that for every point (x,y), either x==x1 or x==x2 or y==y1 or y==y2.

How can we choose x1 and y1? Actually, we can set x1 and y1 independently? Not exactly: because s must be the same for both. So s must be at least max(R - x1, T - y1). But we can set x1 and y1 arbitrarily low? Then s becomes large. However, we must avoid having any point in the interior.

But note: if we set x1 very low and y1 very low, then the square is very large. Then the interior is huge. Then we must check that every point is on one of the borders. How to check that? For each point, we require that either x==x1 or x==x1+s or y==y1 or y==y1+s.

But we have freedom to choose x1 and y1 arbitrarily? Then we can set:
  x1 = L - a, for some a>=0
  y1 = B - b, for some b>=0
  s = max(R - x1, T - y1)   [to minimize s? But note: we can set s larger?]

But if we set s larger than max(R-x1, T-y1), then the borders extend beyond. Then we have to check the condition for every point.

But we can also set x1 = L and y1 = B? Then s must be at least max(R-L, T-B). Then we set s0 = max(R-L, T-B). Then we set x2 = x1 + s0, y2 = y1 + s0.

Then we check: every point must be either at x1, x2, y1, or y2.

But wait: what if the side length must be exactly s0? Then we set the square as [L, L+s0] x [B, B+s0]. Then we check every point.

But is this the only possibility? Actually, we might set s larger than s0. Then the borders are extended. Then we must set x1 <= L and y1 <= B, and then x2 = x1+s and y2 = y1+s, and s must be at least max(R-x1, T-y1). Then we can set s arbitrarily as long as it is at least that. However, if we set s too large, then the condition for a point (x,y) to be on the border becomes harder? Actually, no: because the point must be either on the left (x=x1) or right (x=x1+s) or bottom (y=y1) or top (y=y1+s). If we set x1 too low, then the left border (x=x1) is very far to the left, and no point (except maybe one at x1) will be on the left? Similarly, we don't have any point at x1? Then the only way a point is on the border is by being on the right, bottom, or top. Similarly, if we set y1 too low, then the bottom border might not have any point.

But note: we have a point at L (the minimum x) and at B (the minimum y). How do we use them? The point at L must be on the left border? But if we set x1 < L, then the point at L is not at x1? Then it must be on the bottom or top? But the point at L has y-coordinate which we don't know. Similarly, the point at B has x-coordinate which we don't know.

So we have two cases:

Case 1: We set the left border at L. Then the point at L is on the left border. Similarly, we set the bottom border at B. Then the point at B is on the bottom border. Then we set s = max(R - L, T - B). Then we set:
  x1 = L, y1 = B, x2 = L+s, y2 = B+s.

Then we check every point: they must be on the border.

Case 2: We do not set the left border at L? Then we set x1 < L. Then the point at L must be on the right border? Because it cannot be on the left (x1) and it cannot be strictly inside. So we require that L = x2 = x1+s. Similarly, we might set the bottom border at B? Or not? 

Alternatively, we can consider that the square might be defined by:

  x1 and x2 = x1 + s
  y1 and y2 = y1 + s

and the constraints:
  x1 <= L, x1+s >= R
  y1 <= B, y1+s >= T

and also:
  For every point (x,y):
      x == x1 OR x == x1+s OR y == y1 OR y == y1+s.

Moreover, we have the extreme points: 
  The point at L: must have L = x1 or L = x1+s. But we set x1 < L, so L must equal x1+s.
  Similarly, the point at R: must be either x1 or x1+s? But we have R <= x1+s, and R is the maximum. Since L = x1+s, then R <= L? But L is the minimum x, so that is impossible unless R = L. Therefore, if we set x1 < L, then we must have L = x1+s and also R <= x1+s. But since L is the minimum, we have R>=L. So R<=x1+s and L=x1+s implies R<=L? Then R=L. So the entire set of points has the same x-coordinate? Then we set x1 = L - s, and then the right border is at L. Then the points must all have x=L? Then they are on the right border. Then we can set the y boundaries arbitrarily? But note: we also have the bottom and top.

But also, the side length s must be the same for y. So we set y1 and y2=y1+s. And we must have y1<=B and y1+s>=T.

But then the condition for the points: they are all at x = L (which is x1+s). So they are on the right border. Then we don't care about the y borders? Actually, no: the points must also not be in the interior? They are on the right border, so that's okay. But we must have the entire set of points lying on the border. Since they are on the right border, they are on the border.

Similarly, we could set the bottom border not at B? Then the point at B must be on the top border? So we have B = y1+s.

Therefore, we have two types of squares:

Type A: The square has the left border at the minimum x (x1 = L) and the bottom border at the minimum y (y1 = B). Then s = max(R-L, T-B) and then we set x2 = L+s, y2 = B+s.

Type B: The square has the right border at the minimum x? Wait, that doesn't make sense. Actually, we set the right border at the minimum x? Then the entire set of points must be at x = L (which is the right border). But then the left border is at x1 = L - s. Similarly, we can have the top border at the minimum y? Then the bottom border is at y1 = B - s, and the top border is at B. Or the bottom border at the maximum y? 

Actually, we have four possibilities for which borders are set at the extremes? But note: the borders are fixed: left, right, bottom, top. The extreme points (min_x, min_y, max_x, max_y) must lie on the border. Therefore, each extreme point must lie on one of the borders. But the min_x point must be either on the left border or the right border? Similarly, the max_x must be on the left or right? However, if the min_x is on the right border, then the entire set of points must be to the left of the right border? But then the min_x is the right border? Then all points are at the same x? Similarly for y.

Therefore, we have four cases:

Case 1: left border = min_x, bottom border = min_y. Then s = max(max_x - min_x, max_y - min_y). Then set the square as [min_x, min_x+s] x [min_y, min_y+s].

Case 2: left border = min_x, top border = max_y. Then the square must have:
  x1 = min_x
  y2 = max_y
  s = max(max_x - min_x, max_y - min_y)   ??? Actually, no: the side length s must be the same. Then we have:
      x2 = x1 + s
      y1 = y2 - s = max_y - s
  Then the bottom border is at max_y - s. We must have that max_y - s <= min_y (so that the entire set is above the bottom border). Therefore, s >= max_y - min_y. Also, s must be at least max_x - min_x.

  So s = max(max_x - min_x, max_y - min_y). Then the bottom border is at max_y - s. Then we must check that min_y >= max_y - s? Actually, the points must be above the bottom border? But the bottom border is max_y - s, and the points have y>=min_y. We require min_y >= max_y - s? Since s>=max_y-min_y, we have max_y - s <= min_y. Therefore, the entire set is contained in the y-direction? Then we set:
      x1 = min_x, x2 = min_x + s
      y1 = max_y - s, y2 = max_y

  And then check every point.

Case 3: right border = max_x, bottom border = min_y. Then:
      x2 = max_x
      y1 = min_y
      s = max(max_x - min_x, max_y - min_y)   [again?]
      Then x1 = x2 - s = max_x - s
      y2 = y1 + s = min_y + s
  Then we must have min_x >= max_x - s (which is satisfied if s>=max_x-min_x) and max_y <= min_y+s (which is satisfied if s>=max_y-min_y). Then set s = max(...). Then check.

Case 4: right border = max_x, top border = max_y. Then:
      x2 = max_x, y2 = max_y
      s = max(max_x-min_x, max_y-min_y)
      Then x1 = max_x - s, y1 = max_y - s.

But note: these four cases are actually symmetric. They correspond to the square being defined by:

  Case 1: bottom-left corner = (min_x, min_y)
  Case 2: top-left corner = (min_x, max_y) -> then bottom-left corner is (min_x, max_y - s) and top-right is (min_x+s, max_y)
  Case 3: bottom-right corner = (max_x, min_y) -> then bottom-left is (max_x - s, min_y) and top-right is (max_x, min_y+s)
  Case 4: top-right corner = (max_x, max_y) -> then bottom-left is (max_x - s, max_y - s)

But note: the problem requires we output the two opposite corners as (X1,X2,Y1,Y2) with X1<=X2 and Y1<=Y2. Therefore, we are forced to output the bottom-left and top-right? So:

  Case 1: we output (min_x, min_x+s, min_y, min_y+s)
  Case 2: we output (min_x, min_x+s, max_y-s, max_y)   [and note: min_y>=max_y-s, so max_y-s <= max_y, but we also require max_y-s<=min_y? Actually, no: we require min_y>=max_y-s? So max_y-s <= min_y? Then we have max_y-s <= min_y <= max_y. But the problem does not require the bottom to be less than the top? We set Y1 = max_y-s and Y2 = max_y, and we have max_y-s <= max_y, so that's okay. But note: the condition for the output: Y1<=Y2 is satisfied.

  Similarly, Case 3: we output (max_x-s, max_x, min_y, min_y+s)
  Case 4: we output (max_x-s, max_x, max_y-s, max_y)

But note: in Case 2, the bottom border is max_y-s and the top border is max_y. Then we have min_y>=max_y-s, so max_y-s <= min_y <= ... <= max_y. Therefore, the bottom border is below the minimum y? That is acceptable as long as the points are on the border.

However, we must check in each case that every point is on one of the borders.

But note: we have only 10^5 points, but we have 4 cases. We can try each case and check in O(n). Then if any case works, we output the square for that case.

But is that sufficient? Consider: what if the square is defined by non-extreme borders? For instance, we set the left border at a value less than min_x and the right border at min_x (so s = min_x - x1, and then the right border is at min_x). Then the entire set of points is at x>=min_x, so they are on the right border? Then the condition for the borders: every point must be either on the left border (x1) or the right border (min_x) or the bottom (y1) or top (y1+s). But we set the left border at x1 which is below min_x, so no point is at x1. Then every point must be either at x=min_x (right border) or at y=y1 or y=y1+s.

Similarly, we must set the bottom border: we can set it arbitrarily? But we must cover the min_y? The point at min_y must be on the bottom border? Or on the top border? 

Actually, we can have two independent choices for the horizontal and vertical? Specifically, we can choose:

  Either the left border is at min_x, OR the right border is at min_x (if the entire set of points has the same x? then min_x = max_x) then we can set the right border at min_x and then the left border at min_x - s. Similarly, for y: either the bottom border is at min_y, OR the top border is at min_y? But that would require the entire set of points to be at min_y? 

But in general, we cannot arbitrarily assign the borders. The extreme points must be covered. Therefore, the min_x must be either on the left border or the right border. Similarly, the max_x must be either on the left border or the right border. But note: if min_x is on the right border, then we must have the entire set of points at min_x? Because the left border is at min_x - s, and the next x is at least min_x? So the entire set of points must be at min_x? Then max_x = min_x. Similarly, for y.

Therefore, we have:

  If the entire set of points does not have the same x, then min_x must be on the left border and max_x must be on the right border? Similarly for y.

But wait: what if we have multiple points? Consider:

  We have points with x coordinates: min_x (at two different y's) and then a point at max_x (which is > min_x). If we set the left border at min_x, then the points at min_x are on the left border. If we set the right border at max_x, then the point at max_x is on the right border. Then the square is [min_x, max_x] in x, and we set s = max(max_x-min_x, ...). Then the y-direction must be set accordingly.

But what if we set the left border at min_x - d (for some d>0) and the right border at min_x? Then the entire set of points must be at min_x? But we have a point at max_x (which is > min_x) that is not at min_x? Then it cannot be on the border? Because it is not at x1 (min_x-d) nor at x2 (min_x) and it is not at y1 or y2? Then it fails.

Therefore, if there is a point at min_x and a point at max_x and min_x != max_x, then we must set the left border at min_x and the right border at max_x? And then s must be max_x - min_x? But wait: what if the square is larger? Then we set x1 < min_x and x2 = x1+s > max_x. Then the min_x point must be on the left border? Only if x1 = min_x. Otherwise, the min_x point must be on the right border? Then we require min_x = x2 = x1+s. Then the entire set of points must be at x1+s? So all x coordinates must be min_x? But that contradicts min_x != max_x.

Therefore, if the set of points has distinct x values (min_x != max_x), then the only possibility is to set the left border at min_x and the right border at max_x? Then s = max_x - min_x? But wait: the square must have side length s, and the y-direction must also be s. Then the y-direction must have side length s = max_x - min_x. Then we set the bottom border arbitrarily? Actually, we must set the bottom border at some y1 and the top border at y1+s.

But then we must have the entire set of points in the y-direction between y1 and y1+s, and every point must be on one of the borders. Also, the extreme y values: the min_y must be at least y1 and the max_y must be at most y1+s. And the min_y must be on the bottom border or the top border? Similarly for max_y.

But note: we have set the left and right borders. Then the points that are not at min_x and not at max_x must be on the bottom or top border. Therefore, for a point that is not at min_x and not at max_x, we require that its y is either y1 or y1+s.

How to choose y1? The entire set of points must be contained in [y1, y1+s]. Therefore, y1 <= min_y and y1+s >= max_y. But also, for every point that is strictly between min_x and max_x, we require that y must be either y1 or y1+s.

Therefore, we must set y1 to be the minimum y among the points that are strictly between min_x and max_x? Actually, no: because we can set y1 below the min_y? Then the condition for the interior points: they must be at y1 or y1+s. But we don't have any point at y1? Then the interior points must be at y1+s? But they have y coordinates that are arbitrary? 

Actually, we can set y1 arbitrarily as long as y1 <= min_y and y1+s >= max_y, and additionally, for every point that is strictly between min_x and max_x, we require y==y1 or y==y1+s.

But note: we don't have a point at y1? Then the condition for the interior points is that they must be at y1+s? Then all interior points must have the same y = y1+s? Similarly, we could set y1+s arbitrarily above max_y? Then the interior points must be at y1? 

But we have the freedom? So:

  We can set y1 to be any value such that:
      y1 <= min_y
      y1+s >= max_y

  and for every point that is not at min_x and not at max_x: y_i must be either y1 or y1+s.

But note: we don't care about the points at min_x or max_x: they are already on the vertical borders, so they don't need to be on the horizontal borders.

Therefore, the condition is:

  For all points i:
      if X_i != min_x and X_i != max_x, then Y_i must be either y1 or y1+s.

But we can choose y1 arbitrarily as long as y1<=min_y and y1+s>=max_y? Then we can set y1 to be the minimum y among the interior points? Actually, no: because the interior points must all be either at y1 or at y1+s. Therefore, the set of y-coordinates for the interior points must have at most two distinct values: one for the bottom border and one for the top border. And these two values must be exactly y1 and y1+s.

But note: we can set y1 arbitrarily? Actually, we are forced: the interior points have two distinct y values: say a and b, with a <= b. Then we must set y1 = a and y1+s = b? Then s = b - a. But we already fixed s = max_x - min_x. Therefore, we must have b - a = max_x - min_x.

But wait: what if the interior points have only one y value? Then we can set y1 arbitrarily? But we must cover min_y and max_y. The min_y and max_y might come from the points at the borders? 

Actually, the entire set of points: the min_y might come from an interior point? Then we must set y1 <= that min_y. And similarly, the max_y might come from an interior point? Then we set y1+s >= that max_y. But the interior points have only one y value? Then we set that value as either y1 or y1+s? 

But if the interior points have only one y value, then we can set:
  Option 1: set y1 = y_value, then the interior points are on the bottom border. Then we set y1+s = y_value + s. Then we must have y_value + s >= max_y (the maximum y from the entire set). And also, we must have y1 = y_value <= min_y? But min_y is the minimum y in the entire set, so we require min_y >= y_value? Actually, min_y must be at least y1? But we set y1=y_value. Then min_y must be at least y_value? But the interior points have y_value, so min_y is at most y_value? Therefore, min_y = y_value. Then we set y1 = min_y. Then the top border is at min_y + s. Then we require that the entire set of points has y <= min_y+s? And the points at min_x and max_x that are not interior (so on the vertical borders) can have y from min_y to min_y+s.

Similarly, we could set the interior points on the top border: set y1+s = y_value, then y1 = y_value - s. Then we must have y1 <= min_y, so y_value - s <= min_y. But the entire set must be above y1. And the interior points are at the top border. Then the min_y must be at least y_value - s? But we have min_y from the entire set, which might be lower? Then we must have min_y >= y_value - s? Actually, min_y must be at least y1 = y_value - s. But we have an interior point at y_value, so min_y <= y_value. Then we set y1 = y_value - s, and then the bottom border is at y_value - s. Then the entire set must be above y1.

But note: we must have the side length s = max_x - min_x. Then we have:

  In the first option: 
        y1 = min_y (the minimum y of the entire set) and then the top border is min_y + s = min_y + (max_x - min_x).
        Then we require that the entire set of points has y <= min_y + s.

  In the second option:
        y1 = max_y - s = max_y - (max_x - min_x), and then we require that the entire set of points has y>=y1.

But note: we have the freedom to set the interior points to either border? Actually, we don't: the interior points must be assigned to one of the borders. But if they are all the same, we have two options? Actually, we can assign them to the bottom border (then set y1 = min_y) or to the top border (then set y1 = max_y - s). But we must cover the entire set.

Therefore, we have two possibilities for the y-direction when the x-borders are fixed at min_x and max_x (so s = max_x - min_x):

  Option A: Set the bottom border at min_y and the top border at min_y + s. Then check:
        - The entire set of points must have y in [min_y, min_y+s]
        - Every interior point (x not min_x and not max_x) must have y = min_y or y = min_y+s.

  Option B: Set the bottom border at max_y - s and the top border at max_y. Then check:
        - The entire set of points must have y in [max_y-s, max_y]
        - Every interior point must have y = max_y-s or y = max_y.

But note: we must also consider that the side length s must be at least the spread in y? Actually, we have s = max_x - min_x. We require that s >= max_y - min_y? Because the square must cover the entire set in y. Therefore, if max_y - min_y > s, then it is impossible.

But wait: we set the x-borders at min_x and max_x, so s = max_x - min_x. Then we require s >= max_y - min_y? Otherwise, the square would not cover the entire set in y? Actually, the square must cover the entire set. So the condition is s = max_x-min_x >= max_y-min_y? 

Similarly, in the other cases (like Case 2,3,4) we had s = max( ... ). But here we fixed s to max_x-min_x. Therefore, we must have max_x-min_x >= max_y-min_y.

But what if max_x-min_x < max_y-min_y? Then we cannot set the x-borders at min_x and max_x? Then we must consider the other cases? Actually, we have four cases overall. In Case 1, we set s = max(max_x-min_x, max_y-min_y). But in this scenario, we are not in Case 1? We are in a case where the left border is min_x and the right border is max_x, so s = max_x-min_x. Then if max_x-min_x < max_y-min_y, we cannot cover the entire set in y? Therefore, this case fails.

But wait: we have not considered the other cases? The other cases (Case 1,2,3,4) already include the possibility that s = max( ... ). 

So the plan:

  Precompute:
      min_x, max_x, min_y, max_y.

  Then try the four cases:

  Case 1: 
        s = max(max_x-min_x, max_y-min_y)
        Then the square: 
            x1 = min_x, x2 = min_x+s
            y1 = min_y, y2 = min_y+s
        Then check that for every point (x,y):
            x == min_x OR x == min_x+s OR y == min_y OR y == min_y+s.

  Case 2:
        s = max(max_x-min_x, max_y-min_y)
        Then:
            x1 = min_x, x2 = min_x+s
            y1 = max_y - s, y2 = max_y
        Check: for every point (x,y):
            x == min_x OR x == min_x+s OR y == max_y-s OR y == max_y

  Case 3:
        s = max(max_x-min_x, max_y-min_y)
        Then:
            x1 = max_x - s, x2 = max_x
            y1 = min_y, y2 = min_y+s
        Check: every point: x == max_x-s or x == max_x or y == min_y or y == min_y+s

  Case 4:
        s = max(max_x-min_x, max_y-min_y)
        Then:
            x1 = max_x - s, x2 = max_x
            y1 = max_y - s, y2 = max_y
        Check: every point: x in {x1, x2} or y in {y1, y2}

But note: in Case 1, the square might extend beyond in the direction that is not the extreme? For example, if s = max(...) and the spread in x is less than s, then the right border is at min_x+s which is greater than max_x. Similarly, the top border is at min_y+s which is greater than max_y. Then we check the condition: the points must be on the borders. The left border at min_x, the right border at min_x+s (which is beyond max_x), the bottom at min_y, the top at min_y+s (beyond max_y). Then a point at (min_x, y) for any y in [min_y, min_y+s] is on the left border. Similarly, a point at (max_x, y) is not on the right border? Because the right border is at min_x+s, which is >= max_x. But if max_x < min_x+s, then the point at max_x is not on the right border? Then it must be on the top or bottom? But the top and bottom are at min_y and min_y+s. So if the point at max_x has y not min_y and not min_y+s, then it fails.

Therefore, we must have in Case 1: every point must be either at x=min_x, x=min_x+s, y=min_y, or y=min_y+s. But note: min_x+s might be greater than max_x, so we cannot have a point at x=min_x+s? Then the only points that are on the right border are the ones at x=min_x+s? But we don't have any? Then the points that are not at min_x must be at min_y or min_y+s? 

Similarly, the points at max_x: they are not at min_x (unless min_x==max_x) and not at min_x+s (because min_x+s>=max_x and if min_x+s>max_x, then they are not at min_x+s) so they must be at min_y or min_y+s.

Therefore, the condition for the entire set of points: they must lie on the four borders defined by the square.

But note: the problem does not require that the entire border is covered, only that every point lies on the border.

So we can check in O(n) for each case.

But note: what if s=0? Then the square is a single point. Then we must have all points at (min_x, min_y). Then we set x1=x2=min_x, y1=y2=min_y. Then the condition: every point must be at (min_x,min_y). So we check that all points are the same.

But our four cases will work? In Case 1: s = max(0,0)=0. Then the square is (min_x,min_x,min_y,min_y). Then we check: for every point, x==min_x (which is true) and then we don't care? Actually, the condition: 
  x == min_x OR x == min_x (since min_x+s = min_x) OR y==min_y OR y==min_y (min_y+s=min_y). So it holds.

Similarly for the other cases? But note: in Case 2: 
  x1 = min_x, x2 = min_x (so the x range is a single point) and y1 = max_y, y2 = max_y? Then the square is (min_x, min_x, max_y, max_y). Then we require every point to be at (min_x, max_y)? But we have points at (min_x,min_y) which is not the same? Then it fails.

Therefore, we must try all four cases? But in the degenerate case, the four cases might be the same? Only if min_x==max_x and min_y==max_y. Then all cases are the same: the square is a single point.

But if not, then we try the four cases.

But note: what if the set of points is such that the square must be defined by non-extreme borders? For example, if we have two points: (0,0) and (1,1). Then the bounding box is [0,1]x[0,1]. Then s = max(1,1)=1.

Case 1: square [0,1]x[0,1]. Then the point (0,0): on the border? Yes (left and bottom). The point (1,1): on the border? Yes (right and top). Then it works? But actually, the square has side length 1, so the borders are at x=0, x=1, y=0, y=1. Then both points are on the border.

But what if we have points: (0,0), (1,1), and (0.5, 0.5) in a non-integer example? But our points are integers. Then we have (0,0), (1,1), and (1,0) for example? Then the square in Case 1: [0,1]x[0,1]. Then (0,0): border, (1,1): border, (1,0): border. Then it works.

But what if we have (0,0), (1,1), and (0.5, 0.6) (but integers: say (0,0), (1,1), (0,1))? Then Case 1: the square [0,1]x[0,1]. The point (0,1): on the border. Then (0,0), (1,1), (0,1) are all on the border.

But what if we have (0,0), (1,1), (0.5,0.5)? Then the point (0.5,0.5) is not on the border? Then Case 1 fails. Then we try Case 2: square [0,1]x[0,1]? Actually, same as Case 1? No: Case 2: [0,1]x[?] 

Wait: in Case 2: 
  s = max(1, (max_y-min_y)) = max(1, (1-0)=1.
  Then the square: x in [0,1], y in [max_y-s, max_y] = [1-1,1] = [0,1]. So same as Case 1.

Therefore, all four cases might be the same if the spreads are equal? 

But if the spreads are not equal? For example: 
  Points: (0,0), (2,0), (0,1), (2,1), (1,0.5)   -> but integers: so (0,0), (2,0), (0,1), (2,1), (1,1) -> wait, to have an interior point that is not on the border, we need a point with x=1 and y not 0 or 1? But integers: then (1,0) is on the bottom border. So let me make one: (1, 0.5) is not integer. So we use integers: 
  Input: 
      5
      0 0
      2 0
      0 1
      2 1
      1 0

  Then the bounding box: [0,2]x[0,1]. Then s = max(2,1)=2.

  Case 1: square: [0,2]x[0,2]. Then the point (1,0) is at x=1 (which is not 0 or 2) and y=0 -> so it is on the bottom border? Then it is okay.

  But wait: the square in Case 1: bottom border is y=0, top border is y=2. The point (1,0) is on the bottom border. So it is okay.

  However, the square is [0,2]x[0,2] and the points are at y=0 and y=1? Then the point (0,1) is on the left border? And (2,1) is on the right border? Then they are all on the border.

  But what if we have a point at (1,1)? Then it is on the top border? No, because the top border is at y=2? Then (1,1) is inside? Then Case 1 fails.

  Then try Case 2: 
        x1=0, x2=0+2=2
        y1 = max_y - s = 1 - 2 = -1, y2 = 1
        Then the square: [0,2]x[-1,1]. Then the point (1,1): at y=1 -> top border? Then it is on the border. The point (0,0): left border and bottom border? Then it is on the border. The point (1,0): bottom border? Then it is on the border.

  So it works.

Therefore, we try all four cases. Each case:

  s = max(max_x-min_x, max_y-min_y)

  Then define the square as per the case.

  Then for each point, check if it lies on one of the four borders.

  If one case passes, output the two opposite corners as defined.

  If none passes, output "Impossible".

But note: what if the square is degenerate? Then s=0. Then the four cases are:

  Case 1: (min_x, min_x, min_y, min_y) -> then we require that every point is at (min_x, min_y). Then if there is only one point, it works. If there are multiple points, they must all be the same.

  Similarly, Case 2: (min_x, min_x, min_y, min_y) -> same as Case 1? 
        Because s=0: then y1 = max_y - 0 = max_y. But if min_y==max_y, then y1 = min_y. Then same as Case 1.

  Similarly, Cases 3 and 4: same as Case 1.

Therefore, we can break early: if all points are the same, then any case will work and we output (min_x, min_x, min_y, min_y).

But what if the set of points is not all the same? Then s=0 fails? Then we try the cases with s>0.

But note: the problem allows degenerate squares, but if the points are not all the same, then we need s>0.

Time complexity: 4 * n, which is O(n). With n up to 10^5, that is acceptable.

But note: what if the square must be defined with s not equal to max( max_x-min_x, max_y-min_y )? For example, we set the left border at min_x and the right border at max_x, and then set s = max_x-min_x, but then the y-direction: we set the bottom border arbitrarily? Then we have two options: set the bottom border at min_y or set it at max_y - s. Then we must check both? 

But we have already considered the four cases above? Actually, no: the above four cases set s = max( ... ) and then set the square accordingly. But the case where we set the left and right borders at min_x and max_x and then the bottom border at min_y (with s = max_x-min_x) is not one of the four? 

Wait: in Case 1, we set the square as (min_x, min_x+s, min_y, min_y+s) with s = max( ... ). But if max_x-min_x < max_y-min_y, then s = max_y-min_y. Then the square extends beyond in x? Then we have x2 = min_x+s = min_x + (max_y-min_y) which is greater than max_x. Then the points that are at max_x are not on the right border? Then we must check: they must be on the top or bottom. Similarly, if we set the left and right borders at min_x and max_x, then we are not using the same s? Then we have s = max_x-min_x, which might be less than the required s for Case 1? 

Therefore, we must also consider the case where we fix the left and right borders at min_x and max_x (so s_x = max_x-min_x) and then set s = s_x, and then set the y-borders arbitrarily? But we have two options for the y-borders: at the bottom or at the top? Then we have two more cases? Similarly, we might fix the top and bottom borders at min_y and max_y, and then set s = max_y-min_y, and then set the x-borders arbitrarily? Then two more cases? 

But note: we have four cases already that set s = max( ... ) and then assign the square. But the case of fixing the left and right borders at min_x and max_x (and then s = max_x-min_x) is actually a subcase of Case 1 and Case 2? 

In Case 1: 
   We set s = max(max_x-min_x, max_y-min_y). 
   Then the square is [min_x, min_x+s] x [min_y, min_y+s]. 
   In this square, the left border is at min_x, and the right border is at min_x+s. 
   But if max_x-min_x < s, then min_x+s > max_x. Therefore, the right border is beyond max_x. 
   Then the point at max_x is not on the right border? Then we require that it is on the top or bottom? 

But we have not considered the case where the right border is exactly at max_x? 

So we need additional cases:

Case 5: Fix the left and right borders at min_x and max_x -> then s = max_x-min_x. Then we set the bottom border at min_y -> top border = min_y+s. Then check: 
   - s must be at least max_y-min_y? Otherwise, the top border min_y+s is less than max_y -> then the point at max_y is above the square -> fails.
   - Then we require s >= max_y - min_y.
   - Also, every point that is not at min_x and not at max_x must be at min_y or min_y+s.

Case 6: same as Case 5 but set the bottom border at max_y - s.

Similarly, we can fix the bottom and top borders at min_y and max_y, then set s = max_y-min_y. Then we have:

Case 7: set the left border at min_x -> right border = min_x+s, and set the bottom border at min_y -> top border = min_y+s. Then check:
   - s must be at least max_x-min_x? Otherwise, the right border min_x+s < max_x -> fails.
   - Then every point that is not at min_y and not at max_y must be at min_x or min_x+s.

Case 8: same as Case 7 but set the left border at max_x - s.

So we have 8 cases? 

But note: Case 1 is a superset of Case 5? Not exactly: in Case 1 we set s = max( ... ), which is at least max_x-min_x and at least max_y-min_y. Then the square extends in both directions. In Case 5, we set s = max_x-min_x, which might be less than max_y-min_y? Then we skip Case 5? Actually, in Case 5 we require s>=max_y-min_y, so if max_x-min_x < max_y-min_y, we skip.

Therefore, we can try:

  Case 1,2,3,4: s = max( max_x-min_x, max_y-min_y )
  Case 5: s = max_x-min_x, and require s>=max_y-min_y. Then the square: 
          x1 = min_x, x2 = max_x, y1 = min_y, y2 = min_y+s
          Then check the border condition.

  Case 6: s = max_x-min_x, and require s>=max_y-min_y. Then the square:
          x1 = min_x, x2 = max_x, y1 = max_y - s, y2 = max_y

  Case 7: s = max_y-min_y, and require s>=max_x-min_x. Then the square:
          x1 = min_x, x2 = min_x+s, y1 = min_y, y2 = max_y
          But wait: we set the top border at max_y? Then the square is [min_x, min_x+s] x [min_y, max_y]. And we require s = max_y-min_y >= max_x-min_x? Then the right border min_x+s is at least min_x + (max_x-min_x) = max_x. Then the entire set is contained. Then check: every point that is not at min_y and not at max_y must be at min_x or min_x+s.

  Case 8: s = max_y-min_y, and require s>=max_x-min_x. Then the square:
          x1 = max_x - s, x2 = max_x, y1 = min_y, y2 = max_y

But note: in Case 7, we set the bottom and top at min_y and max_y, and the left at min_x, and the right at min_x+s. Then we require s>=max_x-min_x -> then min_x+s>=max_x. Then the point at max_x is on the right border? Only if min_x+s == max_x? Or if min_x+s>max_x, then the point at max_x is not on the right border? Then it must be on the top or bottom? 

Actually, the border is defined as x=min_x, x=min_x+s, y=min_y, y=max_y. 
  The point at max_x: if max_x <= min_x+s, then it is contained. But it is on the border only if:
        x = min_x (no, unless min_x==max_x) or x = min_x+s? or y=min_y or y=max_y.

  If the point at max_x is at y=min_y or y=max_y, then it is on the border. Otherwise, if it is strictly in the interior in y, then it must be at x=min_x+s? But min_x+s might be greater than max_x? Then the point at max_x is not at min_x+s? Then it fails.

Therefore, we must require that either:
   (a) min_x+s == max_x, so the point at max_x is on the right border, OR
   (b) the point at max_x is at min_y or max_y.

But we have many points: we cannot assume the point at max_x is the only one at that x. 

So we must check for every point: if it is not at min_x and not at min_x+s and not at min_y and not at max_y, then it is inside -> fails.

But note: min_x+s might be greater than max_x, so we won't have any point at min_x+s? Then the points at max_x must be at min_y or max_y? 

Therefore, the condition is independent of the value of min_x+s as long as min_x+s>=max_x? We just check the border condition as described.

So we have 8 cases.

But is it sufficient? Consider: 
   We have fixed the borders at the extremes in one direction and then set the other direction arbitrarily? 

But note: the extreme points must be on the border. So min_x must be on the left border? Or the right border? In Case 5, we set the left border at min_x and the right border at max_x. Then min_x is on the left and max_x is on the right. Similarly, min_y is on the bottom border (if we set the bottom at min_y) or on the top border (if we set the bottom at max_y-s)? 

But if we set the bottom at min_y, then min_y is on the bottom border. If we set the bottom at max_y-s, then min_y might not be on the border? Then we require that min_y is on the left or right border? 

But in Case 5: 
   We set the square: [min_x, max_x] x [min_y, min_y+s] with s = max_x-min_x.
   Then the bottom border is at min_y. Then the point at min_y is on the bottom border? But what if there is a point at (min_x, min_y)? Then it is also on the left border. But if there is a point at (x, min_y) for x not min_x and not max_x, then it is on the bottom border. So it is okay.

   However, the point at min_y might be at (some x, min_y) and we don't care where the x is? As long as it is between min_x and max_x, then it is on the bottom border.

   Similarly, in Case 6: 
        the square: [min_x, max_x] x [max_y-s, max_y]
        then the point at min_y: it must be at min_y = max_y-s? Or if min_y > max_y-s, then it is in the interior? 

   Actually, in Case 6: we require s>=max_y-min_y? Then max_y-s <= min_y. And the bottom border is at max_y-s. Then the entire set of points has y>=min_y>=max_y-s. So the point at min_y is at least at the bottom border? But to be on the border, it must be at the bottom border (y=max_y-s) or at the top border (y=max_y) or at the left or right border.

   But the point at min_y: we have min_y>=max_y-s, and if min_y>max_y-s, then the point at min_y is not at the bottom border? Then it must be on the left or right border? 

   Similarly, the point at max_y: on the top border.

   Therefore, we must check that the point at min_y is either at the left or right border? Because it is not at the bottom border (unless min_y==max_y-s) and not at the top border (unless min_y==max_y).

   But if min_y is not at the borders? Then it fails.

   So in Case 6, we require that the point at min_y must be at the left border (x=min_x) or the right border (x=max_x). 

   How do we know which point is at min_y? There might be multiple points at min_y. We must check every point at min_y: they must be at x=min_x or x=max_x.

   Similarly, in Case 5: we require that the point at max_y must be at the left or right border? Because if we set the bottom border at min_y and the top border at min_y+s, then the point at max_y must be at the top border? But we have max_y<=min_y+s? And if max_y<min_y+s, then the point at max_y is not at the top border? Then it must be on the left or right border.

   But wait: the top border is at min_y+s. Then the point at max_y is on the top border only if max_y = min_y+s. Otherwise, it is strictly below the top border? Then it must be on the left or right border.

   So we cannot avoid checking every point.

   Therefore, we do:

      For each case, set the square parameters.

      Then for every point (x,y):
          if x is not x1 and x is not x2 and y is not y1 and y is not y2 -> fail.

      Then the case works.

   Then we output the square.

   We have 8 cases.

But note: what if the square is defined by non-extreme borders? For example, we set the left border at min_x - d, then the right border at min_x, and then the bottom and top borders accordingly. But we already considered that in Case 3 and Case 4? 

   In Case 3: 
        x1 = max_x - s, x2 = max_x, y1 = min_y, y2 = min_y+s.
        This could be non-extreme in x: if we set s = max( ... ) and max_x-min_x < s, then x1 = max_x - s < min_x. Then the left border is below min_x. Then the point at min_x must be on the right border? But the right border is at max_x. And min_x is not max_x? Then it is not on the right border? Then it must be on the bottom or top? 

   But in Case 3, we set the bottom and top at min_y and min_y+s. Then the point at min_x: if it is at min_y or min_y+s, then it is on the border. Otherwise, it fails.

   Similarly, the point at max_x: on the right border.

   So it is covered.

Therefore, we have 8 cases:

   Let s1 = max_x - min_x
   Let s2 = max_y - min_y
   Let s0 = max(s1, s2)

   Case 1: (min_x, min_x+s0, min_y, min_y+s0)
   Case 2: (min_x, min_x+s0, max_y-s0, max_y)
   Case 3: (max_x-s0, max_x, min_y, min_y+s0)
   Case 4: (max_x-s0, max_x, max_y-s0, max_y)

   Case 5: if s1 >= s2: (min_x, max_x, min_y, min_y+s1)
   Case 6: if s1 >= s2: (min_x, max_x, max_y-s1, max_y)
   Case 7: if s2 >= s1: (min_x, min_x+s2, min_y, max_y)
   Case 8: if s2 >= s1: (max_x-s2, max_x, min_y, max_y)

But note: in Case 5 and Case 6, we require s1>=s2? Because we set the y-direction to have length s1, and we require that it covers the y spread (so s1>=s2). Similarly, for Case 7 and 8, we require s2>=s1.

Also, note that if s1==0 or s2==0, then we might be in a degenerate case? But we already cover with s0.

But what if both s1 and s2 are zero? Then all points are the same. Then all cases will work? But we can break: we can output any, for example Case 1.

But the problem: if there is only one point, then s1=0 and s2=0. Then s0=0. Then Case 1: (min_x,min_x,min_y,min_y). Then check: the only point is at (min_x,min_y) -> passes.

So we do:

  Precomputation: min_x, max_x, min_y, max_y.

  Let s1 = max_x - min_x
  Let s2 = max_y - min_y

  Case 1: 
        x1 = min_x, x2 = min_x + s0, y1 = min_y, y2 = min_y + s0   [with s0 = max(s1,s2)]
        Check all points.

  Case 2: 
        x1 = min_x, x2 = min_x+s0, y1 = max_y - s0, y2 = max_y
        Check.

  Case 3: 
        x1 = max_x - s0, x2 = max_x, y1 = min_y, y2 = min_y+s0
        Check.

  Case 4: 
        x1 = max_x - s0, x2 = max_x, y1 = max_y - s0, y2 = max_y
        Check.

  Case 5: if s1>=s2:
        x1 = min_x, x2 = max_x, y1 = min_y, y2 = min_y+s1
        Check.

  Case 6: if s1>=s2:
        x1 = min_x, x2 = max_x, y1 = max_y - s1, y2 = max_y
        Check.

  Case 7: if s2>=s1:
        x1 = min_x, x2 = min_x+s2, y1 = min_y, y2 = max_y
        Check.

  Case 8: if s2>=s1:
        x1 = max_x - s2, x2 = max_x, y1 = min_y, y2 = max_y
        Check.

  If any case passes, output the square (x1, x2, y1, y2) for that case.

  If none passes, output "Impossible".

But note: we have 8 cases, each O(n). Total 8 * 10^5 = 800000, which is acceptable.

But what if the entire set of points is large? 10^5, and we do 8 passes? Then 800000 operations, which is acceptable in 1 second.

Let me test with the sample:

Sample 1: 3 points: (7,6), (2,4), (4,0)

  min_x=2, max_x=7 -> s1=5
  min_y=0, max_y=6 -> s2=6
  s0 = max(5,6)=6

  Case 1: (2, 2+6=8, 0, 0+6=6) -> square [2,8]x[0,6]
      Check:
          (7,6): x=7 -> not 2 or 8? Then check y: y=6 -> top border -> ok.
          (2,4): x=2 -> left border -> ok.
          (4,0): y=0 -> bottom border -> ok.
      Then output: 2 8 0 6.

  So we output Case 1.

Sample 2: 4 points: (2,6), (8,8), (10,2), (3,3)

  min_x=2, max_x=10 -> s1=8
  min_y=2, max_y=8 -> s2=6
  s0 = 8

  Case 1: (2,10,2,10) -> square [2,10]x[2,10]
      Check (2,6): x=2 -> left border -> ok.
            (8,8): x=8 (not 2 or 10), y=8 (not 2 or 10) -> fail? Because 2<8<10 and 2<8<10 -> not on border.

  Case 2: (2,10, 8-8=0,8) -> [2,10]x[0,8]
      (2,6): x=2 -> ok.
      (8,8): y=8 -> top border -> ok.
      (10,2): x=10 -> right border? And y=2 -> bottom border? But bottom border is 0? Then y=2 is not 0 or 8? -> fail.

  Case 3: (10-8=2,10,2,2+8=10) -> same as Case 1? [2,10]x[2,10] -> same as Case 1.

  Case 4: (10-8=2,10,8-8=0,8) -> [2,10]x[0,8] -> same as Case 2.

  Case 5: s1=8>=s2=6 -> (2,10,2,2+8=10) -> same as Case 1 -> fails on (8,8).

  Case 6: s1>=s2 -> (2,10, 8-8=0,8) -> same as Case 2 -> fails on (10,2).

  Case 7: s2>=s1? 6>=8? -> false, skip.
  Case 8: skip.

  Then output "Impossible".

So matches sample.

Another test: two points: (0,0) and (1,1)

  min_x=0, max_x=1 -> s1=1
  min_y=0, max_y=1 -> s2=1
  s0=1

  Case 1: (0,1,0,1) -> the square [0,1]x[0,1]. The points (0,0): left and bottom -> ok. (1,1): right and top -> ok.

  So output (0,1,0,1).

But what if we use Case 5: s1=1>=s2=1 -> then (0,1,0,0+1=1) -> same as Case 1.

But it doesn't matter: we output the first that works.

But note: what if multiple cases work? Then we output the first one.

We can try the cases in order.

But note: the problem says "any" square.

Implementation note: we might break at the first case that works.

But note: the square in Case 1 and Case 5 are the same? Only if s0 = s1 and s0>=s2? But in this example s0=1 and s1=1, so Case 1 and Case 5 are the same.

But in general, they might be different.

Therefore, we do:

  s0 = max(s1, s2)

  Try Case 1,2,3,4: in order.

  Then if s1>=s2, try Case 5,6.

  Then if s2>=s1, try Case 7,8.

But note: if s1==s2, then we try both? But that's okay.

However, to avoid duplication, we can skip Case 5 and 7 if s0==s1 and we already did Case 1? But not necessary.

Let's code the checking function:

  For a given square (x1, x2, y1, y2) and side length s = x2-x1 (which should equal y2-y1), we check each point (x,y):

        if x == x1 or x == x2 or y == y1 or y == y2: then it is on the border.

        else: fail.

But note: what if the point is outside the square? Then it fails. But we have defined the square to contain the bounding box? 

  In Case 1: 
        x1 = min_x, x2 = min_x+s0, which is >= max_x (because s0>=max_x-min_x) -> so all points are in [x1,x2]? 
        Similarly, y in [y1,y2]. 

  So the point cannot be outside? 

  But in Case 2: 
        x1 = min_x, x2 = min_x+s0, which is >=max_x -> so x is in [x1,x2].
        y1 = max_y-s0, and we have s0>=max_y-min_y -> so max_y-s0 <= min_y -> then the entire set has y>=min_y>=max_y-s0? And y<=max_y. So y in [y1,y2].

  Similarly for the others.

  And in Cases 5,6,7,8: we have the condition that the square covers the bounding box.

  Therefore, we only need to check the border condition.

But what about the corners? The corners are covered by two borders? Then the condition still holds.

Therefore, we check:

  for each point (x,y):
        if (x == x1 || x == x2 || y == y1 || y == y2) -> true
        else -> false

But note: the problem does not require the point to be in the square? We have already ensured the square covers the bounding box? So it is inside the square? Then if it is not on the border, it is strictly inside -> invalid.

So we do:

  for each case:
      valid = true
      for each point:
          if not (x==x1 or x==x2 or y==y1 or y==y2):
              valid = false; break
      if valid: output and break out of the case loop.

  If no case valid: output "Impossible"

But note: we must be cautious with integer coordinates? The comparisons are exact.

Let me test with a degenerate square: one point.

  Then: min_x = max_x = a, min_y = max_y = b, s0=0, s1=0, s2=0.

  Then Case 1: (a,a,b,b)
        Check the point: (a,b): 
            a==a -> true.

  Then output.

Edge: two points: (0,0) and (0,1)

  min_x=0, max_x=0 -> s1=0
  min_y=0, max_y=1 -> s2=1
  s0 = max(0,1)=1

  Case 1: (0,0+1=1, 0,0+1=1) -> square [0,1]x[0,1]
        (0,0): x=0 -> left border -> ok.
        (0,1): x=0 -> left border -> ok.

  Then output.

Another: two points: (0,0) and (1,0)

  min_x=0, max_x=1 -> s1=1
  min_y=0, max_y=0 -> s2=0
  s0=1

  Case 1: (0,1,0,1) -> 
        (0,0): x=0 -> ok.
        (1,0): x=1 -> ok.

  Also, Case 5: s1=1>=s2=0 -> (0,1,0,0+1=1) -> same as Case 1? Actually, the square in Case 5 is (0,1,0,1) -> same.

  But we break at Case 1.

But what if we have a point at (0,0) and (2,0)? Then min_x=0, max_x=2, s1=2; min_y=0, max_y=0, s2=0; s0=2.

  Case 1: (0,2,0,2) -> 
        (0,0): x=0 -> ok.
        (2,0): x=2 -> ok.

  Also, Case 5: (0,2,0,0+2=2) -> same.

But note: the square extends to y=2, but the points are at y=0. Then the condition: the points are on the bottom border (y=0). So it is okay.

Therefore, the algorithm:

  Step 1: Read n, points.

  Step 2: If n==0, then we can output any square? But n>=1.

  Step 3: Compute min_x, max_x, min_y, max_y.

  Step 4: 
        s1 = max_x - min_x
        s2 = max_y - min_y
        s0 = max(s1, s2)

        cases = []

        Case1: (min_x, min_x+s0, min_y, min_y+s0)
        Case2: (min_x, min_x+s0, max_y-s0, max_y)
        Case3: (max_x-s0, max_x, min_y, min_y+s0)
        Case4: (max_x-s0, max_x, max_y-s0, max_y)

        If s1>=s2:
            Case5: (min_x, max_x, min_y, min_y+s1)
            Case6: (min_x, max_x, max_y-s1, max_y)
        Else:
            Case5,6: skip

        If s2>=s1:
            Case7: (min_x, min_x+s2, min_y, max_y)
            Case8: (max_x-s2, max_x, min_y, max_y)
        Else:
            Case7,8: skip

        Then iterate over the cases in the order 1,2,3,4,5,6,7,8.

        For a case (x1,x2,y1,y2):
            valid = True
            for each point (x,y):
                if x != x1 and x != x2 and y != y1 and y != y2:
                    valid = False
                    break
            if valid:
                print(f"{x1} {x2} {y1} {y2}")
                return

        If no case is valid: print "Impossible"

But note: the problem constraints: the output must satisfy -10^9<=X1<=X2<=10^9 and -10^9<=Y1<=Y2<=10^9.

  In our cases:
        Case1: 
            x1 = min_x, x2 = min_x+s0 -> s0>=0, so x1<=x2.
            y1 = min_y, y2 = min_y+s0 -> same.

        Case2: 
            y1 = max_y - s0, and since s0>=max_y-min_y, we have y1 = max_y - s0 <= min_y <= max_y = y2, so y1<=y2.

        Similarly for the others.

        Also, the values: 
            min_x, min_y, max_x, max_y are in [-10^8,10^8]
            s0, s1, s2 are at most 2e8, so the coordinates we output are in [-10^8, 10^8+2e8] which is within [-10^9,10^9]? 
            -10^8 - 2e8 = -3e8, which is >=-10^9.
            10^8+2e8=3e8 <=10^9.

        So we are safe.

Let me test with the sample that requires a non-square bounding box:

  Points: (0,0), (1,0), (0,2)

  min_x=0, max_x=1 -> s1=1
  min_y=0, max_y=2 -> s2=2
  s0 = 2

  Case1: (0,0+2=2,0,0+2=2) -> square [0,2]x[0,2]
        (0,0): x=0 -> ok.
        (1,0): x=1 (not 0 or 2) and y=0 -> bottom border? -> ok.
        (0,2): x=0 -> ok.

  Then output.

  But also we have:
        Case5: s1=1 < s2=2 -> skip.
        Case7: s2=2>=s1=1 -> 
             Case7: (0,0+2=2,0,2) -> same as Case1? Then same square.

        Case8: (1-2 = -1, 1, 0,2) -> square [-1,1]x[0,2]
             (0,0): x=0 (not -1 or 1) and y=0 -> bottom border? -> ok.
             (1,0): x=1 -> right border? -> ok.
             (0,2): y=2 -> top border? -> ok.

        So Case8 would also work.

  We output the first that works: Case1.

  But note: the problem says "any", so either is acceptable.

One more: the point (1,1) in a square that is too big? 

  Points: (0,0), (2,0), (0,1), (2,1), (1,1)  -> the center at (1,1) is the problem.

  We want a square that covers [0,2]x[0,?] but must have side length at least 2.

  Case1: s0 = max(2,1)=2 -> square [0,2]x[0,2]
        (1,1): not on border? -> fail.

  Case2: [0,2]x[?] -> [0,2]x[1-2,1] = [0,2]x[-1,1]
        (0,0): y=0 -> bottom border? But bottom border is -1? Then y=0 is not -1 or 1? Then it must be on left or right? It is at x=0 -> left border -> ok.
        (2,0): right border -> ok.
        (0,1): left border -> ok.
        (2,1): right border -> ok.
        (1,1): y=1 -> top border? Then ok.

  So Case2 works.

  Therefore, we output: 0 2 -1 1.

  But note: the point (0,0) is at (0,0): 
        x=0 -> left border -> ok.

  The point (1,1) is at y=1 -> top border -> ok.

  So it is valid.

Therefore, we do:

  Implement the 8 cases as described.

  Note: the coordinates can be negative? Yes.

  We must use long integers? Because s0 might be 2e8, and min_x might be -10^8, then x1 = min_x might be -10^8, x2 = min_x+s0 = -10^8+2e8 = 10^8, which fits in int? But the problem says output integers in the range -10^9 to 10^9. So we use long integers to avoid overflow? But the inputs are integers.

  However, in C++ we would use long long. But in the problem, the constraints: -10^8 to 10^8 for input, and we do additions: min_x + s0, and s0<=2e8, so the maximum absolute value is 3e8? which is 300,000,000, which fits in 32-bit signed integer? But the problem says output can be as low as -10^9 and as high as 10^9, so 300e6 is within.

  But if we do: min_x = -10^8, s0=200e6, then min_x+s0 = 100e6 -> fits.

  But if we do: min_x = -10^8, s0 = 200e6 -> 100e6.

  However, if we do Case2: y1 = max_y - s0: if max_y=10^8, s0=200e6, then y1 = 10^8 - 200e6 = -100e6 -> fits.

  So we can use int if the problem says the output integers are in the range? But the problem says -10^9<=...<=10^9, and our computed values are in [-300e6, 300e6]? Actually, worst-case: 
        min_x = -10^8, s0 = 200e6 -> x2 = 100e6.
        Or if s0 = 2e9? But note: s0 = max(s1,s2) and s1 = max_x-min_x, which is at most 200e6 (because max_x<=10^8, min_x>=-10^8). So s0<=200e6.

  Therefore, we are safe.

  However, in the problem: the input constraints: -10^8 to 10^8, so the differences are at most 200e6.

  So we can use 64-bit integers to be safe? Or 32-bit? The problem says memory 1024MB, so we can use long long.

But the problem: n up to 10^5, so storing points as long long is acceptable.

But in C++ we can use long long.

But since we are writing pseudocode, we just note.

Let me write the steps in pseudocode:

  n = input()
  points = []
  for i in range(n):
      x, y = input().split()
      points.append( (x,y) )

  min_x = min(p.x for p in points)
  max_x = max(p.x for p in points)
  min_y = min(p.y for p in points)
  max_y = max(p.y for p in points)

  s1 = max_x - min_x
  s2 = max_y - min_y
  s0 = max(s1, s2)

  cases = []

  cases.append( (min_x, min_x+s0, min_y, min_y+s0) )   # case1
  cases.append( (min_x, min_x+s0, max_y-s0, max_y) )   # case2
  cases.append( (max_x-s0, max_x, min_y, min_y+s0) )    # case3
  cases.append( (max_x-s0, max_x, max_y-s0, max_y) )    # case4

  if s1 >= s2:
        cases.append( (min_x, max_x, min_y, min_y+s1) )   # case5
        cases.append( (min_x, max_x, max_y-s1, max_y) )   # case6

  if s2 >= s1:
        cases.append( (min_x, min_x+s2, min_y, max_y) )   # case7
        cases.append( (max_x-s2, max_x, min_y, max_y) )   # case8

  for (x1, x2, y1, y2) in cases:
        valid = True
        for each point (x,y) in points:
            if x == x1 or x == x2 or y == y1 or y == y2:
                continue
            else:
                valid = False
                break
        if valid:
            print(f"{x1} {x2} {y1} {y2}")
            exit(0)

  print("Impossible")

But note: in some cases, the computed coordinates might be very large? But we are within the bounds.

One more corner: what if s0 is negative? But s1 and s2 are nonnegative because min_x<=max_x, so s0>=0.

  Similarly, in Case5: s1>=s2, and s1>=0.

  But what if all points are the same: then s1=0, s2=0, s0=0.

  Then the square is a point: (min_x, min_x, min_y, min_y) -> then we check: every point is at (min_x,min_y) -> ok.

  Therefore, it works.

We are done.

But note: the problem says "It can be proven that if a solution exists, there will be at least one solution that satisfies the constraints." -> so we don't worry about exceeding the output coordinate constraints.

Let me test with the sample that fails: Sample Input #2.

  Points: (2,6), (8,8), (10,2), (3,3)

  We do the 8 cases and all fail? Then we output "Impossible".

So we are done.

Therefore, the solution is to try the 8 candidate squares.

Final note: the problem says "two opposite corners" and we output (X1,X2,Y1,Y2) meaning the first corner is (X1,Y1) and the second is (X2,Y2). And we have defined the squares by two opposite corners: in our representation, (x1,y1) and (x2,y2) are the bottom-left and top-right? But in Case2, we have (x1,y1) = (min_x, max_y-s0) and (x2,y2) = (min_x+s0, max_y). Then the two corners are (min_x, max_y-s0) and (min_x+s0, max_y). These two corners are opposite? 

  The square has corners:
      (min_x, max_y-s0) -> bottom-left? 
      (min_x, max_y) -> top-left?
      (min_x+s0, max_y) -> top-right?
      (min_x+s0, max_y-s0) -> bottom-right?

  The two opposite corners could be (min_x, max_y-s0) and (min_x+s0, max_y) -> they are not adjacent? They are diagonal? Then they are opposite.

  Similarly, in Case3: (max_x-s0, min_y) and (max_x, min_y+s0) -> which are bottom-left? and top-right? 

        bottom-left: (max_x-s0, min_y)
        top-right: (max_x, min_y+s0)

  But these two are opposite? Yes.

  So our representation always outputs the bottom-left and top-right? Actually, no: 

  In Case2: 
        (x1,y1) = (min_x, max_y-s0) -> this is the bottom-left? 
        (x2,y2) = (min_x+s0, max_y) -> top-right.

  But the bottom-left is (min_x, max_y-s0) and top-right is (min_x+s0, max_y). Then they are opposite.

  Similarly, in Case4: 
        (x1,y1) = (max_x-s0, max_y-s0) -> bottom-left?
        (x2,y2) = (max_x, max_y) -> top-right.

  But note: in Case2, the bottom-left is (min_x, max_y-s0) and the top-right is (min_x+s0, max_y). Then the bottom-left has the smallest x and the smallest y? But we have max_y-s0 which might be less than max_y? Then the bottom-left has the smallest y? Actually, we have max_y-s0 <= min_y (because s0>=max_y-min_y) and min_y is the smallest y. So the smallest y is min_y, and max_y-s0 is <= min_y? Then the bottom-left has y = max_y-s0, which is the bottom? 

  So the entire square is from (min_x, max_y-s0) to (min_x+s0, max_y). Then the bottom border is at y=max_y-s0 and the top at y=max_y. So the bottom-left corner is (min_x, max_y-s0) and the top-right is (min_x+s0, max_y).

  Therefore, they are opposite.

  So the representation is consistent.

Therefore, we have the solution.

Let me write the editorial:

Editorial:

We are given N points and we wish to find an axis-aligned square (possibly degenerate) such that every point lies on the border of the square. The square is defined by two opposite corners (x1,y1) and (x2,y2) with x1<=x2 and y1<=y2, and the side length s = x2-x1 = y2-y1.

Key observations:
1. The entire set of points must be contained in the square [x1, x2] x [y1, y2]. Therefore, we must have x1 <= min_x, x2 >= max_x, y1 <= min_y, and y2 >= max_y.
2. The side length s must be at least the maximum of (max_x-min_x) and (max_y-min_y). Let s0 = max(max_x-min_x, max_y-min_y).
3. The square has four borders: left (x=x1), right (x=x2), bottom (y=y1), and top (y=y2). Every point must lie on at least one of these borders.

We consider 8 candidate squares:

Candidate 1: 
   x1 = min_x, x2 = min_x + s0
   y1 = min_y, y2 = min_y + s0

Candidate 2:
   x1 = min_x, x2 = min_x + s0
   y1 = max_y - s0, y2 = max_y

Candidate 3:
   x1 = max_x - s0, x2 = max_x
   y1 = min_y, y2 = min_y + s0

Candidate 4:
   x1 = max_x - s0, x2 = max_x
   y1 = max_y - s0, y2 = max_y

Candidate 5: (if max_x-min_x >= max_y-min_y)
   x1 = min_x, x2 = max_x
   y1 = min_y, y2 = min_y + (max_x-min_x)

Candidate 6: (if max_x-min_x >= max_y-min_y)
   x1 = min_x, x2 = max_x
   y1 = max_y - (max_x-min_x), y2 = max_y

Candidate 7: (if max_y-min_y >= max_x-min_x)
   x1 = min_x, x2 = min_x + (max_y-min_y)
   y1 = min_y, y2 = max_y

Candidate 8: (if max_y-min_y >= max_x-min_x)
   x1 = max_x - (max_y-min_y), x2 = max_x
   y1 = min_y, y2 = max_y

For each candidate, we check that every point (x,y) satisfies:
   x == x1 OR x == x2 OR y == y1 OR y == y2.

The first candidate that satisfies the condition is the answer. If none does, output "Impossible".

Why these 8 candidates? 
  - They cover the common choices of aligning the borders with the extreme values (min_x, max_x, min_y, max_y) and also the possibility of extending the square beyond the extremes to achieve the same side length in both directions.

Complexity: O(8 * N) = O(N), which is acceptable for N up to 10^5.

Note: The computed coordinates for the square in the candidates are within the bounds [-3e8, 3e8] (since min_x,min_y>=-10^8 and s0<=2e8), which satisfies the output constraints.

This solution is complete.