 Okay, we are going to follow the approach described in the editorial.
 Steps:
 1. Read the integer `n` and the matrix.
 2. We know that the tree must be built starting from node 1 (the smallest node). Then we add nodes 2, 3, ..., n.
 3. For each node `i` (from 2 to n):
      - Consider the row `i-1` (0-indexed) of the matrix (which corresponds to the i-th town).
      - We look at the entries in this row for the columns corresponding to the nodes already in the tree (which are 1 to i-1). Actually, note: the j-th element (0-indexed) in the row corresponds to j+1? Actually, the problem states: the i-th line contains A_{i,1}, A_{i,2}, ... A_{i,N}. So the first element is for j=1, second for j=2, etc.
      - For the row of node i, we consider j from 1 to i-1 (i.e., indices 0 to i-2). We want the maximum value among these A[i][j] (for j from 1 to i-1). Why maximum? Because we know that the parent of i must be a node that is already in the tree, and for the direct edge from i to its parent p, we have A_{i,p} = p (since the path from i to p has the minimum as p, because p is the only node on the path that is less than i and also the parent must be the closest node that is less than i). Moreover, the condition for any other node j (already in the tree) is that the path from i to j must go through the parent of i. Therefore, the minimum on the entire path from i to j is the minimum between the parent of i and the minimum on the path from the parent to j. But note: the parent of i is the highest node (in value) that we can get as A_{i,j} for any j? Actually, the parent p must appear as A_{i,p}=p, and for any other j, A_{i,j} must be at least the parent p? Actually, the insight is: the parent must be the maximum value we see in the row for j from 1 to i-1. Why?
        Explanation: For any node j that is in the subtree of p (the parent of i), the path from i to j goes from i to p and then from p to j. The minimum on the entire path is min( min(i,p) [but note p<i, so min(i,p)=p?] and the minimum on the path from p to j). Actually, the minimum on the path from i to j is min(p, min_path(p, j)). But note: the parent p must be the highest value that appears as A_{i,j} for j in [1, i-1] because:
          - For the parent p, we have A_{i,p}=p (since the direct edge gives that the minimum is p, because i>p and p is the only node on the direct edge that is less than i? Actually, the path is just i and p, so the minimum is min(i, p)=p).
          - For any other node j that is not in the subtree of p (but that's not possible because we are building the tree and we assume that the parent p is the direct connection for i to the existing tree) we have to consider the entire path. Actually, note: the entire existing tree is connected and we are adding i as a leaf? Not necessarily a leaf, but we are building from small to large.

        However, an important observation: the condition that the parent p is the maximum value in the row for indices 1 to i-1 is because:
          - The parent p must appear as p (so p is in the set of values we are looking at).
          - For any other node j, the path from i to j must go through p, so the minimum on the path is at most p (because p is on the path) and might be less if there is a node with a smaller label on the path from p to j. Therefore, we cannot get a value greater than p. But we can get p again? Actually, we get at least p only for the direct edge? Not exactly: if there is a node j that is connected to p and has a path that goes from p to j without any node less than p, then the minimum would be p. But note: the minimum along the path from p to j must be at least the minimum label in the entire path from p to j, which might be a node smaller than p? But we know that the entire existing tree (nodes 1 to i-1) has nodes that are less than i, but they might include 1? Actually, the parent p is the one that is the immediate connection, and the path from i to j must include the entire path from p to j, so the minimum is min( min_path(i to p), min_path(p to j) ) = min(p, min_path(p to j)). Since p is the smallest node on the path from i to p? Actually, the path from i to p has only i and p. Since i>p, the minimum is p. Then the entire path has min(p, min_path(p to j)). Now, if the min_path(p to j) is less than p, then the overall minimum is that value. But note: we are building the tree in increasing order of node labels, so when we add node i, the existing tree has nodes 1,2,...,i-1. The parent p must be the node that we found as the maximum value in the row? Actually, the problem's sample input 2:

          Input:
          6
          1 1 1 1 1 1 
          1 2 2 2 2 2 
          1 2 3 2 2 2 
          1 2 2 4 2 2 
          1 2 2 2 5 2 
          1 2 2 2 2 6 

          We build:
            Start with 1.
            For node 2: row = [1, 2, 2, 2, 2, 2] -> for j=1 (the only existing node) we get 1. But wait: the row for node 2 (0-indexed row index=1) is the second row: [1, 2, 2, 2, 2, 2]? Actually, the first row is for town 1: [1, 1, 1, 1, 1, 1]. The second row is for town 2: [1, 2, 2, 2, 2, 2]. So for j=1 (the first element, which is the connection to node 1) we have 1. Then the maximum value in the existing nodes (only node 1) is 1. So the parent of 2 is 1? Then we output (1,2). Then for node 3: row = [1, 2, 3, 2, 2, 2] (third row, index2). The existing nodes are 1 and 2. We look at the first two elements: 
              j=1: A[2][0] = 1? Actually, in 0-indexed: 
                row index 2: [1, 2, 3, 2, 2, 2] -> for j=1: the element at index0 is 1 (which is for j=1) and for j=2: the element at index1 is 2. The maximum is 2. So parent of 3 is 2? Then we output (2,3). Similarly, for node 4: row = [1,2,2,4,2,2] -> existing nodes 1,2,3: we look at the first three: 
                j=1: 1, j=2:2, j=3:2 -> maximum is 2 -> parent=2 -> edge (2,4). Similarly for node5: parent=2 -> edge (2,5). For node6: parent=2 -> edge (2,6). Then we also have the edge (1,2) from node2. But note: we built edges for 2,3,4,5,6. Then we have 5 edges. However, the sample output is:

                2 3
                2 4
                2 5
                2 6
                1 2

          How do we output the edges? The editorial says: we collect the edges and then sort them in descending order of the minimum node and ascending order of the maximum node? Actually, the sample output does not have the edge (1,2) as the last? Let me check: 
            The edges we have so far:
                node2: (min(1,2)=1, max=2) -> (1,2)
                node3: (min(2,3)=2, max=3) -> (2,3)
                node4: (2,4)
                node5: (2,5)
                node6: (2,6)

          Now, we want to sort: descending by the first element? But the first element is the min. So the edges: 
            (1,2): first element=1
            (2,3): first element=2
            (2,4):2
            (2,5):2
            (2,6):2

          Then descending by the first element: the edge (2,3), (2,4), (2,5), (2,6) come first? Then (1,2). But the sample output is:

                2 3
                2 4
                2 5
                2 6
                1 2

          So we output the edges with the larger min first? Then we output (2,3), (2,4), etc. then (1,2). But note: the sample output has the edge (1,2) last.

          Alternatively, the problem does not require a particular order? However, the problem says: "Output N-1 lines, each with two space-separated integers A_i B_i". But the sample outputs are specific. The problem sample input 1:

                Output: 
                2 1
                3 1

          Actually, note: the sample output for input1 is:
                2 1
                3 1

          But if we build:
            For node2: parent = max in row2 for j=1: the row for node2 (0-indexed row1) is [1,2,1] -> for j=1: the element at index0 is 1 -> so parent=1 -> edge (1,2) -> represented as (min=1, max=2) -> (1,2) but then we output as (1,2)? 
            But the sample output has "2 1" and "3 1". 

          How did we get that? 
            Actually, the problem input sample1:

                3
                1 1 1 
                1 2 1 
                1 1 3 

          For node2: row = [1,2,1] -> existing nodes: [1] -> we look at the first element (j=1) -> 1 -> parent=1 -> edge (1,2) -> we represent as (min(1,2)=1, max=2) -> (1,2). 
          For node3: row = [1,1,3] -> existing nodes: 1 and 2. We look at the first two elements: 
                j=1: 1
                j=2: 1 -> maximum is 1 -> parent=1 -> edge (1,3) -> (1,3).

          Then we have edges: (1,2) and (1,3). Then we sort: 
                (1,2): min=1, max=2
                (1,3): min=1, max=3

          Now, sort descending by min: both have min=1 -> then ascending by max: (1,2) then (1,3). But the sample output is:

                2 1
                3 1

          Alternatively, we can output the edges as (min, max) but then when printing we output as (max, min) if we want the smaller node to be the parent? Actually, no: the problem does not specify the order of the two nodes in the edge. The sample output for input1 is:

                2 1
                3 1

          Which is the same as (2,1) and (3,1). That is: the larger node first? Actually, note: in the sample output, the first number is the larger? 2>1 and 3>1.

          But wait: the problem says "Output N-1 lines, each with two space-separated integers A_i B_i". There is no requirement on the order of the two numbers in the edge? However, the sample outputs have the edge represented as (child, parent) in the case of the root? Or perhaps they want the edges in any order? But the problem sample outputs are specific.

          Actually, the problem says: "Sample Output #1" is:

                2 1
                3 1

          So we must output the edges in the form: for an edge (u, v) we output the larger node first? Or we output the min and then max? The sample output for input1: 
                (2,1): min=1, max=2 -> but we output 2 then 1 -> that is: we output the edge as (max, min) for the two nodes? 

          However, the sample input2 output:

                2 3
                2 4
                2 5
                2 6
                1 2

          Here, the edge (2,3) is output as (2,3) -> which is min then max? (2<3). Similarly, (2,4): min=2, max=4 -> output 2 then 4. Then (1,2): output 1 then 2 -> which is min then max? 

          But wait: in the first sample, the edge (2,1) is output as 2 then 1 -> which is max then min? 

          Actually, the problem does not specify the order of the two numbers in the edge. However, the sample outputs have:

            Input1: 
                Output: 
                    2 1
                    3 1

            Input2:
                Output:
                    2 3
                    2 4
                    2 5
                    2 6
                    1 2

          We see that in the first sample, the edges are written as (child, parent) because the root is 1 and the children are 2 and 3. But in the second sample, the root is 1, and then 2 is a child of 1, and then 3,4,5,6 are children of 2. So the edges are written as (parent, child) for the children of 2? Actually, no: the edge (2,3) has 2 as the parent and 3 as the child? Then the edge (1,2) has 1 as the parent and 2 as the child. Then the output for the first sample: 
                edge from 1 to 2: if we write (1,2) then that would be parent then child? But they wrote (2,1) and (3,1) which is the reverse: child then parent? 

          Alternatively, the problem does not care about the order? But the sample outputs are specific.

          After checking the problem statement: "each with two space-separated integers A_i B_i" and the sample outputs, we see:

            In sample1: the two edges are (2,1) and (3,1). 
            In sample2: the edges are (2,3), (2,4), (2,5), (2,6), (1,2).

          How can we reconcile? 

          Actually, note: the problem says: "construct a fake Town Map" and the tree is undirected. So the edge (u,v) can be printed in any order. However, the problem sample outputs have a specific order.

          The editorial guidelines say: 
            "Sort all edges in descending order of the minimum node, and ascending order of the maximum node for ties."

          Then the edges for sample1:
                (1,2): min=1, max=2 -> key: (-min, max) = (-1,2)
                (1,3): min=1, max=3 -> key: (-1,3)
            Then sorted: both have -1, then by max: 2 then 3? So the sorted order: (1,2) then (1,3). Then we output (1,2) and then (1,3) -> but the sample output is (2,1) and (3,1). 

          How do we get 2 and 1? We stored the edge as (min, max) = (1,2). Then when we output, we output as (min, max)? Then we would output (1,2) and (1,3). But that doesn't match.

          Alternatively, we stored the edge as (u, v) = (min, max) and then we output as (max, min) for the first sample? That would give (2,1) and (3,1). But then for the second sample: 
                edge (1,2): stored as (1,2) -> output as (2,1)? That's not the case: the last edge in the second sample is (1,2) not (2,1).

          Actually, the problem sample output for the second sample has the edge (1,2) as (1,2). 

          What is the difference? 

          In the second sample, the edge (1,2): min=1, max=2 -> so stored as (1,2). Then we output as (1,2) and that matches.

          In the first sample, the two edges are (1,2) and (1,3). Then if we output as (1,2) and (1,3) that does not match the sample output.

          But wait: the sample output for the first sample is:

                2 1
                3 1

          So that is the same as (2,1) and (3,1). How can we output the same edge in two different ways? 

          Actually, the problem does not require the edges to be directed. So we can output an edge (u,v) as either (u,v) or (v,u). However, the sample outputs have:

            Input1: output (2,1) and (3,1) -> meaning they output the root (1) as the second node in the edge? 

          The editorial says: "Represent each edge as (min(i,p), max(i,p))" and then sort. Then when printing, we output as "u v" without flipping. Then the edge (1,2) is output as "1 2". But the sample output for input1 is "2 1" and "3 1". 

          Therefore, the problem sample outputs for input1 are printed as (max, min) and for input2 we have both: 
                (2,3) -> min=2, max=3 -> output "2 3" (min first) for the non-root edges? 
                and (1,2) -> min=1, max=2 -> output "1 2" (min first) for the root edge.

          But wait: the root edge in input2 is output as (1,2) (min then max) and the other edges (2,3) etc. are also min then max? Then why in input1 we have max then min? 

          Actually, the problem does not specify the order. The judge must be accepting any representation of an undirected edge. However, the problem sample outputs are specific. So we must match the sample outputs.

          How did the sample outputs get generated? 

          Sample Input #1:

                3
                1 1 1 
                1 2 1 
                1 1 3 

          The solution:

            Start with node1.

            For node2: 
                row = second row: [1, 2, 1] -> the existing nodes are [1] -> we look at the first element (which is for j=1) -> value=1. So the parent is 1. Then we store the edge as (min(2,1)=1, max=2) -> (1,2). 

            For node3:
                row = third row: [1,1,3] -> existing nodes [1,2]. We look at the first two: 
                    j=1: 1
                    j=2: 1 -> maximum=1 -> so parent=1 -> edge (1,3).

            Then we have two edges: (1,2) and (1,3). Then we sort by descending min: 
                (1,2): key = (-1,2) -> (-1,2)
                (1,3): key = (-1,3) -> (-1,3)
                sorted: both have the same first key, then by the second key: 2 then 3 -> so (1,2) then (1,3).

            Now, we output the first edge: we output "1 2" for the first edge? But the sample output is "2 1" for the first edge? 

          Alternatively, the problem sample output is:

                2 1
                3 1

          So we want to output the edges as (max, min) for the edges that are incident to the root? But then the root edge in sample2 would be (2,1) but we have (1,2) in the sample2 output.

          This is confusing.

          Let me check the sample input1: the matrix for node2: 
                A_{2,1} = 1 -> the path from 2 to 1: the minimum is 1 -> that is correct if the edge is (1,2) or (2,1). 
                A_{2,2}=2 -> the path from 2 to 2: just 2 -> min=2 -> correct.
                A_{2,3}=1 -> the path from 2 to 3: the entire path is 2-1-3 -> min=1 -> correct.

          So the edge representation in the output does not affect the matrix. Therefore, the judge must accept any representation of the undirected edge.

          However, the problem sample outputs are specific. And the problem says: "Sample Output #1" and "Sample Output #2". So we must output the edges in the exact representation as the samples.

          How do we achieve the sample output #1? 

            We have two edges: (1,2) and (1,3). We want to output:

                2 1
                3 1

          That is: for each edge, we output the larger node first? 

          Then for edge (1,2): we output "2 1"
          For edge (1,3): we output "3 1"

          How about sample2: 
            We have edges: 
                (1,2): output "2 1" or "1 2"? 
                (2,3): output "3 2" or "2 3"?
            The sample output is:

                2 3
                2 4
                2 5
                2 6
                1 2

          So the edge (2,3) is output as "2 3", which is the min then max? (2<3). Similarly, (2,4): min then max. The edge (1,2) is output as "1 2", which is min then max? (1<2).

          But then the edge (1,2) is output as min then max, but the edge (1,2) has min=1 and max=2 -> output "1 2", which matches.

          For the edges incident to 2 and a larger node: we output the parent (2) then the child? So that would be min then max? 

          However, the edge (1,2) is incident to the root and the root is the min? So we output min then max.

          The problem: in sample1, why do we output the edges as max then min? 

          Actually, in sample1, the edges are incident to the root and a child that is larger than the root? So we want to output the child (larger) first? 

          Alternatively, the problem sample output for input1 is:

                2 1
                3 1

          which is the same as: for each edge, we output the non-root node first? Then the root. But in sample2, the root is 1, and the edge (1,2) is output as "1 2" -> which is root then child? That doesn't match.

          Actually, the problem does not require a specific order. We can output the edges in any order and the two nodes in any order? But the samples are specific.

          After reading the problem statement: "Output N-1 lines, each with two space-separated integers A_i B_i". The judge is likely to accept any representation of the undirected edge. However, to match the sample outputs exactly, we must:

            For each edge (u, v) that we store as (min, max) (so that u<=v), we then output:

                If u==1? then output as (v, u) -> that is, (v,1). 
                Else, output as (u, v).

          Then for sample1: 
                edge1: (1,2) -> u=1, so output (2,1)
                edge2: (1,3) -> output (3,1)

          Then for sample2:
                edge (1,2): output (2,1) -> but the sample output for the last edge is "1 2", not "2 1". 

          Alternatively, the sample output for sample2 does not output the root edge as (2,1) but as (1,2). So that doesn't work.

          Another possibility: the problem sample outputs are sorted in descending order by the minimum node in the edge? Then we output the edge as (max, min) if the min is 1? 

          Actually, the sample output for sample1: 
                (2,1): min=1, max=2 -> so the min is 1 -> we output as (max, min) -> (2,1)
                (3,1): output (3,1)

          For sample2: 
                (2,3): min=2, max=3 -> min is 2 (which is not 1) -> output as (min, max) -> (2,3)
                (2,4): (2,4)
                (2,5): (2,5)
                (2,6): (2,6)
                (1,2): min=1 -> output as (max,min) -> (2,1) -> but the sample output has (1,2) for the last edge.

          So that does not match.

          The problem sample output for sample2 has the edge (1,2) as (1,2). 

          How can we explain? 

          Actually, the problem says: sort the edges in descending order of the minimum node. Then for edges with the same minimum, ascending by the maximum.

          Then the edges for sample2:

                (1,2): min=1 -> key = (-1,2) -> (-1,2)
                (2,3): min=2 -> key = (-2,3) -> (-2,3)
                (2,4): min=2 -> key = (-2,4)
                (2,5): min=2 -> key = (-2,5)
                (2,6): min=2 -> key = (-2,6)

          Then sorted: 
                (-1,2) -> then (-2,3), (-2,4), (-2,5), (-2,6)

          So we output first the edge (2,3), (2,4), (2,5), (2,6), and then (1,2). 

          Now, how to represent each edge? 
          The problem sample output for the edge (1,2) is "1 2", which is the min then max? 
          For the edges (2,3) etc., they are output as "2 3", which is min then max.

          Therefore, we can output every edge as (min, max). Then:

            Sample1: 
                edges: 
                  (1,2): output "1 2"
                  (1,3): output "1 3"
                But we sorted: (1,2) then (1,3) -> so output:
                    "1 2"
                    "1 3"

                But the sample output is "2 1" and "3 1". 

          Alternatively, we output every edge as (max, min) for sample1? 

          Actually, the problem sample outputs:

            Input1: 
                Output: 
                    2 1
                    3 1

            Input2:
                Output:
                    2 3
                    2 4
                    2 5
                    2 6
                    1 2   -> here (1,2) is output as (1,2) which is min then max? 

          This is inconsistent.

          After reâ€examining the sample input1: the matrix for node2 (second row) is [1,2,1]. The matrix for node3 (third row) is [1,1,3]. 

          How about the edge (2,1): the path from 2 to 1 is 2-1, so the minimum is 1 -> matches A_{2,1}=1.
          The edge (3,1): the path from 3 to 1 is 3-1, so the minimum is 1 -> matches A_{3,1}=1.

          But what about the edge (2,3)? We don't have a direct edge. The path is 2-1-3, so the minimum is 1 -> matches A_{2,3}=1.

          So the tree has edges (2,1) and (3,1). 

          Therefore, the tree is:

                node1 is connected to node2 and node3? Actually, the edges are (1,2) and (1,3) but we can also represent as (2,1) and (3,1). They are the same.

          Conclusion: the judge is likely comparing the set of edges. Therefore, we can output the edges in any order and the two nodes in any order. 

          However, to exactly match the sample outputs, we note:

            The problem sample output for input1 has the edges (2,1) and (3,1). 
            The problem sample output for input2 has the edges (2,3), (2,4), (2,5), (2,6), (1,2).

          How did they get (2,1) for input1 and (1,2) for input2? 

          Actually, in the algorithm for input1: 
            For node2: we stored the edge as (1,2) -> then we stored as a tuple (min, max) = (1,2). 
            For node3: (1,3) -> (1,3).

          Then we sorted by descending min: 
            (1,2): key = (-1,2) 
            (1,3): key = (-1,3)
            -> so (1,2) then (1,3) in the list.

          Then we output: 
            first: we output "1 2" -> but the sample output for input1 is "2 1" for the first edge.

          How can we get "2 1"? 

          We stored the edge as (min, max). Then we can output the edge as (max, min) for the first sample? 

          Actually, there is no reason. 

          Alternatively, we can note: the sample output for input1 has the edges as (child, parent) and the parent is 1. In input2, the edge (1,2) is output as (parent, child) and the edges from node2 to its children are output as (parent, child) as well? 

          But then the edge (2,3) is (2,3) -> parent then child.

          Then why in input1 we output the edges as (child, parent)? 

          Actually, the algorithm: when we add node i, we connect it to its parent p. Then we store the edge as (i, p). Then for the output, we output the edge as "i p" (child first, then parent). 

          Then for sample1: 
                node2: edge (2,1)
                node3: edge (3,1)
                then we sort: by what? We stored the edge as (i, p). Then we sort by descending p? Or by the minimum in the edge? 

          The edge (2,1): min=1, max=2 -> the minimum is 1.
          The edge (3,1): min=1, max=3 -> minimum=1.

          Then we sort by descending minimum? Then both are 1, then by what? We didn't specify the second key.

          Alternatively, we store the edge as (min, max) = (min(i,p), max(i,p)) and then we output the stored representation as (min, max) -> then we get (1,2) and (1,3) -> which we don't want.

          Or we store the edge as (i, p) without swapping. Then we have (2,1) and (3,1). Then we sort: we want to sort by descending the minimum node in the edge? 

          For (2,1): min=1, max=2 -> key = (-1,2) -> then we sort and get (2,1) first? Actually, no: we have two edges: 
                (2,1): min=1, max=2 -> key = (-1,2)
                (3,1): min=1, max=3 -> key = (-1,3)
          Then sorted by the key: (-1,2) and then (-1,3) -> so we output (2,1) then (3,1). 

          That matches sample1.

          For sample2: 
            We add nodes in order 2,3,4,5,6.

            node2: parent=1 -> edge (2,1) -> stored as (2,1) -> then min=1, max=2 -> key=(-1,2)
            node3: parent=2 -> edge (3,2) -> stored as (3,2) -> min=2, max=3 -> key=(-2,3)
            node4: parent=2 -> edge (4,2) -> key=(-2,4)
            node5: parent=2 -> edge (5,2) -> key=(-2,5)
            node6: parent=2 -> edge (6,2) -> key=(-2,6)

          Then we sort by the key: 
            (-1,2) -> then the rest: (-2,3), (-2,4), (-2,5), (-2,6) -> so the list of edges to output: 
                (3,2), (4,2), (5,2), (6,2), (2,1)

          But then we output:
                "3 2"
                "4 2"
                "5 2"
                "6 2"
                "2 1"

          But the sample output is:

                2 3
                2 4
                2 5
                2 6
                1 2

          This is different.

          How can we get the sample output? 

          The sample output has:
                "2 3": that is parent=2, child=3 -> so we want to output as (2,3) for that edge.

          But we stored it as (3,2). 

          How about if we store the edge as (p, i) (parent, child)? Then:

            node2: edge (1,2) -> stored as (1,2) -> min=1, max=2 -> key=(-1,2)
            node3: edge (2,3) -> stored as (2,3) -> key=(-2,3)
            node4: edge (2,4) -> key=(-2,4)
            node5: edge (2,5) -> key=(-2,5)
            node6: edge (2,6) -> key=(-2,6)

          Then sort: 
            key (-1,2) -> then (-2,3), (-2,4), (-2,5), (-2,6) -> list: 
                (2,3), (2,4), (2,5), (2,6), (1,2)

          Then output:
                "2 3"
                "2 4"
                "2 5"
                "2 6"
                "1 2"

          That matches sample2.

          But what about sample1? 

            node2: parent=1 -> store as (1,2) -> key=(-1,2)
            node3: parent=1 -> store as (1,3) -> key=(-1,3)
            Then sorted: (-1,2) then (-1,3) -> output:
                "1 2"
                "1 3"

          But the sample output for sample1 is "2 1" and "3 1". 

          So we have a conflict: 
            In sample1, we want to output the edge as (child, parent) to match the sample output, but in sample2 we want to output as (parent, child) to match.

          How can we decide? 

          The problem: the sample output for sample1 has the edge (2,1) and (3,1) -> which is (child, parent). 
          The sample output for sample2 has the edge (1,2) as (1,2) (parent, child) and the others as (parent, child).

          The difference: in sample1, the parent is 1 (the smallest) and the child is greater. In sample2, the edge (1,2) is parent then child, and the edges from 2 to its children are parent then child.

          But in sample1, the root is 1. In sample2, the root is also 1. 

          Then why in sample1 we output (child, parent) and in sample2 we output (parent, child) for the root edge? 

          Actually, the sample output for sample1 has the root as the second node in the edge? 

          How about: we always output the edge as (min, max) in the stored representation? 

          Then for sample1: 
                edge (1,2): stored as (1,2) -> output "1 2" -> but sample output is "2 1"
          So that doesn't work.

          Or we output the edge as (max, min) always? 
                edge (1,2): output "2 1" -> matches sample1.
                edge (1,3): output "3 1" -> matches sample1.
                For sample2: 
                    edge (1,2): output "2 1"
                    edge (2,3): output "3 2" -> but sample output has "2 3", not "3 2".

          That doesn't work.

          How about: for an edge (u, v), we output the two nodes in ascending order? 
                sample1: 
                    (1,2) -> sorted: (1,2) -> output "1 2" -> doesn't match.
                sample2: 
                    (1,2): "1 2"
                    (2,3): "2 3"
                    ... matches sample2, but sample1 not matched.

          Or in descending order? 
                sample1: (1,2) -> output "2 1" -> matches.
                sample2: 
                    (1,2): "2 1" -> but sample output has "1 2" for the last edge? -> doesn't match.

          We see that the sample outputs for the two samples have different orders for the root edge.

          This is likely a misunderstanding: the problem sample outputs are generated by the same rule? 

          Sample1 output: 
                "2 1"
                "3 1"

          Sample2 output: 
                "2 3"
                "2 4"
                "2 5"
                "2 6"
                "1 2"

          Notice that in sample1, the two edges are both incident to 1, and they are output with the non-1 node first and then 1. 
          In sample2, the edges not incident to 1 are output with the smaller node first, and the edge incident to 1 is output with the 1 first? 

          How about: 
            For an edge (u,v), if 1 is one of the nodes, then output the edge as (other, 1). 
            Otherwise, output as (min, max).

          Then sample1: 
                (1,2): output (2,1)
                (1,3): output (3,1) -> matches.

          Sample2:
                (2,3): output (2,3) [min=2, max=3] -> matches.
                (2,4): (2,4)
                (2,5): (2,5)
                (2,6): (2,6)
                (1,2): output (2,1) -> but the sample output has (1,2) for this edge.

          So that doesn't work.

          Or: if 1 is in the edge, output as (1, other) -> then sample2: (1,2) becomes (1,2) which matches, but sample1: (1,2) becomes (1,2) -> doesn't match sample1 output.

          Given the time, and since the problem says the judge must accept any representation of the undirected edge, we will output the edge as (parent, child) for all edges. Then:

            In sample1: 
                node2: parent=1 -> edge (1,2)
                node3: parent=1 -> edge (1,3)
                then we sort the edges: 
                  We'll have two edges: (1,2) and (1,3). We sort by the key (min in the edge, then max) in descending order for the min? 
                  key for (1,2): (-1,2)
                  key for (1,3): (-1,3)
                  then we output: 
                      first: (1,2) -> "1 2"
                      second: (1,3) -> "1 3"

            This does not match sample1 output.

          Alternatively, output as (child, parent) for all edges. Then sample1: 
                edge1: (2,1)
                edge2: (3,1) -> matches sample1.
            sample2: 
                node2: (2,1)
                node3: (3,2)
                node4: (4,2)
                node5: (5,2)
                node6: (6,2)
                then sort: 
                  (2,1): key = min=1, max=2 -> (-1,2)
                  (3,2): min=2, max=3 -> (-2,3)
                  ... 
                output: 
                  (3,2) -> "3 2"
                  (4,2) -> "4 2"
                  (5,2) -> "5 2"
                  (6,2) -> "6 2"
                  (2,1) -> "2 1"

            sample2 output: 
                 3 2
                 4 2
                 5 2
                 6 2
                 2 1

            but expected: 
                 2 3
                 2 4
                 2 5
                 2 6
                 1 2

          This is the same as the sample2 output if we for each edge (u,v) we swap the two nodes? 

          sample2 output we have: 
                edge1: "2 3" -> which is the swap of "3 2"
                edge2: "2 4" -> swap of "4 2"
                ... 
                last: "1 2" -> swap of "2 1"

          So if we output every edge as (v, u) if we stored it as (u,v), then sample1 becomes: 
                stored (2,1) -> output (1,2) and (1,3) for the two edges? -> no, sample1 we stored (2,1) and (3,1). 
                (2,1) swapped becomes (1,2)
                (3,1) becomes (1,3) -> which is not sample1.

          Alternatively, if we stored the edge as (parent, child), then sample1: stored (1,2) and (1,3) -> swap: (2,1) and (3,1) -> matches sample1.
          sample2: stored (1,2), (2,3), (2,4), (2,5), (2,6) -> swap: (2,1), (3,2), (4,2), (5,2), (6,2) -> which is not sample2.

          sample2 expected: 
                not swapped: (2,3), (2,4), etc and (1,2)

          Therefore, to please sample1, we swap only the edges where the parent is 1? 

          sample1: 
                edge (1,2) -> swap to (2,1)
                edge (1,3) -> swap to (3,1)
          sample2: 
                edge (1,2) -> swap to (2,1) -> but expected (1,2) in the sample output.

          This is not working.

          Given the complexity and the fact that the edge representation does not matter for the judge (since the graph is undirected), and the samples are just two examples, I will output the edge as (min, max) for the two nodes, and then in the sorted list we will output the min first and then the max. 

          Then sample1: 
                edges: (1,2) -> output "1 2"
                       (1,3) -> output "1 3"
          sample2:
                (1,2) -> "1 2"
                (2,3) -> "2 3"
                (2,4) -> "2 4"
                (2,5) -> "2 5"
                (2,6) -> "2 6"

          Then sort sample2: 
                by descending min: 
                    min=2: edges (2,3), (2,4), (2,5), (2,6) -> sorted by the max in ascending order: (2,3), (2,4), (2,5), (2,6)
                    then (1,2) -> min=1.
                so output: 
                    "2 3"
                    "2 4"
                    "2 5"
                    "2 6"
                    "1 2"

          which matches sample2.

          For sample1, we then output: 
                after sort: 
                  (1,2) then (1,3) -> 
                    "1 2"
                    "1 3"

          which does not match sample1's output of "2 1" and "3 1".

          But the problem's sample input1 might have a tree that is different? 

          Actually, the sample input1 matrix is:

                1 1 1 
                1 2 1 
                1 1 3 

          And the output of the program in the problem statement is:

                2 1
                3 1

          So we must output in the representation used in the sample output.

          How about we output the edge as (max, min) for the entire edge set? 

          sample1: 
                (1,2) -> (2,1)
                (1,3) -> (3,1) -> matches.
          sample2: 
                (1,2) -> (2,1)
                (2,3) -> (3,2)
                (2,4) -> (4,2)
                (2,5) -> (5,2)
                (2,6) -> (6,2)

          then sort sample2 by descending min (min in the edge) of the original edge (min is the first in the stored representation (min, max) -> wait, we are now storing differently? 

          Let me be clear: 
            In the algorithm, we will store the edge as a tuple (min, max) for the two nodes. 
            Then when outputting, we will output the edge as (max, min) always.

          Then sample1 becomes: 
                (1,2) -> output "2 1"
                (1,3) -> output "3 1" -> matches sample1.

          sample2: 
                (1,2) -> output "2 1"
                (2,3) -> output "3 2"
                (2,4) -> "4 2"
                (2,5) -> "5 2"
                (2,6) -> "6 2"
            then we have to sort the list of edges by the min of the edge (which is the first element in the stored (min,max) tuple) in descending order.
                The stored tuple for the edge (1,2) is (1,2) -> min=1.
                for (2,3): (2,3) -> min=2.
                ...
            sort by descending min: 
                first: min=2 -> then min=1.
                within min=2: we have (2,3), (2,4), (2,5), (2,6) -> these have stored tuple: (2,3), (2,4), etc. -> when output as (max,min) we get (3,2), (4,2), etc.

            then the sorted order: 
                (2,3) becomes (3,2) -> key for sorting: the min of the stored tuple is 2 -> key = -2, and then the second element is 3 -> so we should sort the stored tuples by stored tuple's min and then stored tuple's max? 
                But the output is (3,2), (4,2), (5,2), (6,2), and then (2,1) for the last.

            so output: 
                "3 2"
                "4 2"
                "5 2"
                "6 2"
                "2 1"

          which is not the sample output.

          sample output is: 
                "2 3"
                "2 4"
                "2 5"
                "2 6"
                "1 2"

          Therefore, even though sample1 is matched, sample2 is not.

          Given the complexity, and since the problem has only two samples, and sample2 is available in the editorial as well, and the sample output in the editorial for sample2 is as provided, I will output the edge as (min, max) and hope that the judge is not sensitive to the order of the two nodes in the edge. 

          But sample1 then will be "1 2" and "1 3", which is not the sample output.

          How about we output the edge in the order: (smaller node first) for all edges, and then sort the list of edges by the first node descending and the second node ascending? 

          sample1: 
                edges: (1,2) and (1,3) -> 
                output in sorted order: 
                  sort by first node descending: 
                      (1,2): first node=1 -> key=-1
                      (1,3): key=-1
                  then by the second node ascending: 
                      (1,2) has second node=2, (1,3) has second node=3 -> so (1,2) then (1,3) -> 
                  output: 
                      "1 2"
                      "1 3"

          sample2: 
                edges: (1,2), (2,3), (2,4), (2,5), (2,6) -> stored as (1,2), (2,3), (2,4), (2,5), (2,6)
                sort by first node descending: 
                    (2,3), (2,4), (2,5), (2,6) have first node=2 -> key=-2.
                    (1,2) has first node=1 -> key=-1.
                within the group of first node=2: sort by second node ascending: 3,4,5,6 -> already in order.
                within the group of first node=1: only one.
                sorted: (2,3), (2,4), (2,5), (2,6), (1,2) -> output: 
                      "2 3"
                      "2 4"
                      "2 5"
                      "2 6"
                      "1 2"   -> matches sample2.

          sample1 does not match.

          The only way to match sample1 is to output the edge as ( second, first ) for the edge incident to node1? 

          We can do: 
            For an edge (u,v) (which we have stored as (min, max)), if the min is 1, then output as (max, min). 
            Otherwise, output as (min, max).

          sample1: 
                (1,2) -> min=1 -> output (2,1)
                (1,3) -> output (3,1) -> matches.
          sample2: 
                (1,2) -> output (2,1) -> but sample output has (1,2) for the last edge.

          sample2 expected: last edge "1 2", not "2 1". 

          sample2 has min=1 for the edge (1,2) -> so we would output (2,1) for it. 

          But expected sample2 output last edge is "1 2". 

          Unless the sample2 output for the edge (1,2) is not last in the sorted list? 

          In sample2, we have to sort the edges. 
          The edge (1,2) will have stored (min,max) = (1,2) -> min=1.
          The other edges have min=2.
          sorted by first node (which will be the min for these) descending: 
                min=2: for (2,3), (2,4), (2,5), (2,6) -> we output as (min, max) = (2,3), (2,4), etc.
                then min=1: (1,2) -> output as (2,1) -> 
          so the last edge is (2,1) and the sample expected last edge is (1,2).

          Therefore, we will not do that.

          Given the time, I will output the edge as (min, max) for every edge, and then sample1 will be (1,2) and (1,3) and sample2 will be (2,3) etc and (1,2) in the sorted order. 
          This matches sample2 and does not match sample1, but sample1 only has 3 nodes and the set of edges is the same.

          Alternatively, the problem might have an alternative solution for sample1? 

          The sample input1 matrix is:

                1 1 1 
                1 2 1 
                1 1 3 

          We reconstructed the tree with edges (1,2) and (1,3). 
          But the sample output is (2,1) and (3,1), which is the same set.

          Therefore, we output the edges in sorted order by the criteria and as (min, max) and hope the judge is not sensitive to the order of the two nodes in the edge. 

          However, the sample output for sample1 in the problem is specific, so the judge might check the string.

          I have an idea: output the edge in the order ( greater, smaller ) for the entire.
          sample1: 
                (1,2) -> greater=2, smaller=1 -> output "2 1"
                (1,3) -> "3 1" -> matches sample1.
          sample2: 
                (1,2) -> "2 1"
                (2,3) -> "3 2"
                (2,4) -> "4 2"
                (2,5) -> "5 2"
                (2,6) -> "6 2"
          then sort: 
                criteria: the editorial says: sort by the minimum node in the edge descending. 
                What is the minimum node in the edge? 
                    for (2,1): min=1, for (3,2): min=2, etc.
                then keys: 
                    (3,2): min=2 -> key=-2
                    (4,2): min=2 -> key=-2
                    ... 
                    (2,1): min=1 -> key=-1
                within the min=2 group, sort by the maximum node in the edge (which is the greater of the two) ascending? 
                    (3,2): greater=3, smaller=2 -> min=2, max=3.
                    (4,2): min=2, max=4.
                    -> sorted by max: (3,2), (4,2), etc.

                output: 
                    "3 2"
                    "4 2"
                    "5 2"
                    "6 2"
                    "2 1"

          which is not sample2 output.

          sample2 output is: 
                "2 3"
                "2 4"
                "2 5"
                "2 6"
                "1 2"

          So if we output the edge as ( smaller, greater ) for sample2, we would get sample2 output, but then sample1 becomes (1,2) and (1,3) -> not sample1.

          Finally, we must choose one representation. 
          I will output the edge as (min, max) [smaller first, then larger] for every edge. 
          Then sample1: 
                edges: (1,2) -> "1 2"
                       (1,3) -> "1 3"
                sorted by the min (which is 1 for both) in descending order: then we have to remember that the editorial says: descending order of the minimum node -> so the edge (1,2) and (1,3) have the same min=1, so they are by the second element (max) in ascending order: (1,2) then (1,3) -> 
                output: 
                    "1 2"
                    "1 3"

          sample2: 
                edges: (1,2), (2,3), (2,4), (2,5), (2,6) -> stored as (1,2), (2,3), (2,4), (2,5), (2,6)
                sort by min descending: 
                    (2,3): min=2 -> key=-2
                    (2,4): min=2 -> key=-2
                    (2,5): min=2 -> key=-2
                    (2,6): min=2 -> key=-2
                    (1,2): min=1 -> key=-1
                within the min=2 group, sort by max ascending: 
                    (2,3): max=3
                    (2,4):4
                    (2,5):5
                    (2,6):6 -> already in order.
                then output: 
                    "2 3"
                    "2 4"
                    "2 5"
                    "2 6"
                    "1 2"

          which matches sample2.

          For sample1, it does not match the problem's sample output, but the set of edges is the same and the judge might be tolerant.

          Or, the sample input1 provided in the problem might have a tree that is not rooted at 1 in the output representation. 

          Given the time, I will output in the format (min, max) for the edge, and then sort by min descending and by max ascending.

          We'll do:

            n = int(input)
            matrix = list of lists

            edges = []
            for i from 2 to n:
                parent = maximum value in the row for node i (0-indexed row i-1) for j in [0, i-2] (because the existing nodes are 1..i-1) -> note: the j-th element in the row corresponds to town j+1.

            But note: the matrix is given as:
                  row0: for town1: A_{1,1}, A_{1,2}, ... 
                  row1: for town2: A_{2,1}, A_{2,2}, ...

            For node i (0-indexed index = i-1), the value for town j (0-indexed index = j-1) is in the row[i-1][j-1].

            For node i, we are to consider j from 1 to i-1, which in the row is at positions 0 to i-2.

            Then for node i, we want to consider the values in row[i-1][0] to row[i-1][i-2] and find the maximum value.

            Then the parent of i is that value.

            Then the edge is (min(i, parent), max(i, parent)) = (parent, i) because parent < i.

            Then we add the edge (parent, i) to the list, and then we will represent it as (parent, i) for sorting, but note: the edge is stored as (parent, i) and parent < i, so the min is parent and the max is i.

            Then later we will sort the list of edges by the first element (parent) descending and the second element (i) ascending? 

            But the editorial says: sort by the minimum node in the edge descending, and then by the maximum node in the edge ascending.

            Since the edge is (min, max) = (parent, i), then we can sort by:
                key = ( -min, max ) = ( -parent, i )

            Then in sample1: 
                  edge for node2: parent=1 -> (1,2) -> key = (-1,2)
                  edge for node3: parent=1 -> (1,3) -> key = (-1,3)
                  sorted: since the first key is the same, then by the second key: 2<3, so (1,2) then (1,3) in the list.

            Then output: 
                  (1,2) as "1 2"
                  (1,3) as "1 3"

            sample2: 
                  node2: (1,2) -> key = (-1,2)
                  node3: (2,3) -> key = (-2,3)
                  node4: (2,4) -> key = (-2,4)
                  node5: (2,5) -> key = (-2,5)
                  node6: (2,6) -> key = (-2,6)
                  sorted: 
                      (-2,3), (-2,4), (-2,5), (-2,6), then (-1,2)
                  output: 
                      (2,3) -> "2 3"
                      (2,4) -> "2 4"
                      (2,5) -> "2 5"
                      (2,6) -> "2 6"
                      (1,2) -> "1 2"

            matches sample2.

          Therefore, we will do:

            for i from 2 to n:
                row = matrix[i-1]   # because i-th town is at index i-1
                parent = 0
                for j from 0 to i-2:   # j from 0 to i-2 inclusive -> corresponding to town j+1 from 1 to i-1
                    if row[j] > parent:
                        parent = row[j]

                then we know parent is the parent of i.
                add edge (parent, i) to the list.

            then create a list of edges, each edge is (p, i) and p < i.

            then sort the list of edges by key = ( -p, i ) 
                (because: descending in p (which is the min in the edge) and then ascending in i)

            then for each edge in the sorted list, output: p, i (which is the representation (min, max))

          sample1 output: 
                edge1: (1,2) -> then we output "1 2"
                edge2: (1,3) -> then we output "1 3"

          sample2 output: 
                edges: (2,3), (2,4), (2,5), (2,6), (1,2) -> output in sorted order: 
                      "2 3", "2 4", "2 5", "2 6", "1 2"

          This matches sample2 and does not match sample1's provided sample output, but the sample1 output in the problem is "2 1" and "3 1", which is the same set of edges.

          We must hope that the judge only cares about the set of edges.

          But note: the problem sample output for sample1 is "2 1" and "3 1", so the judge might be checking the string.

          How about: instead of outputting the edge as (p, i) [which is (min, max)] for the edge, we output it as (i, p) for sample1 and (p, i) for sample2? 
          That is not possible.

          Given the time, I will output the edge as (min, max) in the sorted order as described.

          If the sample1 is the only sample that fails, then we try to output the edge as (max, min) for sample1 and (min, max) for sample2? 
          We cannot.

          Or, we can output the edge in the sorted order as (min, max) for the edge, but then sample1 becomes (1,2) and (1,3), which is not the sample output (2 1 and 3 1) but is the same edge set.

          Given the constraints, and that sample1 has only one test, and sample2 is more complex, and sample2 matches, I will output in this way.

          Let's code accordingly.

          Note: we must be cautious about the indexing.

          Example for sample1 (n=3):
            i=2: 
                row = matrix[1] = [1, 2, 1] (from input second line: "1 2 1")
                j from 0 to i-2 = 0 to 0: only j=0 -> value=1.
                parent = 1.
                edge (1,2)

            i=3:
                row = matrix[2] = [1, 1, 3]
                j from 0 to 1 (because i-2=1): 
                    j=0: value=1
                    j=1: value=1 -> parent=1.
                edge (1,3)

          Then we have edges = [ (1,2), (1,3) ]

          Then we sort by key = ( -1, 2 ) and ( -1, 3 ) -> then sorted: (1,2), (1,3) and output:
                "1 2"
                "1 3"

          But the expected sample1 output is:
                "2 1"
                "3 1"

          However, if the judge is using an undirected edge, then (1,2) is the same as (2,1). We hope so.

          If not, we can change the sorting to output in the order: 
                sort by -min (which is -p) and then by -i (descending) for the second? 
          sample1: 
                (1,2): key = (-1, -2)
                (1,3): key = (-1, -3) -> then sorted: (1,3) then (1,2) -> output "1 3", "1 2" -> still not (2,1) and (3,1)

          or we output the edge as (i, p) for the representation? 
                sample1: 
                    (1,2) becomes (2,1) and (3,1) -> then sort: 
                      (2,1): key for sorting (min in the edge) = min(2,1)=1, and max=2 -> key = (-1,2) for the edge (2,1) stored as (min=1, max=2) in our criteria for sorting the list of edges? 

          But then we would have to store the edge differently.

          Given the time, I will output the edge as (min, max) for the edge, and hope the judge is tolerant for sample1.

          Or, the problem might have provided the matrix in 1-indexed and we are using 1-indexed for the nodes, so (1,2) is the edge between node1 and node2, and the output of (1,2) is acceptable.

          We'll output as described.

          Let's try sample2 to be sure.

          sample2 input:

                6
                1 1 1 1 1 1 
                1 2 2 2 2 2 
                1 2 3 2 2 2 
                1 2 2 4 2 2 
                1 2 2 2 5 2 
                1 2 2 2 2 6 

          We process:
            i=2: 
                row = [1,2,2,2,2,2] -> for j=0 to 0: value=1 -> parent=1 -> edge (1,2)
            i=3:
                row = [1,2,3,2,2,2] -> j=0 to 1: 
                    j=0: value=1 (for town1)
                    j=1: value=2 (for town2) -> parent=2 -> edge (2,3)
            i=4:
                row = [1,2,2,4,2,2] -> j=0 to 2:
                    j0:1, j1:2, j2:2 -> parent=2 -> edge (2,4)
            i=5: similarly -> parent=2 -> edge (2,5)
            i=6: similarly -> parent=2 -> edge (2,6)

          edges = [ (1,2), (2,3), (2,4), (2,5), (2,6) ]

          sort by key = ( -min, max ) for the edge (min, max):
                (1,2): min=1, max=2 -> key=(-1,2)
                (2,3): min=2, max=3 -> key=(-2,3)
                (2,4): key=(-2,4)
                (2,5): key=(-2,5)
                (2,6): key=(-2,6)

          sorted: 
                [ (2,3), (2,4), (2,5), (2,6), (1,2) ]

          output: 
                2 3
                2 4
                2 5
                2 6
                1 2

          matches sample2.

          Therefore, we output for sample1 as "1 2" and "1 3", and hope the judge is not checking the exact string for sample1.

          If the judge does not accept, we can change the output order of the two nodes in the edge for sample1 specifically? 
          We can do: if n==3, output as (2,1) and (3,1), else use the (min, max) for the edge.

          But the problem constraints are up to 1500, and we don't know the test cases.

          Alternatively, output every edge as (max, min) -> then sample1: 
                (1,2) becomes (2,1)
                (1,3) becomes (3,1) -> matches sample1.
          sample2: 
                (1,2) becomes (2,1)
                (2,3) becomes (3,2)
                (2,4) becomes (4,2)
                (2,5) becomes (5,2)
                (2,6) becomes (6,2)
          then sort by the min of the edge (which is the stored min) descending, and then by the stored max ascending? 
                But note: the edge we are outputting is (max, min), and the stored min is the first of the edge we had initially.

          Actually, the sorting should be done on the stored (min, max) representation, not on the output representation.

          We can sort first, then convert to (max, min) for output.

          sample1: 
                stored edges: (1,2) and (1,3) -> 
                sort by stored_min descending: both have 1, then by stored_max ascending: (1,2) then (1,3) -> 
                then output (1,2) as (2,1), (1,3) as (3,1) -> matches.

          sample2: 
                stored edges: (1,2), (2,3), (2,4), (2,5), (2,6) -> 
                sort by stored_min descending: 
                    stored_min=2: for (2,3), (2,4), (2,5), (2,6) -> within, sort by stored_max ascending: (2,3), (2,4), (2,5), (2,6)
                    then (1,2)
                then output: 
                    (2,3) as (3,2)
                    (2,4) as (4,2)
                    (2,5) as (5,2)
                    (2,6) as (6,2)
                    (1,2) as (2,1)

                -> 
                    "3 2"
                    "4 2"
                    "5 2"
                    "6 2"
                    "2 1"

          sample2 expected: 
                "2 3"
                "2 4"
                "2 5"
                "2 6"
                "1 2"

          So that does not match.

          unless we output the edge as ( stored_max, stored_min ) only for sample1-like (where the stored_min==1) and for others we output (stored_min, stored_max)? 

          sample2: 
                (1,2) -> stored_min=1 -> output (2,1)
                (2,3) -> stored_min=2 (>=2) -> output (2,3)
                (2,4) -> (2,4)
                (2,5) -> (2,5)
                (2,6) -> (2,6)
                then sort by stored_min descending: 
                    (2,3), (2,4), (2,5), (2,6) -> output in sorted order: (2,3), (2,4), etc.
                    then (1,2) -> output (2,1)
                so output: 
                    "2 3"
                    "2 4"
                    "2 5"
                    "2 6"
                    "2 1"

          sample2 expected last edge is "1 2", not "2 1". 

          Therefore, I will output the edge as (min, max) and hope the judge uses an undirected edge.

          We'll output the code in C++ as described for the sorted order by the stored min and stored max, and then output the edge as (min, max).

          If the judge is not sensitive to the order of the two nodes, then sample1 is (1,2) and (1,3) and sample2 is as expected.

          This is the code in C++.

          Note: we must sort the edges by:
                key = (-min, max) 
          then output each edge as (min, max)

          Let's code accordingly.

          Complexity: O(N^2) which is acceptable for N<=1500.

          Steps in C++:

            int n;
            cin >> n;
            vector<vector<int>> matrix(n, vector<int>(n));
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    cin >> matrix[i][j];
                }
            }

            vector<pair<int, int>> edges;

            for (int i = 2; i <= n; i++) { // i from 2 to n (inclusive), i is the town number
                int row_index = i-1; // 0-indexed row for town i
                int parent = 0;
                // j from 1 to i-1: corresponding to columns 0 to i-2 in the row.
                for (int j = 0; j < i-1; j++) {
                    if (matrix[row_index][j] > parent) {
                        parent = matrix[row_index][j];
                    }
                }
                edges.push_back({parent, i});
            }

            // Now sort the edges by: first by the first element (parent) descending, then by the second element (i) ascending.
            // We can use: 
            //   sort(edges.begin(), edges.end(), [](const pair<int,int> &a, const pair<int,int> &b) {
            //        if (a.first != b.first) return a.first > b.first;
            //        return a.second < b.second;
            //   });
            // Then output: a.first and a.second for each edge.

          However, note: the edge (parent, i) has parent < i, so the first is the min and the second is the max.

          But sample1 edge (1,2): output "1 2", which is not the sample output, but we hope.

          Let me submit and hope.

          But note: the sample input1 might be provided as a test in the system, so we must output as the problem sample output.

          One more idea: output the edge in the order ( larger, smaller ) for the edge. 
          sample1: (1,2) -> (2,1), sample2: (1,2) -> (2,1) and (2,3)-> (3,2) -> which is not sample2.

          Given the time, I will output the edge as (min, max) and hope that the judge uses a set of edges.

          If the samples provided in the problem are the only ones and sample1 is not a test in the judge, then we are safe.

          Otherwise, we can try to output the edge in the order: 
                for all edges, output ( stored_min, stored_max ) for the edge representation, and then the sorted order as described.

          Start coding accordingly.

          Note: the sample input1 has been provided in the problem, so we must pass it.

          How about: the problem sample output for sample1 is town2 to town1, town3 to town1. 
          The matrix for sample1 is:

                1 1 1
                1 2 1
                1 1 3

          condition: 
            for the edge (2,1): the path from 2 to 1 is [2,1] -> min=1 -> matches A_{2,1}=1.
            for the edge (3,1): similarly.
            for the path from 2 to 3: [2,1,3] -> min=1 -> matches A_{2,3}=1.

          The edge (1,2) is the same as (2,1) for the tree.

          Therefore, the judge should accept (1,2) and (1,3) as well.

          So we output the code as described.

          Let me code in C++.