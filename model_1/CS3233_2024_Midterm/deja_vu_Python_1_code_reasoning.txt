 Okay, let's implement the solution as described in the editorial.

 Steps:
 1. Read input: n, k, l and the list of happiness ratings.
 2. Sort the list in descending order (or ascending and then reverse, but we can use negative to make min-heap as max-heap? Actually, we want max-heap so we can use negative in heap? But the problem is we need the largest sums. Alternatively, we can use a max-heap by storing negative values? But the standard heapq in Python is a min-heap.

 However, we are going to use a max-heap for the states. Since we want to pop the largest sum first, we can store tuples as (-sum, ...) to simulate a max-heap? But the problem: the sums are positive and large. Alternatively, we can store the sum as negative so that the smallest (most negative) is the largest in absolute value.

 Actually, we'll store the state as:
   (current_sum, i, j, depth)   but we want the largest current_sum to come first.

 We can use a min-heap for the states? No. Instead, we store the state with negative current_sum so that the largest current_sum becomes the smallest negative. Then we pop the smallest negative (which is the largest positive). But that's a bit messy.

 Alternatively, we can use a max-heap by storing the current_sum as negative? Then we push (-current_sum, ...) and when we pop, we take the smallest (which is the most negative) and then use -value to get the largest.

 However, the problem: we are going to output the actual positive sums.

 But note: the editorial says to use a max-heap. We can simulate a max-heap by storing (-sum, ...) and then when we pop, we take the top and then use -sum.

 Actually, we can do:

   heap = []   # we will store tuples: (-sum, i, j, depth)

   Then, pushing a state with sum S: heapq.heappush(heap, (-S, i, j, depth))

   Then, when we pop, we get the state with the smallest key (which is the largest S).

 3. We also need to avoid duplicates? The editorial states that we generate states in a systematic way to avoid duplicates.

 Implementation details:

   Steps:
     - Sort the array in descending order? Actually, we want the top k largest. So we can sort in descending order? Or we can sort in ascending and then take the last k? Alternatively, sort in ascending and then reverse? But note the indices.

     We'll sort the array in non-increasing order.

     Let's do:
        H.sort(reverse=True)

     Then the initial sum = sum(H[0:k])

     Then, we note:
        The initial set: indices [0, 1, ..., k-1] are selected.

        The unselected elements are from index k to n-1.

     How do we represent a state?

        We are going to represent a state by:
          (current_sum, i, j, depth)

        But what do i and j mean?

        The editorial says:
          i: the highest index in the initial selection that we are replacing. 
          j: the last added element's index (the unselected element we are adding).

        Actually, we start from the initial set. Then we consider swapping an element at position i (which is in the initial set) with an element at position j (which is in the unselected set, starting at k).

        How we generate the initial states?
          For each index i in the initial set (i from 0 to k-1), we can swap it with the first unselected element (at index k). Then the new sum = initial_sum - H[i] + H[k].

        Then we push state: (new_sum, i, k, 1)

        But note: we want to avoid duplicates. The state representation must be unique? Actually, we are using (i, j) to represent the swap? But we might have multiple swaps? The depth is the number of swaps? Actually, the state is defined by the set of selected elements. However, we are generating by a series of swaps. The depth is the number of swaps? Actually, the depth is the number of swaps we have done? But in our representation, we are only doing one swap in the initial state.

        However, the next states: from a state (current_sum, i, j, depth), we can do:

          Option 1: Replace the element at j (which we added) with the next unselected element at j+1? Actually, we are replacing the last added element (which is at index j) with the next unselected element (at j+1). Then the new sum = current_sum - H[j] + H[j+1]. But note: the element that was originally at the position we swapped (i) is now back? Actually, no: we are swapping again. How do we track?

        Actually, we are not storing the entire set. The state representation in the heap is:

          (current_sum, i, j, depth) meaning:
            We have swapped the initial element at positions: i, i-1, ... (a contiguous set from i down to i-depth+1?) and then we have added elements starting from k to j.

        Actually, the editorial's state representation is a bit abstract. We can follow the method from known problems (like "K-th largest sum of contiguous subarray" or "K-th smallest sum in matrix" but different).

        Alternatively, we can use the following method:

          We consider that we start with the initial set S0 = {0,1,...,k-1}. Then we consider swapping an element from S0 with an element from the unselected set. But we want to generate the next largest sums.

          We can use a state (i, j) meaning: we have swapped the element at position i (in the initial set) with the element at position j (in the unselected set) and also we have swapped all the elements in the initial set that are to the right of i? Actually, we are going to generate:

            From a state (i, j): 
              - We can swap the element at j (which is the last we added) with the next unselected element (j+1), provided j+1 < n.
              - We can also swap the next element in the initial set to the left of i (i-1) with the element at j+1? But note: we are maintaining that we have swapped a contiguous set? Actually, the swaps are independent.

          However, the known solution for this problem (from similar problems) is:

            We sort in descending order.
            We use a heap. The state is: (current_sum, i, j) meaning that we have taken the initial set but we have swapped the element at the initial set at index i (which is the i-th largest in the initial set) with the element at j (which is the j-th largest in the entire array, but j is the index in the sorted array). Actually, j is the index in the sorted array.

          But note: we have sorted the array, so the indices are in the sorted array.

          We are going to represent:

            Let:
              selected: the indices in the initial set: [0,1,...,k-1]
              unselected: [k, k+1, ..., n-1]

          Then, we can generate a state by:

            We have swapped the element at position i (in the initial set) with the element at position j (in the unselected set). Then we can also swap the element at j with j+1? But note: we can only swap one element? Actually, we can have multiple swaps? The state we are going to store is:

            (current_sum, i, j, depth)   # depth is the count of swaps? Actually, we don't need depth? 

          Actually, the known solution (from similar problems) is to use a state that records the last swap indices to avoid duplicates. Specifically:

            We define a state as (i, j) meaning we have swapped the element at position i in the initial set with the element at position j in the unselected set, and we have also swapped all the elements in the initial set that are to the right of i? Actually, no.

          Instead, we use:

            We start from the initial set. Then we push states for each swap of an element in the initial set with the first unselected element (k). Then:

              state0 = (sum0 - H[i] + H[k], i, k)

            Then, from a state (sum_val, i, j), we can generate:

              Option 1: swap the same element i with the next unselected element (j+1): new state (sum_val - H[j] + H[j+1], i, j+1)
              Option 2: swap a new element (the next one to the left in the initial set, i-1) with the same j (but we have already swapped j? Actually, we want to use j? Actually, we have to use the next available unselected element? But note: we are building a sequence of swaps. However, the state (i, j) only represents the last swap? Actually, the known solution in many problems (like "K-th largest sum of k elements") uses:

                We push two options from a state (i, j):
                  - (i, j+1): swap the same initial element i with the next unselected element (j+1) -> but note: we are replacing the element at j (which we swapped in) with j+1? Actually, we are not removing the element at j? Actually, we are swapping the element at i with j, and then we can swap the element at i with j+1? Then we have to remove the element at j and put back the original element at i? But that is complicated.

          Actually, we are representing the entire set by the swaps. We are storing the entire set implicitly by the swaps? But we are only storing one swap? Then how to represent two swaps?

          We need a different representation.

          Known solution from problems like "find k-th largest sum of k elements" (with n up to 1000, but here n up to 10^6) requires a more efficient method.

          Actually, the known efficient solution is to use:

            We sort in descending order.

            The state: (diff, i, j) where diff is the current difference from the initial sum? Actually, we store the current sum.

          Alternatively, we can use the following representation:

            Let A = sorted list (descending) of the happiness.

            We consider the initial set: indices [0, k-1]. Then we are going to consider swaps that only involve the smallest element in the selected set and the largest element in the unselected set? But we want to generate the next largest.

          Actually, the method by Etsuji Anai (known from AtCoder) for similar problems:

            We use a heap that stores: (current_sum, i, j, last) 
            but then the generation:

              We start with the initial set: (S0, k-1, k, ...) 

            Then:

              We can remove an element from the selected set that is at index i (from the initial set) and add an element from the unselected set at index j.

            However, we can generate:

              From state (sum, i, j) [meaning we have selected the initial set up to i (which is the last selected element we are considering for removal) and we have considered the unselected set up to j (the last unselected element we added)]:

                Option 1: remove the element at i and add the element at j -> then we push (sum - A[i] + A[j], i-1, j+1) [but then we can also consider replacing the element at i with j?]

            Actually, the known solution (from the editorial) is:

              We consider two types of moves from a state (i, j, depth):

                Type 1: Replace the last added unselected element (which we added at j) with the next unselected element (j+1). Then the state becomes (i, j+1, depth) [same depth?]

                Type 2: Replace the next element in the initial set (i-1) with the same j (but then we have to add the next unselected element? Actually, we are replacing the initial element at i-1 with the element at j, and then we can also consider replacing the next one? But we are increasing the depth (number of swaps) by one.

          However, the sample solution from the editorial for the sample input works as:

            Initial: [3,3,3,2] (sorted descending). k=2.

            Initial set: [3,3] -> sum=6.

            Then, we push states for swapping the first element (index0) with index2: (6-3+3=6, 0,2,1) and swapping the second element (index1) with index2: (6-3+3=6,1,2,1).

            Then we pop 6 (from state (0,2,1)) and then we generate:

              Option1: from (0,2,1): replace the element we added (at index2) with the next unselected (index3): (6-3+2=5, 0,3,1) 
              Option2: from (0,2,1): we do a new swap: we replace the next element in the initial set (which is index0-1 = index -1? Actually, we are going to the left? We start at index0 and then the next to the left? There is no left? Actually, we are storing the index i that we swapped? Then the next swap can be on an element at index i-1? But i=0: then i-1 is -1 -> invalid.

            Actually, the state representation in the editorial says: "replace the next highest element in the initial selection (i-1)" meaning we go to the left? But the initial set indices are 0 and 1. For the state (0,2,1): we swapped the element at index0. The next swap we can do is on the element at index1? But the element at index1 is still there? Actually, we only swapped index0. So we can also swap index1? Then we generate: (6 - A[1] + A[2] -> but wait, we have already replaced index0? Then the set is { element at index2 (which we swapped in) and the element at index1? So we can swap the element at index1? Then we get: 6 - A[1] + A[3]? But note: we already have index2 in the set? Actually, we have to account: 

              Initial set: indices0 and 1: [A0, A1] = [3,3]
              Then we swapped index0 with index2: becomes [A2, A1] = [3,3] -> still 6.
              Then we want to swap A1 (which is at index1) with the next unselected? The next unselected after index2 is index3. Then we get [A2, A3] = [3,2] -> sum=5.

            But the state we generated from the first state (0,2,1) for Option2 would be: 
                current_sum = 6 - A[1] + A[3] = 6 - 3 + 2 = 5, and we set i = 1-1 = 0? Actually, the state representation: (sum, i, j, depth) -> for Option2 we do: 
                  new_i = i-1? 
                  new_j = j+1? Actually, the editorial says: "replace the next element (i-1) with the next unselected element (j+1)"? 

            Actually, the editorial says: 
              Option 2: Replace the next element in the initial selection (with index i-1) with the next unselected element (j+1) -> then the state becomes: (current_sum - A[i-1] + A[j+1], i-1, j+1, depth+1)

            But in our example: 
              state (0,2,1): 
                Option2: i-1 = -1 -> invalid? So we skip.

            Then we pop the state (1,2,1): 
              Option1: replace index2 with index3: (6-3+2=5, 1,3,1)
              Option2: replace the next element in the initial set (which is i-1=0) with the next unselected element (j+1=3): then the new sum = 6 - A[0] + A[3]? But wait, we have to account: currently the set is: we swapped the element at index1 (which was 3) with index2 (which is 3) -> so the set is [A0, A2] = [3,3]. Then if we swap the element at index0 (which is still 3) with index3 (which is 2): then we get [A3, A2] = [2,3] -> sum=5.

            How do we compute the new sum? 
              We started with the initial set: [A0, A1] = 3+3=6.
              Then we swapped index1: subtract A1 and add A2: 6 - A1 + A2 = 6 -3+3=6.
              Then we swap index0: subtract A0 (which is still there) and add A3: 6 - A0 + A3 = 6-3+2=5.

            But note: we cannot do two independent swaps arbitrarily? We have to account for the current set.

            How to compute the new sum without storing the entire set? 

            The state representation: 
              We are storing the current_sum, the index i (which is the last swapped element in the initial set that we removed), and the index j (the last added unselected element). 

            To generate Option2: we are going to remove the next element in the initial set (which is at index i-1) and add the next unselected element (j+1). Then the new sum = current_sum - A[i-1] + A[j+1].

            Why is that? 
              Because the current set has already been modified by swapping the element at i and j. Then we are swapping the element at i-1 (which is still the original element) with j+1.

            However, this is only valid if we have not swapped the element at i-1 already? Actually, we are storing the state such that we have swapped the elements from the initial set at indices from i to i+depth-1? and we have added the unselected elements from j-depth+1 to j? 

            Actually, the known solution from problems (like ABC328F) is:

              We use a state: (sum, i, j) meaning we have swapped the initial set from index i to the last (i, i+1, ... , k-1) with unselected elements from j to j+depth-1? 

            Alternatively, we can use the method from:

              "kth largest sum of k elements" from Leetcode, but with k up to 10^6.

          After checking known problems, a standard solution for "K-th largest sum of k elements" (with n up to 10^6) is:

            Sort the array in descending order.

            Let S = sum of the first k.

            We use a heap: we store (sum, i, j) meaning that we have replaced the element at position i in the initial set (i from 0 to k-1) with an element at position j (from k to n-1). Then:

              The next states from (sum, i, j) are:
                1. (sum - a[i] + a[j+1], i, j+1)   [if j+1 < n]
                2. (sum - a[i+1] + a[j], i+1, j)   [if i+1 < k and j==k?] -> no, conditionally.

            But then we might generate duplicates? 

          Actually, a known solution (from AtCoder) for the problem "K-th largest sum" is:

            #include <queue>
            #include <vector>
            #include <algorithm>
            #include <iostream>
            using namespace std;
            typedef long long ll;
            int main() {
                int n, k, l;
                cin >> n >> k >> l;
                vector<ll> a(n);
                for (int i=0; i<n; i++) cin >> a[i];
                sort(a.rbegin(), a.rend());
                ll base = 0;
                for (int i=0; i<k; i++) base += a[i];
                priority_queue<tuple<ll, int, int>> pq;
                for (int i=k-1; i>=0; i--) {
                    if (k < n) pq.push({base - a[i] + a[k], i, k});
                }
                vector<ll> ans;
                ans.push_back(base);
                set<pair<int, int>> seen;
                while (ans.size() < l && !pq.empty()) {
                    auto [val, i, j] = pq.top(); pq.pop();
                    if (seen.count({i,j})) continue;
                    seen.insert({i,j});
                    ans.push_back(val);
                    if (j+1 < n) pq.push({val - a[j] + a[j+1], i, j+1});
                    if (i-1 >=0) pq.push({val - a[i-1] + a[j], i-1, j});
                }
                // then output
            }

          But the above might not be efficient for l=10^6? Because we store a set of pairs and the heap might grow to O(l) and set operations O(log l) per state.

          However, note that the total states we generate is at most l (plus the initial k). But the problem: the same state (i,j) might be pushed multiple times? So we use a set to avoid duplicates.

          But the constraints: l up to 10^6, and the set will store at most 10^6 states? Then the memory is about 10^6 * (2 integers) * (about 16 bytes per pair? that's 32 MB) and the heap also 10^6 states. So it is acceptable.

          However, the above method:

            We start from base = sum of a[0..k-1].

            Then we push for each i from k-1 down to 0: (base - a[i] + a[k], i, k)

            Then we pop the largest value. Then from state (i,j), we generate:

              1. (val - a[j] + a[j+1], i, j+1)   [replace the unselected element at j with j+1]
              2. (val - a[i-1] + a[j], i-1, j)   [replace the next initial element (i-1) with the same unselected element j]

          Why is this correct?

          Explanation:

            The state (i,j) represents: 
              We have swapped the initial element at position i with the unselected element at j, and also we have swapped all the initial elements at positions from i to k-1? Actually, no. The state (i,j) is independent: we are only swapping one element? Then why we can generate two moves?

          Actually, the state (i,j) in the above code represents: 
            We started from the initial set and swapped the element at i with j. Then the set has the element j and the other initial elements except a[i]. 

          Then:

            Move 1: we can swap the unselected element j (which we added) with the next unselected element j+1? But then we are effectively replacing j with j+1. Then the new sum = old_sum - a[j] + a[j+1].

            Move 2: we can swap the next initial element (at position i-1) with the same j? But note: the element at j is already in the set. Then we are swapping an initial element (at i-1) with the element j? Then the set would have: 
              - We remove the element at i-1 (which is still in the set) and remove the element j (which we had previously swapped in) and then add j again? That doesn't make sense.

          Actually, the second move is: 
            We are going to swap the element at i-1 (which is still the original a[i-1]) with the element j (which is an unselected element). But note: j is already in the set? Then we cannot swap an element that is already in the set? 

          This suggests that the state representation is not storing the entire set. 

          Alternatively, the state (i,j) might represent: 
            We have swapped the initial element at position i and also the initial element at position i+1, ... and then we have added j? 

          Actually, the known solution from AtCoder for a similar problem (ABC328F) uses:

            We start with the initial set. Then we push states: 
               (base - a[i] + a[k], i, k) for each i from k-1 down to 0.

            Then from a state (val, i, j):
               Option1: swap the unselected element j with j+1: (val - a[j] + a[j+1], i, j+1)
               Option2: swap the initial element at i-1 with the unselected element j: (val - a[i-1] + a[j], i-1, j)

          How does Option2 make sense? 

          Example: 
            Initial: [3,3,3,2] (k=2). 
            base = 6.

            We push for i=1: (6 - a[1] + a[2] = 6-3+3=6, 1,2)
            We push for i=0: (6 - a[0] + a[2] = 6-3+3=6, 0,2)

            Then we pop (6,1,2): 
                Option1: (6 - a[2] + a[3] = 6-3+2=5, 1,3)
                Option2: (6 - a[0] + a[2] = 6-3+3=6, 0,2) -> but we already have (0,2) in the heap? 

            Then we pop (6,0,2):
                Option1: (6 - a[2] + a[3] = 5, 0,3)
                Option2: (6 - a[-1] ... ) -> i-1 = -1: invalid.

            Then we pop (6,0,2) again? But we have a set to avoid duplicates? 

          But wait: we pushed (0,2) and (1,2) initially. Then we pop (1,2) and we generate (0,2) again? But (0,2) is already in the heap? Then we avoid duplicates by the set? Then we skip.

          Then we pop (0,2) and then generate (0,3) and then we have the next state.

          Then we pop (5,1,3) and then (5,0,3). Then we output: 6,6,6? Actually, we output base first? Then the next two pops: two 6's? Then we have two 5's.

          The output: 
            6 (base)
            6 (from state (1,2))
            6 (from state (0,2))
            5 (from state (1,3))
            5 (from state (0,3))

          But the sample output is: 6,6,6,5,5,5 -> so we are missing one 5? 

          How do we get the third 5? 

          Actually, from state (1,3): 
            Option1: j+1 = 4 -> out of bound? 
            Option2: i-1=0: then (5 - a[0] + a[3] = 5 - a[0] + a[3] = 5-3+2=4) -> but that is not 5.

          And from state (0,3): 
            Option1: j+1=4 -> out of bound.
            Option2: i-1=-1 -> invalid.

          Then we only have two 5's? 

          How to get the third 5? 

          The sample: 
            There are 3 ways to get 5: 
              [3,2] (using the first 3 and the last 2) -> but we have two 3's at the beginning? Actually, the objects are: [3,2,3,3] -> so we have duplicates.

          The combinations:

            The objects: [3,2,3,3] -> we have:

              Ways to get 6: 
                (3,3) -> three ways: (first and third), (first and fourth), (third and fourth) -> three ways.

              Ways to get 5:
                (3,2) -> three ways: (first and second), (second and third), (second and fourth) -> three ways.

          So we need to output three 5's.

          How to get the third 5? 

          The known solution above does not generate the third 5. 

          What is the third 5? 

          The state that gives 5: 
            The set { second, third } -> which is the object at index1 and index2? But in our sorted array: [3,3,3,2] -> 
              index0: 3
              index1: 3
              index2: 3
              index3: 2

          The initial set: [0,1] -> 3+3=6.

          How do we represent the set {1,2}? 
            We swapped the element at index0 with index2: then we have {2,1} -> [a2, a1] = [3,3] -> not 5.
            How about swapping two elements? 

          Actually, the set {1,3}: 
            We swapped the element at index0 (which is the first 3) with the element at index3 (2) -> then we have: a3 and a1: 2+3=5.
            Then we swapped the element at index1 (the second 3) with the element at index3: then we have: a0 and a3: 3+2=5.
            And then the set {1,3}? How to get that? 

          How do we get the set that uses the element at index1 and index3? 
            We have to swap two elements? 

          The above method only does one swap per state. How to represent two swaps?

          Actually, the state (i,j) is intended to represent one swap? Then we cannot represent two swaps? 

          The known solution above has a second move: 
            Option2: (val - a[i-1] + a[j], i-1, j)

          This move does not change j? It only changes i to i-1. 

          How do we get a state with two swaps? 

          We start from the initial set (0,1). 
            We push state (0,2): base - a0 + a2 = 6-3+3=6.
            We push state (1,2): 6-3+3=6.

          Then we pop (1,2): 
            Then we generate:
              Option1: (1,3): 6 - a2 + a3 = 6-3+2=5.
              Option2: (0,2): but we already have that.

          Then we pop (0,2): 
            Then we generate:
              Option1: (0,3): 6 - a2 + a3 = 6-3+2=5.
              Option2: (invalid)

          Then we pop (1,3): 
            Then we generate:
              Option1: (1,4): invalid.
              Option2: (0,3): (5 - a0 + a3) = 5 - 3 + 2 = 4 -> which is not 5.

          But we have not generated the state for two swaps? 

          Actually, we have: 
            How about: from the state (0,2) we swapped the element at index0 with index2, then we can also swap the element at index1 with index3? 

          The known solution does not generate that. 

          Alternative known solution (from an accepted code in a similar problem) uses:

            We consider states that can have multiple swaps? 

          After research, the standard solution for "K-th largest sum of k elements" is to use a heap and represent the state by the last removed and added indices, and then generate:

            Option1: (i, j+1)   -> same as above
            Option2: (i+1, j)   -> but then we require that i+1 is less than k and j is the next? 

          But that did not work.

          Another known solution (from AtCoder) for a problem with n=50, k=50, l=100000 is:

            # We use a heap of states: (sum, i, j) meaning that the last swap is at initial index i and unselected index j, and we have done arbitrary swaps? 

          Actually, we need to represent multiple swaps? 

          Insight: the state (i, j) should represent: 
            The highest index in the initial set that we swapped is i, and the last unselected element we added is j.

          Then we can generate:

            Option1: replace the last added element j with j+1: (val - a[j] + a[j+1], i, j+1)
            Option2: do a new swap: swap the next element in the initial set (the one to the left of i: i-1) with the next unselected element (j+1) -> (val - a[i-1] + a[j+1], i-1, j+1)

          Why not swap the next element in the initial set (i-1) with the same j? That would be redundant because j is already in the set? 

          But the sample: to get the third 5, we need to swap index1 with index3. How can we generate that?

          We start from the initial set.

          Then we generate state (1,2): swapping index1 with index2 -> sum=6.
          Then we generate from (1,2):
             Option2: swap the next element (i-1=0) with the next unselected element (j+1=3): then we get: 6 - a0 + a3 = 6-3+2=5, and state (0,3).

          Then we also have the state (0,2) and then from (0,2) we generate (0,3): 5.

          And the state (1,3) by option1 from (1,2): 5.

          Then we have three states that yield 5: 
            (0,3): 5
            (1,3): 5
            (0,3) again? no, we avoid duplicates.

          But wait: the state (0,3) is generated twice? 
            Once from (1,2) by option2: (0,3) with sum=5.
            Once from (0,2) by option1: (0,3) with sum=5.

          But they are the same state? (0,3) -> so we avoid duplicate.

          How do we get the third 5? 

          We haven't generated the state for swapping index1 with index3 without swapping index0? 

          How is that represented? 

          We can also swap index1 with index3 directly? That would be state (1,3) generated from the initial set? 

          But we did: from the initial set, we pushed states for swapping index0 with index2 and index1 with index2. We did not push swapping index0 with index3 and index1 with index3 initially.

          However, we can push state (1,3) from (1,2) by option1: replacing index2 with index3.

          So we have:
            (0,3) -> 5 (from two different paths? but we avoid duplicate state (0,3))

          Actually, we have two distinct states that yield 5: 
            (0,3) and (1,3)

          But we need three 5's.

          How to get the third? 

          The answer is: we don't need to represent every combination explicitly, because the same sum can come from multiple states. But we output the sum, and we need to output the same sum multiple times if there are multiple configurations.

          However, the above method stores the state (i,j) and avoids duplicates, but the same sum can appear from different states.

          But in our example: 
            The state (0,3): sum = 5.
            The state (1,3): sum = 5.
            And is there a state (0,3) generated twice? We avoid by the set.

          How about a state that has two swaps? 

          We have not considered states with two swaps? 

          The known solution we described earlier does not consider two swaps in one state? 

          In the state (0,3): it was generated by swapping index0 with index3? That is one swap.

          In the state (1,3): one swap.

          How do we get the third swap? 

          There is another configuration: swapping index0 with index3 and index1 with index3? That would be two swaps? But then the set would have index3 and index3? That is not allowed.

          Actually, the configuration that yields 5 is always one swap: remove one 3 and add the 2.

          There are three ways to remove one 3: because there are three 3's in the selected set? But wait, the initial set has two 3's, and there are three 3's in the array. 

          How many initial sets are there? 
            The initial set is the first two 3's: the first and the second.

          How many ways to swap one 3 with the 2? 
            We can swap the first 3 in the initial set -> then the set becomes: the second 3 and the 2.
            We can swap the second 3 in the initial set -> then the set becomes: the first 3 and the 2.
            But there is a third 3? (the third element in the array) that is not in the initial set? 

          How do we get a set that has the third 3 and the 2? 
            That would be: swapping the first 3 with the third 3? then we have the second 3 and the third 3? that is 6, then swapping the second 3 with the 2? then we have the third 3 and the 2 -> 5.

          So that is two swaps.

          How to represent two swaps? 

          The state (0,3) only represents swapping the first 3 with the 2.
          The state (1,3) only represents swapping the second 3 with the 2.

          The two-swap state: first swap index0 with index2 (which is the third 3) -> state (0,2) with sum=6, then from state (0,2) we swap the second 3 (index1) with index3 (the 2) -> then we get sum=6 - a1 + a3 = 6-3+2=5. But this is represented by a new state: (1,3) generated from the state (0,2) by option2? 

          But note: from state (0,2) (which means we swapped index0 with index2), we generate:
             Option2: (0-1, j=2) -> i-1 = -1? invalid.

          Or from state (0,2) we generate:
             Option2: we cannot generate (1,3) because the state for two swaps would be represented as (1,3) and we already generated (1,3) from the initial swap on index1 then extended to 3.

          How then can we generate the state that does two swaps? 

          The known solution we described earlier (with two moves) does not naturally generate two swaps? 

          After further research, a better approach is to use a heap that stores the current sum and the last indices (i,j) and also allows for multiple swaps by increasing j in the unselected set and decreasing i in the selected set independently, and then the state (i,j) means that the swaps we have done are: 
             removed the initial elements at indices i, i+1, ... up to some point? 
             added the unselected elements at indices j, j-1, ... down to some point? 
          -> This is not it.

          Known solution in C++ for the sample input (from an accepted submission on a similar platform):

            #include <bits/stdc++.h>
            using namespace std;
            typedef long long ll;
            int main() {
                ios::sync_with_stdio(false);
                cin.tie(0);
                int n, k, l;
                cin >> n >> k >> l;
                vector<int> a(n);
                for (int i=0; i<n; i++) {
                    cin >> a[i];
                }
                sort(a.begin(), a.end(), greater<>());
                vector<ll> res;
                res.push_back(accumulate(a.begin(), a.begin()+k, 0LL));
                priority_queue<tuple<ll, int, int>> que;
                for (int i=0; i<k; i++) {
                    que.push({res[0] - a[i] + a[k], i, k});
                }
                set<pair<int, int>> seen;
                while (res.size()<l && !que.empty()) {
                    auto [val, i, j] = que.top(); que.pop();
                    if (seen.count({i,j})) continue;
                    seen.insert({i,j});
                    res.push_back(val);
                    if (j+1 <n) {
                        que.push({val - a[j] + a[j+1], i, j+1});
                    }
                    if (i-1>=0) {
                        que.push({val - a[i-1] + a[j], i-1, j});
                    }
                }
                for (int i=0; i<l; i++) {
                    if (i < res.size()) {
                        cout << res[i] << '\n';
                    } else {
                        cout << "-1\n";
                    }
                }
            }

          When run on the sample: 
            n=4, k=2, l=6.
            a = [3,3,3,2] (sorted descending: [3,3,3,2])

            base = 3+3 = 6.
            res = [6]

            Then we push for i=0: (6 - a0 + a2 = 6-3+3=6,0,2)
                   i=1: (6 - a1 + a2 = 6-3+3=6,1,2)

            Then we start the while:

              Pop the largest: (6,1,2) -> then push to res: res=[6,6]
              Then we mark (1,2) as seen.
              Generate:
                 j+1=3: push (6 - a2 + a3 = 6-3+2=5, 1,3)
                 i-1=0: push (6 - a0 + a2 = 6-3+3=6, 0,2) -> but (0,2) is not seen? then push.

              Pop next: (6,0,2) -> res=[6,6,6]
                 mark (0,2)
                 generate: 
                    j+1=3: (6 - a2 + a3=5,0,3)
                    i-1=-1: invalid.

              Then pop: (6,0,2) is already seen? no, we just popped it. The next largest is the (5,1,3) and (5,0,3) -> but the heap is a max-heap, so we pop the 6's first.

              Now we pop (6,0,2) and then we generate (5,0,3) and then we pop (5,1,3) and then (5,0,3) and then we have:

                res = [6,6,6,5,5,5] -> then we stop.

          How does the state (0,2) appear twice? We pushed it once initially and then again from (1,2) by option2.

          But then we avoid the duplicate by the set? So when we push (0,2) the second time, we see that (0,2) is not in the set initially? 

          Initially, we pushed (0,2) and (1,2) and then when we pop (1,2) we generate (0,2) and push it. Then when we pop (0,2) the first time (which was pushed initially), then when we later try to pop the duplicate (0,2) (pushed from state (1,2)), we see that (0,2) is in the set and skip.

          But in the above code, we do:

            while (res.size()<l && !que.empty()) {
                auto [val, i, j] = que.top(); que.pop();
                if (seen.count({i,j})) continue;   // if we've seen (i,j) then skip.
                ...

          So when we pop the duplicate (0,2), we skip.

          Therefore, the states we process are:

            (6,1,2) -> output 6, then generate (5,1,3) and (6,0,2) [but note: the heap has (6,0,2) from the initial push and now we push another (6,0,2) -> then the heap has two (6,0,2)].

            Then we pop one (6,0,2) (the initial one), output 6, and generate (5,0,3). Then we mark (0,2).

            Then we pop the next: the heap has (6,0,2) (the one generated from (1,2)) and (5,1,3) and (5,0,3). The largest is (6,0,2) but when we pop it, we see that (0,2) is already in seen -> skip.

            Then we pop (5,1,3): 
                not seen, so output 5.
                generate: 
                   j+1=4: invalid.
                   i-1=0: (5 - a0 + a3 = 5-3+2=4, 0,3) -> push.
                then mark (1,3).

            Then we pop (5,0,3): 
                not seen, output 5.
                generate: 
                   j+1=4: invalid.
                   i-1=-1: invalid.
                mark (0,3).

            Then we pop (4,0,3): 
                but we haven't outputted 5 five times? 
                and the next state is 4, which is not 5.

          We only output: 6,6,6,5,5 -> missing one 5.

          What is the issue? 

          The state (0,3) is distinct from (1,3) and both are 5, but there is a third state that yields 5? 

          How is the third 5 represented? 

          The configuration that yields 5 is always one swap: either swap the first initial element (index0) or the second (index1) or the third initial element? But there is no third initial element.

          Wait, the initial set only has two elements: indices0 and 1.

          But there is a third 3 in the array (at index2) that is not in the initial set. 

          The only way to have a sum of 5 is to have one 3 and the 2. The 3 can be any of the three 3's, and the 2 is the last element.

          How many ways to choose one 3 and the 2? 
             The 3 can be any of the three 3's: 
                 object0: 3
                 object1: 3
                 object2: 3
                 object3: 2
             So the sets are:
                 {0,3} -> 3+2=5
                 {1,3} -> 3+2=5
                 {2,3} -> 3+2=5

          So there are three ways.

          How do we represent the set {2,3}? 
             The initial set is {0,1}. To get {2,3}, we need to swap both elements: 
                 swap index0 with index2: then we have {2,1} -> [3,3] -> sum=6.
                 then swap index1 with index3: then we have {2,3} -> 3+2=5.

          This state should be represented as two swaps. 

          In our state representation, we have only one swap per state. 

          Therefore, we need to allow states that have more than one swap.

          Revised state representation:

            We store (sum, i, j, depth) where depth is the number of swaps done? 

          Then the initial states: depth=1.

          Then from a state (sum, i, j, depth):

             Option1: replace the last added element (j) with the next unselected element (j+1): new state (sum - a[j] + a[j+1], i, j+1, depth)
             Option2: do an additional swap: swap the next element in the initial set (i-1) with the next unselected element (j+1) [not the same j, because j is already used]: new state (sum - a[i-1] + a[j+1], i-1, j+1, depth+1)

          Why j+1 for the new swap? Because the unselected elements from k to n-1 are sorted in descending order, so the next best is j+1.

          Then the state for two swaps would be generated from a state of one swap.

          For the sample:

            base = 6.

            Initial states for one swap: 
               stateA: (6 - a0 + a2 = 6, 0,2,1)
               stateB: (6 - a1 + a2 = 6, 1,2,1)

            Then we pop stateB (6,1,2,1):
               Option1: (6 - a2 + a3 = 5, 1,3,1)
               Option2: (6 - a0 + a3 = 5, 0,3,2)   [depth becomes 2: two swaps]

            Then we pop stateA (6,0,2,1):
               Option1: (6 - a2 + a3 = 5, 0,3,1)
               Option2: (6 - a_invalid? ) -> i-1 = -1: invalid.

            Then we pop the states: 
               next largest is 5: we have three states: (1,3,1), (0,3,2), (0,3,1) -> and also stateB generated a (0,3,2) from stateB.

            Then we output 6,6, then 5 three times, and then we have the state (0,3,2) might generate more.

          How to generate the state for the third 5? 
            The state (0,3,2) is for two swaps: it represents that we swapped the initial element at index0 and index1 with unselected elements at index2 and index3? 

            Specifically: 
               swapped index0 with index2: then index1 with index3? 
               sum = 6 - a0 - a1 + a2 + a3 = 6 -3 -3 +3+2 = 5.

            But then the set is { index2, index3 } -> which is the third 3 and the 2.

          So we have three states that yield 5: 
             state1: (1,3,1) -> sum=5: represents swapping index1 with index3: then the set is { index0, index3 } -> the first 3 and the 2.
             state2: (0,3,1) -> sum=5: represents swapping index0 with index3: then the set is { index1, index3 } -> the second 3 and the 2.
             state3: (0,3,2) -> sum=5: represents swapping index0 with index2 and index1 with index3: then the set is { index2, index3 } -> the third 3 and the 2.

          Therefore, we have three distinct states all yielding 5.

          Note: state3 has depth=2, and we generate it from stateB by option2.

          Then the processing order might be:

            res = [6]
            heap = [ (6,0,2,1), (6,1,2,1) ]   [both 6]

            pop (6,1,2,1) -> res=[6,6]
              generate: (5,1,3,1) and (5,0,3,2)
            heap becomes: [ (6,0,2,1), (5,1,3,1), (5,0,3,2) ]  -> the heap is a max-heap, so the next pop is (6,0,2,1)

            pop (6,0,2,1) -> res=[6,6,6]
              generate: (5,0,3,1) and nothing for option2.
            heap becomes: [ (5,1,3,1), (5,0,3,2), (5,0,3,1) ]

            Then we pop the three 5's in the order: 
                The heap is a max-heap, so all 5's are equal. But we might pop (5,1,3,1) first: res=[6,6,6,5]
                   then generate from (5,1,3,1): 
                       Option1: j+1=4: invalid.
                       Option2: i-1=0: (5 - a0 + a3 = 5-3+2=4,0,3,2) -> but note: we already have a state (0,3,2) (depth=2) in the heap? But this new state is (0,3,2) with depth=2? and the sum is 4, not 5.
                Actually, from (5,1,3,1): 
                  Option2: new state: (5 - a[0] + a[3] = 5-3+2=4,0,3,2)
                Then we also have states (5,0,3,2) and (5,0,3,1) in the heap.

            Then we pop (5,0,3,2): res=[6,6,6,5,5]
                  generate: 
                     Option1: j+1=4: invalid.
                     Option2: i-1=-1: invalid.
            Then we pop (5,0,3,1): res=[6,6,6,5,5,5]

          Therefore, we output three 5's.

          So the state representation should include depth? and the moves are:

            State: (sum, i, j, depth)
            From state (sum, i, j, depth):
               Option1: if j+1 < n: new_sum = sum - a[j] + a[j+1], state = (new_sum, i, j+1, depth)
               Option2: if i-1 >=0 and j+1 < n: new_sum = sum - a[i-1] + a[j+1], state = (new_sum, i-1, j+1, depth+1)

          But note: in option2, we are not touch the element at j? We are replacing the element at i-1 (which is still in the set) with a[j+1]. And we are not removing the element we added at j? 

          Why can we do that? 

          Explanation:

            The state (sum, i, j, depth) means: 
              We have done 'depth' swaps. The swaps are: 
                 swap1: removed an initial element at index i0 and added an unselected element at index j0.
                 swap2: removed an initial element at index i1 and added an unselected element at index j1.
                 ...
                 swap_{depth}: removed an initial element at index i_{depth-1} and added an unselected element at index j_{depth-1}.
              And we require that the indices in the initial set that we swapped are contiguous and in decreasing order? Specifically, the swaps are at indices: i, i-1, ... , i-depth+1.

            Then the set of selected indices is: 
                 [0, i-depth] (initial set indices) U [ the added unselected indices: j, j-1, ... , j-depth+1] 
                 and we remove the initial set indices: [i, i-1, ..., i-depth+1].

            Therefore, the current sum = base 
                   - (a[i] + a[i-1] + ... + a[i-depth+1]) 
                   + (a[j] + a[j-1] + ... + a[j-depth+1])

            But note: the unselected elements are from index k to n-1, and we are taking them in increasing order of index? But we sorted in descending order, so a[j] is the largest unselected element we haven taken, and then a[j-1] would be the next? 

          Actually, in our sorted array (descending), the unselected elements are in descending order. So the largest unselected is a[k], then a[k+1] might be<=a[k].

          In option1: we are replacing the last added unselected element (which is a[j]) with a[j+1] (which is <= a[j]). 
          In option2: we are doing an additional swap: remove the next initial element at i-1 and add the next unselected element at j+1.

          But in the state representation, we only store the last index of the initial set removed (i) and the last index of the unselected set added (j), and the depth.

          How do we compute the sum for option2 without storing the entire history? 

          We can't! Because the sum depends on all the swaps.

          Therefore, we must recompute the sum from scratch if we store only (i,j,depth) -> no, we store the current sum in the state.

          The state stores the current sum. Then for option1: new_sum = sum - a[j] + a[j+1].
          For option2: new_sum = sum - a[i-1] + a[j+1].

          Why is option2's new_sum = sum - a[i-1] + a[j+1]? 

          Because the state (sum, i, j, depth) has not swapped the initial element at i-1 yet, and we are adding the unselected element at j+1 (which is the next available).

          But wait: the state (sum, i, j, depth) has already depth swaps. The initial elements from i down to i-depth+1 have been swapped out. Then the element at i-1 is still in the set? 

          Yes, because we only swapped out depth elements starting from i and going down to i-depth+1. Then the element at i-1 is still in the set.

          Therefore, we can swap it out and add a[j+1].

          Example for two swaps from state (6,1,2,1) (depth=1):

            Currently, we have swapped the initial element at index1. The initial element at index0 is still in the set.

            Then option2: swap the initial element at index0 (i-1=0) with the unselected element at j+1=3.

            Then the new sum = 6 - a0 + a3 = 6-3+2=5.

          But wait, the state (6,1,2,1) means: 
               base = 6.
               we swapped index1: then the sum should be 6 - a1 + a2 = 6 -3+3=6.
               then swapping index0: new_sum = 6 - a0 + a3 = 6-3+2=5.

          So it is correct.

          Therefore, the state representation works.

          We must store: (current_sum, i, j, depth)

          However, depth might not be necessary for generating new states? But the moves do not require depth explicitly. The moves only use i and j. 
            Option1: (i, j+1)
            Option2: (i-1, j+1)

          Then why store depth? 
            Actually, we don't use depth in the moves. We only use it to compute the next state? 

          But we do not need depth for the next state's sum calculation: 
            Option1: new_sum = current_sum - a[j] + a[j+1]
            Option2: new_sum = current_sum - a[i-1] + a[j+1]

          So we don't need to store depth. 

          But then how do we know the state's composition? 
            The state (i,j) might have depth = any value? -> no, because the moves are well-defined. The state (i,j) is generated with a specific depth, but the sum is stored.

          However, we do not need depth for anything. We only need i and j for generating new states and the current sum for the value.

          Therefore, we can store (current_sum, i, j) and use a set to avoid duplicate (i,j).

          But is the state (i,j) sufficient to uniquely identify the set of swaps? 
            In this method, the state (i,j) means: 
               The highest index in the initial set that we swapped is i, and the last unselected element we added is j.
            But note: the swaps are exactly: 
               swap1: remove i and add some unselected element, then swap2: remove i-1 and add another unselected element, etc.
            However, the unselected elements added are not stored explicitly, only the last one (j) is stored.

          How do we know the entire history? 
            We don't. But the current_sum is stored, and for generating new states we only need the last j to be replaced with j+1, or to swap the next initial element i-1 with the next unselected element j+1.

          Therefore, we can simply store (sum, i, j) and avoid duplicates on (i,j).

          The algorithm:

            n, k, l = map(int, input().split())
            a = list(map(int, input().split()))
            a.sort(reverse=True)
            base = sum(a[0:k])
            res = [base]

            # If l==1, we output base and done.
            heap = []
            # We use a max-heap: so we store (-sum, i, j) or (sum, i, j) and then use negative? Actually, we want the largest sum first.
            # We can store (-sum, i, j) and then pop the smallest negative sum (which is the largest positive).
            # But the state comparison in heap: by sum. We want the largest sum.

            # Alternatively, we can store (sum, i, j) and then make a max-heap by negating sum? 
            # But heapq in Python is a min-heap. So we store: (-sum, i, j) then when we pop, we get the smallest -sum (which is the largest sum).

            # But the moves: we need to compare the sum. We will use a heap for the next largest sum.

            import heapq
            heap = []   # min-heap for tuple ( -sum, i, j )
            seen = set()

            # Initial states: for i in range(k-1, -1, -1): from the largest index in the initial set to the smallest.
            #   if k < n: then we can swap a[i] with a[k]
            if k < n:
                for i in range(k-1, -1, -1):
                    new_sum = base - a[i] + a[k]
                    # state: (new_sum, i, k)
                    heapq.heappush(heap, (-new_sum, i, k))

            # Then we start popping.
            while len(res) < l and heap:
                neg_sum, i, j = heapq.heappop(heap)
                if (i,j) in seen:
                    continue
                seen.add((i,j))
                current_sum = -neg_sum
                res.append(current_sum)
                if len(res) == l:
                    break

                # Option1: replace the last added unselected element j with j+1
                if j+1 < n:
                    new_sum1 = current_sum - a[j] + a[j+1]
                    heapq.heappush(heap, (-new_sum1, i, j+1))

                # Option2: replace the next element in the initial set (i-1) with the next unselected element (j+1)
                if i-1>=0 and j+1 < n:
                    new_sum2 = current_sum - a[i-1] + a[j+1]
                    heapq.heappush(heap, (-new_sum2, i-1, j+1))

            # Then output: 
            for i in range(l):
                if i < len(res):
                    print(res[i])
                else:
                    print(-1)

          Let's test on sample input2: "5 1 10" with [1,1,1,1,1]

            sorted: [1,1,1,1,1] (descending)
            base = a0 = 1.
            res = [1]

            Then push for i in range(0, -1, -1) for i from 0 to 0? (k=1, so i from 0 to 0)
                new_sum = 1 - a0 + a1 = 1-1+1=1.
                push (-1, 0, 1)

            Then while:
                pop: (-1,0,1) -> current_sum = 1, append res=[1,1]
                mark (0,1)
                generate:
                   Option1: j+1=2: push (1 - a1 + a2 = 1, 0,2) -> (-1,0,2)
                   Option2: i-1=-1 -> invalid.

            Then pop (-1,0,2): 
                current_sum=1, res=[1,1,1]
                generate: Option1: (0,3): (-1,0,3)

            Then pop (0,3): res=[1,1,1,1]
                generate: Option1: (0,4): (-1,0,4)

            Then pop (0,4): res=[1,1,1,1,1]

            Then the heap is empty? 
            Then for the next 5, we output -1.

          This matches sample2.

          Let's run sample1: 
            a = [3,3,3,2] (k=2, l=6)
            base = a0+a1 = 3+3=6.

            Push for i in range(1, -1, -1): i=1, then i=0.
               i=1: new_sum = 6 - a1 + a2 = 6-3+3=6 -> push (-6,1,2)
               i=0: new_sum = 6 - a0 + a2 = 6-3+3=6 -> push (-6,0,2)

            Then:
              res = [6]
              heap = [(-6,1,2), (-6,0,2)]

            Pop: the smallest negative is -6, so we pop one of them. Let's say we pop (-6,1,2) first.
                current_sum = 6, res = [6,6]
                mark (1,2)
                generate:
                  Option1: j+1=3: new_sum1 = 6 - a2 + a3 = 6-3+2=5 -> push (-5,1,3)
                  Option2: i-1=0: new_sum2 = 6 - a0 + a2 = 6-3+3=6 -> push (-6,0,2)   [but (0,2) is not marked yet]

            Then pop: next smallest is -6: from state (0,2)
                current_sum=6, res=[6,6,6]
                mark (0,2)
                generate:
                  Option1: j+1=3: new_sum1 = 6 - a2 + a3 = 5 -> push (-5,0,3)
                  Option2: i-1=-1: skip.

            Then pop: the next smallest is -5: (1,3)
                current_sum=5, res=[6,6,6,5]
                mark (1,3)
                generate:
                  Option1: j+1=4: skip.
                  Option2: i-1=0: new_sum2 = 5 - a0 + a3 = 5-3+2=4 -> push (-4,0,3)   # Note: a0 is the element at index0 in the sorted array? which is 3.

            Then pop: -5 from (0,3)
                current_sum=5, res=[6,6,6,5,5]
                mark (0,3)
                generate:
                  Option1: skip.
                  Option2: skip.

            Then pop: -4 from (0,3) [but (0,3) is already marked?] -> no, we pushed (0,3) for the state (0,3) and we just popped it. The state (0,3) is now in seen. The state (0,3) for the new state (with sum=4) is different? 
                But we store state by (i,j). So when we pop (-4,0,3), we see (0,3) is in seen -> skip.

            Then the heap is empty, and we output the next line as -1.

            But we only output 5 twice, but we need three times.

          What's the issue? 

          We are missing the state (0,3) with depth=2? In our representation, the state (0,3) is used for two different configurations? 
            One: depth=1: swapped index0 with index3: sum=5.
            Two: depth=2: swapped index0 and index1 with index2 and index3: sum=5? -> but wait, in that state the last swap is at index0 and the last unselected added is index3? 
                   but also the previous swap was index1 and index2? then the last unselected element added should be index3, but the last swap added index3 and the swap before added index2.

          How would we represent the depth=2 state? 
            In our state representation, we only store (i,j) = (0,3). But the depth=1 state and depth=2 state both have (0,3)? 

          This is a conflict: two different configurations yield the same (i,j) state representation.

          How to distinguish? 

          We cannot. Therefore, we must store depth in the state? 

          But then the state becomes (i,j,depth) and we avoid duplicates on (i,j,depth).

          However, the depth is not stored in the state in the heap? and we don't use it for the sum calculation.

          Alternatively, we can notice that the depth is not needed for the sum calculation, but the same (i,j) might appear with different depths and different sums? 

          In our example, the depth=1 state (0,3) has sum=5, and the depth=2 state (0,3) has sum=5 as well? 

          Actually, no: the depth=2 state (0,3) is generated from state (1,2) by option2: then the sum=6 - a0 + a3 = 6-3+2=5.

          And the depth=1 state (0,3) is generated from state (0,2) by option1: 6 - a2 + a3 = 6-3+2=5.

          So both have the same sum and the same (i,j) representation.

          But they are the same state? 

          In terms of the set of selected objects, they are different:

             depth=1 state (0,3): the set is: remove index0 and add index3 -> selected: {1,3} -> the objects: a1 and a3: 3 and 2.

             depth=2 state (0,3): the set is: remove index0 and index1, and add index2 and index3 -> selected: {2,3} -> a2 and a3: 3 and 2.

          But the state representation (0,3) doesn't capture the depth. 

          Therefore, we must store depth in the state to avoid considering these as the same state.

          However, the moves do not require depth, but the state itself is not uniquely identified by (i,j) without depth. 

          How to compute the sum for the depth=2 state? 
             It is generated from a state of depth=1: then we did option2: new_sum = current_sum - a[i-1] + a[j+1]

          But then we store the state as (i-1, j+1) and the depth is increased by one.

          Therefore, we should store depth in the state tuple for the seen set.

          Revised: 
            state: (i, j, depth)
            but depth is not used in generating new states, only in the seen set.

          However, we don't need to store depth for the sum calculation. But for the seen set, we must store (i, j, depth) to avoid conflating states with different depths.

          But wait: the state (0,3) with depth=1 and depth=2 have the same (i,j) and the same sum, but they are different. We want to output the sum 5 three times, so we want to allow both states to be processed.

          However, the sum is the same, and we want to output the same sum multiple times. The seen set is only to avoid processing the same state twice. 

          The state (0,3) with depth=1 and (0,3) with depth=2 are different states, so we should not avoid one because of the other.

          Therefore, we must include depth in the state identifier for the seen set.

          But then the state identifier is (i, j, depth). 

          How to generate the depth for new states?

            Option1: depth remains the same.
            Option2: depth increases by 1.

          In the initial states, depth=1.

          Let's re-run sample1 with state identifier (i,j,depth) and store depth in the heap.

          We store: ( -sum, i, j, depth)

          Then the seen set will avoid the same (i,j,depth).

          The initial states:
             ( -6, 1, 2, 1)
             ( -6, 0, 2, 1)

          Then we pop ( -6, 1,2,1):
             generate:
                Option1: ( -5, 1,3,1)
                Option2: ( -6, 0,2,2)   # because depth increases by 1: depth=1+1=2, and i-1=0, j+1=3? -> no, j+1=3, but we are not using j+1 in the unselected? 
                   Actually, option2: 
                      new_sum = 6 - a0 + a3 = 6-3+2=5? -> no, wait: we are using j+1=3? 
                      But the state (1,2,1): option2: 
                         new_sum = current_sum - a[i-1] + a[j+1] = 6 - a0 + a3 = 6-3+2=5? -> no, that is 5, not 6.
                   Let me recompute: 
                      state (1,2,1): current_sum=6.
                      i-1=0, j+1=3.
                      new_sum = 6 - a0 + a3 = 6-3+2=5.
                   So we push ( -5, 0,3,2)

          Then we pop ( -6,0,2,1): 
             generate:
                Option1: ( -5,0,3,1)
                Option2: skip.

          Then we have heap: [ (-5,1,3,1), (-5,0,3,2), (-5,0,3,1) ]

          Then we pop one -5: say ( -5,1,3,1) -> res=[6,6,6,5]
             generate from (1,3,1):
                Option1: skip.
                Option2: new_sum = 5 - a0 + a4 -> invalid.
          Then pop ( -5,0,3,2): -> res=[6,6,6,5,5]
             generate: nothing.
          Then pop ( -5,0,3,1): -> res=[6,6,6,5,5,5]

          This works.

          Therefore, we will store depth in the state.

          But note: the depth is not used in the sum calculation, only in the state identifier and for generating the next states (specifically, we do not use depth in the next state's sum, but we do use it to determine the next state's depth).

          Algorithm:

            n, k, l = map(int, input().split())
            a = list(map(int, input().split()))
            a.sort(reverse=True)
            base = sum(a[:k])
            res = [base]

            # If there are no moves possible, then we break.
            if k < n:
                heap = []
                seen = set()
                # depth is initially 1 for all these states.
                for i in range(k-1, -1, -1):
                    # new state: swap a[i] with a[k]
                    new_sum = base - a[i] + a[k]
                    # state: (i, k, 1)
                    state = (i, k, 1)
                    # push: (-new_sum, i, k, 1)
                    heapq.heappush(heap, (-new_sum, i, k, 1))
                    # Note: we might push the same new_sum multiple times, but the state is different.

                while len(res) < l and heap:
                    neg_sum, i, j, depth = heapq.heappop(heap)
                    if (i,j,depth) in seen:
                        continue
                    seen.add((i,j,depth))
                    current_sum = -neg_sum
                    res.append(current_sum)
                    if len(res) == l:
                        break

                    # Option1: replace a[j] with a[j+1]
                    if j+1 < n:
                        new_sum1 = current_sum - a[j] + a[j+1]
                        new_state1 = (i, j+1, depth)
                        heapq.heappush(heap, (-new_sum1, i, j+1, depth))

                    # Option2: swap a[i-1] with a[j+1] (and increase depth by 1)
                    if i-1>=0 and j+1 < n:
                        new_sum2 = current_sum - a[i-1] + a[j+1]
                        new_state2 = (i-1, j+1, depth+1)
                        heapq.heappush(heap, (-new_sum2, i-1, j+1, depth+1))

            # Output
            for i in range(l):
                if i < len(res):
                    print(res[i])
                else:
                    print(-1)

          Let's test with sample1: 
            a = [3,3,3,2] -> k=2, n=4.
            base = 6.

            Initial states: 
               i=1: state (1,2,1) with new_sum=6 -> heap: [ (-6,1,2,1) ]
               i=0: state (0,2,1) with new_sum=6 -> heap: [ (-6,0,2,1), (-6,1,2,1) ]

            Then:
              pop state (-6,1,2,1): 
                  res = [6,6]
                  generate:
                     Option1: (1,3,1) -> new_sum = 6 - a2 + a3 = 6-3+2=5 -> heap: [ (-6,0,2,1), (-5,1,3,1) ]
                     Option2: (0,3,2) -> new_sum = 6 - a0 + a3 = 6-3+2=5 -> heap: [ (-6,0,2,1), (-5,1,3,1), (-5,0,3,2) ]

              pop state (-6,0,2,1):
                  res = [6,6,6]
                  generate:
                     Option1: (0,3,1) -> new_sum = 6 - a2 + a3 = 5 -> heap: [ (-5,1,3,1), (-5,0,3,2), (-5,0,3,1) ]

              pop state (-5,1,3,1): 
                  res = [6,6,6,5]
                  generate:
                     Option1: j+1=4 -> skip.
                     Option2: i-1=0: new_sum = 5 - a0 + a4 -> invalid? so skip.

              pop state (-5,0,3,2):
                  res = [6,6,6,5,5]
                  generate: skip.

              pop state (-5,0,3,1):
                  res = [6,6,6,5,5,5]

            This matches.

          However, note that the state (0,3,1) and (0,3,2) are different states.

          This solution might use more memory: the heap can grow to O(l) and each state has depth. But l<=10^6, so it is acceptable.

          Let's run sample3 to see if it matches.

          But sample3: "20 10 20" with the given list.

          We know the expected output.

          We trust the algorithm.

          Code implementation:

            We note: n, k, l up to 10^6.

            The initial loop: k iterations (<=10^6).

            The heap operations: at most l (10^6) states, each with two pushes -> total operations about 3*l, which is 3e6, which is acceptable.

            But worst-case, the heap size may be 2*l = 2e6, and each push is O(log(heap_size)) -> total O(l * log(l)) ~ 10^6 * log2(10^6) ~ 10^6 * 20 = 20e6, which is acceptable in Pyton (1 second).

          Let's code accordingly.

          Important: we only generate states if k < n. If k==n, then there is no unselected element, so we cannot swap. Then the only configuration is the base. Then we output base and then l-1 times -1? But note: if k==n, then there is exactly 1 configuration. So if l>1, we output base and then l-1 times -1.

          But also, if k==0? the problem states k>=1.

          We are ready to code.

          Edge: if l==0, output nothing? but l>=1.

          Let's code accordingly.

          Note: the array is 0-indexed.

          We'll do:

            n, k, l = map(int, input().split())
            a = list(map(int, input().split()))
            a.sort(reverse=True)
            base = sum(a[:k])
            res = [base]

            if k < n: 
                # we can generate states
                heap = []
                seen = set()
                # We consider i from k-1 downto 0: so that the larger i (closer to k-1) are pushed first? but the heap will sort by sum.
                for i in range(k-1, -1, -1):
                    # The new sum: base - a[i] + a[k]
                    s_val = base - a[i] + a[k]
                    # state: (i, k, 1)
                    state_tuple = (i, k, 1)
                    heapq.heappush(heap, (-s_val, i, k, 1))

                while len(res) < l and heap:
                    neg_val, i, j, depth = heapq.heappop(heap)
                    if (i,j,depth) in seen:
                        continue
                    seen.add((i,j,depth))
                    current_sum = -neg_val
                    res.append(current_sum)
                    if len(res) == l:
                        break

                    if j+1 < n:
                        new_val1 = current_sum - a[j] + a[j+1]
                        new_state1 = (i, j+1, depth)
                        heapq.heappush(heap, (-new_val1, i, j+1, depth))

                    if i-1>=0 and j+1 < n:
                        new_val2 = current_sum - a[i-1] + a[j+1]
                        new_state2 = (i-1, j+1, depth+1)
                        heapq.heappush(heap, (-new_val2, i-1, j+1, depth+1))

            # Output
            for i in range(l):
                if i < len(res):
                    print(res[i])
                else:
                    print(-1)

          Let's hope it passes.

          But note: the array a has size n, and we access a[j] and a[j+1] and a[i-1] within bounds.

          We have checks: j+1<n, and i-1>=0.

          We'll run the sample2 to be sure.

          Sample2: "5 1 10" with all ones.

            a = [1,1,1,1,1] (sorted descending: still [1,1,1,1,1])
            base = a0 = 1.
            k=1, n=5 (k<n) -> enter the if.

            for i in range(0,-1,-1): i=0 only.
                s_val = 1 - a0 + a1 = 1 - 1 + 1 = 1.
                push: (-1, 0, 1, 1)

            Then while:
                pop: ( -1,0,1,1): not seen, mark, current_sum=1, res=[1,1]
                generate:
                   Option1: j+1=2: new_val1 = 1 - a1 + a2 = 1-1+1=1 -> push (-1,0,2,1)
                   Option2: i-1=-1 -> skip.

                pop: (-1,0,2,1): res=[1,1,1]
                generate: j+1=3: push (-1,0,3,1)

                pop: (-1,0,3,1): res=[1,1,1,1]
                generate: j+1=4: push (-1,0,4,1)

                pop: (-1,0,4,1): res=[1,1,1,1,1]
                generate: j+1=5: skip.

                Then we break the while.

            Then output: 
                1
                1
                1
                1
                1
                then 5 times -1.

            This matches.

          We'll submit.

          Note: worst-case the heap may grow large, but l is 10^6 and we break when we have l elements in res.

          But the heap might contain duplicates? We avoid by the seen set.

          We use a set of tuples (i,j,depth) and the total states we generate is at most O(l) because we break at l.

          But the heap might have more than l states? However, we only generate two new states per popped state, and we pop at most l states (since we break at l). So the total states in the heap is O(l).

          We are safe.

          Let's run the sample3 to see if the output matches? 
            Input: "20 10 20" and then the 20 numbers.

            We are expected to output 20 lines: the first is 71, then 70 (7 times), then 69 (12 times) -> total 20.

          We trust the algorithm.

          Code:

            We'll write accordingly.

          Note: we are using a lot of memory: set with up to 10^6 states, and heap with up to 10^6 states. But 10^6 states is about 10^6 * (size of a tuple of 3 integers and a float? and the heap stores also the negative sum) -> about 10^6 * 24 bytes = 24 MB, which is acceptable.

          We write the code.

          IMPORTANT: We must sort in descending order.

          Let's code.