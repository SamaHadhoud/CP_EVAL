To solve this problem, we need to determine if there exists an axis-aligned square (with sides parallel to the coordinate axes) such that all given points lie on its border. The solution involves generating potential candidate squares based on the extreme coordinates of the points and checking if any of these squares satisfies the condition that every point lies on at least one of its borders.

### Approach
1. **Problem Analysis**: The problem requires connecting all given points to form an axis-aligned square where each point lies on the border of the square. The square can be degenerate (i.e., a single point). The solution involves finding any such square defined by two opposite corners or determining that it's impossible.

2. **Key Insights**:
   - The square must enclose all points, so its left border must be at most the minimum x-coordinate, the right border at least the maximum x-coordinate, the bottom border at most the minimum y-coordinate, and the top border at least the maximum y-coordinate.
   - The side length of the square must be equal in both x and y directions, i.e., \(s = X_2 - X_1 = Y_2 - Y_1\), where \(s\) is at least the maximum of the spreads in the x and y directions (\(s \geq \max(\text{max}_x - \text{min}_x, \text{max}_y - \text{min}_y)\).
   - Every point must lie on at least one border of the square (left, right, bottom, or top).

3. **Candidate Generation**:
   - **First Set (4 candidates)**: These candidates are generated by aligning the square's corners with the extreme points (min_x, min_y), (min_x, max_y), (max_x, min_y), and (max_x, max_y), with side length \(s_0 = \max(\text{max}_x - \text{min}_x, \text{max}_y - \text{min}_y)\).
   - **Second Set (4 candidates)**: These are generated conditionally:
     - If the x-spread is greater than or equal to the y-spread, two candidates are generated by fixing the left and right borders at min_x and max_x, and varying the bottom and top borders.
     - Similarly, if the y-spread is greater than or equal to the x-spread, two candidates are generated by fixing the bottom and top borders at min_y and max_y, and varying the left and right borders.

4. **Validation**: For each candidate square, check if every point lies on at least one of its borders. The first valid candidate found is the solution; if none are valid, the solution is impossible.

### Solution Code
```python
import sys

def main():
    data = sys.stdin.read().split()
    n = int(data[0])
    points = []
    xs = []
    ys = []
    index = 1
    for i in range(n):
        x = int(data[index])
        y = int(data[index+1])
        index += 2
        points.append((x, y))
        xs.append(x)
        ys.append(y)
    
    min_x = min(xs)
    max_x = max(xs)
    min_y = min(ys)
    max_y = max(ys)
    
    s1 = max_x - min_x
    s2 = max_y - min_y
    s0 = max(s1, s2)
    
    candidates = []
    candidates.append((min_x, min_x + s0, min_y, min_y + s0))
    candidates.append((min_x, min_x + s0, max_y - s0, max_y))
    candidates.append((max_x - s0, max_x, min_y, min_y + s0))
    candidates.append((max_x - s0, max_x, max_y - s0, max_y))
    
    if s1 >= s2:
        candidates.append((min_x, max_x, min_y, min_y + s1))
        candidates.append((min_x, max_x, max_y - s1, max_y))
    if s2 >= s1:
        candidates.append((min_x, min_x + s2, min_y, max_y))
        candidates.append((max_x - s2, max_x, min_y, max_y))
    
    for cand in candidates:
        x1, x2, y1, y2 = cand
        valid = True
        for (x, y) in points:
            if x == x1 or x == x2 or y == y1 or y == y2:
                continue
            else:
                valid = False
                break
        if valid:
            print(f"{x1} {x2} {y1} {y2}")
            return
    
    print("Impossible")

if __name__ == "__main__":
    main()
```

### Explanation
1. **Reading Input**: The input is read and parsed into a list of points, with their x and y coordinates stored separately.
2. **Extreme Values Calculation**: The minimum and maximum x and y coordinates are computed to determine the bounding box of the points.
3. **Spread Calculation**: The spreads in the x and y directions (\(s1\) and \(s2\)) are calculated, along with the maximum spread (\(s0\)).
4. **Candidate Generation**: Eight candidate squares are generated:
   - Four candidates align the square's corners with the extreme points using \(s0\).
   - Two candidates fix the left and right borders (if \(s1 \geq s2\)) and adjust the bottom and top borders.
   - Two candidates fix the bottom and top borders (if \(s2 \geq s1\)) and adjust the left and right borders.
5. **Validation Check**: Each candidate is checked to ensure all points lie on at least one border (left, right, bottom, or top).
6. **Output**: The first valid candidate is printed; if no candidates are valid, "Impossible" is printed.

This approach efficiently checks all plausible squares by leveraging the constraints and properties of axis-aligned squares, ensuring optimal performance even for large inputs.