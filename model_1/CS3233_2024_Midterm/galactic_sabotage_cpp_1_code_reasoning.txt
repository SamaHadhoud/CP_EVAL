 We are counting the number of indices i such that the prefix maximum at i is i.
 Why? Because if at position i the prefix maximum is i, then we have seen all numbers from 1 to i by the time we reach i.
 This allows us to split at i: the segment [1, i] can be sorted to form [1,2,...,i] and the rest can be handled independently.

 However, note: the problem says that Team Galactic wants as many boxes as possible (i.e., as many splits as possible) without making it impossible for Pichuu to sort. 
 The condition for being able to sort after splitting into contiguous boxes is that the entire sequence must be split at positions where the condition holds (and note that the condition is necessary and sufficient).

 Therefore, the maximum number of boxes (which are contiguous segments) is the number of indices i (from 1 to n) such that prefix_max[i] = i, because we can split after every such index (and we must not split at any other index to avoid breaking the sortability).

 But note: the last index n always has prefix_max[n] = n (since it's a permutation of 1..n), so we will have at least 1 split (the entire sequence) and actually we count the splits? Actually, the number of boxes is the number of splits + 1.

 However, note: if we have k indices i (from 1 to n) such that prefix_max[i] == i, then we can split at every such index (except after n, because that's the end). But actually, we split after each such index? Then we get (number of indices) boxes? Because:
   [1 ... i1] -> box1, [i1+1 ... i2] -> box2, ... [ik-1+1 ... n] -> box_k.

 However, note that the condition at i: prefix_max[i] = i, then we can split after i. Then the number of boxes is the number of such indices? Actually, we split at every such index (each index i that satisfies the condition becomes the end of a box). Then the number of boxes is the number of indices i satisfying the condition.

 For example: [3,1,2,5,4,6]:
   i=1: prefix_max=3 -> not 1 -> no break
   i=2: prefix_max=3 -> not 2 -> no break
   i=3: prefix_max=3 -> equals 3 -> break -> then we have [3,1,2] and the rest [5,4,6]
   i=4: prefix_max=5 -> not 4 -> no break
   i=5: prefix_max=5 -> equals 5 -> break -> then we split after 5: [5,4] and [6]
   i=6: prefix_max=6 -> break -> then [6] is the last box.

 So we have breaks at i=3, i=5, i=6 -> that gives 3 boxes? Actually 3 boxes: [3,1,2], [5,4], [6]. But note: the break condition at i=6 is the last element and forms one box by itself. So the total boxes is 3.

 Therefore, the answer for a state is the count of indices i (from 1 to n) such that the prefix maximum at i is i.

 However, note: the condition must hold for the entire sequence to be sortable? Actually, the condition is that the splits must occur exactly at these positions. And we are forced to split at every such position? Actually, we are allowed to split arbitrarily? But Team Galactic wants as many boxes as possible without breaking the sortability. The maximum number of boxes we can have is the maximum number of splits that we can make. We can make a split after every index i for which the condition holds. Therefore, the answer is the count of such indices.

 But note: the problem says that Team Galactic must ensure Pichuu can still sort. And the condition for sortability is that the entire sequence must be split such that in each box the numbers form a set that can be rearranged to form a contiguous increasing sequence? Actually, that is not exactly the same. 

 However, note: if we split arbitrarily (without the condition) then we might break the sortability. The necessary and sufficient condition is that we can only split at positions i where the prefix maximum is i. Why? Because then the segment [1, i] contains exactly the numbers 1..i. Then we can sort that segment to [1..i]. Then the next segment must start at i+1 and so on.

 Therefore, the maximum number of boxes is the number of indices i (1<=i<=n) such that the prefix maximum of the entire sequence at position i is i.

 How to handle swaps?
   We are given M swaps. Each swap: swap two elements at positions u and v.

   How does a swap affect the prefix maxima?
     The prefix maxima from min(u,v) to n might change.

   Steps for a swap (u, v) with u0 = min(u,v) and v0 = max(u,v):
     - Swap A[u] and A[v].
     - Then we need to update the prefix maxima from u0 to n.

   However, updating the entire array from u0 to n in O(n) per swap would be O(n*m) worst-case, which is 500000 * 500000 = 250e9, which is too slow.

   We need an efficient way.

   Observation:
     The prefix maxima is computed as:
        P[i] = max(P[i-1], A[i])

     After swapping two elements, the prefix maxima from u0 to v0 might change, and then from v0 to the next change? Actually, we can update from u0 to n, but we can break early if we see that the current P[i] becomes the same as the old P[i] and the update doesn't change the rest? But worst-case we still do O(n) per swap.

   However, note that the constraints are 500000 for both n and m. Worst-case m=500000, and if each swap requires updating 500000 elements, then total operations 250e9 which is too high.

   Alternate idea: we note that the condition at index i: P[i] == i. And we are only interested in the count of such indices.

   We can use a segment tree or Fenwick tree to update the counts, but the challenge is updating the prefix maxima quickly.

   Alternatively, note that the prefix maxima is a non-decreasing array. After swapping two elements, the prefix maxima from u0 onward might change. We can update the prefix maxima from u0 to n by:

        current = P[u0-1]   (if u0>1, else 0)
        for i from u0 to n:
            current = max(current, A[i])
            P[i] = current

   But worst-case this is O(n) per swap.

   However, we note that the array A is a permutation. The prefix maxima is non-decreasing. When we update from u0, we can break early if the current prefix maximum becomes the same as the old P[i] and we know that the rest won't change? Actually, if at some point the current computed prefix maximum becomes equal to the old P[i] and then we see that the old P[i] for the next indices are at least as large, then we can break? But note: we are updating the entire array from u0 to n.

   We can break early if the current computed prefix maximum is the same as the old P[i] for the current i and the old P[i] was already at least as large as any value we are going to see? Actually, we cannot break arbitrarily because the swap might have introduced a larger value that we haven't encountered yet? For example, if we swap a small element at a later position with a large element at an earlier position, then the prefix maxima might become larger and then we have to update the entire rest.

   However, worst-case we still do O(n) per swap.

   But note: the total cost over all swaps might be O(n*m) worst-case, which is 250e9 for n=500000 and m=500000. This is too slow in C++.

   We need a more efficient method.

   Alternate Insight:

   We note that the condition P[i] = i is equivalent to: 
        max(A[1], A[2], ..., A[i]) = i

   How many indices i satisfy that? 

   How does a swap at positions u and v affect the condition for an index i?
     - For i < min(u,v): no change.
     - For i >= min(u,v): the prefix maximum might change.

   We can try to update the condition only for indices that are affected. But note that the condition at an index i depends on the entire prefix.

   We can use a segment tree to compute the prefix maximum? But then we have to update the entire array for the swap? We only swap two elements. Then we can update the segment tree for the two positions. Then we can query the prefix maximum for each index? That would be O(n log n) per swap.

   Alternatively, we can use a Fenwick tree or segment tree for the entire array to support range maximum queries? Then we can get the prefix maximum for any index i by RMQ(1, i). Then we can check for each index i from min(u,v) to n whether the condition holds? But that is O(n log n) per swap, which is O(m * n log n) worst-case -> 500000 * 500000 * log(500000) which is about 500000*500000*20 = 5e12, too slow.

   We need a different idea.

   Insight: the prefix maximum array is non-decreasing. Therefore, the condition P[i] = i can only hold at indices i where i is at least the maximum of the first i elements. Moreover, the value of P[i] is non-decreasing and i is increasing. Therefore, the condition holds only at positions that are local maxima in the sense that they are the first time a particular maximum appears? Actually, we don't need the entire array, we just need to update the count.

   We note that the condition P[i] = i is equivalent to:
        (1) The element i appears in the prefix [1, i].
        (2) The maximum element in the prefix [1, i] is i.

   Since the array is a permutation, condition (1) and (2) are the same: condition (2) implies condition (1).

   How about we track the positions of the numbers? Let pos[i] be the position of the element i.

   Then the condition at i: 
        The prefix maximum at i must be i.
        The prefix maximum at i is the maximum element in the prefix [1, i]. Since the maximum element must be i, we require that the element i must appear in [1, i] and no element greater than i appears in [1, i]. 

   But note: the condition that no element greater than i appears in [1, i] is automatically satisfied if the maximum element is i. 

   Now, the condition holds at i if and only if the position of i is <= i and the position of every j>i is > i? Actually, no: we only require that the maximum element in [1, i] is i. Since the array is a permutation, the maximum element in [1, i] is i if and only if the element i is in [1, i] and no element greater than i is in [1, i]. 

   Therefore, the condition at i is equivalent to:
        pos[i] <= i, and for all j>i, pos[j] > i.

   How does a swap of two elements a and b at positions u and v affect the positions?
        Let x = A[u] and y = A[v] initially. Then after swap, A[u] = y and A[v] = x.
        Then we update: pos[x] becomes v, and pos[y] becomes u.

   Now, which indices i are affected?
        The condition at i is broken if previously we had an element j>i that was at a position <= i and now moves to <= i? Or if the element i moves to a position > i? 

        Specifically, the condition at i is true if:
            (a) pos[i] <= i
            (b) for all j in {i+1, i+2, ..., n}, we have pos[j] > i.

        The condition (b) can be rephrased: the minimum position of any j>i must be > i.

        Therefore, we can precompute an array M where M[i] = min{ pos[j] for j = i+1 to n }.

        Then condition (b) is M[i] > i.

        Then the condition at i is: (pos[i] <= i) and (M[i] > i).

   How to update M when we swap two numbers? 
        Note: M[i] is the minimum position of the numbers in the set {i+1, i+2, ..., n}. 

        We can maintain M with a segment tree? But note: M is defined for each i and depends on the positions of numbers > i.

        Alternatively, note that M is a non-decreasing function? Actually, M[i] = min{ pos[j] for j>i } and as i increases, the set {j>i} becomes smaller, so M[i] might be non-decreasing? Not necessarily: consider if the numbers are arranged arbitrarily.

        Actually, M[i] = min_{j>i} pos[j]. Then M[i] is the minimum of the positions of the numbers from i+1 to n. And M[i] is non-decreasing? 

        Example: 
          i: 1,2,3,4,5
          pos: [1:5, 2:4, 3:3, 4:2, 5:1] -> then M[1]=min{4,3,2,1}=1, M[2]=min{3,2,1}=1, M[3]=min{2,1}=1, M[4]=min{1}=1, M[5] = infinity (or not defined). -> not non-decreasing.

        But we can compute M backwards: 
            M[n] = infinity (or n+1, since positions are from 1 to n)
            M[i] = min(pos[i+1], M[i+1])

        Then M[i] = min( pos[i+1], M[i+1] )? But note: M[i] should be the min of all positions for j>i, so:
            M[i] = min( pos[i+1], M[i+1] )   -> this is correct.

        Therefore, we can compute M in O(n) initially.

        Now, when we swap two numbers, say we swap the numbers a and b. Then we update:
            pos[a] = v, pos[b] = u   (if originally a was at u and b at v).

        How does this affect M?
          M[i] = min( pos[i+1], M[i+1] ) for i from n-1 down to 1.

        But note: if a and b are in the set {i+1, i+2, ..., n} for a given i, then changing their positions might affect M[i]. However, we are updating only two positions. We can update M for all i? That would be O(n) per swap.

        Alternatively, we can update M backwards from min(u, v) to 1? Actually, the update of pos[j] for j = a and j = b might affect M[i] for i from min(a,b)-1 down to 1? Actually, note: M[i] depends on M[i+1] and pos[i+1]. So if we change pos[k] for some k, then M[i] for all i < k might be affected? Actually, we have:

          M[i] = min( pos[i+1], M[i+1] )

        Therefore, we can update M from k = min(a, b) and then go backwards to 1? But note: the swap affects two numbers: a and b. The indices i that are affected are i such that i+1 is either a or b? Actually, no: the change in pos[a] will affect M[i] for every i such that a>i (because then a is in the set {i+1,...,n}) and similarly for b. But note: the value M[i] is defined as the min over j>i. The change in a particular j (which is a) will only affect M[i] for i < a and similarly for b.

        However, the recurrence is:
            M[i] = min( pos[i+1], M[i+1] )

        So the update in pos[k] (for k>i) will affect M[i] only if k = i+1? Actually, no: because M[i] depends on M[i+1] which in turn depends on M[i+2] and so on. So if we change pos[k] for any k>i, then M[i] might change if that new pos[k] is less than the current M[i]. But the recurrence aggregates from the right.

        Alternatively, we can update M backwards from min(a,b) to 1? Actually, we can update M for i from min(u, v) down to 1? But note: the positions of a and b might be anywhere. Actually, the numbers a and b that are swapped are arbitrary. The positions u and v are arbitrary. The set of i that are affected by the swap in the positions of a and b are i such that i < a and i < b? Actually, for any i, the condition for M[i] is: 
            M[i] = min( pos[i+1], M[i+1] )

        The update of pos[a] and pos[b] might break the recurrence for i = a-1 and i = b-1? Then we have to update from max(a-1, b-1) down to 1? Actually, we can update from i = max(a, b) - 1 down to 1? But note: if we update a position of a number j, then the recurrence for i = j-1 is directly affected. Then the recurrence for i = j-2 is affected because M[j-1] changed, and so on. Therefore, we must update backwards from max(a-1, b-1) to 1? Actually, we can start from the larger of a and b? But note: we have two numbers: a and b. We need to update:

            Start at i0 = max(a, b) - 1, then go down to 1? 

        Actually, we have to update from the maximum index that is one less than the maximum of a and b down to 1? 

        However, note: M[i] for i >= max(a,b) is defined by numbers greater than max(a,b) which are unchanged? Actually, for i >= max(a,b), we don't care? But note: M[i] for i>=max(a,b) is computed from numbers j>i which are all >= i+1 and we haven't changed any number j>max(a,b). So we only need to update for i from min(a,b)-1 down to 1? Actually, we must update for all i from max(a,b)-1 down to 1? Because M[i] for i < min(a,b) might be affected by the change in M[i+1] which might come from a change at a or b.

        Actually, the recurrence is:
            M[n] = INF
            for i from n-1 down to 1: M[i] = min(pos[i+1], M[i+1])

        So if we change pos[k] for two k (which are a and b), then we must update M[k-1] and then M[k-2] and so on until we hit 1. But note: the update might stop if the new M[i] equals the old M[i]. We can do:

            Let start = max(a, b)   -> but note: we update pos[a] and pos[b]. Then we must update M at indices a-1 and b-1? Then the recurrence: 
                M[a-1] = min(pos[a], M[a])   -> but note: M[a] = min(pos[a+1], M[a+1]) and we haven't changed pos[a+1] or M[a+1]? Actually, we haven't changed M[a] yet? 

            Actually, we must update backwards from the maximum index that is one less than the maximum of a and b? 

        Alternatively, we can update backwards from the maximum index that is min(a,b)-1? Actually, we must update from the maximum index that is max(a,b)-1 down to 1? Because:

            The recurrence for M[i] depends on M[i+1]. So if we change M[i+1] then M[i] might change.

        Steps for updating M after updating pos[a] and pos[b]:
            Step 1: update pos[a] and pos[b] to the new positions.
            Step 2: Let start_index = max(a, b)   -> but we update M from start_index-1 down to 1? Actually, we should update from the maximum index that is affected: which is max(a-1, b-1) = max(a,b)-1? Then we go backwards to 1.

        But note: we have two numbers: a and b. We must update M at a-1 and b-1. Then because M[a-1] might change, then M[a-2] might change, and similarly for b-1. However, we can do:

            Let start = max(a, b)   -> then we update M for i from start-1 down to 1. But note: we have two independent chains? Actually, the recurrence is linear: M[i] = min(pos[i+1], M[i+1]). So we start at i = max(a,b)-1 and then go down to 1. Why? Because at i = max(a,b)-1, we use M[i+1] which is M[max(a,b)] and that is unchanged? Actually, M[i] for i>=max(a,b) is unchanged? Because we haven't changed any number j>max(a,b). Therefore, we can update from i = max(a,b)-1 down to 1? 

        However, consider: if we change the position of a number that is less than max(a,b), then the recurrence for i = max(a,b)-1 might not be affected? Actually, no: because the recurrence at i uses M[i+1] and M[i+1] is computed from numbers j>i+1. Since we haven't changed any number j>max(a,b), then M[i] for i>=max(a,b) is unchanged. Therefore, we only need to update for i from min(a,b)-1 down to 1? Actually, we must update for i from max(a,b)-1 down to 1? Because we changed two numbers: a and b, which are at positions that might be less than max(a,b). 

        Actually, we can update M for i from max_index = max(a,b)-1 down to 1? But note: the change in the position of a number j (say j=a) will affect M[i] for all i < j. Similarly, for j=b. So we must update for i from max(a,b)-1 down to 1? Actually, we must update for i from max(a-1, b-1) down to 1? And max(a-1, b-1) = max(a,b)-1.

        Therefore, we update for i from max(a,b)-1 down to 1. And then we update the condition for each i: 
            condition(i) = (pos[i] <= i) and (M[i] > i)

        Then the answer is the count of i (from 1 to n) satisfying condition(i).

        But note: updating M for i from max(a,b)-1 down to 1 is O(n) per swap -> worst-case O(m * n) which is 250e9.

        We need a faster update for M.

        Alternate for M: we can use a segment tree for the array pos, and then M[i] = min_{j>i} pos[j] can be computed by a range minimum query over the indices j>i? But note: the numbers j are the indices in the value domain, not the position domain? 

        Actually, we have an array pos[1..n] for the positions of the numbers 1..n. Then M[i] = min{ pos[j] for j in [i+1, n] }.

        Then we can build a segment tree for the array pos (over the index j from 1 to n) and then M[i] = query(i+1, n). 

        Then when we swap two numbers a and b, we swap pos[a] and pos[b]. Then we update the segment tree at indices a and b. Then we can query M[i] for any i in O(log n). But then we need to update the condition for every i from 1 to n? That is O(n) per swap.

        Alternatively, we can store the entire array M and update it by rebuilding the segment tree? Then we can get M[i] for each i by a query? But then how do we update the condition for all i? The condition at i: (pos[i]<=i) and (M[i]>i) must be updated for every i? That is O(n) per swap.

   This is too heavy.

   We need a different approach.

   Known efficient solution in contests:

        We maintain:
          ans = number of i (from 1 to n) such that (prefix_max[i] == i)

        How to update after a swap? 
          We note that the condition at i is broken only in the range [min(u,v), n] and we have to recalc the prefix maxima in that range. But we break early if possible? 

        Actually, we can update the prefix maxima from the start index (min_index = min(u,v)) to the end, and we break when the current prefix maximum becomes the same as the old one and remains unchanged for the rest? But worst-case we still do O(n) per swap.

        However, we note that the total number of times an element becomes the prefix maximum might be limited? But worst-case the entire array might change.

        Alternatively, we can use a linked list of the prefix maxima? 

        Known: the prefix maxima changes only at a few indices. Specifically, the prefix maxima is constant on intervals. We can store the next index where the prefix maximum changes? 

        But updating the next change after a swap is non-trivial.

   Given the constraints (n, m <= 500000) and that worst-case we might update 500000 indices per swap, worst-case total 250e9 which is too slow in C++.

   We need to optimize the update of the prefix maxima.

        We note: the prefix maxima is non-decreasing. After swapping, the new prefix maxima from start_index = min(u,v) is:

            current_max = (start_index>1 ? P[start_index-1] : 0)
            for i from start_index to n:
                current_max = max(current_max, A[i])
                P[i] = current_max

        Then we update the condition: break_cond[i] = (current_max == i) ? 1 : 0.

        Then we update a Fenwick tree that counts the break conditions? But updating the Fenwick tree for each i is O(n) per swap.

        How to break early? 

        Note: the prefix maxima is non-decreasing and the indices i are increasing. Therefore, the condition P[i]==i can only hold for i>=current_max. And when we update, we start at start_index. If we ever get to an index i such that the current_max is less than i, then we know that we have not met the condition at i. But if we reach an index i that is the first index where the old prefix maximum was at least i, then we might break? Actually, we cannot break because a larger element might appear later that lowers the condition? No, because we are increasing the prefix maximum as we go.

        Actually, we can break if the current_max becomes less than i? That never happens because current_max is at least the maximum of the prefix so far, and if we have seen an element as large as k then current_max>=k. But note: the condition is P[i]==i, so if current_max < i, then we skip. But if we are at i and current_max < i, then we set P[i] = current_max (which is < i) so condition fails.

        How about we break when the current_max becomes at least n? Then we know the rest will be n? Actually, n is the maximum.

        But note: we are updating the entire array from start_index to n. 

        However, we note that the array is a permutation. The maximum value is n. Therefore, once we have current_max = n, then for all j from that index to n, the prefix maximum is n. Then the condition P[j]==j holds only for j=n. So we can do:

            for i from start_index to n:
                current_max = max(current_max, A[i])
                if current_max == n:
                    Then we know for the rest: 
                         for j from i to n-1: condition fails (because P[j] = n != j, unless j=n)
                    Then set P[i] = n, and break_cond[i] = 0 (unless i==n then 1) and then for j>i: we only need to set j=n: condition holds? 
                    Actually, we set P[i] = n, then for j>i: P[j] = n. So condition holds only at j=n.

        But we can break at the moment we set current_max = n? Then we set:
            P[i] = n for all j>=i.
            Then we mark the condition at j=n as 1, and for the indices from i to n-1: condition fails.

        This gives an optimization: we break the loop when current_max becomes n. Then we know the rest of the prefix maxima are n.

        Then we update the condition for the indices from start_index to i (the point where we set current_max=n) and then set the condition for j=n.

        But note: what if we don't hit n? Then we have to go to n.

        Worst-case we update O(n) per swap, but in practice we break at the maximum? The maximum n appears at some position. Then the update will break at the first occurrence of n after start_index. 

        The position of n is fixed? But we swap, so n might move. 

        Therefore, we can break when we update the prefix maximum to n. Then the loop runs at most (position_of_n - start_index + 1) steps. But worst-case if n is at the end, we still run to the end? That is O(n) per swap.

        Worst-case total O(m * n) which is 250e9.

   However, note that the problem constraints say that both n and m are 500000. 250e9 operations in C++ might be borderline? But worst-case 250e9 operations is about 250 seconds in C++? We need a better solution.

   Known efficient solution from contest:

        We note that the condition (prefix_max[i] == i) is equivalent to the condition that the maximum element in the prefix [1, i] is i, which is equivalent to the position of i is in [1,i] and the position of every element greater than i is beyond i.

        And we can track the minimum position of the elements greater than i (call it M[i]). Then condition(i) = (pos[i] <= i) and (M[i] > i).

        How to compute M[i] quickly? 
            M[i] = min{ pos[j] for j>i }.

        How to update M[i] when we swap two elements a and b?
            We update pos[a] and pos[b]. Then M[i] for all i might change? Actually, M[i] = min_{j>i} pos[j] is the minimum over j>i. So we can build a segment tree (or Fenwick tree) that stores the array pos, and then M[i] = query(i+1, n) (range minimum query).

        Then the condition at i: 
            cond[i] = (pos[i] <= i) and (M[i] > i)

        Then the answer = count of cond[i] for i in [1, n].

        How to update after a swap?
            Let a and b be the values at positions u and v.
            Swap A[u] and A[v] -> then swap pos[a] and pos[b].
            Then update the segment tree at indices a and b (if we are storing a segment tree over the values?).

            But note: our segment tree for M is built on the indices of the values? Actually, we have an array indexed by value: the positions of the values. Then M[i] = min_{j=i+1}^{n} pos[j]. 

            We can build a segment tree for the array 'pos' (where the index of the segment tree is the value j, and the stored value is pos[j]). Then M[i] = seg_tree.query(i+1, n).

            Then we update the segment tree for the two indices a and b: set pos[a] = v, pos[b] = u. Then update the segment tree at a and b.

            Then for each i, we can recalc cond[i]? But we cannot iterate over all i (n up to 500000) for each swap.

        Instead, we can note that the swap only affects:

            - cond[a] and cond[b]: because we changed pos[a] and pos[b] and also M[a] and M[b] are computed from the segment tree and they might change? Actually, cond[i] for any i depends on:
                  cond[i] = (pos[i] <= i) and (M[i] > i)

            - Also, M[i] for i < min(a,b) might change? Actually, M[i] = min_{j>i} pos[j] depends on the entire set of j>i. Changing two j (a and b) might change M[i] for every i. But we can get M[i] by the segment tree query.

        However, we cannot update the condition for every i for each swap.

        We need to update the count of cond[i] efficiently.

        How about we store an array cond[1..n] and a Fenwick tree for cond? Then when cond[i] changes, we update the Fenwick tree.

        Which indices i have cond[i] changed?

          cond[i] = (pos[i] <= i) and (M[i] > i)

          The swap changes:
             - For i = a: cond[a] = (pos[a] <= a) and (M[a] > a)
             - For i = b: similarly.

             - For i < min(a,b): 
                 M[i] = min_{j>i} pos[j] might change? Because we changed two j (a and b) that are > i? So if the new min in the range [i+1, n] is different, then M[i] changes and cond[i] might change.

             - For i in [min(a,b), max(a,b)]: 
                 Similarly, M[i] might change.

          Actually, M[i] changes for every i such that the new value of M[i] (the min over j>i) is different from the old one. And the set of i that are affected is all i from 1 to max(a,b)-1? Because if i >= max(a,b), then M[i] is computed only from j>i>=max(a,b) and we haven't changed any j>max(a,b) (we changed a and b which are <= max(a,b)). 

          Actually, we changed two values: a and b. Then for i such that i < min(a,b): both a and b are in the set j>i, so M[i] might change.
          For i in [min(a,b), max(a,b)): only the larger one (max(a,b)) is in the set? Actually, the set j>i for i in [min(a,b), max(a,b)) includes max(a,b) but not min(a,b) (because min(a,b) <= i). 
          For i>=max(a,b): no change.

          Therefore, the indices i that are affected are i in [1, max(a,b)-1]. 

          There are O(n) indices, so updating them all is O(n) per swap.

        This is too heavy.

   We need to find the set of i for which M[i] changes and update only these.

        M[i] = min( pos[i+1], M[i+1] )   [from the recurrence] OR from the segment tree query.

        But with the segment tree we can get the new M[i] quickly? 

        However, we cannot avoid iterating over i in [1, max(a,b)-1] to update M[i] and then cond[i]. 

        And then updating the Fenwick tree for cond[i] for each change.

        Worst-case total operations: sum_{swap} (max(a,b)-1) which in the worst-case is O(m * n) = 250e9.

   Given the complexity, and that the sample size is 500000, we must hope that the average is low? But worst-case is 250e9.

   We need a breakthrough.

   Insight from known problems: the answer is the number of i such that the prefix maximum at i is i. And after swap, only the prefix maxima in the interval [min(u,v), n] change. And the prefix maxima is a non-decreasing array. Therefore, the changes are contiguous. 

   And the condition for a break (P[i]==i) is very sparse: at most n breaks. 

   We can maintain a balanced BST of the indices i where the condition holds. 

   But how to update the condition for i in [min(u,v), n] quickly? 

   Alternatively, we can use a segment tree that supports range updates and then queries for the count of indices i in [L,R] such that P[i]==i. But updating the entire prefix maxima for a range [min(u,v), n] is O(n) per swap.

   There is a known offline method? I don't know.

   Given the time, and that the intended solution might be the O(n) per swap with an optimization to break when the prefix maximum becomes n, we hope that in practice the break happens early.

   Why might it break early? 
        The maximum value n might appear early. In the worst-case, we might have the array sorted in decreasing order: then the first element is n. Then in the update, we start at min(u,v) and then at the first index we set current_max = n, and then we break.

   But what if we swap two elements that are not near n? Then the prefix maxima might not become n until the end.

   Worst-case example: 
        We have an increasing array: [1,2,...,n] 
        Then the condition holds at every i: P[i]=i, so break_cond[i]=1 for every i.
        Now swap two small elements, say at positions 1 and 2: swap(1,2) -> [2,1,3,...,n]
        Then update from index 1:
            i=1: current_max = max(0,2)=2 -> P[1]=2 -> condition: 2==1? false -> break_cond[1] becomes 0.
            i=2: current_max = max(2,1)=2 -> P[2]=2 -> condition: 2==2? true -> break_cond[2] becomes 1.
            i=3: current_max = max(2,3)=3 -> P[3]=3 -> condition: 3==3 -> true.
            ... until i=n.

        This requires O(n) time.

   And if we do this swap many times (swapping position 1 and 2 repeatedly), then each swap takes O(n) and total O(m*n)=250e9.

   We need a more efficient solution.

   New idea: 
        Maintain a global array P (prefix maxima) and an array for break_cond.
        Also, for each index i, we note that the value of P[i] is the maximum of the values from 1 to i.

        We can try to update the prefix maxima with a sparse structure. We maintain the entire array A and a segment tree for range maximum query. Then P[i] = query(1, i). Then after a swap, we can update the segment tree for indices u and v. Then for any i, we can get P[i] in O(1) with a segment tree that does RMQ in O(1) after O(n) build? But then updating the segment tree for two positions is O(log n). 

        Then we need to update the break_cond[i] for i in [min(u,v), n]? And there are O(n) such i.

        Alternatively, we can use a Fenwick tree for the count of break_cond[i] and update it by setting break_cond[i] = (P[i]==i) for every i in the range. 

        Then for each swap, we spend O(n) to update the break_cond array for the range [min(u,v), n]. 

        This is O(m*n) = 250e9.

   Given the constraints, we must have a solution that is O(n log n) per swap or better.

   There is a known solution: 
        Maintain the positions of the leftmost occurrence of each value? 

   Another known solution from similar problems (e.g.,, 
        We maintain: 
          ans = 0
          min_of_next = a very big number
          for i from n downto 1:
             if A[i] < min_of_next:
                 then break_cond[i] = 1
                 ans += 1
             else:
                 break_cond[i] = 0
             min_of_next = min(min_of_next, A[i])

        But this is for suffix minima? 

   Actually, the condition is: 
        We can split at i if the minimum of the next box (from i+1 to n) is > i. 
        But wait, we have a condition on the minimum position of the values greater than i.

   Note: 
        The condition for i is: 
            M[i] = min_{j>i} pos[j] > i
        and also pos[i] <= i.

   But note: the value of the element at position i doesn't matter directly, what matters is the position of the values.

   Given the time, we will implement the straightforward O(n) per swap with optimization: 
        We for (int i = start; i <= n; i++) {
            new_max = max(new_max, A[i])
            if new_max == n) {
                // then from i to n-1: condition fails, and at n: if new_max==n, then condition holds.
                // update the Fenwick tree for these indices.
                // Specifically, for j from start to i-1: we have updated, for j from i to n-1: condition fails (set break_cond[j]=0), and for j=n: set break_cond[n]=1.
                break;
            }
            // update break_cond[i] if needed
        }

   But note: the optimization may not help if we never see n until the end.

   Worst-case swap in the middle of the array might require updating to the end.

   However, note that n is the largest, so once we meet n, we break. Therefore, the loop runs only until the first occurrence of n in the range [start, n].

   The hope is that n is not at the very end every time. But the position of n might be anywhere. 

   In the worst-case, if n is at the last position, then we always have to go to the end.

   Therefore, worst-case swap at the beginning might update the entire array, O(n) per swap, total O(n*m) = 250e9.

   We must try to avoid it.

   We can precompute the position of n, and then know that after index = pos[n], the prefix maxima is n. Then in the update, we only need to update from start to min(pos[n], n) (because after pos[n], the prefix maxima is n).

   Specifically, 
        Let last = pos[n]  (initially)
        Then when we update, if the new position of n is new_pos, then we update last = new_pos.

        Then in the loop: 
            for i from start to min(last, n) 
            // because after last, the prefix maxima is n, and we know the conditions: 
                for i in [start, last-1]: we update.
                for i = last: we then set break_cond[last] = (n==last) -> wait, n==last? last is the position, and the condition at last: prefix_max[last]==last? 
                    prefix_max[last] = n, so if last==n, then condition holds, else not.
                for i from last+1 to n: 
                    prefix_max[i] = n, so condition: n==i -> only if i==n then it holds.

        Therefore, after last, we know:
            break_cond[i] = 0 for i from last+1 to n-1, and break_cond[n] = (n>=last) -> always holds because last<=n.

        So we can do:

            // update the new last if we swap n with something
            // In the swap, if one of the values is n, then update last to the new position of n.

            // Then in the update loop, we go from start to new_last (which is the new position of n) inclusive? 
            // But note: at new_last, we might update the prefix maxima to n.

            // Then for i from new_last+1 to n: 
                   break_cond[i] = 0 for i < n, and break_cond[n] = 1.

        How to update the Fenwick tree for indices from new_last+1 to n-1? We set them to 0. And for n, we set to 1.

        But note: these indices might have been 1 before? 

        Therefore, we must 
            - remember the old break_cond for the indices we are not updating in the loop (i>new_last) and then update the Fenwick tree for the changes.

        However, we are only 
            - updating the range [start, new_last] in the loop.
            - and then we set the range [new_last+1, n] to 0 except n to 1.

        But note: before the swap, the break_cond for indices in [new_last+1, n-1] might not be 0. 

        This complicates.

 Given the complexity of the problem and the time, and that there is an known efficient solution in C++ that uses a segment tree for the positions and a Fenwick tree for the count, but worst-case O(n) per swap, and the intended solution in C++ might rely on the fact that the average-case is good, or on the break early with n.

   We will implement the following:

        // Initialization:
          A[1..n]: the array.
          P[0]=0; for i from 1 to n: P[i] = max(P[i-1], A[i])
          break_cond[i] = 1 if P[i]==i, else 0.
          // Fenwick tree for break_cond, but we might not need range query, only total sum.
          total = 0
          for i from 1 to n: 
              if break_cond[i]: total++

          // Also, we maintain the position of the value n: last = the index i such that A[i] = n.

        // For each swap (u, v):
          swap(A[u], A[v]);

          // if the value n is swapped, update last.
          if A[u] == n: last = u;
          if A[v] == n: last = v;

          // Find start = min(u, v)

          // backup the old break_cond for the range [start, n] if needed? We are going to recalc that range.

          // We will recalc the prefix maxima from start to n, and update break_cond and the total.

          // We will also remember that after last, the prefix maxima is n, so we only need to go from start to last.

          current_max = (start>1 ? P[start-1] : 0)
          // We will create a list of indices where break_cond might have changed: only [start, n] might change.

          for i from start to last: 
             current_max = max(current_max, A[i])
             P[i] = current_max
             new_cond = (current_max == i) ? 1 : 0
             if new_cond != break_cond[i]:
                 if break_cond[i] == 1: 
                     total--
                 else:
                     total++
                 break_cond[i] = new_cond

          // Now, for i from last+1 to n-1: 
          //   we know that the prefix maxima is n (>= last+1 > i, so break_cond[i] should be 0)
          for i from last+1 to n-1:
             if break_cond[i] == 1:
                 total--
                 break_cond[i] = 0

          // For i = n:
          //   prefix maxima is n, so break_cond[n] = (n==n) = 1.
          if break_cond[n] == 0:
             total++
             break_cond[n] = 1

          // But note: it's possible that last==n, then the for-loop already set break_cond[n] correctly.

          // However, if last < n, then we set break_cond[n]=1.

          // But what if last==n, then the for-loop at i=n: 
          //   current_max = max(current_max, A[n]) = n, then break_cond[n] becomes 1.

          // Therefore, we only need to adjust for last+1 to n-1 and then ensure n is 1.

          // But wait: if last might be greater than n? no, last is between 1 and n.

          // However, note: if last==n, then the loop goes to i=last (which is n) and sets break_cond[n]=1.

          // But if last < n, then the loop does not set break_cond[n], so we must set it.

          if last < n:
              if break_cond[n] != 1:
                  if break_cond[n] == 1: 
                      // already 1, do nothing
                  else:
                      total += 1 - break_cond[n]   // if break_cond[n] was 0, then add 1.
                      break_cond[n] = 1

          // But wait, our for-loop did not touch break_cond[n] in the case last < n.

          // However, we had a separate setting for break_cond[n] above. 

          // But note: the for-loop went only to last, so it did not set break_cond[n] in the case last < n.

          // Therefore, we set break_cond[n] to 1 unconditionally? 

          // But what if the condition at n was already 1? 

          // We only want to update if it changed.

          // Alternatively, we can do: 
             // before the swap, break_cond[n] was 1, because the entire array has maximum n, and n appears somewhere, so at n the prefix maximum is n.
          // So it is always 1.

          // Therefore, we can simply set break_cond[n]=1, and if it was 0 then we do total++.

          // But note: after swap, the condition at n might change? 
          //   The prefix maxima at n is n, because the array is a permutation of 1..n. 
          //   So always break_cond[n]=1.

          // Therefore, we can assume that break_cond[n] is always 1.

          // Then we only need to ensure that in our Fenwick tree, break_cond[n] is 1.

          // So in the initial, we set break_cond[n]=1.

          // In the swap, after recalc from start to last, and then for i from last+1 to n-1: we set break_cond[i]=0 (if it was 1, then we decrement total).

          // And we do nothing for n.

          // Therefore, we can remove the setting for n.

        But note: what if during the swap, the value n is moved to a position before 'last' (which might be the current last)? Then in the for-loop, when we update to the new last (which is the new position of n), then we might break_cond[n] not being set by the for-loop if the new last is not n? 

        // We did update last: if we swap away n from its current position, then last becomes the new position.

        // And the for-loop goes from start to last (which is the new last) inclusive.

        // And if the new last is n, then the for-loop sets break_cond[n]=1.

        // If the new last is less than n, then the for-loop does not set break_cond[n], and we know break_cond[n] should be 1.

        // Therefore, after the for-loop, we must ensure break_cond[n]=1.

        // We can do: 
            if last < n:
                if break_cond[n] != 1:
                    total += 1
                    break_cond[n] = 1
            else: // last==n, then the for-loop set it.
                // do nothing

        // But note: the for-loop might have set break_cond[n] to 1 if last==n.

        // And if last==n, then we don't need to set it.

        // Alternatively, we can set break_cond[n]=1 always and then in the initial and in each swap, but we would have to account for changes. However, it is always 1, so we can set it initially to 1 and then in the Fenwick tree it is always 1.

        // Then in the swap, if we ever set it to 0 in the for-loop, we will 
        //   in the for-loop for i=n (if last>=n) we set it to 1.

        // Or if last==n, then the for-loop will set it to 1.

        // But if last < n, the for-loop does not touch n, and we have a separate assignment after the for-loop to set it to 1.

        // However, we might have touched break_cond[n] in the for-loop only if last>=n, i.e., last==n.

        // Therefore, let's not set it in the for-loop for i>last.

        // Instead, we know break_cond[n] is always 1, so we can:
            - initially: break_cond[n]=1, and total = 1 for sure.
            - in the swap, after updating [start, last] (where last is the new position of n), and then we set for i in [last+1, n-1] to 0, and then set break_cond[n]=1. 

        // But wait, initially we set break_cond[n]=1, and then in the swap, we might have 
        //   in the for-loop for i=n (if last==n) set break_cond[n]=1 (no change) or if last<n, then we set break_cond[n]=1 (no change) -> so it's always 1.

        // Therefore, the only change in break_cond is for the indices [start, last] and [last+1, n-1] (which are set to 0 if they were 1).

        // Algorithm for a swap (u, v):

          // If one of the swapped values is n, update last to the new position of n.
          swap(A[u], A[v])
          if A[u] == n: last = u
          if A[v] == n: last = v   // note: if both are n, then last becomes v, but it's the same as not swapping? 

          start = min(u, v)
          // If last < start, then we don't need to update the prefix maxima from start? 
          //   But the prefix maxima might change at start if last < start? 
          //   No, because the value n might be at last<start, and then the prefix maxima for indices >= last is at least n, and for start>last, the prefix maxima for start-1 is at least n, and then for start, we take max(P[start-1], A[start]) and P[start-1] is at least n, so it won't change.
          //   Therefore, we only need to update if last >= start? 

          // But wait, we might swap two elements that are not n, then last remains the same, but we still need to update the prefix maxima from start.

          // So we must always update the prefix maxima from start to min(last, n) (and last might be < start? then we update from start to last, but last<start, so the loop is empty).

          current_max = (start>1 ? P[start-1] : 0)
          for i from start to last:   // if last < start, the loop does nothing.
             current_max = max(current_max, A[i])
             if current_max == n and i < n:
                 // We can break after this iteration, because for the next i, the prefix maxima will be n.
                 // But note: we are at i, and we must update this i.
                 // Then after this i, we set current_max = n, and we know for the indices from i+1 to last, the prefix maxima is n.
                 // So for j from i+1 to last: 
                 //   break_cond[j] = (n==j) ? 1 :0 -> which is 1 only if j==n, but last might be <n, then we won't see j=n.
                 //   But note: last might be the position of n, and it might be greater than i and <=n, but not necessarily n in value.
                 //   Actually, last is the position of the value n, not the value.

                 //   So for j in [i+1, last]: 
                 //        prefix_max[j] = n, and j (the index) is in [i+1, last] (and last<=n-1) so n!=j, so break_cond[j]=0.

                 //   Therefore, we can: 
                 //       for j in [i+1, last]: set break_cond[j] = 0 (if it was 1, then decrement total) 
                 //   then break the loop.

             else:
                 // update normally

          // then for indices from last+1 to n-1: set break_cond to 0 if not already.

          // and ensure break_cond[n]=1.

        This is complicated.

 Given the complexity, we will do the following in the swap without the inside break for n, 
   but then we hope that last is not too large. 
   And we will then after the swap. 

   Specifically, we will 

        for i in [start, last] in increasing order, and then separately set [last+1, n-1] to 0.

   But note, last might be up to n, so the loop is O(n) in the worst-case.

   Total worst-case 250e9.

   We must output the answers for the sample.

   For sample input 6 5 and swaps, the sample output is 3,3,5,4,3,2.

   We will try to run the sample with the following method:

        Initial: A = [0, 3,1,2,5,4,6] (1-indexed)
        P[0]=0
        P[1]=3 -> break_cond[1]: 3==1? 0
        P[2]=3 -> 0
        P[3]=3 -> 1 (3==3)
        P[4]=5 ->0
        P[5]=5 ->1 (5==5)
        P[6]=6 ->1

        total = 3 (indices 3,5,6)

        last = position of 6: initially 6.

        Swap 2 3: swap A[2] and A[3]: 
           A = [0,3,2,1,5,4,6]
           start = min(2,3)=2
           current_max = P[1]=3
           i=2: current_max = max(3, A[2]=2) = 3 -> P[2]=3 -> break_cond[2]: 3==2? ->0 (same as before:0) -> no change.
           i=3: current_max = max(3,1)=3 -> P[3]=3 -> break_cond[3]: 3==3 ->1 (same as before:1) -> no change.
           i=4: current_max = max(3,5)=5 -> break_cond[4]: 5==4?0 -> no change.
           i=5: current_max = max(5,4)=5 -> break_cond[5]:5==5 ->1 -> no change.
           i=6: current_max = max(5,6)=6 -> break_cond[6]:6==6 ->1 -> no change.
           // the last is still 6.
           // then for i in [last+1, n-1] = [7,5] (empty) and ensure break_cond[6]=1 (which is true).

           total=3 -> output 3.

        But sample output after first swap is 3.

        Next swap: 1 3: swap A[1] and A[3]: 
            A = [0,1,2,3,5,4,6]
            last: not change (since we didn't swap 6) -> last=6.
            start = min(1,3)=1.
            current_max = 0
            i=1: current_max = max(0,1)=1 -> break_cond[1]:1==1 -> becomes 1 (previously 0) -> total becomes 4.
            i=2: current_max = max(1,2)=2 -> break_cond[2]:2==2 -> becomes 1 (previously 0) -> total=5.
            i=3: current_max = max(2,3)=3 -> break_cond[3]:3==3 ->1 (remains 1) -> no change.
            i=4: current_max = max(3,5)=5 -> break_cond[4]:5==4?0 (remains 0) -> no change.
            i=5: 5==5 ->1 (remains 1) -> no change.
            i=6:6==6 ->1 (remains) -> total=5.

            sample output is 5? But the sample output is 5.

        Next swap: 3 5: swap A[3] and A[5] -> positions 3 and 5.
            A = [0,1,2,4,5,3,6]
            start = 3.
            current_max = P[2]=2.
            i=3: current_max = max(2,4)=4 -> break_cond[3]:4==3?0 (previously 1) -> change: total becomes 4.
            i=4: current_max = max(4,5)=5 -> break_cond[4]:5==4?0 -> no change (was 0) -> total=4.
            i=5: current_max = max(5,3)=5 -> break_cond[5]:5==5 ->1 (was 1) -> no change.
            i=6:6==6 ->1 -> no change.
            total=4, but sample output is 4? 
            However, sample output after this swap is 4? 
            But the sample output says: 
                 3
                 3
                 5
                 4
                 3
                 2
            So after the third swap (which is the third line of output after the initial) is 4.

        Next swap: 1 2: swap A[1] and A[2]: 
            A = [0,2,1,4,5,3,6]
            start=1.
            current_max=0
            i=1: current_max = max(0,2)=2 -> break_cond[1]:2==1?0 (previously 1) -> change: total=3.
            i=2: current_max = max(2,1)=2 -> break_cond[2]:2==2?1 (previously 1) -> no change (was 1, remains 1) -> total=3.
            i=3: current_max = max(2,4)=4 -> break_cond[3]:4==3?0 (remains 0) -> no change.
            i=4:5>4 -> break_cond[4]=0 -> no change.
            i=5:5==5 ->1 -> no change.
            i=6:6==6 ->1 -> no change.
            total=3.

        Next swap:3 6: swap A[3] and A[6]: 
            A = [0,2,1,6,5,3,4]   [Note: at position 3:6, at position 6:4]
            last = 3 (because we moved 6 to position 3) 
            start = min(3,6)=3.
            current_max = P[2] = 2 (since start=3, we use P[2])
            i=3: current_max = max(2,6)=6 -> break_cond[3]:6==3?0 (was 0) -> no change.
            // But also, we know that the prefix maxima from now on will be at least 6, and then we will see that 6==n? no, n=6, so we break_cond at i=6 would be 1, but we haven't seen the whole array.

            However, we only go to last=3.
            Then for i in [4,5]: we haven't updated in the loop, but we then do:

            for i from last+1 to n-1: i=4,5 -> we set break_cond[4]=0, break_cond[5]=0. 
                // But before the swap, break_cond[4] and break_cond[5] were 0 and 1 respectively.

                break_cond[5] was 1, so we do total-- -> total=2.

            then ensure break_cond[6]=1 -> it was 1, so no change.

            But we haven't updated the prefix maxima for i=4,5,6.

            This is a flaw.

        Therefore, we must update the prefix maxima from start to the new last (which is 3) and then from the new last to the old last? 

        But note: last is the position of the value n. After we set last=3, we then must update the prefix maxima from start=3 to the end of the array? 

        Actually, the condition for indices after last might change, and the prefix maxima might change.

        Therefore, the optimization to only go to last (the position of n) is not valid for the indices after last.

        We must update the entire array from start to n.

        So we cannot use last to break early.

        We then change: we will update from start to n, and within this, we break if current_max becomes n, and then for indices from the first occurrence of n to n-1, we set break_cond[i]=0, and at n set to 1.

        Specifically:

          for i from start to n:
             current_max = max(current_max, A[i])
             if current_max == n and i < n: 
                 // Then for this i, and for the rest (i+1 to n-1) the prefix maxima is n, so break_cond = 0 for i to n-1, and 1 for n.
                 // But note: we are at i, and i might be less than n.

                 // First, update the current i:
                 new_cond = (current_max == i) ? 1 :0
                 if new_cond != break_cond[i]:
                     update total and break_cond[i]

                 // Then for j from i+1 to n-1: 
                     if break_cond[j] is 1, then set to 0 and total--
                 // And ensure break_cond[n]=1.

                 break the loop.

             else:
                 new_cond = (current_max == i) ? 1 :0
                 if new_cond != break_cond[i]:
                     update total and break_cond[i]

          if we didn't break in the loop (meaning we never encountered n in the update), then we set break_cond[n] by hand: 
             // because at n, current_max>=A[n] and we have a permutation, so the prefix maxima at n is n.
             if break_cond[n] != 1:
                 total += 1 - break_cond[n]
                 break_cond[n] = 1

        But note: we might have updated break_cond[n] in the loop if we reached i=n.

        Therefore, only if we broke in the loop, then we already set break_cond[n]=1.

        And if we didn't break, then we set break_cond[n]=1 at the end.

        Let's run the sample swap:3 6 in sample:

          A = [0,2,1,6,5,3,4] 
          start=3.
          current_max = P[2]=2 (from the previous state, but after swap, we should not reuse P from the previous state for indices before start? 
             However, we did start at 3, and we use the saved P for index 2.

          i=3: current_max = max(2,6)=6.
            6==n? yes, and i=3<n, so we break after this iteration.
            update break_cond[3]: (6==3) ->0. Previously it was 0, so no change.
            Then for j from 4 to 5: 
               break_cond[4] was 0 -> leave 0.
               break_cond[5] was 1 -> set to 0, total becomes 2.
            Then set break_cond[6]=1 (but it already is) -> total=2.

          Output 2.

        The sample expects 2.

        Therefore, we will implement:

          Initialization: 
             // read n, m, then array A of size n+1 (1-indexed)
             // compute P[0..n]: 
                P[0]=0
                for i in 1..n: 
                    P[i] = max(P[i-1], A[i])
                    break_cond[i] = 1 if P[i]==i else 0

             total = 0
             for i in 1..n:
                 if break_cond[i]: total++

          For each swap (u,v):

             swap(A[u], A[v])

             start = min(u, v)
             // We reuse the P array for indices < start, but for start and beyond, we will recalc.
             current_max = (start>1 ? P[start-1] : 0)
             encountered_n = false
             // We will update from start to n.
             for i from start to n:
                 current_max = max(current_max, A[i])
                 // If we haven't encountered n and current_max becomes n, and i < n, then we will break after this i.
                 if not encountered_n and current_max == n and i < n:
                     encountered_n = true
                     // We will have to set all j from i+1 to n-1 to 0.
                     // But we do one step: update i, and then break after setting the rest in a batch.
                     new_cond = 1 if (current_max == i) else 0
                     if new_cond != break_cond[i]:
                         if break_cond[i] == 1:
                             total -= 1
                         else:
                             total += 1
                         break_cond[i] = new_cond
                     // Now, from i+1 to n-1: set to 0 if currently 1.
                     for j in range(i+1, n):   // j from i+1 to n-1
                         if break_cond[j] == 1:
                             total -= 1
                             break_cond[j] = 0
                     // and ensure break_cond[n] = 1.
                     if break_cond[n] != 1:
                         total += 1
                         break_cond[n] = 1
                     // break the loop
                     break

                 else:
                     new_cond = 1 if (current_max == i) else 0
                     if new_cond != break_cond[i]:
                         if break_cond[i] == 1:
                             total -= 1
                         else:
                             total += 1
                         break_cond[i] = new_cond

             // If we did not break in the loop (meaning we never encountered n in a position that is not the last, or we went to n without seeing n? 
             //   But note: we have a permutation, so we will see n by n. 
             //   But if we didn't break, it means we did not have the batch break, then we ensure break_cond[n] is 1.
             if not encountered_n:
                 // and we have updated i=n in the loop? 
                 //   or if the loop went to n, then we updated it.
                 // But what if we never encountered n in the batch break, then we did the loop to n and updated break_cond[n] in the else part.
                 //   However, at i=n, current_max = n, so new_cond=1, so it should be set to 1.
                 // So we do nothing.
                 // But note: it's possible that the loop did not set break_cond[n] to 1? 
                 //   if the else part might have not been run for i=n if we didn't break and the loop went to n.
                 //   So we trust the loop.
                 pass

         // then output total.

   Let's hope that the batch break (for when we meet n) and then the for j in [i+1, n-1] is not too heavy.

   In the worst-case, if we meet n at the very first element, then i=1, and then we do a loop of n-2 for j in [2, n-1]. That is O(n) per swap.

   Therefore, worst-case swap at the beginning with n at the beginning: O(n) per swap.

   Total O(n*m) = 250e9.

   We must hope that the test data is not worst-case.

   Alternatively, we can batch break without the for-loop for j in [i+1, n-1] by having a Fenwick tree for break_cond and then doing a range query for [i+1, n-1] and then subtract the sum in that range, and then set them to 0. But setting them to 0 in the array break_cond would require a loop to know which ones are 1? 

   Or we can have a data structure that stores the ones in break_cond as a set. 
        We maintain a set (or sorted list) of indices i where break_cond[i]=1.

        Then when we batch break at i, we 
             // update the current i in the set.
             // Then for the range [i+1, n-1]: we remove all indices in this range from the set, and then the new total = set.size().

        But then we must iterate over the indices in the set in the range [i+1, n-1] to remove them. The worst-case there are O(n) indices in the set in that range.

   Alternatively, we can use a Fenwick tree and then do:
        // In the batch break at i:
            // for the current i: update the Fenwick tree (if there is a change) 
            // then let old_sum = Fenw_tree.query(i+1, n-1)
            // then we set a lazy flag that the entire range [i+1, n-1] is 0, and then subtract old_sum from total.
            // and then mark that in the array break_cond, these are 0.
        // But then future updates might be a problem.

   Given the time, and that the intended solution might be the O(n) per swap, and the constraints are 500000 and 500000, and worst-case 250e9 operations might be borderline in C++ (each operation is a few instructions), we hope that in practice the batch break happens early and the inner loop for j in [i+1, n-1] is not heavy.

   But worst-case if n is at the beginning, then i=1 and then we do a loop of n-2 (nearly n) for every swap -> 500000 * 500000 = 250e9.

   250e9 iterations in C++ might be 250 seconds, which is not acceptable.

   Therefore, we must avoid the inner loop for j in [i+1, n-1].

   Instead, we can do:

        // In the batch break:
           // for the current i: update as before.
           // then let to_remove = (number of indices j in [i+1, n-1] with break_cond[j]==1)
           // we then do: total -= to_remove.
           // and then set an array break_cond for j in [i+1, n-1] to 0. But how to know to_remove without iterating? 

        // We can maintain a Fenwick tree for break_cond.
           Fenw_tree: for update and range sum query.

        Then in the batch break:

           // update break_cond[i] if changed: 
                if it changed, we update Fenw_tree at i with the change (delta).

           // then to_remove = Fenw_tree.range_query(i+1, n-1)
           // then we set a lazy flag for range [i+1, n-1] to 0, and then Fenw_tree should be updated: set to 0 for these indices.

        But Fenw_tree doesn't support range updates to 0 and then maintain the values. 

        We might do:

           // We maintain a Fenw_tree that is the current break_cond.
           // In the batch break, after updating i, we do:
                to_remove = Fenw_tree.range_query(i+1, n-1)
                // then we set for every j in [i+1, n-1]: break_cond[j] = 0, and then update Fenw_tree to 0 for these indices. 

        But updating potentially O(n) indices in the Fenw_tree is O(n) per swap.

   Given the time, we will output the O(n) per swap solution in C++ and hope that the test data is not worst-case.

   Or we might try to use a segment tree for range set to 0 and then queries, but then the total might be maintained in a separate variable.

   However, the intended solution in C++ for problems of this size is often a more efficient, and we are not aware of it.

   Since the problem is from a contest, and there are known submissions in C++ for this problem, 
        we can assume that the efficient solution exists and uses a segment tree or Fenwick tree in a smarter way.

   Given the time constraints, we will output the straightforward O(n) per swap solution in C++ and hope that the worst-case doesn't happen.

   Or note: the batch break might help in the average-case.

   We will implement the batch break without the Fenw_tree for the range [i+1, n-1] (using a for-loop) and hope that the batch break happens early.

   In the worst-case where the batch break does not happen, then the loop goes to n, which is O(n). In the batch break case, we do an additional O(n) for the inner for-loop.

   Therefore, worst-case swap in the middle and batch break not happening: O(n), swap at the beginning and batch break happening at the beginning: O(n) [because the inner for-loop is O(n)].

   So worst-case is O(n) per swap.

   Given m and n up to 500000, worst-case 250e9 iterations, which in C++ might be:

        250e9 iterations * a few instructions per iteration = 250e9 * 4 = 10^12 operations, which is about 100 seconds in C++. 

   We need to optimize the inner loops.

   We will use:

        // in the batch break: 
           for (int j = i+1; j < n; j++) {
               if (break_cond[j] == 1) {
                   total--;
                   break_cond[j] = 0;
               }
           }

   But we hope that in the batch break, the amount of work in the inner for-loop is not heavy because break_cond is not sparse in the range [i+1, n-1]? 

   However, in the worst-case, break_cond might be all ones in that range.

   Therefore, we will try to use a more efficient method:

        We maintain an array next_one that points to the next index where break_cond is 1.

        Specifically, we maintain a linked list of indices that are 1 in break_cond.

        Then in the batch break, for the range [i+1, n-1], we traverse the linked list of indices in this range and remove them.

        How to maintain the linked list? 

           next_ptr[i] for i not in the list is -1, and we have a head pointer for the list.

        But then we also need to update break_cond in the for-loop for the main part.

        Alternatively, we can simply use a set of indices where break_cond is 1.

        Then in the batch break, we do:

           // for the current i: if there is a change, update the set and total.

           // then find all indices in the set that are in [i+1, n-1], and remove them, and subtract the count.

        This is O(number of indices to remove) per batch break, which is O(n) in the worst-case.

   Given the complexity, we will not change.

   Conclusion: we will implement the O(n) per swap solution and hope that the judge's test data is not worst-case.

   If not, we might need to switch to a more efficient method, but we don't know one.

   Let's code accordingly.

   Steps for C++ code:

      // Use:
        vector<int> A(n+1);
        vector<int> P(n+1);
        vector<int> break_cond(n+1,0);
        int total = 0;

        // initial:
        P[0]=0;
        for (int i=1; i<=n; i++) {
            cin >> A[i];
        }
        for (int i=1; i<=n; i++) {
            P[i] = max(P[i-1], A[i]);
            if (P[i] == i) {
                break_cond[i] = 1;
                total++;
            } else {
                break_cond[i] = 0;
            }
        }

        // the last element: we know break_cond[n] should be 1, but our loop sets it.

        int last = -1; // the position of n, initially
        for (int i=1; i<=n; i++) {
            if (A[i] == n) {
                last = i;
                break;
            }
        }

        // But note: after swap, last may change.

        // However, in our new method, we don't use last for breaking in the main loop, but we do use the condition (current_max == n and i<n) to batch break.

        // Then for each swap:

        for (int k=0; k<m; k++) {
            int u, v;
            cin >> u >> v;
            // update last if we are swapping the value n
            if (A[u] == n) {
                last = v;   // because after swap, the value n will be at v
            }
            if (A[v] == n) {
                last = u;
            }
            swap(A[u], A[v]);

            int start = min(u,v);
            int current_max = (start>1) ? P[start-1] : 0;
            bool encountered_n = false;
            for (int i=start; i<=n; i++) {
                current_max = max(current_max, A[i]);
                if (!encountered_n && current_max == n && i<n) {
                    encountered_n = true;
                    // update break_cond for i
                    int new_cond = (current_max == i) ? 1 : 0;
                    if (new_cond != break_cond[i]) {
                        if (break_cond[i] == 1) {
                            total--;
                        } else {
                            total++;
                        }
                        break_cond[i] = new_cond;
                    }
                    // set break_cond for j from i+1 to n-1 to 0, if currently 1.
                    for (int j=i+1; j<n; j++) {
                        if (break_cond[j] == 1) {
                            total--;
                            break_cond[j] = 0;
                        }
                    }
                    // ensure break_cond[n] = 1
                    if (break_cond[n] != 1) {
                        total++;
                        break_cond[n] = 1;
                    }
                    // Also, note: we break out of the for-i loop.
                    break;
                } else {
                    int new_cond = (current_max == i) ? 1 : 0;
                    if (new_cond != break_cond[i]) {
                        if (break_cond[i] == 1) {
                            total--;
                        } else {
                            total++;
                        }
                        break_cond[i] = new_cond;
                    }
                }
                // Also, update P[i] for the next iteration? 
                //   But if we are not at the batch break, then the next i will use current_max, but we are not saving P for future swaps.
                //   Actually, in the next swap, we reuse P for indices < start. But we are recompute for indices>=start, and in the next swap we might have a new start.
                //   So we should update P[i] for the next iteration in the for-loop? 
                //   But in the next swap, we do not use P for indices >= start of this swap. 
                //   However, if the next swap has a start that is within the updated range, then we will use P from this swap for indices < its start.
                //   So we should update P[i] = current_max for i in the loop.
                P[i] = current_max;   // so that the next swap can use it for the prefix.
            }
            // If we didn't encounter_n, we ensure break_cond[n]=1? 
            //   But in the loop, for i=n, we updated it. And current_max at n is at least n, and in a permutation it is exactly n, so break_cond[n] should be 1.
            //   So we do nothing.

            // However, if we did not do the batch break, then we did the loop to n and set P[n]=current_max, and then break_cond[n] should be 1.

            // Output total.
        }

   Let's hope.

   But note: in the batch break branch, we break out of the loop and do not set P[i] for i>start_index to the new values. In particular, we only set P[i] for i in [start, i] (the current i) and not for i+1 to n. 
   But in the next swap, we might start at an index in [start, i] or after i. 

   If the next swap starts at an index after i, then we will use the old P for the index before that start, which might be the current i.

   But we did update P[i] in the batch break branch?

   In the batch break branch, we did update break_cond for i and then broke. We did not update P[i] to current_max in the batch break branch.

   Therefore, we must update P[i] = current_max for the current i in the batch break branch.

   And for the indices i+1 to n, we know the prefix maxima is n, so we can set P[j] = n for j in [i+1, n]. 
   But the next swap might start at j in [i+1, n], then it will use P[j-1] (which we did not update).

   Therefore, we must update the entire P array for the indices in [start, n].

   In the batch break branch, after the inner for-loop for j in [i+1, n-1], we should set:
        for j in [i+1, n]: 
            P[j] = n

   But that is O(n) per swap.

   Alternatively, we can not update P explicitly for j>i, and then in the next swap, if the start is in [i+1, n], then we will have to recalc the prefix maxima from scratch from start to n, but we can use that from start to i, the P is updated, and then from i+1 we know the prefix maxima is n.

   However, to be safe, we will not update P for j>i, and then in the next swap, we might have to recompute the prefix maxima from the last updated index? 

   Given the time, we will update the entire P array for the indices from start to n in the main for-loop for i in [start, n] (which we do in both branches). 

   In the batch break branch, we break after setting the current i and the batch for j in [i+1, n-1] and break_cond[n], but we haven't set P for j>i. 

   Therefore, we should extend the for-loop to set P for all indices, or explicitly set P for j in [i+1, n] to n.

   We do in the batch break branch after the inner for-loop:

        for (int j=i+1; j<=n; j++) {
            P[j] = n;
        }

   Then we break.

   In the non-batch break branch, we already set P for j in [start, n] in the for-loop.

   So the plan is:

        for (int i=start; i<=n; i++) {
            current_max = max(current_max, A[i]);
            // then update P[i] = current_max   [even in the batch break branch, we do this for the current i]
            P[i] = current_max;
            // then the rest as before
            if (!encountered_n && current_max == n && i<n) {
                encountered_n = true;
                ... // and then after the inner for-loop for break_cond, do:
                for (int j=i+1; j<=n; j++) {
                    P[j] = n;
                }
                break;
            }
            ...
        }

   But note: in the batch break branch, for i+1 to n, we know the prefix maxima is n, so we set P[j]=n.

   However, the next swap will use P for indices < its start. 

   This should be correct.

   Given the complexity, we will output the code in C++ and hope it passes.

   Note: worst-case O(n) per swap -> 250e9 operations in worst-case.

   We use:

        #include <iostream>
        #include <vector>
        #include <algorithm>
        #include <cctype>
        using namespace std;

   And we hope.

   Let's run the sample swap that moves n to the middle.

   Due to the complexity, we might not be able to run on the whole sample, but we did try the samples.

   We will output the code accordingly.

   Note: the problem also requires the initial total before any swaps.

   Sample input: "6 5" and then "3 1 2 5 4 6"

   We hope.