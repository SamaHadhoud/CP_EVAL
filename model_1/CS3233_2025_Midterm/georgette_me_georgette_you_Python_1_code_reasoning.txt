 We are given T and M, then T lines of N.
 However, note that the constraints: T up to 10^6, and N up to 10^6.
 We need to precompute:
   fact[0..max_n] : factorials modulo M
   involution[0..max_n] : number of involutions modulo M

 The recurrence for involutions:
   involution[0] = 1
   involution[1] = 1
   for n>=2: involution[n] = involution[n-1] + (n-1)*involution[n-2]   (all mod M)

 Then for each N: answer = (fact[N] - involution[N]) % M, and adjust if negative.

 But note: the problem says M is between 10^8 and 10^9+7, and we have to do modulo M.

 However, the sample input and output provided are not matching the problem? 
 The sample input is:
     2
     4 6
     20 20

 But the sample output is:
     2/1
     1/1

 This does not seem to align. Actually, the problem statement sample input has a drawing? 
 But looking at the problem statement again: the input format is:

     The first line of input contains two integers T and M.
     The next T lines of the input contain one integer N.

 So the sample input might actually be:

     2 1000000007
     4
     20

 And the sample output would be:

     16   (because 4! = 24, involutions for n=4: 10, so 24-10=14? but wait, let me check:)

 Actually, let's compute for n=4:
   Involutions: 
      I0=1
      I1=1
      I2 = I1 + 1*I0 = 1+1=2
      I3 = I2 + 2*I1 = 2+2=4
      I4 = I3 + 3*I2 = 4 + 3*2 = 10

   So 4! = 24, then 24-10 = 14.

 But the sample output says "2/1" and "1/1", which seems like fractions? 
 However, the problem states: 
        Output T lines, each line containing one integer corresponding to the answer.

 This discrepancy suggests that the sample input and output in the problem statement might be corrupted.

 But the editorial and the problem description are clear: we are to compute (n! - I(n)) mod M.

 However, the sample input provided in the problem statement is:

     2
     4 6
     ... (with a drawing of 20 lines)

 This is confusing. But the problem says: "The next T lines of the input contain one integer N".

 Therefore, the sample input should be:

     2 1000000007   (or any M, but then two integers: 4 and 20)

 But the problem says: first line: T and M, then T lines each with one integer N.

 Actually, the sample input in the user's message has:

        "Sample Input #1
         2
         4 6
         ###### ... (and then 20 20 with a drawing)"

 This is inconsistent. The problem statement in the beginning says:

        Input: 
          First line: T and M
          Next T lines: each one integer N.

 So the sample input should be:

        2 998244353
        4
        20

 But the sample output is:

        14
        (and for 20: 20! - I(20))

 However, the sample output provided is "2/1" and "1/1", which is not matching.

 After reevaluating: the problem statement has a note that the sample input has a drawing? 
 Actually, the problem statement says:

        "Sample Input #1
         2
         4 6
         ###### ..."

 This is probably a formatting error. We ignore the drawing and note that the problem says:

        "Mutsumi will ask T questions, each question will correspond to a different N"

 So we stick to the input: first line T and M, then T integers.

 Therefore, we write the code accordingly.

 Implementation in Python:

 However, note: T and N can be up to 10^6. Precomputation for factorials and involutions for up to 10^6.

 Steps:
   Precompute:
      fact[0..max_n]   (max_n = 1000000)
      involution[0..max_n]

   Then for each query N, output (fact[N] - involution[N]) % M (making sure nonnegative).

 But note: we don't know the M until the first line. We have to precompute modulo M.

 However, M is given in the first line. So we can precompute arrays of size 1000001 (0-indexed to 1000000) modulo M.

 But note: T can be up to 10^6, and we are precomputing two arrays of 10^6+1 elements. This is acceptable in Pyton? 
 We have to do two loops of 10^6 iterations. That is acceptable in Pyton if we use efficient loops.

 However, note: the modulus M might be as large as 10^9+7, and numbers in the arrays are mod M, so they are integers within [0, M-1]. 
 We can do:

   fact[0] = 1
   for i from 1 to max_n:
        fact[i] = (fact[i-1] * i) % M

   involution[0] = 1
   if max_n>=1: involution[1] = 1
   for i from 2 to max_n:
        involution[i] = (involution[i-1] + (i-1)*involution[i-2]) % M

 But note: (i-1)*involution[i-2] might be huge? But we are mod M. However, M is large and i is up to 10^6, so the multiplication (i-1)*involution[i-2] might be up to 10^6 * (something mod M) which is about 10^15? That is acceptable in Python because we do modulus after.

 However, to avoid temporary huge numbers, we can do:

        term = ( (i-1) * involution[i-2] ) % M
        involution[i] = (involution[i-1] + term) % M

 But note: (i-1) is an integer up to 10^6, and involution[i-2] is at most M-1 (which is about 10^9). So the product is up to 10^15, which is acceptable in Python (Python integers are arbitrary precision, but we want to avoid too big for performance). Alternatively, we can do:

        term = (i-1) % M * involution[i-2]   # but note: (i-1) is less than 10^6, so modulo M doesn't change it? 
        # Actually, since M >= 10^8, then i-1 < M for i<=10^6, so we can skip mod for (i-1). 

 But the multiplication (i-1)*involution[i-2] might be as big as 10^6 * (10^9) = 10^15, which is 1e15, which is acceptable in Python? 
 Because 10^15 is 1e15, which is about 1e6 operations of multiplying 10^15? Actually, we are doing 10^6 iterations, and each multiplication is of two integers that are at most 10^9 and 10^6? So the product is at most 10^15, which is about 50-60 bits? Python can handle that, but then we take mod M.

 Alternatively, we can break the multiplication and mod to avoid temporary big integers? But 10^15 is acceptable in Pyton in terms of memory and time? It is, because we are doing 10^6 operations, each with numbers that are at most 10^15, and modulus is then applied.

 However, we can do:

        term = ( (i-1) * involution[i-2] ) % M

 to keep the intermediate term from being too huge.

 But the recurrence for involution: 
        involution[i] = (involution[i-1] + term) % M

 So we do:

   involution = [0]*(max_n+1)
   involution[0] = 1
   if max_n>=1: involution[1] = 1
   for i in range(2, max_n+1):
        term = ( (i-1) * involution[i-2] ) % M
        involution[i] = (involution[i-1] + term) % M

 However, note: the recurrence is: I(n) = I(n-1) + (n-1)*I(n-2). 

 But we must precompute for the entire range [0, 1000000] at the beginning.

 But the problem: we have multiple test cases, and M is given at the start. So we precompute for the maximum N we might see? 
 However, the constraints: each N is at least 1 and at most 10^6. So we precompute up to 1000000.

 But note: T can be up to 10^6, but each query N is in [1,10^6]. We precompute for all n in [0,1000000] once.

 Steps in the code:

   Read T and M.
   Precompute fact[0..1000000] and involution[0..1000000] modulo M.

   Then for each of the T queries:
        read N
        ans = (fact[N] - involution[N]) % M
        if ans < 0: ans += M
        print(ans)

 However, note: the maximum N we see in queries might be less than 1000000? But the problem says N in [1,10^6]. 
   We precompute up to 1000000, which is the maximum possible.

 But what if we see an N that is 0? The problem says N>=1, so we don't need to worry about 0 in the queries.

 However, our arrays are 0-indexed to 1000000, so we have computed for n=0 as well.

 But note: the problem says permutation arrays of size N: the total permutations are N! and the involutions for n=0 is 1.

 However, the queries N are at least 1.

 Let's test with n=1:
      fact[1] = 1
      involution[1] = 1
      answer = (1-1) % M = 0.

 For n=2:
      fact[2]=2
      involution[2]= I1 + 1*I0 = 1+1=2 -> so (2-2)=0.

 For n=3:
      fact[3]=6
      involution[3]= I2 + 2*I1 = 2+2=4 -> 6-4=2.

 But wait: the sample input had n=4: 24-10=14.

 The sample output in the problem statement was:
        2/1
        1/1

 But that doesn't match. Actually, the problem statement sample output might be for a different problem? 

 Since the problem statement sample input has a drawing, we suspect that the sample input and output provided were from a different problem. 
 Therefore, we stick to the problem as described.

 We output the code accordingly.

 However, note: the problem statement sample input and output are:

        Input: 
          2
          4 6
          ... (a drawing of 20 lines)

        Output:
          2/1
          1/1

 This does not match our computation. 

 But the problem says: "The next T lines of the input contain one integer N", so the sample input should have two integers: 4 and 20? 
 But the sample input has "4 6" and "20 20" which are two integers per line? 

 This is a problem. The problem says: "each question will correspond to a different N", meaning one integer per line.

 After reading the problem statement again: 

        Input:
          First line: T and M
          Then T lines: each one integer N.

 So the sample input should be:

          2 1000000007
          4
          20

 But the provided sample input has:

          2
          4 6
          ... (a drawing for 20 lines)

 This suggests that the sample input is actually:

          First line: "2" -> T=2
          Then two lines: 
             first: "4 6" -> but that would be two integers? 
             second: a drawing that ends with "20 20" -> meaning two integers?

 How to reconcile? 

 The problem statement says: "The next T lines of the input contain one integer N", so each of the T lines has exactly one integer.

 Therefore, the sample input must be:

          2 1000000007
          4
          20

 And the sample output:

          14
           <something for 20>

 But the problem statement sample output is:

          2/1
          1/1

 This is confusing. 

 However, the problem statement also has:

        "Sample Input #1
         2
         4 6
         ###### ... (20 lines)"

 And then:

        "Sample Output #1
          2/1
          1/1"

 This is likely an error in copying the problem. We will ignore the drawing and the fractions and solve the problem as described.

 We output the code as described.

 Important: Precomputation for up to 1000000 is acceptable in Pyton? 
   We have to do 10^6 iterations for factorials and 10^6 iterations for involutions. 
   Each step: 
        factorial: one multiplication and mod -> O(1)
        involution: one multiplication (with two numbers, one of which is at most 10^6 and the other modulo M) and two mods -> O(1)

   Total: O(10^6) for each array -> 2*10^6 steps, which is acceptable in Pyton? But note: T can be 10^6, but we precompute once and then each query is O(1). 

   However, the precomputation is done once at the beginning.

 But the modulus M is given at the start. So we precompute the arrays for the given M.

 However, the problem states that M is in the range [10^8, 10^9+7]. The multiplications and mod operations for numbers in this range are O(1) in Pyton? Yes, because they are fixed-precision (the numbers we multiply are at most M, so the product is at most M^2 which is about 10^18, and modulus is O(1)).

 But note: the involution recurrence: 
        term = (i-1) * involution[i-2]   # i-1 is at most 10^6, and involution[i-2] is at most M-1 (which is about 10^9), so the product is about 10^15 -> which is 15 digits, and modulus by M (about 10^9) is O(1). 

 Therefore, the entire precomputation is O(10^6) which is acceptable.

 But worst-case: T=10^6, and we precompute two arrays of 10^6+1 integers. The memory: about 2*(10^6+1) integers, each about 4-8 bytes? So about 16 MB? That's acceptable.

 However, in Python, integers are larger (they are arbitrary precision, but for numbers in the range of M, which is 10^9, they are about 4 bytes? Actually, Python uses 24 bytes for integers). So 10^6 integers * 24 bytes * 2 arrays = 48 MB? This is acceptable in 1024 MB memory.

 But note: the problem memory limit is 1024 MB.

 Therefore, we code accordingly.

 Let's write the code.

 Important: We must precompute for all n from 0 to 1000000. But note that the problem says N>=1, but we precompute from 0 to 1000000.

 However, we are going to read T and M first, then precompute the arrays for the given M.

 Steps:

   import sys

   data = sys.stdin.read().split()
   T = int(data[0]); M = int(data[1])

   max_n = 1000000

   Precompute fact[0..max_n] and involution[0..max_n] modulo M.

   Then the next T integers: indices = 2 to 2+T-1.

   For each N in the next T integers:
        ans = (fact[N] - involution[N]) % M
        if ans < 0: ans += M
        print(ans)

 However, note: the mod operation might give negative? In Python, (a % M) is nonnegative. But if we do (a - b) % M and a-b is negative, then (a-b) % M is nonnegative? Actually:

        In Python, (a - b) % M is nonnegative? 
        Example: (10-20) % 100 -> 90, which is nonnegative.

        But we do: (fact[N] - involution[N]) might be negative? Then we do mod: 
            (fact[N] - involution[N]) % M 
        However, if fact[N] < involution[N], then we get a negative number? Then mod M gives a positive? 

        But note: we want the answer mod M, and the modulus operation in Python for negative: 
            (x) % M = x + k*M so that the result is in [0, M-1]. 

        Therefore, we can just do: 
            ans = (fact[N] - involution[N]) % M

        However, if we do (a - b) % M, it is equivalent to (a - b + M) % M if a < b? 

        Actually, we can do:

            ans = (fact[N] - involution[N]) % M
            # This will give a nonnegative number.

        But to be safe and explicit, we can do:

            ans = fact[N] - involution[N]
            if ans < 0:
                ans %= M   # but if negative, we can add M until nonnegative? 
            else:
                ans %= M

        However, the modulus operation in Python for negative numbers already adjusts to [0, M-1]. 
        But the problem: if we do (a-b) % M, it is the same as (a-b + M) % M? 

        Example: (10-20) % 10 -> 0? Actually: 
            (10-20) = -10 -> (-10) % 10 = 0? 
            But we want: 10-20 = -10 mod 10 is 0? 

        Actually, for modulo arithmetic, we want the representative in [0, M-1]. 

        Alternatively, we can do:

            ans = (fact[N] - involution[N]) % M
            if ans < 0:
                ans += M
            # then we do ans %= M? But we did modulus already? 

        Actually, the modulus operation in Python for negative:

            >>> (-10) % 10
            0
            >>> (-1) % 10
            9

        So we don't need to adjust because modulus gives nonnegative.

        However, we can do:

            ans = (fact[N] - involution[N]) % M
            # This will be in [0, M-1]? 

        But note: the modulus operation for a negative x: 
            x % M = x + M * ceil(|x|/M) ? 

        Actually, it's defined as: 
            (a - b) % M = (a - b + k*M) such that the result is in [0, M-1]. 

        Therefore, we can rely on that.

        However, if we do:

            a = fact[N]   # in [0, M-1]
            b = involution[N] # in [0, M-1]
            then a-b is in [-M+1, M-1]. Then (a-b) % M will be nonnegative.

        So we can simply do:

            ans = (fact[N] - involution[N]) % M

        But note: if (fact[N] - involution[N]) is negative, then (fact[N] - involution[N]) % M is the same as (fact[N] - involution[N] + M) % M? 
        And if nonnegative and less than M, then it remains the same? 

        Actually, if we do:

            (x) % M = x % M   and for negative, it becomes x + M (if x is negative, then we add M until nonnegative and in [0, M-1])

        However, the modulus operator in Python does that.

        Therefore, we can do:

            ans = (fact[N] - involution[N]) % M

        But note: if (fact[N] - involution[N]) is nonnegative and less than M, then modulo M is the same. 
        If it is negative, then modulo M gives the nonnegative equivalent.

        However, what if (fact[N] - involution[N]) is negative? Then:

            Let x = fact[N] - involution[N] (negative)
            Then x % M = x + M   if x is in (-M, 0)? 

            Example: x = -5, M=10 -> -5 % 10 = 5.

        So we can simply use modulus.

        But we must be cautious: if the result is negative, then we add M until nonnegative? 

        Actually, the modulus operation does that. So we can do:

            ans = (fact[N] - involution[N]) % M

        However, to avoid confusion, we can do:

            ans = fact[N] - involution[N]
            ans %= M

        This is safe.

        But note: if the result is positive and very big? Then we mod M.

        Actually, fact[N] and involution[N] are mod M, so they are in [0, M-1]. Then:

            fact[N] - involution[N] is in [-M+1, M-1]. 

        So the modulus operation will adjust negative to positive.

        Therefore, we can do:

            ans = (fact[N] - involution[N]) % M

        But if the result is nonnegative and less than M, then modulus doesn't change it? 

        Actually, if the result is in [0, M-1], then modulus doesn't change it. 
        If the result is negative, modulus makes it positive by adding M.

        But note: if the result is negative, then adding M once is enough because the absolute value is at most M-1? 

        Example: if fact[N]-involution[N] = -k (with k in [1, M-1]), then (-k) % M = M - k, which is in [1, M-1].

        So we can do:

            ans = (fact[N] - involution[N]) % M

        However, if the subtraction is nonnegative and less than M, then we don't need to mod? But if it is >=M? 

        Since fact[N] and involution[N] are mod M, then:

            fact[N] = F mod M, so F mod M is in [0, M-1].
            involution[N] = I mod M, in [0, M-1].

            Then fact[N] - involution[N] can be as large as M-1 (if fact[N]=M-1 and involution[N]=0) -> M-1, which is < M, so no mod needed? 

            Or as low as - (M-1) (if fact[N]=0 and involution[N]=M-1) -> then mod M becomes M-1? 

        Actually, the range of the subtraction is [-M+1, M-1]. So the modulus operation is safe.

        Therefore, we can simply do:

            ans = (fact[N] - involution[N]) % M

        But note: if the result is nonnegative and less than M, then modulus doesn't change it. 
        And if negative, modulus makes it positive.

        However, the modulus operation for any integer x is defined as:

            x % M = x - M * floor(x/M)

        But for x in [-M+1, M-1], we have:
            if x >=0: then floor(x/M)=0 -> so x % M = x.
            if x <0: then floor(x/M) is -1? 
                so x % M = x - M * (-1) = x + M.

        And since x is at least -M+1, then x+M is at least 1 and at most M-1.

        Therefore, we can do:

            ans = (fact[N] - involution[N]) % M

        and that gives the answer in [0, M-1].

 Implementation:

   Precomputation arrays for n from 0 to max_n (1000000) for factorials and involutions modulo M.

   Then for each query, we output (fact[N]-involution[N]) % M.

 However, note: the modulus operations in the precomputation: we did % M at every step. 

   For factorials: 
        fact[0]=1
        for i in range(1, max_n+1):
            fact[i] = (fact[i-1]*i) % M

   For involution:
        involution[0]=1
        if max_n>=1: involution[1]=1
        for i in range(2, max_n+1):
            term = ( (i-1) * involution[i-2] ) % M
            involution[i] = (involution[i-1] + term) % M

   Then for each query: 
        N = ... 
        ans = (fact[N] - involution[N]) % M

   But note: if (fact[N] - involution[N]) is negative, then we want to add M until nonnegative? 
        Actually, we use modulus: 
            ans = (fact[N] - involution[N]) % M

   However, we can also do:

        ans = fact[N] - involution[N]
        if ans < 0:
            ans += M
        # then we don't need mod? because then ans is in [0, M-1]? 
        But note: if fact[N] >= involution[N], then ans is nonnegative, but it might be >= M? 
        But no: because fact[N] and involution[N] are mod M, so they are in [0, M-1]. 
        Therefore, the difference is in [-M+1, M-1]. 
        Then if we do:

            if ans < 0: 
                ans += M

        then ans becomes in [0, M-1]. 

        But if we do modulus, it does the same.

        We can choose either. The modulus operator is one line.

   I choose: 
        ans = (fact[N] - involution[N]) % M

   Because it is one line and efficient.

 But note: the modulus operator for negative numbers in Pyton is a bit expensive? But we are doing T up to 10^6, and modulus for each is O(1). 

   Alternatively, we can do:

        ans = fact[N] - involution[N]
        if ans < 0:
            ans += M
        # then output ans

   This avoids the modulus operation for nonnegative numbers? But the modulus operation for nonnegative numbers that are in [0, M-1] is very fast? Actually, it's just a conditional check? 

   However, we know that fact[N] and involution[N] are in [0, M-1], so the difference is in [-M+1, M-1]. Therefore, we can do:

        ans = fact[N] - involution[N]
        if ans < 0:
            ans += M

   and then we have ans in [0, M-1].

   This is one addition for negative cases, which is about half the time? 

   But we don't know the sign. It might be that for large N, the factorials are huge mod M? but we have computed mod M, so they are in [0, M-1]. 

   Therefore, the subtraction is at most M-1 in absolute value? 

   So we can do:

        ans = fact[N] - involution[N]
        if ans < 0:
            ans += M

   and then output ans.

   This is two conditionals: subtract and then check sign. 

   Alternatively, modulus is one operation.

   Since T is 10^6, the difference might be negligible.

   We'll use modulus for simplicity.

 But note: the modulus operation for negative numbers might do an expensive modulo? 

   Actually, the modulus operation for numbers in the range [-M, M] is O(1). 

   So both methods are O(1). 

   We choose:

        ans = (fact[N] - involution[N]) % M

   and then output ans.

 Code:

   Precomputation:

        fact = [0]*(max_n+1)
        fact[0] = 1
        for i in range(1, max_n+1):
            fact[i] = (fact[i-1] * i) % M

        involution = [0]*(max_n+1)
        involution[0] = 1
        if max_n>=1:
            involution[1] = 1
        for i in range(2, max_n+1):
            term = ( (i-1) * involution[i-2] ) % M
            involution[i] = (involution[i-1] + term) % M

   Then for each query:

        N = int(input_line)
        ans = (fact[N] - involution[N]) % M
        print(ans)

 However, note: if (fact[N]-involution[N]) is negative, then (fact[N]-involution[N]) % M gives a nonnegative number? Yes.

 Let's test with small numbers: 
        fact[3]=6, involution[3]=4 -> 6-4=2 -> 2 % M = 2.
        fact[1]=1, involution[1]=1 -> 0 % M = 0.

        fact[4]=24, involution[4]=10 -> 14 % M = 14.

        But if M=10, then 14 % 10 = 4? 
        However, the problem: the modulo M is given. So if M=10, then the answer for n=4 is 14 % 10 = 4.

        But the problem says: output the number in modulo M.

        Therefore, 4 is correct.

        However, the actual answer for n=4 is 14, but modulo 10 is 4.

        So we are doing modulo at the end as well? 

        But note: in the precomputation, we did:

            fact[4] = (fact[3]*4) % M   -> for M=10: 6*4=24 -> 24%10=4.
            involution[4] = (involution[3] + 3*involution[2]) % M 
                involution[3] = (I2 + 2*I1) % 10 = (2+2) %10=4
                involution[2] = (I1 + 1*I0) %10 = (1+1)=2 -> then 3*2=6 -> 4+6=10 -> 10%10=0? 
                But wait: the recurrence: 
                    I0=1
                    I1=1
                    I2 = 1+1=2 -> mod10: 2
                    I3 = I2 + 2*I1 = 2+2=4 -> mod10:4
                    I4 = I3 + 3*I2 = 4+3*2=10 -> mod10:0.

            Then answer = (fact[4] - involution[4]) %10 = (4-0)%10=4.

        But the actual number of involutions for n=4 is 10, and 24 mod10=4, then 4-0=4.

        But 10 mod10=0, so that's consistent.

        However, note: the recurrence for involution: we are doing modulo at every step. 
            This is valid? Because the recurrence is linear: 
                I(n) = I(n-1) + (n-1)*I(n-2) mod M.

        And we want the value mod M. So it is valid.

        Therefore, we are doing the entire precomputation modulo M.

        Then the subtraction and modulus at the end.

        This is correct.

 Code:

   We precompute for n=0 to 1000000.

   But note: the maximum N in the queries is at most 1000000, but we precomputed for all.

   We read T and M, then precompute, then process T queries.

   However, if M is 1, then all answers are 0? 

   But M>=10^8, so we don't have to worry about M=1.

   Let's code accordingly.

   We use sys.stdin for fast input.

   Steps:

        import sys
        data = sys.stdin.read().split()
        T = int(data[0]); M = int(data[1])
        queries = []
        index = 2
        for i in range(T):
            queries.append(int(data[index])); index += 1

        max_n = 1000000
        # Precompute fact and involution for 0..max_n mod M

        fact = [0]*(max_n+1)
        fact[0] = 1
        for i in range(1, max_n+1):
            fact[i] = fact[i-1] * i % M   # we do mod at every step

        involution = [0]*(max_n+1)
        involution[0] = 1
        if max_n>=1:
            involution[1] = 1
        for i in range(2, max_n+1):
            # term = (i-1)*involution[i-2] mod M
            term = (i-1) * involution[i-2] % M
            involution[i] = (involution[i-1] + term) % M

        # Now process each query:
        for N in queries:
            ans = (fact[N] - involution[N]) % M
            # Since modulus for negative is handled, we output
            print(ans)

 But note: we must not forget that the modulus operation in the subtraction might yield a negative representation? 
        Actually, the modulus operator in Pyton always returns a nonnegative integer in [0, M-1]. 

        Therefore, we can output directly.

 However, we can also do:

        ans = fact[N] - involution[N]
        ans %= M
        print(ans)

        This is the same.

   But to be safe, we do:

        ans = (fact[N] - involution[N]) % M
        print(ans)

   But if the subtraction is nonnegative and less than M, then modulus does nothing? 
        If it's negative, modulus adds M until nonnegative? 

        Actually, modulus for a negative x: 
            x % M = (x + M) % M? 
            But the modulus operator does the correct thing.

   We'll output the code.

   However, we must note: the precomputation for involution might be heavy? We are doing 10^6 iterations. 
        But 10^6 is acceptable in Pyton? It should be in Pyton if we use PyPy or Pyton in C++ competition, but in Pyton we might be borderline? 

        We are doing two loops: one for factorial (10^6 iterations) and one for involution (10^6 iterations). 
        Each iteration: 
            factorial: one multiplication and one modulus.
            involution: one multiplication, one modulus, and one addition, one modulus.

        The modulus operations for numbers that are at most 10^18? Because in factorial: 
            the numbers we multiply: i up to 10^6, and fact[i-1] is mod M (so at most M, which is 10^9). 
            Then fact[i] = fact[i-1] * i -> at most 10^9 * 10^6 = 10^15, then mod M.

        Similarly, in involution: 
            term = (i-1) * involution[i-2] -> i-1 is at most 10^6, involution[i-2] at most M (10^9) -> product at most 10^15, then mod M.

        Then involution[i] = (involution[i-1] + term) -> at most 2*M (10^9) -> mod M.

        The modulus operation for numbers up to 10^15: 
            We do: x % M, where M is about 10^9. 
            This is one integer division? Which is O(1) for fixed size? 

        Therefore, each iteration is O(1). 

        Total time: 2*10^6 * O(1) = 2e6, which is acceptable.

   We run the code.

   But note: the problem T up to 10^6, and we are storing 2 arrays of 10^6 integers. The memory is about 2*10^6*8 bytes? (if we use 8 bytes per integer) -> 16 MB? 
        But in Pyton, integers are 24 bytes? Then 2*10^6*24 = 48 MB? 

        The problem memory limit: 1024 MB -> acceptable.

   Therefore, we write the code.

   However, we must note: the problem says that M is at least 10^8 and at most 10^9+7.

   We'll test with the sample: 
        T=2, M=1000000007
        queries: [4, 20]

        For n=4: 
            fact[4] = 24 % 1000000007 = 24
            involution[4] = 10
            ans = (24-10) % 1000000007 = 14.

        For n=20: 
            We need to compute fact[20] mod 1000000007 and involution[20] mod 1000000007.

            fact[20] = 2432902008176640000 mod 1000000007 -> we can compute by our precomputation.

            But we can compute: 
                We do a loop from 1 to 20.

            How to compute involution[20]? 
                We do the recurrence.

            We don't need the exact numbers, we trust our code.

        We output:
            14
            [some number for 20]

   But the problem sample output is "2/1" and "1/1", which we ignore.

   We output the code.

   Note: if we run into performance issues in Pyton, we can try to optimize the precomputation by using local variables? 

   We write the code accordingly.

   However, the problem T can be 10^6, but we precompute once and then each query is O(1). The precomputation is O(10^6). 

   We'll use:

        import sys

        data = sys.stdin.read().split()
        if not data: 
            exit(0)
        T = int(data[0])
        M = int(data[1])
        queries = list(map(int, data[2:2+T]))

        max_n = 1000000

        # Precomputation for factorials
        fact = [1] * (max_n+1)
        for i in range(1, max_n+1):
            fact[i] = fact[i-1] * i % M

        # Precomputation for involutions
        involution = [1] * (max_n+1)
        # For n=0 and n=1 we have 1, so we start from n=2
        # But if max_n==0, we skip. If max_n>=1, we have involution[0]=1, involution[1]=1.
        for i in range(2, max_n+1):
            # term = (i-1) * involution[i-2] mod M
            term = (i-1) * involution[i-2] % M
            involution[i] = (involution[i-1] + term) % M

        # Process each query
        res = []
        for N in queries:
            ans = (fact[N] - involution[N]) % M
            res.append(str(ans))

        # Output each result on a separate line.
        print("\n".join(res))

   But note: if M is 1, then all factorials and involutions are 0? 
        Then for each N: (0-0)%1=0.

        But M>=10^8, so we don't have to worry.

   Let me test with n=3 and M=1000000007: 
        fact[3] = 6
        involution[3] = 4
        ans = 2

   But wait: we computed for n=3: 
        involution[0]=1, involution[1]=1
        i=2: term = 1 * involution[0] = 1 -> involution[2]=1+1=2
        i=3: term = 2 * involution[1] = 2 -> involution[3]=2+2=4.

   Then 6-4=2.

   So for n=3: output 2.

   For n=4: 24-10=14.

   Therefore, the sample: 
        Input: 
            2 1000000007
            4
            3
        Output:
            14
            2

   We output:

        14
        2

   This matches.

   We run the code.

   But note: the precomputation for involution: we have an array of size 1000001. 
        We do the loop from 2 to 1000000.

   We assume that the maximum n in the queries is at most 1000000? The problem says: N in [1,10^6]. 

   But what if the query has N=0? The problem says N>=1, so we skip.

   Therefore, we are safe.

   We output the code.

   However, note: the problem says the first line: T and M, then T lines of N.

   We read all the data at once. This is acceptable for 10^6 integers? The total number of integers is T (first line) + T (queries) + 1 (M) -> about 10^6 + 10^6 + 2 = 2000002 integers. 

   The memory for storing the data as strings? Then we split. The total characters: 
        T and M: two integers, each up to 10^6 and 10^9 -> about 6 and 10 digits -> 16 digits for the first line? 
        Then T integers (each up to 10^6 -> 6 digits each) -> total characters: 16 + T*7 -> about 7e6 characters -> 7 MB? 

   This is acceptable.

   We run the code.

   But note: the problem constraints: T up to 10^6, and N up to 10^6. 

   We precomputed for n=0 to 1000000, which is 10^6+1, which is acceptable.

   We hope it runs within 1 second? 
        Precomputation: two loops of 10^6 iterations. Each iteration: 
            factorial: one multiplication and one modulus -> O(1)
            involution: one multiplication, one modulus, one addition, one modulus -> O(1)

        Total operations: about 2 * 10^6 * (a few operations) -> 2e6 * 4? = 8e6 operations? 

        And reading: 10^6 integers from a list of tokens.

        Then processing the queries: 10^6 iterations, each one subtraction and modulus.

        Total operations: about 10^6 * 2.

        Total: 8e6 + 2e6 = 10e6 operations, which in Pyton might be borderline in 1 second? 

        But the modulus and multiplication for numbers as large as 10^15 might be heavy? 

        However, the modulus for numbers up to 10^15 is a single division, which is O(1) in terms of digit length? 

        But the modulus operation for two integers: the modulus operator in Pyton for integers is O(n) in the number of digits? 
            The numbers we mod are at most 10^15, which is about 15 digits, and M is about 10^9 (10 digits). 
            The modulus operation for 15-digit number by a 10-digit modulus is O(1) in terms of the number of digits? 
            Actually, it's O(1) because the numbers are bounded (fixed size).

        Therefore, the entire precomputation is about 10^6 * constant, which is acceptable.

   But in Pyton, constant factors matter. We might need to optimize by using local variables.

   We can try to use:

        for i in range(2, max_n+1):
            term = (i-1) * involution[i-2] % M
            involution[i] = (involution[i-1] + term) % M

   This is already efficient.

   However, we can precompute the entire array without function calls? 

   Alternatively, we can use:

        import array
        But we are using list, which is dynamic.

   We try to use local variables to speed up:

        We can do:

            f0 = 1
            f1 = 1
            fact = [1]*(max_n+1)
            for i in range(1, max_n+1):
                f0 = f0 * i % M
                fact[i] = f0

        Similarly for involution:

            i0 = 1
            i1 = 1
            involution = [1]*(max_n+1)
            for i in range(2, max_n+1):
                # term = (i-1) * involution[i-2] % M
                term = (i-1) * i0 % M
                curr = (i1 + term) % M
                # shift: for next iteration, we need to update i0 and i1
                # But we are storing the entire array, so we don't need to shift? 
                # Instead, we store the entire array.

        But we need the entire array for the queries.

   Therefore, we stick to the array method.

   We hope it runs in Pyton in 1 second? 

   But note: the problem time limit is 1.0s per test case? Actually, the problem says: 
        Time limit: 1.0s

        And memory: 1024 MB

        And we are doing precomputation once and then T queries.

        The precomputation is about 10^6 iterations, which in Pyton might be 0.5 seconds? 

        Then the queries: 10^6 iterations, which is about 0.1 seconds? 

        Total 0.6 seconds? 

        But worst-case: 10^6 iterations for two loops, and each iteration has a multiplication that might be 10^15? 
            The multiplication of two numbers of 10^9 and 10^6: 10^9 * 10^6 = 10^15, which is 15 digits -> fast in Pyton? 

        However, in Pyton, the multiplication of two integers is O(n*m) in the number of digits? 
            But for fixed size, it's O(1). 

        Therefore, we hope it passes.

   If not, we might have to use Pyton optimizations.

   Alternatively, we can use Pyton's built-in array for faster access? 

        We are using lists. 

        But the problem is the size: 1000000. 

        We can try to use:

            import array
            fact = array.array('l', [0]*(max_n+1))

        But in Pyton, 'l' is signed long, which is 4 or 8 bytes? But we are on 64-bit, and the numbers are mod M (which is 10^9) so they fit in 32-bit? 
            But 10^9 is 2^30, so 32-bit signed long can hold up to 2^31-1 (about 2e9). 

        However, during computation we have intermediate results (like i-1 up to 10^6, and involution[i-2] up to 10^9) -> product 10^15, which is 50 bits -> we need 64-bit integers.

        But Pyton integers are arbitrary precision, so we don't worry about overflow? 

        But the array module for 'l' might be 32-bit? Then we cannot use it.

        We stick to lists.

   We output the code as below.

   Note: we must not forget that the precomputation for involution[0] and [1] is set to 1.

   We run the sample.

   Sample: 
        Input: "2 1000000007\n4\n3"

        Expected output: 
            14
            2

   We run:

        T=2, M=1000000007
        queries = [4,3]

        Precompute fact: 
            fact[0]=1
            fact[1]=1
            fact[2]=2
            fact[3]=6
            fact[4]=24

        Precompute involution:
            involution[0]=1
            involution[1]=1
            i=2: term = (2-1)*involution[0] = 1*1=1 -> involution[2] = (1+1)=2
            i=3: term = (3-1)*involution[1]=2*1=2 -> involution[3]= (2+2)=4
            i=4: term = 3*involution[2]=3*2=6 -> involution[4]=(4+6)=10

        Then:
            for N=4: (24 - 10) % 1000000007 = 14
            for N=3: (6 - 4) % 1000000007 = 2

        Output: 
            14
            2

   Correct.

   We write the code.

   But note: the modulus in the precomputation for involution: 
        We did: 
            term = (i-1) * involution[i-2] % M
            involution[i] = (involution[i-1] + term) % M

        This is correct.

   We hope it passes.

   Note: the maximum n is 1000000, so we precomputed for n=1000000. 
        The multiplication for i=1000000: 
            (1000000-1) * involution[1000000-2] 
        The term might be huge? But we mod M, so we do:

            term = (999999 * involution[999998]) % M

        Then add to involution[999999] and mod M.

   This is acceptable.

   Code:

        import sys

        def main():
            data = sys.stdin.read().split()
            if not data:
                return
            T = int(data[0])
            M_val = int(data[1])
            queries = list(map(int, data[2:2+T]))
            
            max_n = 1000000
            # Precompute factorials modulo M_val
            fact_arr = [1] * (max_n+1)
            # Start from 1 to max_n
            for i in range(1, max_n+1):
                fact_arr[i] = fact_arr[i-1] * i % M_val

            # Precompute involutions modulo M_val
            involution_arr = [1] * (max_n+1)
            # Base cases: n=0, n=1 are already set to 1.
            # For n>=2
            for n in range(2, max_n+1):
                term = (n-1) * involution_arr[n-2] % M_val
                involution_arr[n] = (involution_arr[n-1] + term) % M_val

            # Prepare output
            out_lines = []
            for N in queries:
                # Compute answer = (fact_arr[N] - involution_arr[N]) % M_val
                # But we do modulus to ensure nonnegative?
                ans = (fact_arr[N] - involution_arr[N]) % M_val
                out_lines.append(str(ans))
            
            # Output each answer on a separate line.
            sys.stdout.write("\n".join(out_lines))

        if __name__ == '__main__':
            main()

   We hope it runs within the time limit.

   However, we can try to optimize by using local variables for the modulus and the arrays? 

   But the inner loops are already as simple as possible.

   We run it on the sample.

   But note: the problem constraints: T up to 10^6, and we are building a list of 10^6 strings for output, then writing at the end. 
        That's acceptable.

   We hope.

   Let me test with T=10^6: 
        We have an array of 10^6 strings, which is 10^6 * (length of the string for the answer) -> the answer is at most 10 digits? 
        Then 10^6 * 10 = 10^7 bytes = 10 MB? 

        Then we do a "\n".join(out_lines) -> this creates a string of size 10^6 * 10 + 10^6 (for the newlines) = 11e6 bytes? -> 11 MB? 

        This is acceptable.

   We run.

   But if we are concerned about performance, we can write each line as we go? 

        for N in queries:
            ans = ... 
            sys.stdout.write(str(ans)+'\n')

        But writing to stdout 10^6 times might be slow? 

        Alternatively, we build a list and then write once.

        We choose the list and then write once.

   We output the code.