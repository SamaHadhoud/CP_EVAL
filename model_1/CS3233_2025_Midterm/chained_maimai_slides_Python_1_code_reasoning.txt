 We are given M and K, then M lines of (X_i, Y_i, V_i)
 Steps:
 1. Preprocess: We have 8 nodes (1-indexed: 1..8). But note: the net flow for the 8th node is determined by the others (conservation: sum of net flows must be 0). So we can represent the state for nodes 1 to 7.

 2. Sort all edges by V_i (speed).

 3. Use two pointers (left and right) to form a window of edges [L, R] (sorted by speed). We want to check for each window [L, R] whether there exists a subset of edges (each edge used at most once) such that:
    - The net flow for each node i (from 1 to 7) is 0 (and then node 8 will automatically be 0 by conservation).
    - Additionally, every node must have at least one outgoing edge? Actually, the condition is that every button must be a starting button of at least one slide. This means that every node must have at least one outgoing edge in the selected set.

 4. However, note: the problem requires forming one or more disjoint cycles. In a cycle, every node in the cycle has out-degree at least 1 (and in fact, the out-degree equals the in-degree). But the condition "every button is a starting button" is equivalent to requiring that every node has out-degree at least 1. Since the graph is Eulerian (each node has in_deg = out_deg), then if a node has out_deg >= 1, then in_deg >= 1 as well. But note: it is possible that a node has out_deg=0? Then we don't require it? Actually the condition: "for every button 1<=B<=8, there exists j such that X_{i_j}=B". So every node must have at least one outgoing edge.

 5. How to enforce the condition that every node has at least one outgoing edge? We can note that in the Eulerian condition, if the net flow is zero and the graph is non-empty, then every node must have at least one outgoing edge if and only if the entire set of edges we choose is such that no node is isolated? Actually, no: it is possible that a node has in_deg=out_deg=0. That would violate the condition. Therefore, we must also ensure that every node has positive out_degree (which implies positive in_degree by Eulerian condition).

 6. However, we can break the problem into two parts:
    - First, we must have an Eulerian subgraph (net flow 0 for every node) and the number of edges >= K.
    - Second, every node must have at least one outgoing edge.

 7. But note: if a node has net flow 0 and the entire graph is Eulerian, it doesn't necessarily mean the node has an outgoing edge: it could have 0 in and 0 out. We must explicitly enforce that the out_degree of each node is at least 1.

 8. How to model? We can use DP that also tracks the out_degree for each node? But that would be too heavy (7 dimensions for net flow and 7 dimensions for out_degree?).

 9. Alternative: We can first note that the Eulerian condition is necessary and sufficient for the existence of cycles. Then the condition that every node has an outgoing edge is equivalent to: the subgraph must have no isolated node and must be Eulerian. However, we can break the problem as:

    We require:
      (a) For each node i: in_degree(i) = out_degree(i).
      (b) For each node i: out_degree(i) >= 1.

    But note: condition (b) implies that the total number of edges is at least 8 (since 8 nodes).

 10. How to combine in DP?
     We can use a DP state that represents the net flow for nodes 1 to 7 (since node 8 is determined). The state is a tuple (f1, f2, f3, f4, f5, f6, f7) where fi = out_degree(i) - in_degree(i). We require fi=0 for all i.

     However, condition (b) (out_degree(i)>=1) is not captured by the net flow state. But note: we can only check condition (b) after the fact? Actually, we can design the DP to also record the out_degree for each node? But that would be 8-dimensional for the net flow and then 8-dimensional for the out_degree? That state space is too big.

 11. Insight: We can separate the two conditions. We can use the DP to find a subset of edges that yields net flow 0 for all nodes 1..7 (which implies also for node 8) and then check if the induced subgraph has no isolated node? But note: the DP does not record which edges are chosen, only the net flow.

 12. However, we can also record the out_degree for each node? Actually, we don't need the exact out_degree, we only care that the out_degree is at least 1. But note: we can enforce that the out_degree is at least 1 by requiring that we have chosen at least one edge incident to each node as an outgoing edge. But how?

 13. Alternate approach: We can run the DP to compute the net flow state, and then after we get a state with zeros, we must check that the selected set of edges has every node having at least one outgoing edge. However, the DP does not store the entire set of edges, so we cannot check that.

 14. We can modify the DP state to also include a bitmask of 8 bits (for the 8 nodes) that records which nodes have at least one outgoing edge so far? Then the state becomes (f1, f2, f3, f4, f5, f6, f7, mask). The mask is 8 bits, but we note that if a node has at least one outgoing edge, we set the bit for that node. The state space: 
     - The net flow for each node: we can bound the net flow? The net flow for a node i can be in the range [-d, d] where d is the number of edges incident to i in the current window? But worst-case, d can be up to M (1000). That state space is (2001)^7 * 256 -> which is about 2001^7 * 256 = (2001^7) is astronomically huge.

 15. Therefore, we must avoid tracking the mask and the net flow together. Instead, we can do:

     Step 1: Precompute all edges and sort by speed.

     Step 2: Use two pointers to consider the window [L, R]. For a fixed window, we wish to know: is there a subset of edges in the window such that:
          (a) The net flow is zero for every node (1..7, and then 8 is automatically zero).
          (b) The number of edges is at least K.
          (c) Every node has at least one outgoing edge.

     However, condition (c) is independent: if we have an Eulerian subgraph (so net flow 0) and the subgraph is non-empty, condition (c) is equivalent to: every node has positive out_degree. But note: the net flow 0 does not force positive out_degree: we could have a graph with no edges at all? Then net flow 0, but then no node has an outgoing edge.

     How to enforce positive out_degree? We can note that the Eulerian condition and the requirement of positive out_degree for every node is equivalent to: the graph is a disjoint union of cycles that together cover all nodes? But note: it could be multiple cycles that together cover all nodes. So we require that the graph is Eulerian and the underlying graph (ignoring directions) is connected? Actually, not necessarily connected: disjoint cycles. But we don't require connectivity? The problem says: "These chain slides do not need to be connected to each other". So we can have multiple disjoint cycles.

     Therefore, condition (c) is: every node must be included in at least one cycle? Which is equivalent to: every node must have at least one outgoing edge (and then by Eulerian condition, it will also have one incoming edge).

     So condition (c) is: the induced subgraph has no isolated node.

 16. How to enforce in the DP? We can run the DP that computes the net flow state, and then at the end we can check: if the set of edges we have selected (which is not stored) actually covers all nodes? But we don't store the edges.

 17. We can do: 
     We run the DP that only tracks the net flow for nodes 1..7. Then we require that the state (0,0,...,0) is achieved. But then how do we know if every node has at least one outgoing edge? 

     Note: the DP does not record the actual degrees, only the net flow. However, we can also record the total out_degree for each node? That would be 7 more dimensions? Then the state becomes (f1,...,f7, d1,...,d7) and we require f_i=0 and d_i>=1 for each i? And similarly for node 8: we can derive d8 from the fact that the total number of edges is the sum of out_degrees? But then we also have to ensure d8>=1. The state space is: (2D+1)^7 * (D+1)^7, which is too big.

 18. Another idea: condition (c) is independent of the net flow? Actually, no. But note: we can break the problem into two steps:

     Step A: Find a set of edges that forms an Eulerian subgraph (net flow 0) and has at least K edges.

     Step B: Additionally, the set must cover all nodes (each node has at least one outgoing edge).

     How about: after we get a solution from the DP (with net flow 0), we can check the set of edges that we selected? But the DP doesn't remember the edges.

 19. We must design the DP to also record the set of nodes that have been covered (i.e., have at least one outgoing edge). But we have 8 nodes, so we can use an 8-bit mask. Then state = (f1, f2, f3, f4, f5, f6, f7, mask). The mask has 256 states.

     The net flow: we need to bound the net flow. How to bound the net flow? The net flow for a node i must be in the range [-count_i, count_i] where count_i is the number of edges incident to i in the window? But worst-case, count_i can be 1000, so the state space is (2001)^7 * 256. This is about 2001^7 * 256 = (2001 is 2001, 2001^7 is 1.28e22) -> too big.

 20. We must find a better way. Note that the net flow for each node cannot exceed the total number of edges incident to that node in the window, but we can also note that the net flow must be balanced: the sum of net flows must be 0. However, even with that, the state space is too big.

 21. Alternative approach: we note that the graph has only 8 nodes. We are going to use a state that is a tuple of 7 integers (for net flow of nodes 1..7). The net flow for each node i is between -D and D, but we can bound D by the maximum number of edges incident to i in the window? Actually, the absolute value of net flow for a node i cannot exceed the number of edges incident to i in the window. However, worst-case, the window may have up to 1000 edges, so the net flow for one node can be as large as 1000 in absolute value? Then the state space is (2001)^7 which is about 2001^7 = 1.28e22, which is too big.

 22. We need a different idea. 

 23. Insight: The net flow for each node must be zero. The entire graph has 8 nodes. The net flow of node 8 is determined by the net flows of the first 7. So we have 7 variables. However, the net flows are integers and bounded by the total number of edges. But note: the net flow for a node i is the difference: out_degree(i) - in_degree(i). Since each edge contributes to the net flow: +1 to the source and -1 to the target. The net flow of the entire graph is 0. 

     However, the net flow for a node i can be bounded by the total number of edges incident to i? Actually, the net flow cannot exceed the total number of edges incident to i as an outgoing edge, and similarly for negative. But worst-case, the net flow for one node might be as large as the total number of edges that start at that node, which could be 1000.

 24. But note: the problem constraints: M<=1000, but we have only 8 nodes. The maximum net flow for a node i is at most the number of edges starting at i in the window? Actually, the net flow for i is (out_i - in_i). The maximum out_i is the number of edges from i, and the minimum in_i is 0, so net flow can be at most the number of edges from i. Similarly, the minimum net flow is -(number of edges ending at i). 

 25. However, we cannot avoid the state space being huge. Therefore, we must use iterative methods that use state space reduction? Or we note that the net flows must be small? Actually, the net flow for each node must be zero in the end, so we only care about states that are "close" to zero? But we are building the state by adding edges.

 26. Alternatively, we can use a meet-in-the-middle? But M is 1000, and we have 7-dimensional state, which is too high.

 27. We must use the fact that the graph is small and the net flow is balanced. We can use a state that is 7 integers, but we note that the net flows are bounded by the size of the window? Actually, we can set a bound: the absolute value of net flow for any node cannot exceed the number of edges we have processed so far? But that doesn't bound it by a constant.

 28. However, note: the net flow of each node must be zero at the end. We are going to iterate over edges and update the net flow. The net flow for a node can be positive or negative. But we can use a dictionary for DP per window? But the window changes? 

 29. Alternatively, we can use a different approach: for a fixed window [L,R], we want to know: is there a nonempty subset of edges that forms an Eulerian subgraph (net flow 0) and covers all nodes (each node has at least one outgoing edge) and has at least K edges? 

     We can use a DFS or BFS to explore the state space of net flows for nodes 1..7? The state space is the net flows. But worst-case the net flows can be large.

 30. We need to bound the net flow. Note: the conservation of flow: the net flow of node 8 is -(net flow of nodes 1..7). And the net flow of node 8 must be 0 too? Actually, we require net flow for all nodes 1..8 to be 0. So the net flow of nodes 1..7 must be 0 and then node 8 is 0. So we are only interested in the state (0,0,...,0). But we are building the state by adding edges: we start at (0,...,0) and then for each edge we update: 
        state[u] += 1 (if u is in 1..7, note: if u is 8, we don't track? Actually, we don't track node 8? But then how do we account for edges incident to node 8?)

     We must track the net flow for nodes 1..7. For an edge from a to b:
        if a is in [1,7]: then we update net_flow[a] += 1
        if b is in [1,7]: then we update net_flow[b] -= 1
        if a is 8: then we do nothing to net_flow (because node 8 is not tracked, but then the net flow of node 8 becomes involved? Actually, we can derive the net flow for node 8 as:
            net_flow8 = - (net_flow1 + ... + net_flow7)

        Similarly, if b is 8: then we do nothing? But then we are effectively ignoring node 8.

     However, when we include an edge that starts at 8, we must account for the net flow of node 8: we are increasing net_flow8 by 1? But we don't track it. How to enforce net_flow8=0? 

     We require: net_flow8 = 0 = - (net_flow1+...+net_flow7) => so the sum of net_flow1 to net_flow7 must be 0.

     Therefore, we can represent the state by 7 integers, but we know that the sum of the state must be 0? Actually, no: the net_flow8 = - (s), so we require s=0. So the state must satisfy: net_flow1+...+net_flow7=0.

     This reduces the state space by one dimension? But still, the state space is the same as 6 dimensions? Actually, we can represent the state by 6 integers and then the 7th is fixed by the sum? But the 7th is not independent? 

     Specifically, let f1, f2, f3, f4, f5, f6, f7 be the net flows. We require:
        f7 = - (f1+f2+f3+f4+f5+f6)   [because the total sum must be 0? Actually, no: the total sum of net flows for all 8 nodes is 0: 
              f1+f2+f3+f4+f5+f6+f7+f8 = 0, and we have f8 = - (f1+...+f7) => so we get:
              f1+...+f7 + [-(f1+...+f7)] = 0 -> always true. 
        But we require f8=0, so we require: f1+...+f7 = 0.

     Therefore, the state is (f1, f2, f3, f4, f5, f6) and f7 = - (f1+...+f6). 

     Now the state space is (2D+1)^6. For D=1000, that's 2001^6 = about 6.4e18, which is still too big.

 31. We must use iterative updates and use a dictionary to store only reachable states? But the number of edges is 1000, and the net flows might be bounded by the number of edges incident to the node? But worst-case, a node might appear in all edges (as source or target) up to 1000 times, so the net flow for one node could be as large as 1000. The number of states is 2001^6 = 6.4e18, which is too many.

 32. We need a better bound. Note that the net flow for a node i cannot exceed the number of edges that start at i in the window, and similarly the negative net flow cannot exceed the number of edges that end at i. But we are considering a fixed window [L,R]. The number of edges incident to a particular node in the window might be at most (number of edges in the window) which is at most 1000. But we have 6 dimensions, 2001^6 is too big.

 33. Alternative: we can use a BFS with a dictionary that maps state (f1..f6) to the minimum number of edges or something else? But we are only interested in whether we can achieve state (0,0,...,0) and also that the set of edges covers all nodes. 

     But then condition (c): covering all nodes (each node has at least one outgoing edge) is not tracked.

 34. Given the complexity, we might reconsider the problem constraints: M <= 1000, but also there are only 8 nodes. The number of edges in the window is at most 1000. We might try to use a different approach: 

     We note that the entire graph is small (8 nodes). We are looking for a spanning Eulerian subgraph (disjoint union of cycles covering all nodes) that uses at least K edges.

     But note: we are allowed to use more than one edge per node? The Eulerian subgraph does not have to be connected. 

     How about: we want a set of edges that forms an Eulerian subgraph (in_deg(i)=out_deg(i) for every i) and out_deg(i)>=1 for every i, and |E|>=K.

     And we want to know if there is such a set in the window [L,R]? 

     This is equivalent to: we want an assignment of multiplicities to edges (0 or 1, since we can use an edge at most once) such that:
        For each node i: 
            out_deg(i) = in_deg(i) = d_i, and d_i>=1.
        and |E| = sum(d_i) [actually, |E|= sum(out_deg(i)) ] and |E|>=K.

     This is an integer linear system? But the number of variables is the number of edges in the window, which can be up to 1000.

 35. We can use a different idea: the entire set of edges in the window forms a directed multigraph. We wish to know if there is a spanning Eulerian subgraph (covering all nodes) with at least K edges. 

     This is equivalent to: the graph must be such that the underlying graph is covered and the directed degrees are balanced. 

     We can try to iterate by node degrees? But then we are back to the state space of degrees.

 36. Given the low number of nodes (8), we can try to use state = (d1, d2, d3, d4, d5, d6, d7, d8) for out_degrees? But then the in_degrees are determined by the out_degrees? No, because we don't know the in_degrees. But we know that in_deg(i) = out_deg(i) for every i. So the state is (d1, d2, d3, d4, d5, d6, d7, d8) with di>=1 and the entire set of edges must form a directed graph with these degrees. 

     How many such states? The total out_degree is D = d1+...+d8. Each di>=1, so D>=8. The maximum D is the number of edges in the window, which can be up to 1000. The state space is 1000^8, which is 1e24, too big.

 37. We are stuck. Let's read the sample inputs and see if there is a simpler insight.

     Sample Input #3:
        8 8
        1 2 1
        2 3 3
        3 4 5
        4 1 7
        5 6 9
        6 7 11
        7 8 13
        8 5 15

        This forms two cycles: one on 1-2-3-4 and one on 5-6-7-8. The range is 15-1 = 14.

     What if we try to use a brute force over the entire set of edges in the window? The window size might be up to 1000, so 2^1000 is too big.

 38. Another idea: we note that the spanning Eulerian subgraph (disjoint union of cycles covering all nodes) is equivalent to a disjoint union of directed cycles that together cover all nodes. 

     This is a spanning subgraph that is Eulerian and has no isolated node. 

     How to count such subgraphs? We can use the inclusion of edges. But the number of cycles in a directed graph of 8 nodes might be many, but we can use DP over subsets of nodes.

     Specifically, we can use a DP for the entire graph on 8 nodes. The state is a bitmask of the nodes that have been covered? But we are not building a single cycle, but multiple disjoint cycles.

     We can use: 
        dp[mask] = whether it is possible to have a collection of cycles that cover the set of nodes in mask, using a subset of the edges in the window.

     Then we require dp[255] (if 8 nodes) to be true, and also the number of edges used is at least K.

     How to transition? 
        We can iterate over the edges in the window and update? But then we have to worry about the order.

     Alternatively, we can iterate over the edges and use a Hamiltonian cycle style DP? But we want multiple cycles.

     We can do: 
        dp[mask] = the minimum/maximum number of edges that can be used to form a disjoint union of cycles covering mask? Or we want to know if it is possible to achieve mask with at least K edges? Actually, we care about the existence and the size (number of edges) for the entire set.

     However, we are allowed to choose any subset of edges in the window. We don't require to use all edges? But we are forming a covering by cycles: we must use exactly the edges that form the cycles. And the cycles must cover all nodes.

     The catch: the same edge cannot be used twice.

     Steps for the DP over mask:
        dp[mask] = the minimum number of edges (or maximum? we care about at least K) or simply a boolean: is it possible to cover the set 'mask' by disjoint cycles? And we also record the number of edges used for that mask.

     How to update?
        We can iterate over a cycle that is a subset of mask. But the number of subsets of mask is 2^8=256. The number of cycles in a subset S? We can precompute for every nonempty subset S and every ordering? 

     Alternatively, we can use:
        dp[mask] = exists a subset of edges in the window that form a collection of cycles covering exactly the nodes in mask.

     Then we can iterate over a subset T of mask that forms one cycle, and then the remaining is mask\T, which must be covered by cycles.

        dp[mask] = OR_{nonempty T ⊆ mask} [ (there is a directed cycle that covers T) and dp[mask\T] ]

     But then how to check for a directed cycle covering T? We need to know if there is a directed cycle that uses exactly the nodes in T? 

     We can precompute for every subset T and every two nodes u,v in T whether there is a path from u to v? But we want a cycle. 

     We can use a sub-DP for one subset T: 
        Let f[T][v] = the number of edges used in a path that has covered a subset of T and ended at v? But we want a cycle: we need a path that starts at some node and returns to that node? 

     Alternatively, we can use a standard Hamiltonian cycle in a directed graph for the set T, but T has up to 8 nodes. The number of subsets T is 2^8=256, and for each T we can do a Hamiltonian cycle in O(|T|^2 * 2^(|T|)) which is O(8^2 * 2^8) = 64*256=16384 per T? Then for all T, we do:
        total = 256 * 16384 = 4e6, which is acceptable.

     But note: we have to do this for every window? And the window changes. The two pointers will iterate over O(M) windows, and M<=1000, so total windows 1000, and for each window we do 4e6 work? Then total work 4e6 * 1000 = 4e9, which is borderline in C++ but in Python it might be too slow.

     However, note: the window [L,R] is changing incrementally. We might be able to precompute the entire graph for the union of all edges, and then for a fixed window, we consider the edges with speed between [L,R]. We can precompute for every subset T and every window? But the window is defined by the speed range, and the edges in the window change.

 39. Plan for a fixed window [L,R]:
        Let E_window = sorted_edges[L:R+1]  (edges in the current window).

        Precomputation for cycles on each subset T of [1,8]:
            We want to know: is there a directed cycle that uses exactly the set T? And also, what is the minimum number of edges? Actually, we want to know if there is ANY cycle (we don't care about minimizing edges, just existence) for the set T using the edges in E_window. But note: we are allowed to use any subset of the edges in the window? And we can use multiple edges? But wait: we can use an edge at most once. Also, the cycle must be simple? Not necessarily: but if there is a cycle that uses an edge twice, that is not allowed. So we require a simple cycle? Or can we have multiple cycles? 

        Actually, the problem: we are going to break the entire set of 8 nodes into disjoint subsets, each of which will be covered by a cycle. And within a cycle, we can have a simple cycle? But note: the graph is a multigraph? We can have a cycle that uses an edge only once.

        For a fixed subset T, we want to know if there is a collection of edges that forms a directed cycle that covers T? But it could be one cycle that covers T? Or we can break T into smaller cycles? But the definition for a cycle is a connected directed cycle? Actually, the cycle covering T might be one cycle that visits every node exactly once? Or it might be multiple cycles within T? 

        But our dp by mask will break T into one cycle? Actually, the recurrence is:

            dp[mask] = OR_{T ⊆ mask, T nonempty and connected by one cycle} and dp[mask\T]

        However, the cycle for T might be one cycle that covers every node in T? Or it might be multiple cycles within T? 

        Actually, we design: 
            Let cycle[T] = whether there exists a set of edges that forms a disjoint union of cycles that cover T? But then we don't need to break T further. 

        But then the recurrence for the entire covering becomes exponential in the number of cycles. 

        Alternatively, we can use the recurrence that breaks off one cycle at a time:

            dp[mask] = OR_{ for every nonempty subset T of mask such that T is the union of one or more cycles } ... 

        This is not trivial.

 40. We can use a different approach for the fixed window: we want to know if there is an Eulerian subgraph (covering all nodes) and using at least K edges. This is equivalent to: 
        (1) The subgraph is Eulerian: in_deg(i)=out_deg(i) for every i.
        (2) The subgraph has no isolated node: so the support is the entire set of 8 nodes.
        (3) The number of edges >=K.

     We can iterate over all possible out_degrees for the 8 nodes: d1, d2, ..., d8 such that di>=1 and the total edges D = d1+...+d8>=K. And then check if there is a directed graph on the given multigraph (with the edges in the window) that has out_degree di for node i and in_degree di for node i.

     How to check? This is a bipartite matching problem? We can use the following:

        We have a directed multigraph. We wish to know if there is a subgraph with out_degree for node i = di and in_degree for node j = dj. 

        This is a directed degree-constrained subgraph. We can use a flow formulation:

            Create a bipartite graph: left side = nodes, right side = nodes.
            For each directed edge (u, v) in the window, add an edge from u (left) to v (right) with capacity 1.
            Add a source connected to each left node u with capacity = d_u.
            Add a sink connected from each right node v with capacity = d_v.

            Then the max flow should be D = sum(d_i).

        The number of distinct degree sequences: The total D is at least 8 and at most the number of edges in the window (<=1000). The out_degrees are bounded by D, and there are 8 nodes. The number of nonnegative integer solutions to d1+...+d8 = D with di>=1 is C(D-1,7) which for D=1000 is huge.

 41. Given the complexity, we might have to abandon the two pointers over sorted speeds. But the problem asks for the minimal range. 

 42. We might try to iterate over the minimal speed and then binary search on the maximal speed? But then for each candidate range we would have to do the above expensive procedure.

 43. After reading the sample inputs, we see that the answer for Sample Input #6 is 17. The minimal range is 17.

 44. There is a known solution for this problem in C++ that uses two pointers and a 7-dimensional DP with net flow and a bitset for the covered nodes. But then the state is (f1,...,f7, covered: an 8-bit mask). The net flow we hope to be not too large. However, note that the net flow for a node might be large, but we are only storing states that are reachable. In practice, the net flow might be bounded by a small constant? 

     But worst-case, the net flow might be as large as the number of edges incident to that node that have been processed. 

     However, the problem: M is 1000 and there are 8 nodes. The worst-case net flow might be 1000, but the number of states might be reduced by the fact that the net flows are not independent. And also, we are only storing states that are reachable. 

     We will try to use a dictionary for the DP state: state = (f1, f2, f3, f4, f5, f6, f7, mask) -> but then the state space might be too large. But note: the net flows must be with small absolute values? Or maybe not.

 45. Alternatively, we can use a different state: 
        state = (mask, net_flow_vector) 
     but the net_flow_vector has 7 integers. But then we use a dictionary: keys are (mask, f1, f2, f3, f4, f5, f6) (with f7 = - (f1+..+f6)).

     How many states in practice? The net flow values might be in the range [-M, M] for each, so 7 dimensions with 2*M+1 values, and 256 for the mask -> (2001)^6 * 256 = 6.4e18 * 256 = 1.6e21, which is too many.

 46. We must use a iterative DP and hope that the net flow doesn't get too large? Or use a bound: since the total number of edges is at most 1000, the net flow for a node cannot exceed 1000, but we also know that the net flow for node i is at most the number of edges that start at i minus the number of edges that end at i that we have processed. But then it might be prune if the net flow cannot be zeroed out by the remaining edges.

 47. Given the time, we might implement the two pointers and for each window use a brute force over all subsets of the edges in the window? The window can be large (up to 1000 edges), so 2^1000 is not feasible.

 48. We return to the net flow DP with state = (f1, f2, f3, f4, f5, f6, f7) and we only care about the state (0,0,...,0) and also that the out_degree of each node is at least 1. We can run a BFS or DFS in the state space. We start at (0,0,...,0) and then add edges. But then we are. 

 49. But note: we are not required to know the minimal range for the entire set of edges in the window, but for the window [L,R] we want to know if there is any subset that has net flow 0 and covers all nodes (each node has at least one outgoing edge). 

     We can do: 
        Let dp be a set of states (net_flow_vector) that are achievable with the edges in the window.
        Initially, dp = { (0,0,...,0) } (using no edges).
        For each edge in the window (in any order), update:
            new_dp = dp OR ( dp shifted by the edge's effect on net flow )

        Specifically, for a state f in dp, we can choose to not take the edge: state remains.
        Or take the edge: then update net_flow for the source node: if source is i (1..7), then f[i] += 1; if source is 8, then we don't change tracked net flow but we know that node 8's net flow increased by 1, so the sum of tracked net flow must be -1 for node 8's net flow to be 0? Actually, our state f = (f1,...,f7) represents the net flow for nodes 1..7, and the net flow for node 8 is - (f1+..+f7). When we add an edge from 8 to v:
            then node 8: net flow +1, node v: net flow -1 (if v in 1..7) or if v==8, then no change in tracked net flow.
            so if v in 1..7: new_f[v] = f[v] - 1.
            if v==8: then the net flow for node 8 becomes: -s +1 (where s = f1+..+f7) and we require it to be 0, so we require -s+1=0 -> s=1. 
            but also, we then don't change the tracked vector. 

        Therefore, we must also account for the net flow of node 8. 

        Let's redefine the state to be the net flow for nodes 1..7 and also the net flow for node 8? Then the state is (f1,..,f7, f8) and we require f8= - (f1+..+f7) -> so we are at a state where f8 = -s. But then we only need to store (f1,..,f7) and we can compute f8 = -s. 

        However, when we add an edge from 8 to v:
            if v in 1..7: then f8 = f8 + 1, and fv = fv - 1.
            if v==8: then f8 = f8 + 1 - 1 = f8 (because the edge from 8 to 8: out_degree of 8 increases by 1, in_degree of 8 increases by 1, so net flow change is 0).

        wait, let's recompute for an edge from a to b:
            net_flow[a] += 1
            net_flow[b] -= 1

        So for an edge from 8 to 8: net_flow[8] += 1 and then net_flow[8] -= 1 -> net change 0.

        For an edge from 8 to v (v in 1..7):
            net_flow[8] += 1
            net_flow[v] -= 1

        In our state (f1,..,f7) (which only tracks nodes 1..7), we then must account for the change in node 8 by the sum? 
            Let s = f1+..+f7.
            net_flow[8] = -s.
            After the edge: 
                node 8: -s + 1
                node v: fv - 1.
                new sum for 1..7: (f1+..+fv-1+..+f7) = s - 1.
                then net_flow[8] should be - (s-1) = -s+1, which matches.

        Therefore, we can do for an edge from a to b:
            if a in [1..7]: then new_f[a] = f[a] + 1.
            else (a==8): then we do nothing to f, but the net flow for node 8 increases by 1, which is reflected in the sum: new_sum = (sum of f) - 1 (because the new sum for 1..7 is the old sum if we change nothing, but if we then also do the next step for b, it will reduce by 1) -> actually, we do nothing to the vector for a=8, but then for b: 
            if b in [1..7]: then new_f[b] = f[b] - 1.
            if b==8: then nothing.

        So in summary, for an edge (a,b):
            if a in [1..7]: then new_f[a] = f[a] + 1.
            if b in [1..7]: then new_f[b] = f[b] - 1.
            (if a or b is 8, we do nothing for that part in the vector)

        And then the net flow for node 8 is - (sum of the vector).

        After processing the edge, the new net flow for node 8 might not be 0, but eventually for the final state we require the vector to be (0,..,0) and then node 8 will be 0.

        Therefore, the state is a 7-dimensional vector of integers. The initial state is (0,0,...,0).

        We iterate through each edge in the window (order doesn't matter) and update the set of states.

        After processing all edges, we check if the state (0,0,...,0) is achievable and that the number of edges used in that state is at least K, and also that the state has the property that every node has at least one outgoing edge. 

        But how to track the out_degree for each node? We could, for a state, also a mask of nodes that have been used as a source at least once. Let's add an 8-bit mask: state = (f1,..,f7, mask), where mask has a bit i set if node i has been used as a source at least once in the chosen edges. 

        The state space: 7 integers for net flow and an 8-bit mask. 

        The net flow for each node i in 1..7: we hope that the net flow won't be too large. In the worst-case, the net flow can be as large as the number of edges in the window, which is at most 1000. The state space is (2001)^7 * 256 = 1.28e22 * 256 = 3.2e24, which is too big.

 50. We must try to bound the net flow. Note that the net flow for a node i cannot exceed the number of edges in the window that start at i, and cannot be below (0 - number of edges in the window that end at i). But these are not global bounds for the intermediate state. 

 51. Alternatively, we can use a meet-in-the-middle for the window. The window has up to 1000 edges, and we split into two sets of 500 edges. The state space for one set: we would store a tuple (f1,..,f7, mask) for the net flows and the mask of covered nodes. For the other set, we would look for ( -f1, -f2, -f7, mask2) such that mask OR mask2 = 255. 

     The state space for one set: the net flows might be in the range [-500,500] for each of 7 dimensions, and 256 for the mask. The number of states is (1001)^7 * 256 = (about 1e21) which is too big.

 Given the complexity and the contest constraints (M<=1000, but only 8 nodes), and that the intended solution might use a 7-dimensional DP with net flow and a bound on the net flow by the number of edges in the window, and then hope that the net flow in practice is small, or use a iterative BFS with a queue and a set to store states, and prune states that are not reachable or not able to zero out. 

 We in desperation implement the BFS for the entire window and hope that the net flow states will be sparse.

 Steps for a fixed window [L,R]:
   Let edges = the list of edges in the window.
   Let dp = a dictionary (or set) of states: state = (f1, f2, f3, f4, f5, f6, f7, mask), where 
        fi = net flow for node i (for i=1..7)
        mask = an integer from 0 to 255: bit i (0-indexed for node i+1) is 1 if there is at least one edge in the chosen set that has node (i+1) as a source.

   Initial state: (0,0,0,0,0,0,0, 0) with 0 edges.

   For each edge in the window ( iterating index from L to R):
        (a, b, v) = edge
        Let inew = a - 1  # if a in [1,8], for node index: for the net flow, if a in [1,7] we index a-1, if a==8, we skip for the net flow in the vector? 
        Similarly for b.

        How to update the net flow vector for edge (a,b):
            Let new_f = list(f)   [ for indices 0..6 for nodes 1..7]
            If a <= 7:
                new_f[a-1] += 1
            # for a=8: we do nothing to the vector, but remember: node 8's net flow is -sum(new_f) and it will be adjusted by the edge: node 8's net flow will increase by 1, which should be reflected in the sum.
            # But note: if a==8, then we don't change the vector for a, but then for b:
            If b <= 7:
                new_f[b-1] -= 1

            Additionally, the mask: we set bit (a-1) if a<=8? But node 8 is not in the mask? The mask is for the 8 nodes. We have 8 nodes: node1 to node8. We can let mask have 8 bits: bit0 for node1, bit1 for node2, ... bit7 for node8.
            So for a, we set bit (a-1) in the mask.

   So for an edge (a,b):
        new_f = f ( for the vector of 7 net flows) with:
            if a in [1,7]: position a-1: +1
            if b in [1,7]: position b-1: -1
        new_mask = mask OR (1 << (a-1))   [whether a is 8: then a-1 is 7, so we set bit7]

   Then we update the state with new_f and new_mask.

   Also, we can choose to skip the edge.

   After processing all edges, we look for the state (0,0,0,0,0,0,0, 255) and among these states, we check the number of edges used. We want at least K edges.

   But note: the state does not record the number of edges. We should also record the number of edges? Or we can simply know that the state is achievable with a certain number of edges. We care about: is it achievable with at least K edges? 

   We can store for each state the maximum number of edges used to reach that state? Then for the final state (0,0,..,0, 255), we check if the max edges >=K.

   However, we want to now if there is any>=K, so we only need to know if there is a>=K. We can store the maximum number of edges for state.

   Alternatively, we can store a boolean for each state and the number of edges is just the count of edges we've taken. But we iterate and we are allowed to take or not take.

   We do: 
        dp is a set of states (f1..f7, mask) and for each state we store the number of edges used to achieve it? But we want to maximize the number of edges? Actually, we only care about the existence of a state with at least K edges.

   We can do: 
        Let dp be a set of states (f1..f7, mask), and we don't care about the exact number of edges, because if we can achieve the state with n edges, then any superset (by adding more edges) might not be (because we might break the net flow). Actually, we are including exactly the edges we choose.

   But then how do we know the number of edges? We can store for each state the maximum number of edges used? Because if a state can be achieved with 10 edges, then it is>=K for K<=10. 

   So we want to know: for the state (0,0,...,0,255), what is the maximum number of edges used? Then we can check if it>=K.

   However, we might achieve the state with fewer edges and then by not taking some edges we might have a smaller number. But we are iterating over all edges, and we are allowed to take or not take. The BFS will try all.

   Alternatively, we can use a DP array for the state and store the maximum number of edges used to reach that state.

   Given the state space might be large, we will use a dictionary: key = (f0, f1, f2, f3, f4, f5, f6, mask), value = the maximum number of edges used to achieve this state.

   Initialization: state (0,0,0,0,0,0,0,0) with 0 edges.

   For each edge in the window ( in any order )? We can iterate in the order of the window.

   Then for each edge and for each state in dp, we try:
        not take: state remains.
        take: new_state = (f0', f1',..., f6', mask') and new_edges = count+1.

   After processing, if the state (0,0,...,0, 255) has value>=K, then the window is valid.

   Complexity: the number of states might be large, but note that the net flow cannot exceed the number of edges in the window in absolute value for each node, and the number of edges is up to 1000. The state space is (2001)^7 * 256 = 1.28e22 * 256 = 3.2e24, which is too many.

 52. We must hope that in practice the net flow will be within a small range. We try to prune: if the net flow for a node exceeds the number of remaining edges that can help reduce it, then prune. But this is complicated.

 Given the time, and since M is only 1000, and the window in two pointers will be called O(M) times, and for each window we do a BFS with state space (which is the number of distinct states) hope that the net flow is not too wild.

 Or we might use a randomized algorithm? Not.

 53. Sample: in Sample Input #3, the entire window has 8 edges. The net flow for each node in the final state is 0. In the intermediate state, the net flow might be within [-8,8].

 54. Therefore, we can try to bound the net flow by [-count, count] for count being the number of edges in the window, but then the state space is (2*count+1)^7 * 256. For count=1000, (2001)^7 * 256 is 3.2e24, which is too many.

 55. We must use a different representation. The net flow for node i is the difference between the number of times it is used as a source and the number of times it is used as a sink in the chosen set. We can use a weeding out: the net flow for node i must be between -remaining_edges_from_i_sink and remaining_edges_from_i_source? But then it is branch and bound.

 Given the complexity and the problem constraints (M=1000) and the fact that there are only 8 nodes, and the intended solution in C++ might use a 7-dimensional array with bounded net flow by a small constant (like 8), we not that the net flow in the sample is within [-8,8] because the total number of edges is 8. In general, the net flow for a node i in the chosen set might be between -d and d where d is the degree in the chosen set, which is at most the number of incident edges in the window. However, the net flow in the final state is 0. 

 56. For the sample, we are only the net flow might be small in practice. We may bound the net flow in the intermediate state by the number of edges we have yet to process? This is not sound.

 57. Finally, we do the following: 
        - Sort the edges by speed.
        - Use two pointers L and R, R from 0 to M-1, and L from 0 to R.
        - For each window [L,R], 
            - Use a BFS (DP) that processes the edges in the window one by one. The state is (f0, f1,..., f6, mask) and we use a dictionary to store the maximum number of edges for the state.
            - The state space might be pruned by: 
                  * If the absolute value of net flow for any node exceeds the number of edges in the window that are incident to it (which we can precompute) in a way that cannot be fixed by the remaining edges, then prune. But this is complicated.
        - If we find a state (0,0,...,0, 255) with number of edges>=K, then the window [L,R] is valid.

        - Then we update the minimal range = min(minimal_range, speed[R]-speed[L]), and then L++.

        - Else, R++.

        - We break when R reaches M.

 58. Given the state space might be too big, we hope that the net flow does not exceed in practice a small range. 

 59. We also note that the net flow must eventually be 0, and the mask must be 255. We can also prune states where the net flow is not zero and the remaining edges are not enough to fix it. For example, if the remaining edges (not yet processed) are not enough to cover the current net flow for any node, then prune. Specifically, for a node i, the net flow is f. Then the future edges can change the net flow for node i by at most the number of future edges that have i as source (which would increase by 1) or as sink (which would decrease by 1). So the future can change node i by at most (future_out[i] - future_in[i]) in the net flow. But note: net flow is not linear in that way. 

 60. Given the time, we decide to implement the BFS and hope that the net flow will be bounded in the sample. This might work for M<=1000 if the net flow in intermediate states is not too large. 

 Steps for BFS in a window:

   Let INF = -10**9
   Let dp = a dictionary: key = (f0, f1, f2, f3, f4, f5, f6, mask), value = the maximum number of edges used to reach this state.
   Initialize: 
        state0 = (0,0,0,0,0,0,0, 0) with edges=0.
        dp = { state0: 0 }

   For each edge in the window ( iterate from index L to R ):

        new_dp = a copy of dp   (because we can skip the edge)

        For each state in dp:
            Try taking the edge (a,b,speed) = edge
            new_state = list(state) without mask: (f0,..,f6) and the mask part.
            a0 = a, b0 = b.
            If a0 <= 7:
                new_f[a0-1] = state.f[a0-1] + 1
            If b0 <= 7:
                new_f[b0-1] = state.f[b0-1] - 1
            new_mask = state.mask | (1<< (a0-1))   [because a0 is from 1 to 8, and we use a0-1 for the bit index: for node8, a0=8, then bit index 7]
            new_edges = state_edges + 1

            new_state_tuple = (new_f0, new_f1, new_f2, new_f3, new_f4, new_f5, new_f6, new_mask)

            new_dp[new_state_tuple] = max(new_dp.get(new_state_tuple, INF), new_edges)

        Then set dp = new_dp

   After processing all edges in the window, we are and with dp. Then we look for state (0,0,0,0,0,0,0, 255) and if its value>=K, then the window is valid.

 61. We must be cautious: the net flow for node8 in the state (0,0,...,0) is 0, and the mask=255 means that every node has been used as a source at least once.

 62. For the two pointers:

        sort the edges by speed, and store with the original (a,b,speed)
        Let R = 0
        For L in range(M):
            while R < M and (no valid found for window [L,R] by BFS):
                R += 1
                if R<M: then add the edge at speed[R] to the window and update the BFS state for the window [L,R] (by iterating only the new edge) -> but note, the window is [L,R], so it's easier to recompute the BFS for the entire window for each R? 

        Alternatively, we can do a typical two pointers: 
            R from 0 to M-1, and for each R, we extend the window to include the edge R. Then we move L as much as possible.

        But the BFS for the window [L,R] might be computed from scratch for each R and then for L incremented we remove the edge at L. 

        However, the BFS is over the set of edges in the window. If we do from scratch for each [L,R], then the two pointers will call BFS O(M^2) times, and each BFS is O(2^(#edges in window)) in states, which is too expensive.

 63. We in the two pointers and for each R, we iterate L from 0 to R, and do a BFS for the window [L,R] and if it is valid, then update ans = min(ans, speed[R]-speed[L]). 

        For L in range(current_R+1): 
            BFS for the window [L,R] 

        Then total work is O(M^2 * (state space of BFS)), which is too heavy.

 64. Given the state space of the BFS might be large, we must use a different approach. 

 65. We can try to use a different method for the window [L,R]: we want to know if there is a subset of edges that is Eulerian (net flow 0 for all nodes) and covers all nodes (mask=255) and has at least K edges. This is a well-known 0-1 ILP, and we can use a solver for 8 nodes? The number of edges is up to 1000 in the window, and we are only interested in the feasibility.

 66. We can use a Gaussian elimination over the incidence matrix? The incidence matrix for directed graph: 8 nodes (7 independent) and the number of edges is the window size. We want a subset of edges such that the net flow is 0 for all nodes. This is a linear system in GF2? Not in GF2, in integers. We are in integers: each edge used exactly once or not, and the net flow conservation.

        A x = b, where A is the incidence matrix (8-1=7 rows, and the number of edges in the window is the number of columns), and b=0. And x in {0,1}. 

        This is an integer linear system in the integers, but the matrix A is the incidence matrix, and the entries are: 
            for edge j: 
                if the edge is from a to b, then in the row for node i (i in 1..7):
                    if i==a, then +1
                    if i==b, then -1
                if a or b is 8, then for node 8 we don't have a row, but the condition is that the sum of the net flows for nodes 1..7 must be 0.

        We can include a row for the sum: the net flow for node8 is -sum, so we require the net flow for node8 to be 0, which is: 
            0 = (number of edges from 8 to any node) - (number of edges from any node to 8) 
            = (out_degree(8) - in_degree(8))

        But also, the net flow for node8 = out_degree(8) - in_degree(8) = 0.

        Therefore, the system is the incidence matrix for all 8 nodes, but the rows are not independent: the sum of the net flows is 0. So we only need the first 7 rows.

        The system: 
            A (7 by n) * x = 0   (vector of 7 zeros)

        We want a nontrivial solution in {0,1} such that the solution has at least K edges and the solution has the property that every node has at least one outgoing edge in the solution.

        But then the problem is NP-complete in general (subset-sum on the net flow), and with 7 equations and n up to 1000, we might use dynamic programming on the net flow state for the 7 nodes. This is the same as before.

 67. Given the time, we must output a solution. We will implement the BFS for the net flow state and the mask, and hope that the net flow does not exceed the [-20,20] for each node in the states that are visited. This might work for the provided samples.

 68. Implementation: 
        Pre-sort the edges by speed.
        Let edges_sorted = sorted(edges, key=lambda x: x[2])

        Let ans = a large number, say 10**18.
        Let R = 0
        For L in range(M):
            # We will maintain a dp for the window [L, R-1], and then extend R to include new edges until we have a valid solution.
            while R < M and (not found or (the best for this L is not found)):
                new_edge = edges_sorted[R]
                (a,b,s) = new_edge
                # add this edge to the current dp (which is for edges [L, R-1]) to get dp for [L,R]
                new_dp = copy of dp   (which means we can skip the new edge)
                For each state in the old dp (for [L, R-1]):
                    take the new_edge: 
                        new_state = update_flow(state, a, b) and update_mask(state, a)
                        new_edges_count = state_edges_count + 1
                        update new_dp for the new_state with new_edges_count (taking the maximum count)

                dp = new_dp
                if the state (0,0,...,0, 255) exists in dp and dp[state]>=K:
                    range = edges_sorted[R][2] - edges_sorted[L][2]
                    ans = min(ans, range)
                    break out of the while loop and then we will remove L

                R += 1

            Then remove the edge at L from the dp. How? We must also the states that used the edge at L.

            This is very complex.

 69. Alternatively, for each window [L,R] we do a BFS from scratch. The number of edges in the window is (R-L+1) which for R-L+1=1000 is 1000, and the state space might be huge, but we hope that the net flow states are prune and the window is not worst-case.

 70. Given the sample size (M<=1000) and the two pointers: the total number of windows is O(M^2) which is 1e6, and for each window we do a BFS that iterates over up to 1000 edges and for each edge and for each state in the current dp, we update. The number of states might be 1000 in the current dp, then the total work might be 1e6 * 1000 = 1e9, which is acceptable in C++ but in Python it might be 1e9 * 10 and might be borderline. But the state space might be not 1000 but up to (2*D+1)^7 * 256, which in practice might be pruned.

 We try the following for the sample of 8 edges in Sample #3: 
        L=0, R=7, window has 8 edges.
        The BFS will have at each edge iteration at most 2^(number of states) but initially 1 state, then after one edge: 2 states, after two edges: 4 states, ... exponential in the number of edges? But the state is not just a binary state, so it might be more.

        In the worst-case, the state space might be (2*8+1)^7 * 256 = (17)^7 * 256 = 1.0e9 * 256 = 256e9, which is too many.

 Therefore, we must not iterate over a state space that is exponential in the number of edges.

 Given the time constraints, we output a solution that might work for small net flow (bounding the net flow by [-B, B] for B= for example 8) in the intermediate state. This is justified by the final net flow being 0 and the number of edges in the window being the number of edges in the Eulerian subgraph, which is at least 8. We can set a bound B, for example B=20.

 If the net flow for any node exceeds 20 in absolute value, we prune the state.

 This might work for the provided samples.

 Steps in the BFS for a fixed window:
   Let BOUND = 20   (or 10 might be enough for the samples? sample has at most 8 in the cycle covering, but there might be more edges in the window)

   dp = a dictionary: state: (f0..f6, mask) -> the maximum number of edges used to achieve this state.
   Initialize: state0 = (0,0,0,0,0,0,0, 0) with 0 edges.

   for each edge in the window ( in order of appearance in the sorted by speed? but it doesn't matter) but we use the order in the window (which is sorted by speed).

        new_dp = dp.copy()   # skip the edge

        for each state in dp:
            (f0..f6, mask) = state
            edges_count = dp[state]
            # try taking the edge (a,b,speed)
            new_f = [f0, f1, f2, f3, f4, f5, f6]
            a = edge[0], b = edge[1]
            if a>=1 and a<=7:
                new_f[a-1] = f_list[a-1] + 1
            if b>=1 and b<=7:
                new_f[b-1] = f_list[b-1] - 1

            # if any new_f[i] is > BOUND or < -BOUND, then skip this state.
            if any(abs(x) > BOUND for x in new_f):
                continue

            new_mask = mask | (1 ( those 8 nodes: if a is 8, then a-1=7, if a in [1,7] then a-1 in [0,6], and if a is 8, then bit7 (which is the 8th node) will be set.

            new_state = (new_f[0], new_f[1], new_f[2], new_f[3], new_f[4], new_f[5], new_f[6], new_mask)

            new_count = edges_count + 1
            # if new_state is in new_dp, then new_dp[new_state] = max(new_dp[new_state], new_count)
            # else, new_dp[new_state] = new_count

        then dp = new_dp

   after the window, if (0,0,0,0,0,0,0, 255) in dp and dp[state]>=K: then valid

 71. Then in the two pointers:

        sort the edges by speed.
        ans = 10**18
        for L in range(M):
            # reset dp for new L
            dp = {}
            start_state = (0,0,0,0,0,0,0,0)
            dp[start_state] = 0
            for R in range(L, M):
                edge = edges_sorted[R]
                new_dp = dp.copy()   # not take: states in dp are still valid for window [L,R]
                for state in list(dp.keys()):   # iterate over the states before adding the edge
                    count_edges = dp[state]
                    # try take the edge
                    f0,f1,f2,f3,f4,f5,f6, mask = state
                    f_list = [f0,f1,f2,f3,f4,f5,f6]
                    a, b, speed_val = edge
                    new_f = f_list[:]   # copy

                    if a>=1 and a<=7:
                        new_f[a-1] += 1
                    if b>=1 and b<=7:
                        new_f[b-1] -= 1

                    if any(abs(x) > BOUND for x in new_f):
                        continue   # prune

                    new_mask = mask | (1 << (a-1))   # because a is from 1 to 8, and we use bits 0 to 7 for nodes 1 to 8.

                    new_state = (new_f[0], new_f[1], new_f[2], new_f[3], new_f[4], new_f[5], new_f[6], new_mask)
                    new_count = count_edges + 1

                    # if new_state in new_dp, then new_dp[new_state] = max(new_dp[new_state], new_count)
                    # else, new_dp[new_state] = new_count
                    if new_state in new_dp:
                        if new_count > new_dp[new_state]:
                            new_dp[new_state] = new_count
                    else:
                        new_dp[new_state] = new_count

                dp = new_dp   # dp is for window [L,R]
                # check the state (0,0,0,0,0,0,0, 255) in dp and if dp[state]>=K, then update ans = min(ans, speed_val - edges_sorted[L][2])
                if (0,0,0,0,0,0,0, 255) in dp and dp[(0,0,0,0,0,0,0,255)]>=K:
                    ans = min(ans, edges_sorted[R][2] - edges_sorted[L][2])

            # End of R for fixed L

        If ans==10**18, then impossible and output -1.

 72. But note: the state (0,0,0,0,0,0,0,255) is for net flow 0 for nodes1..7 and mask=255.

 73. However, the net flow for node8 is not stored, but it is - (sum of node1..7) = -0 =0.

 74. This might work for the provided samples.

 75. We choose BOUND=20 (or 15) and hope that the net flow in intermediate states for valid solutions is within [-15,15]. 

 76. Sample Input #1 has 9 edges. In the valid solution, the net flow in intermediate states might not exceed the number of edges incident to a node in the chosen set, which is at most 9. So BOUND=20 is safe.

 77. Sample Input #3 has 8 edges, so net flow in intermediate state at most 8.

 78. Sample Input #6: we use 8 edges, so net flow at most 8.

 79. But what about a node that has many outgoing edges and many incoming edges in the window? For example, if in the window there are 100 edges incident to node1, then in the intermediate state the net flow for node1 might be 20, but then we prune. This is a heuristic.

 80. If the bound is not enough, we might not find a valid solution. But the problem says M<=1000, and we are using a bound of 20. For a node to have net flow 20, it must appear as a source 20 times more than as a sink in the chosen set. In the final state, it must be 0. So the remaining edges must have at least 20 sinks for this node. This is unlikely if the bound is not set to the window size. 

 81. Given the sample inputs are small in the number of edges in the chosen set (at least 8, at most M<=1000), and the net flow for a node in the chosen set is at most the number of times it is used as a source in the chosen set, and the chosen set has at most 1000 edges, but in the samples it is around 8, we hope that 20 is enough.

 82. If a sample fails, we might increase the bound, but then the state space might be (41)^7 * 256 = about 1e11 * 256 = 2.5e13, which is too many.

 83. We will use a bound of 10 initially, and if we find the samples work, then we use bound= ( and then for the worst-case, if the number of edges in the chosen set is large, we might need a large bound). 

 84. Alternatively, we can set the bound dynamically: for a fixed window, the bound for node i could be set to min(20, count_out[i], count_in[i])? or something. 

 Given the complexity, we output the code with BOUND=20.

 Let's hope.

 85. Also note: the state space might be pruned by not exploring the same state with a lower edge count? Actually, we are storing the maximum edge count for a state, so if we see the state again with a lower edge count, we may skip if we had a higher count before.

 But we are iterating and the state might be reached by two different paths, and we only keep the maximum edge count.

 86. For the two pointers: 
        for L in range(M): 
            for R in range(L, M): 
        This is O(M^2) and M=1000, then 1e6 * (state space size) * (work per state) -> and the work per state in the inner loop is the number of states in the dp times (1) for the new edge? 

        But in the inner loop, for each R we are iterating over the current states in dp (from the previous R) and also the new states from the new edge. The total work for fixed L is the sum over R of (number of states in dp at step R). 

        The number of states might be up to (41)^7 * 256 = 41^7 = 1.9e11, which is too many.

 87. Therefore, the state space must be pruned by the bound and by the fact that many states are not reached. In practice, if the bound is 20, then the state space is 41^7 * 256 = 1.9e11, which is too many for a single window, and we have 1e6 windows.

 88. We must not iterate over R in the inner loop for fixed L by this BFS method. 

 Given the complexity, we output a solution that might work only for small net flow and small windows. 

 89. Alternatively, we can use a different approach for the two pointers: 

        Sort by speed.
        Let R = 0
        For L in range(M):
            if R < L: R = L
            while R < M and ( (0,0,0,0,0,0,0,255) not in dp or dp[..]<K ):
                add edge at R
                R += 1
            if the condition meets, update ans = min(ans, edges_sorted[R-1][2]-edges_sorted[L][2])
            remove edge at L from the dp.

        How to add and remove? 
            We maintain a dp for the current window [L, R-1].
            When we add an edge at R, we update dp as described.
            When we remove an edge at L, we must do the opposite: 
                for state in dp that can be formed with the edge at L, we subtract the edge and remove the state that became invalid.

        But this is complex because the states might have many ways to be formed.

 90. Given the time, we output the O(M^2 * state_space) solution with a bound of 20 and hope that the state_space is small in practice.

 91. We try on the sample inputs.

 Sample Input #1: 
        12 9, and the valid range is 7.

 Sample Input #2: 
        4 1, and output -1.

 Sample Input #3: 
        8 8, output 14.

 Sample Input #4: 
        7 7, output -1.

 Sample Input #5: 
        23 8, output -1.

 Sample Input #6: 
        25 8, output 17.

 92. We will run the code on the samples. 

 Let's hope.

 Due to the complexity, we might not be able to run on the worst-case, but the samples are small.

 We set a BOUND = 20.

 Let's code accordingly.

 93. We also note: the sample Input #2 is -1 because there is no way to cover all 8 nodes: node2 is not used as a source.

        In our mask, we require to have bit1 for node2? But the edge that has node2 as a source must be included. In the sample, there is no edge that has node2 as a source. Therefore, the mask will never have bit1 set.

        So we output -1.

 94. Similarly, Sample Input #4: the of the as a whole cannot cover node8? Let's see the edges:

        7 edges: 
          1->2, 2->3, 3->4, 4->1: covers nodes1..4.
          5->6, 6->7, 7->5: covers nodes5..7.
          node8 is never a source.

        So the mask will not have bit7 (node8) set, so the state (0,0,0,0,0,0,0,255) will not be achieved.

 95. Therefore, we output -1.

 96. We will code accordingly.

 Let's write the code.

 97. We must be cautious: the state is a tuple (f0, f1, f2, f3, f4, f5, f6, mask), and the net flow for node1 to node7 is stored in f0..f6. The mask is an integer between 0 and 255.

 98. The initialization state is (0,0,0,0,0,0,0,0) with 0 edges.

 99. For an edge (a,b,speed):
        a and b are given in the input.

        For the net flow vector: we have a list for nodes 1 to 7 (index0 for node1, index1 for node2, ... index6 for node7).
        If a is in [1,7]: then we add 1 to the component at index = a-1.
        If b is in [1,7]: then we subtract 1 from the component at index = b-1.

        For the mask: we set the bit at position a-1 (which is for node a). Note: if a=8, then we set bit7.

 100. Finally, the state we are interested in is (0,0,0,0,0,0,0, 255) (which means all nodes have been used as a source at least once and net flow is 0 for nodes1..7 and hence also for node8).

 101. We then do the two pointers as described: 
        sort the edges by speed.
        ans = a big number
        for L in range(M):
            # for this L, we reset the dp for the window starting at L
            dp = {}
            start = (0,0,0,0,0,0,0,0)
            dp[start] = 0   # number of edges used is 0
            for R in range(L, M):
                edge = edges_sorted[R]   # (a, b, speed)
                new_dp = dp.copy()   # skip the edge: so states from dp are in new_dp
                # For each state in the current dp (which is for edges up to R-1), try to add edge R
                for state, count_edges in list(dp.items()):
                    # state is a tuple (f0,..,f6, mask)
                    f0, f1, f2, f3, f4, f5, f6, mask = state
                    f_list = [f0, f1, f2, f3, f4, f5, f6]
                    a, b, speed_val = edge
                    # make a copy
                    new_f = f_list[:] 
                    if a>=1 and a<=7:
                        new_f[a-1] = new_f[a-1] + 1
                    if b>=1 and b<=7:
                        new_f[b-1] = new_f[b-1] - 1

                    # Check if any net flow exceeds BOUND in absolute value
                    if any(abs(x) > BOUND for x in new_f):
                        continue

                    new_mask = mask | (1 << (a-1))

                    new_state = (new_f[0], new_f[1], new_f[2], new_f[3], new_f[4], new_f[5], new_f[6], new_mask)
                    new_count = count_edges + 1

                    # Update new_dp: we want the maximum new_count for the state.
                    if new_state in new_dp:
                        if new_count > new_dp[new_state]:
                            new_dp[new_state] = new_count
                    else:
                        new_dp[new_state] = new_count

                dp = new_dp

                # Check if we have the final state and the count>=K
                final_state = (0,0,0,0,0,0,0, 255)
                if final_state in dp and dp[final_state]>=K:
                    range_val = edges_sorted[R][2] - edges_sorted[L][2]
                    if range_val < ans:
                        ans = range_val
                    # We can break early for this L? 
                    break

            # End for R
        # End for L

        if ans is still the big number, then print -1, else print ans.

 102. However, this might be too slow for M=1000, because for each L, we do R from L to M, and for each R, we iterate over the states in dp, and the number of states might be up to 41^7 * 256 = 1.9e11, which is too many.

 103. We must hope that the BOUND prune and the reality of the net flow being not too big will keep the state space small.

 104. We will run on the provided samples.

 105. Sample Input #1 has 12 edges. For L in [0,1,...,11] and for each L, R from L to 11. The worst-case L=0, R goes from 0 to 11, and the state space might be not too big.

 106. We run on Sample #1: 
        edges_sorted by speed: 
            (6,3,1) -> (7,3,3) -> (8,5,5) and (5,1,5) -> (4,8,6) and (6,2,6) -> (4,4,7) and (1,6,7) and (3,4,7) and (3,4,7) -> (2,7,10) -> (5,5,100)

        But our algorithm will sort by speed: 
            [1, 3, 5, 5, 6, 6, 7, 7, 7, 10, 100] (and the last 3,4,7 is duplicate? But the input has two (3,4,7))

        The valid window might be from the edge with speed 3 to the edge with speed 10.

        When L=0 (speed=1), then we iterate R from 0 to ... 
        When R=0: only edge (6,3,1) -> state: 
             net flow: 
                 a=6: -> index5: +1
                 b=3: -> index2: -1
                 state: (0,0,-1,0,0,1,0, mask = 1<<(6-1) = bit5: 1<<5 = 32.
            state = (0,0,-1,0,0,1,0, 32)

        Then R=1: edge (7,3,3): 
            a=7: index6: +1 -> new_f[6]=0+1=1
            b=3: index2: -1 -> new_f[2]= -1-1 = -2
            mask = 32 | (1<<(7-1)) = 32 | 64 = 96.
            state = (0,0,-2,0,0,1,1, 96)

        Then R=2: edge (8,5,5): 
            a=8: not in 1..7, so nothing for net flow for 1..7.
            b=5: index4: -1.
            new_f = (0,0,-2,0,-1,1,1)
            mask = 96 | (1<<7) [because a=8 -> 8-1=7, so bit7] = 96 | 128 = 224.
            state = (0,0,-2,0,-1,1,1, 224)

        Then R=3: edge (5,1,5): 
            a=5: index4: +1 -> becomes -1+1=0.
            b=1: index0: -1 -> becomes 0-1=-1.
            state = (-1,0,-2,0,0,1,1, 224 | (1<<4)) = 224 | 16 = 240.

        Continue... 

        The state space might grow.

 107. Given the time, we output the code and hope for the best.

 108. We will use BOUND=20.

 109. If we do not find a solution, then we output -1.

 Let's code accordingly.

 Note: We might also prune states by: if the number of edges in the state + (M - R) < K, then skip? But we are storing the count of edges, and we are at the step R, so we know the state has count_edges. Then the maximum future edges is (R-L+1) - (number of edges already processed in the current window for this state) -- but we are not storing which edges are taken.

 110. We do not prune by this because we don't know.

 Let's hope the samples will run in time.

 111. For the sample inputs, we hope the state space is not more than a few thousand.

 We will also use a for the state space: a dictionary for each L iteration, and for each R, we iterate over the states in the dp from the previous R.

 Given the sample Input #1 has 12 edges, and for L=0, R goes from 0 to 11, and the state space might be not more than a few thousand, it will be fast.

 We run on Sample #1.

 112. Let's do a small bound=2 for Sample #1 and see if it catches the answer? But the net flow might be -2 at R=1, so bound=2 might be not enough. We use bound=20.

 Implementation:

  Let M, K = map(int, input().split())
  edges = []
  for i in range(M):
      a, b, s = map(int, input().split())
      edges.append((a,b,s))

  BOUND = 20   # for net flow for each node

  # sort by speed
  edges_sorted = sorted(edges, key=lambda x: x[2])

  ans = 10**18

  # We'll do two nested loops: L from 0 to M-1, and R from L to M-1
  for L in range(M):
      # dp: dictionary: state -> max_count_edges
      dp = {}
      # initial state: (0,0,0,0,0,0,0,0) with 0 edges.
      init_state = (0,0,0,0,0,0,0,0)
      dp[init_state] = 0

      found = False
      for R in range(L, M):
          a, b, speed_val = edges_sorted[R]
          new_dp = dp.copy()   # not taking the edge: then states in dp are still in new_dp.
          # For each state in the current dp, try to take the edge
          for state, count_edges in list(dp.items()):
              # state is (f0, f1, f2, f3, f4, f5, f6, mask)
              # Unpack the state
              f0, f1, f2, f3, f4, f5, f6, mask = state
              f_list = [f0, f1, f2, f3, f4, f5, f6]
              new_f = f_list[:]   # copy

              # update the net flow for the edge (a,b)
              if a >= 1 and a <= 7:
                  new_f[a-1] += 1
              if b >= 1 and b <= 7:
                  new_f[b-1] -= 1

              if any(abs(x) > BOUND for x in new_f):
                  continue

              new_mask = mask | (1 << (a-1))

              # Create the new state
              new_state = (*new_f, new_mask)   # tuple

              new_count = count_edges + 1

              # Update new_dp: if the state exists, we take the max count, else we set.
              if new_state in new_dp:
                  if new_count > new_dp[new_state]:
                      new_dp[new_state] = new_count
              else:
                  new_dp[new_state] = new_count

          dp = new_dp   # move to the next edge

          # Check for the final state: (0,0,0,0,0,0,0,255) and count>=K
          final_state = (0,0,0,0,0,0,0, 255)
          if final_state in dp:
              if dp[final_state] >= K:
                  range_val = edges_sorted[R][2] - edges_sorted[L][2]
                  if range_val < ans:
                      ans = range_val
                  # We break for this L, because extending R further will only make the range larger.
                  break

      # End R for fixed L
  if ans == 10**18:
      print(-1)
  else:
      print(ans)

 113. Test on Sample Input #2: 
        M=4, K=1
        edges = [ (1,3,5), (4,1,1), (1,8,4), (1,3,5) ]

        We are to output -1.

        Why? because there is no edge that has node2, node5, node6, node7 as a source? 
          - node2: no edge has source=2.
          - node5: no
          - node6: no
          - node7: no

        So the mask in the final state will never have bits for node2 (bit1), node5 (bit4), node6 (bit5), node7 (bit6). So the mask will be at most: 
            edge0: a=1 -> bit0
            edge1: a=4 -> bit3
            edge2: a=1 -> bit0
            edge3: a=1 -> bit0
            so the mask will be bit0 and bit3, which is 1<<0 | 1<<3 = 1 | 8 = 9.

        The final state (0,0,0,0,0,0,0,255) is not reached.

        So we break the R loop for every L, and then output -1.

 114. Sample Input #3: 
        edges = 8, and the valid is the entire set of edges? 
        But the entire set of edges: two cycles: 
            cycle1: 1->2, 2->3, 3->4, 4->1: net flow 0, and the mask: 
                a=1,2,3,4: set bits0,1,2,3.
            cycle2: 5->6,6->7,7->8,8->5: 
                a=5,6,7,8: set bits4,5,6,7.
            mask = 11111111 = 255.

        So we should find the final state with 8 edges (>=8, which is K=8) and the range = 15-1 = 14.

        But note: the edge with speed 1 is the first, and speed 15 is the last.

        When L=0, R=7, we get the entire set.

        So the range = 15-1 = 14.

 115. Sample Input #4: 7 edges, and we cannot cover node8. So the final state is not reached.

 116. Sample Input #5: output -1, and Sample Input #6: output 17.

 117. We hope.

 Let's run the code on the samples.

 118. Sample Input #1: 
        12 9
        edges = [ ... ]
        We sorted by speed: 
            (6,3,1) -> (7,3,3) -> (5,1,5) -> (8,5,5) -> (4,8,6) -> (6,2,6) -> (4,4,7) -> (1,6,7) -> (3,4,7) -> (3,4,7) -> (2,7,10) -> (5,5,100)

        But note: the two (3,4,7) are distinct.

        The valid solution uses 9 edges, and they are in the speed range [3,10]? 
            The edge with speed 1 is not in the window, and 100 is not.
            The window should start at the edge (7,3,3) (which is speed=3) and go to (2,7,10) (speed=10).

        So L should be the index of (7,3,3): which is 1, and R should be the index of (2,7,10): which is 10.

        Then the range = 10-3 = 7.

        In our two pointers, for L=1, and R=10, we will break and update ans=7.

        But will the BOUND=20 work for this window? The chosen set has 9 edges.

        We hope.

 119. We might not need to simulate Sample Input #1 by hand.

 Given the time, we output the code.

 Note: This might not run in time for M=1000 in the worst-case, but we hope the net flow is bounded in practice.

 If not, we might try a smaller bound if the window size is small, and a larger bound if the window size is large? But then the state space might be too big.

 We submit and hope the sample tests are passed.