 Okay, we are given multiple test cases. For each test case:
   - Read R and C, then R lines of grid.

 Steps:
 1. Extract the minimal bounding box of the polyomino (since there might be empty rows/cols).
 2. Represent the polyomino as a set of coordinates (i, j) within the minimal bounding box (relative to top-left of the box).
 3. Identify the border cells: a cell is on the border if it has at least one neighbor (in 8 directions) that is either out of the bounding box or not a cell of the polyomino.

 4. We consider 4 rotations: 0°, 90°, 180°, 270°.
    For each rotation, we create a new set of points (and border points) for the rotated polyomino. We then normalize the rotated set to have minimal bounding box starting at (0,0) again.

 5. For each rotation, we consider all possible translations that result in overlap. However, note that the problem states that the placement must have integral offsets and must have some overlap.

    How to compute the overlap?
      Let A = original polyomino (set of points) and B = rotated polyomino (set of points). We consider a translation vector (dx, dy) such that for a point (x,y) in A, the corresponding point in the rotated copy would be (x+dx, y+dy) in the grid? Actually, we need to align the two sets.

    Alternatively, we can think: 
        For a point a in A and a point b in B, the translation that maps b to a is (a.x - b.x, a.y - b.y). Then the overlap condition is that the set A and (B shifted by (dx,dy)) have at least one common cell.

    However, iterating over all possible translations by going through every pair of points in A and B is O(n^2) per rotation (and n = number of cells). Since the total sum of R^3+C^3 is <= 10^7, and note that the area of the polyomino is at most R*C, and R*C might be up to (say) 10^3? Then (R*C)^2 = 10^6 per test case? But note: the problem says the sum of R^3 + C^3 is <= 10^7. 

    However, note that R and C are the dimensions of the grid, but the minimal bounding box might be H x W (which is the actual size of the polyomino). The area n = H*W. The worst-case H and W can be up to about 100? Because if R and C are 100, then H*W<=10000. Then n^2 = 100e6 which is too high.

    But wait: the problem states that the sum of R^3 + C^3 in a file is no more than 10^7. How does that relate to the number of test cases?

    Let T be the number of test cases. Then for each test case, we have R, C, and the grid. The constraint is that the sum of (R^3 + C^3) for all test cases is <= 10^7.

    How many points? The minimal bounding box has size H x W, and H<=R, W<=C. The area of the polyomino is at most R*C. However, in the worst-case, the polyomino might be the entire grid, so n = R*C. Then the double loop over the original and rotated set would be O(n^2) = O((R*C)^2). But note that (R*C)^2 = R^2 * C^2, and the constraint is on the sum of R^3 + C^3. 

    However, observe: 
        (R*C)^2 = R^2 * C^2 = (R^3 * C^2) / R = ... not directly comparable.

    We must avoid O(n^2) per test case if n is large. But note the constraint: the sum of R^3 + C^3 <= 10^7. This implies that R and C for each test case are not too large. In fact, the maximum R or C in a test case might be around 100 (since 100^3 = 1e6, and if we have 10 test cases each with R=100, then 10 * (100^3) = 10^7). But note: the constraint is on the sum of R^3 + C^3 for the entire file, so we can have multiple test cases.

    However, worst-case: one test case with R=215 (because 215^3 ~ 10^7) and C=1? Then the area n = R*C = 215, and then n^2 = about 46000, which is acceptable. But if we have many test cases? Actually, T<=100000, but the sum of R^3 + C^3 <= 10^7, so the number of test cases with large R or C is limited.

    But note: the minimal bounding box might be small even if R and C are large? However, the minimal bounding box is at most R x C. But the constraint is on the original R and C (the grid dimensions). We are trimming to H x W (which are <= R, <= C). 

    How to avoid O(n^2) for each rotation? Actually, we have 4 rotations and each rotation we do a double loop over the two sets (which are of size n). So total per test case: 4 * n^2.

    The worst-case n: the area of the polyomino. But note: the entire grid might be filled? Then n = R*C. Then (R*C)^2 = (R^2 * C^2). 

    But the constraint is the sum of R^3 + C^3 over test cases <= 10^7.

    How to relate? We know that R and C per test case: let r = R, c = C. Then the area n = r*c. Then we do 4 * (r*c)^2 per test case.

    The total over the file: 
        sum_{test cases} 4*(r*c)^2.

    We know that for each test case: r^3 + c^3 <= (max(r,c))^3 * 2? 
    But note: (r*c)^2 = r^2 * c^2. We have to bound by r^3+c^3.

    However, consider: if r and c are both about k, then (r*c)^2 = k^4, and r^3+c^3 ~ 2*k^3. Then k^4 might be much larger than k^3? So worst-case one test case: r=100, c=100, then r^3+c^3 = 1000000+1000000 = 2000000, and (r*c)^2 = 100000000, which is 100 million. Then 4 * 100 million = 400 million operations which is too heavy in Python.

    Therefore, we must optimize.

    Alternate approach for counting for a fixed rotation:
        We want to count for a translation vector (dx,dy) the following:
          numerator = count of cells a in border0 such that a is in the original and the rotated copy shifted by (dx,dy) contains a? Actually, we need to check that a is in the shifted rotated copy? But note: the rotated copy is represented by a set of points relative to its own minimal bounding box. How do we relate?

        Actually, we can precompute:
          Let A = set of original points (in minimal bounding box, relative coordinates).
          Let B = set of rotated points (in minimal bounding box, relative coordinates).

        Then for a translation (dx,dy), the condition for a point a=(x,y) in A to be covered by the rotated copy is: there exists a point b in B such that a = (b.x + dx, b.y + dy) ??? 

        Actually, the translation vector (dx,dy) is defined as: to place the rotated copy so that its top-left of minimal bounding box is at (dx,dy) in the original grid? But we normalized both to (0,0). 

        Alternatively, we can consider the entire grid? But we normalized both to (0,0). Then the translation vector (dx,dy) must be such that the entire set (B shifted by (dx,dy)) overlaps with A.

        How to iterate over translations? The translations that cause overlap are exactly those such that (dx,dy) = (a.x - b.x, a.y - b.y) for some a in A and b in B.

        Then we can iterate over every a in A and every b in B, and consider the translation (dx,dy) = (a.x - b.x, a.y - b.y). Then for that translation, we can count:
          count1 = number of border0 cells a' in A such that a' = (b' in B) shifted by (dx,dy) i.e., a' = (b'.x+dx, b'.y+dy) is in A? Actually, we require that the entire shifted B set is within the grid? But we are only counting the overlapping part.

        Actually, we don't require the entire shifted B set to be in the grid, but we are only counting the border cells of A that lie in the rotated copy (i.e., in the shifted B set) and the border cells of the rotated copy (the shifted border_rot set) that lie in A.

        Specifically:
          numerator = | { a in border0 such that a is in (B shifted by (dx,dy)) } |
          denominator = | { b in border_rot such that (b shifted by (dx,dy)) is in A } |

        But note: the same translation (dx,dy) must be applied to the entire rotated copy.

        However, note: the expression in the problem:
          numerator: number of cells on A’s border and inside A1 (which is the rotated copy placed at (dx,dy))
          = { a in border0 and a in (B shifted by (dx,dy)) } 

          denominator: number of cells on A1’s border and inside A
          = { b in border_rot such that when we shift b by (dx,dy) we get a point in A }

        But note: the set of points of the rotated copy at (dx,dy) is { (x+dx, y+dy) for (x,y) in B }.

        Then the condition for a in A to be in the rotated copy: a must be in the set { (x+dx, y+dy) for (x,y) in B } -> which is the same as (a.x-dx, a.y-dy) in B? Actually, we have: 
          a = (x+dx, y+dy)  => x = a.x - dx, y = a.y - dy, so we require (a.x-dx, a.y-dy) in B.

        Similarly, for a border cell b in border_rot, the corresponding point in the grid is (b.x+dx, b.y+dy). Then we require that this point is in A.

        Therefore:
          numerator = | { a in border0: (a.x-dx, a.y-dy) in B } |
          denominator = | { b in border_rot: (b.x+dx, b.y+dy) in A } |

        But note: the entire set of overlapping cells is not needed, only the border cells.

        However, we have to be cautious: the same translation (dx,dy) must be considered only for pairs (a,b) that yield that translation. We can iterate over all pairs (a in A, b in B) and then for the translation (dx,dy) = (a.x - b.x, a.y - b.y). Then we can aggregate counts per translation.

        But the same translation (dx,dy) will come from multiple pairs. We want to compute for each translation the two counts.

        Steps for one rotation:
          Create a dictionary: 
            key = (dx,dy) = (a.x - b.x, a.y - b.y) for a in A, b in B.
          Then for each key, we want to know:
            num = count of a in border0 such that (a.x-dx, a.y-dy) in B   -> but note: this is the same as: for a in border0, check if (a.x-dx, a.y-dy) is in B? But we don't want to iterate over all a for each key.

        Alternatively, we can precompute for all translations that appear? 

        How about: 
          For each a in border0: 
            Then for each b in B, we get a translation (dx,dy) = (a.x - b.x, a.y - b.y). Then we can add 1 to the numerator for that translation.
          Similarly, for each b in border_rot:
            For each a in A, we get translation (dx,dy) = (a.x - b.x, a.y - b.y) [same as above] and then for the denominator, we add 1 for that translation.

        But that is again O(n^2) and we are doing two double loops per rotation.

        However, we can do:
          Let D = defaultdict(int) for numerator and denominator per translation.

          Step 1: Build a set of translations? Actually, we are going to iterate over all pairs (a,b) for a in A and b in B. Then we can do:

            trans_numer = defaultdict(int)
            trans_denom = defaultdict(int)

            For each a in A and b in B:
                dx = a[0] - b[0]
                dy = a[1] - b[1]
                trans_denom[(dx,dy)] = 0   # initialize? Actually we can do without initializing, but we are going to iterate border_rot separately.

          Actually, we can do:

            For each a in border0:
                for each b in B:
                    dxdy = (a[0]-b[0], a[1]-b[1])
                    trans_numer[dxdy] += 1

            For each b in border_rot:
                for each a in A:
                    dxdy = (a[0]-b[0], a[1]-b[1])
                    trans_denom[dxdy] += 1

          Then for each translation (dx,dy) that we have (which is the same set as from the pairs (a,b) in A and B, but note: the denominator loop uses A and border_rot, so we might get translations that we did not see in the numerator? But note: the translation must be such that there is at least one overlapping cell (which we get from any a in A and b in B). So we can iterate over the keys that are in both? Actually, we are guaranteed that the translation from (a,b) for a in A and b in B is the same as the one we use for the denominator? Yes.

          However, the dictionary might have keys that do not appear in both? But note: the problem says "they have some overlap", so we only consider translations that have at least one overlapping cell (which is the same as the key from (a,b) for a in A and b in B). But the denominator count is defined for a translation that we get from (a,b) for a in A and b in B? Actually, the translation (dx,dy) we get from a pair (a,b) is the one that maps b to a. Then the same translation must be used for the entire set.

        But wait: the two double loops (over border0 x B and border_rot x A) are both O(n^2). And n = |A| = |B| (the area). The worst-case area can be up to 10000? Then 10000 * 10000 = 100e6 per double loop -> 200e6 per rotation -> 800e6 for 4 rotations. This is 800 million iterations, which might be borderline in C++ but in Python it is too slow.

    We need a more efficient method.

    Alternate approach for fixed rotation:
        We note that the translation (dx,dy) is the same for all pairs. We can use convolution via FFT? But that might be overkill and also the problem constraints are such that the minimal bounding box is small? But worst-case area 10000 is too big for FFT in Python? Also, we are constrained by the sum of R^3+C^3 being 10^7, which we already discussed: worst-case one test case with R=215, then area=215*C? Actually, the minimal bounding box: H and W, and H<=R, W<=C. The area n = H*W. In worst-case, if the entire grid is filled, then n = R*C. For R=215, if C=1, then n=215, which is small. But if R=100, C=100, then n=10000 -> then the double loop would be 10^8 per double loop (which is acceptable in C++ but in Python? 10^8 iterations in Python might be 1-2 seconds? But we have 4 rotations and two double loops per rotation: 8 * 10^8 = 800e6 iterations, which is too slow in Python.

    Therefore, we need to avoid the double loops.

    How about: 
        Instead of iterating over every pair, we can iterate over translations by grouping by dx and dy? 

        For the numerator: 
          We want for a fixed translation (dx,dy): 
            num = | { a in border0: (a.x-dx, a.y-dy) in B } | 
          = | border0 ∩ (B shifted by (dx,dy)) |   [but note: we are shifting B by (dx,dy) and then taking intersection with border0? Actually, we are shifting the set B by (dx,dy) to get a set of points, then we want the points that are in border0?]

        Similarly, denominator = | border_rot ∩ (A shifted by (-dx,-dy)) |? 

        Actually, note: 
          Condition for a in border0: we require (a.x-dx, a.y-dy) in B -> which is the same as a in (B shifted by (dx,dy)). 
          Condition for b in border_rot: we require (b.x+dx, b.y+dy) in A -> which is the same as b in (A shifted by (-dx,-dy))? 

          But wait: 
            We have: a = (x,y) in border0, and we require (x-dx, y-dy) in B -> that is the same as (x,y) in (B shifted by (dx,dy)).
          Similarly, for b: we require (b.x+dx, b.y+dy) in A -> which is the same as (b.x, b.y) in (A shifted by (-dx,-dy))? Not exactly: 
            Let A_shifted = { (x+dx, y+dy) for (x,y) in A }? Then we require (b.x+dx, b.y+dy) in A -> then we have (b.x, b.y) in { (x-dx, y-dy) for (x,y) in A } = A shifted by (-dx,-dy).

        Therefore:
          numerator = | border0 ∩ (B_shifted) |, where B_shifted = { (x+dx, y+dy) for (x,y) in B }.
          denominator = | border_rot ∩ (A_shifted_minus) |, where A_shifted_minus = { (x-dx, y-dy) for (x,y) in A }? 

        But note: we don't have the entire grid? We have the minimal bounding boxes. We are working in relative coordinates? Actually, the sets A and B are defined in their own coordinate systems? But the translation (dx,dy) is in the same global grid? Actually, we normalized both to (0,0) for top-left. Then the translation (dx,dy) can be negative? 

        How to compute the intersection without iterating over every a? We can store A and B as sets of points. Then for a given translation (dx,dy), we can compute:

          numerator = 0
          for a in border0:
              if (a[0]-dx, a[1]-dy) in B_set: # because then a = (b.x+dx, b.y+dy) for b in B -> so b = (a.x-dx, a.y-dy) must be in B.
                  numerator += 1

          denominator = 0
          for b in border_rot:
              if (b[0]+dx, b[1]+dy) in A_set: 
                  denominator += 1

        But then if we do this for each translation, and we have many translations? The number of translations is the number of distinct (a.x-b.x, a.y-b.y) for a in A, b in B. That is O(n^2) distinct translations. Then total work: O(n^2 * n) = O(n^3) per rotation -> 4 * n^3 per test case. Worst-case n=100 -> 4 * 100^3 = 400000, which is acceptable. But if n=200, then 4 * 200^3 = 32e6, and if we have several test cases with n=200? The constraint: the sum of R^3+C^3 is 10^7. But note: the n here is the area, which is R*C. And R and C are the original dimensions. For a test case, R and C are the grid dimensions, and we know that the minimal bounding box H and W are <= R and <= C. The area n = H*W <= R*C. And the constraint is on the sum of R^3+C^3 over test cases <= 10^7.

        How many test cases? The worst-case: one test case with R=215, C=1 -> then n=215, then 4 * (215)^3 = 4 * 9938375 = about 40 million -> acceptable in Python? Maybe borderline.

        But worst-case: one test case with R=46, C=46: then n=46*46=2116? Then 4 * (2116)^3 = 4 * 9.5e9 = 38e9 -> too high.

        Therefore, we must avoid iterating over all distinct translations and then doing an O(n) check per translation.

    Revised plan for fixed rotation:
        Step 1: Precompute all distinct translations? Actually, we can get the set of translations T = { (a.x - b.x, a.y - b.y) for a in A, b in B }.

        Step 2: For each translation t in T, we compute:
            num = 0
            for each a in border0:
                if (a[0]-t[0], a[1]-t[1]) in B_set: num += 1
            den = 0
            for each b in border_rot:
                if (b[0]+t[0], b[1]+t[1]) in A_set: den += 1   [Note: actually, we require (b.x + t[0], b.y + t[1]) in A_set? But wait: 
                    We have translation t = (dx,dy) = (a.x - b.x, a.y - b.y) for the pair (a,b). Then for a border cell a0 in border0, we check: (a0.x - dx, a0.y - dy) in B -> that's the numerator.
                    For a border cell b0 in border_rot, we check: (b0.x + dx, b0.y + dy) in A? 
                    But note: the translation we used to place the rotated copy is such that the point b in the rotated copy becomes (b.x+dx, b.y+dy). Then we require that point to be in A.

            However, observe: 
                We defined t = (dx,dy) = (a.x - b.x, a.y - b.y) for a pair (a,b). Then for a point b0 in the rotated copy, the corresponding grid point is (b0.x+dx, b0.y+dy). We require that to be in A.

            But note: the set of translations T we have is the set of all (a.x - b.x, a.y - b.y) for a in A and b in B. This set T is the same as the set of translations that cause at least one overlap.

        Step 3: Then we update the fraction.

        The problem: the size of T is the number of pairs (a,b) which is |A|*|B| = n^2. And then for each translation, we iterate over border0 (size up to n) and border_rot (size up to n). Then total work per rotation: O(n^2 * n + n^2 * n) = O(n^3). Then 4 rotations: O(4*n^3). 

        Worst-case: n=100 -> 4 * 100^3 = 400000 -> acceptable.
                 n=200 -> 4 * 200^3 = 32e6 -> acceptable in Pyton if there is only one such test case? But the constraint on the entire file: the sum of R^3 + C^3 <= 10^7.

        How to relate n (the area) to R and C? 
            n = H * W, and H<=R, W<=C. Then n <= R*C.

        And the constraint is the sum of (R^3 + C^3) over test cases <= 10^7.

        But note: we are doing 4 * n^3 = 4 * (R*C)^3 per test case? 

        How to bound the total over test cases? 
            total_work = 4 * sum_{test cases} (R*C)^3.

        We know: 
            (R*C)^3 = R^3 * C^3.

        But the constraint is on the sum of (R^3 + C^3) per test case? Actually, the constraint is: the sum of (R^3 + C^3) over test cases <= 10^7.

        How to relate? 
            For a test case, let r = R, c = C. Then we know that the minimal bounding box: H <= r, W <= c, so n = H*W <= r*c. Then (n)^3 <= (r*c)^3.

        However, we cannot bound (r*c)^3 by r^3 + c^3? 

        Example: r=c=100 -> r^3+c^3=2000000, and (r*c)^3 = 10^12.

        Therefore, we must rely on the minimal bounding box being small? But the minimal bounding box is the actual polyomino. The problem does not say the polyomino is the entire grid. In fact, the sample has a convex polyomino that is not the entire grid.

        But worst-case: the entire grid is the polyomino. Then the minimal bounding box is the entire grid: H=R, W=C, so n=R*C.

        Then the work per test case: 4 * (R*C)^3.

        And the constraint: the sum of (R^3 + C^3) over test cases <= 10^7.

        How many test cases? 
            The worst-case: one test case with R=46, C=46: then R^3+C^3 = 46^3+46^3 = 2*(46^3)=2*97336=194672, which is within 10^7. But then (R*C)^3 = (46*46)^3 = (2116)^3 = about 9.5e9 -> too big.

        Therefore, we must not do the triple nested loop per test case if the area is large.

    Alternate efficient approach for fixed rotation:

        We can iterate over the distinct translations without explicitly iterating over every pair? How to generate distinct translations? They are the differences: 
          dx in [min_i - max_j, max_i - min_j] for i in A_x, j in B_x? But the set of distinct differences might be large.

        Instead, we can iterate over the translations that appear? We can use a dictionary to count the numerator and denominator per translation without iterating over every pair for the entire sets? 

        How about:

          For the numerator: 
             We want: for a given translation (dx,dy), 
                 count = number of a in border0 such that (a.x-dx, a.y-dy) in B.

             This is equivalent to: 
                 count = sum_{a in border0}  [ (a.x-dx, a.y-dy) in B ]

          We can precompute a 2D array for B? But the minimal bounding box for the rotated set is (H_rot, W_rot). But the translations dx,dy: the range of dx is from min_i in A.x - max_j in B.x to max_i in A.x - min_j in B.x? And similarly for dy.

          Then we can use convolution? 

        Alternatively, we can use:

          Let F(dx,dy) = [ (a.x-dx, a.y-dy) in B for a in border0 ] -> we can precompute an array for B and then use shifting? 

          Specifically, we can create a set for B: B_set. Then for a fixed translation (dx,dy), we can iterate over a in border0 and check (a.x-dx, a.y-dy) in B_set. 

          But we want to do this for many (dx,dy). The distinct (dx,dy) are the differences: 
              D = { (a.x - b.x, a.y - b.y) for a in A, b in B }

          And |D| = O(|A|*|B|) = O(n^2). Then total work: O(n^3) as before.

        Therefore, we must hope that the area n is small. How small? 

          The constraint: the sum of R^3 + C^3 over test cases <= 10^7.

          The worst-case test case: 
            R = 46, C = 46 -> then R^3+C^3 = 46^3 * 2 = 194672, which is acceptable for one test case? But then the area n = R*C = 2116, and then the distinct translations |D| <= n^2 = 4.5e6. Then iterating over 4.5e6 translations, and for each we iterate over border0 (which is about n, 2116) -> 4.5e6 * 2116 = 9.5e9, which is too many.

        We need a different idea.

    After reevaluation, note that the problem states: the sum of R^3 + C^3 in a file is no more than 10^7. This means that the sum of the cubes of the grid dimensions is bounded. This does not directly bound the area of the polyomino, but note that the minimal bounding box H and W satisfy H<=R and W<=C. The area n = H*W. Then n <= R*C.

    But also note: the number of test cases T is not bounded by the grid size? The constraint T<=100000, but the sum of R^3+C^3<=10^7, so the number of test cases with large R and C is limited. In particular, the maximum R or C in any test case is about 215 (since 215^3 = 9938375, and 2*215^3 is about 20e6 which is >10^7, so the largest R or C might be around 100-200).

    But the product R*C for one test case: worst-case R=100, C=100 -> 10000. Then the number of distinct translations is about 10000 * 10000 = 100e6, which is too many to store in a set.

    Therefore, we must avoid generating all distinct translations explicitly.

    Insight: we only care about the best fraction. We do not need to iterate over every translation. We can iterate over every pair (a in border0, b in B) and every pair (b' in border_rot, a' in A) and then combine by translation?

        Specifically, we can do:

          Create a dictionary: 
             key = (dx,dy) = (a.x-b.x, a.y-b.y) for a in border0 and b in B.
          For each key, we want to count the number of pairs (a in border0, b in B) that yield that key -> that count is the numerator.

          Similarly, for the denominator: 
             key = (dx,dy) = (a'.x - b'.x, a'.y - b'.y) for a' in A and b' in border_rot.
          But note: this is the same as (b'.x+dx, b'.y+dy) = a'.x -> so the translation for the denominator is the same as for the numerator? 

          Actually, the translation we use for the rotated copy is the same: we shift the rotated copy by (dx,dy). Then:

            numerator = count of (a in border0, b in B) such that a = (b.x+dx, b.y+dy) -> which is the same as dx = a.x-b.x, dy=a.y-b.y.

            denominator = count of (b' in border_rot, a' in A) such that a' = (b'.x+dx, b'.y+dy) -> which is the same as dx = a'.x - b'.x, dy = a'.y - b'.y.

          Therefore, we can do:

            trans_numer = defaultdict(int)
            for a in border0:
                for b in B:
                    dx = a[0] - b[0]
                    dy = a[1] - b[1]
                    trans_numer[(dx,dy)] += 1

            trans_denom = defaultdict(int)
            for a in A:
                for b in border_rot:
                    dx = a[0] - b[0]
                    dy = a[1] - b[1]
                    trans_denom[(dx,dy)] += 1

          Then for each translation (dx,dy) that is in both dictionaries (or at least in trans_numer, since it must be from border0 and B), we have:
             num = trans_numer[(dx,dy)]
             den = trans_denom.get((dx,dy),0)

          And then we update the best fraction: best = max(best, Fraction(num, den))? But note: the fraction is num/den, and we want to maximize that.

        But note: the same translation might appear multiple times from different pairs? We are counting the number of border0 cells that are matched by the translation: but wait, for a fixed translation (dx,dy), the numerator should be the number of border0 cells a such that (a.x-dx, a.y-dy) is in B. This is exactly what we are counting: for a fixed (dx,dy), the number of a in border0 and b in B such that (a.x-b.x, a.y-b.y) = (dx,dy) is the number of a in border0 for which there exists at least one b in B such that a.x = b.x+dx and a.y = b.y+dy. But note: for a fixed a, there might be multiple b in B that yield the same translation? That should not happen because for a fixed a and (dx,dy), the b is uniquely determined: b = (a.x-dx, a.y-dy). And if that b is in B, then we count it. But if there are multiple b that are the same? The set B does not have duplicates. So for a fixed a, there is at most one b that yields the translation (dx,dy). Therefore, trans_numer[ (dx,dy) ] is exactly the number of a in border0 for which (a.x-dx, a.y-dy) is in B.

        Similarly, trans_denom[ (dx,dy) ] is exactly the number of b in border_rot for which (b.x+dx, b.y+dy) is in A.

        Therefore, this method gives the correct counts.

        The work per rotation: 
          trans_numer: |border0| * |B| 
          trans_denom: |A| * |border_rot|

        In the worst-case, the entire polyomino is border? Then |border0| = |A| = n, and |border_rot| = n. Then the work per rotation is O(n^2 + n^2) = O(n^2). Then for 4 rotations: 4 * O(n^2) = 4 * (R*C)^2.

        And the total over test cases: 4 * sum_{test cases} (R*C)^2.

        Now, the constraint: sum_{test cases} (R^3 + C^3) <= 10^7.

        How to bound the total work: 
            For a test case: 
                work_rotation = 4 * ( (R*C)^2 )   [since n<=R*C, and we are using n^2, and n<=R*C, so (R*C)^2 is an upper bound]

            total_work = 4 * sum_{test cases} (R_i * C_i)^2.

        We need to bound sum_{test cases} (R_i * C_i)^2.

        Note: by AM-GM: 
            (R_i * C_i)^2 = (R_i^2 * C_i^2) 
            and we know that R_i^3 + C_i^3 is bounded in sum by 10^7.

        But we have no direct bound. However, note that for each test case, we have R_i and C_i, and the minimal bounding box might be smaller, but we are using R_i and C_i as the grid dimensions.

        But worst-case: one test case with R=100, C=100 -> then (R*C)^2 = 1000000, and then 4 rotations: 4 * 1000000 = 4e6 -> acceptable.

        But if we have 10 test cases with R=46, C=46: then for one test case: (46*46)^2 = 2116^2 = 4.5e6, then 10 test cases: 45e6, and then 4 * 45e6 = 180e6 iterations -> acceptable in Python.

        And the sum of R^3+C^3 for 10 test cases: 10*(46^3+46^3)=10*194672=1.95e6, which is within 10^7.

        But what if we have a test case with R=215, C=1? 
            Then n = 215, work per rotation: 4 * (215*1)^2 = 4*46225 = 184900 per rotation? Then for 4 rotations: 4 * 184900 = 739600 per test case? And the sum of R^3+C^3 for this test case: 215^3+1^3 = 9938375+1 ~ 10^7? Then we can only have one such test case? And the work for that test case is 739600, which is acceptable.

        Therefore, we do:

          For each rotation (0,90,180,270):
            - Compute the rotated set of points (minimal bounding box) and the border set for the rotated polyomino.
            - Then:
                trans_numer = defaultdict(int)
                for a in border0:
                    for b in B_rot:   # B_rot is the set of points of the rotated polyomino (not just border, but the entire set)
                        dx = a[0] - b[0]
                        dy = a[1] - b[1]
                        trans_numer[(dx,dy)] += 1

                trans_denom = defaultdict(int)
                for a in A0:   # the entire set of the original polyomino
                    for b in border_rot:   # the border set of the rotated polyomino
                        dx = a[0] - b[0]
                        dy = a[1] - b[1]
                        trans_denom[(dx,dy)] += 1

                For each translation (dx,dy) in trans_numer:
                    if (dx,dy) in trans_denom:
                        num = trans_numer[(dx,dy)]
                        den = trans_denom[(dx,dy)]
                        # We avoid zero denominator? But the problem says the result is not 0 or infinity.
                        # Update the best fraction for this test case: we want the maximum fraction.
                        # But note: the same translation might be considered in multiple rotations, but we are iterating per rotation.
                        if num * best_den > den * best_num:   # to avoid floating point: compare num/den > best_num/best_den
                            best_num, best_den = num, den

          But note: we must consider the same translation across rotations? We are iterating per rotation, and we are updating a global best fraction for the test case.

        However, note: the fraction we are computing is for a specific placement (rotation and translation). We want the maximum fraction over all placements.

        Also, note: we must skip the identity rotation with (dx,dy)=(0,0) if the problem says "some overlap" and might not allow no shift? But the problem says "they have some overlap", and (0,0) might yield the entire polyomino overlapped? That is allowed. But also, the problem says "only rotation by multiples of 90° is allowed", and translation by integral offset is allowed. So (0,0) is allowed.

        But note: the problem says "place A upon an identical copy of itself A1 in such a way that they have some overlap". The identity translation (0,0) has overlap.

        However, the problem does not require the entire polyomino to be overlapped? Only some overlap.

        Therefore, we include (0,0).

        Also, note: the same translation in different rotations is considered separately.

        Finally, we output the best fraction as a reduced fraction.

 6. Special case: if the polyomino is empty? The problem says positive integers R C and then R lines, so there is at least one '#'? Or can there be no '#'? The problem says "positive integers R C", and "it is guaranteed that ...". The sample input has all '#' in the first test. But we must handle no '#'? The problem says "the first line is a positive integer T", then for each test: R C, then R lines. It is possible that there is no '#'? Then we print "0/1" as in the sample? But the problem says the result is neither 0 nor infinity. But the problem statement says "it can be shown that the result is neither 0 nor ∞". So there should be at least one '#'? But the problem says "positive integers R C", and the grid has R lines of C characters. It is guaranteed that the polyomino is non-empty? 

    However, the problem says: "It is guaranteed that T is no more than 100000, and the sum of R^3 + C^3 in a file is no more than 10^7."

    We'll assume there is at least one '#'? But the problem says: "if the polyomino is empty", we skip. We already have code to skip empty.

    Steps in code:

        for _ in range(T):
            read R, C
            grid = []
            for i in range(R): read a line.

            Find minimal bounding box: 
                r0: first row with '#' -> if not found, then skip and output "0/1"? But the problem says the result is not 0 nor infinity? So we must have at least one cell? But the problem says "positive integers R C", but the grid might be empty? 

            According to the problem statement: the result is neither 0 nor ∞. So we can assume at least one '#'? But the problem says "it is guaranteed", so we can assume the polyomino is non-empty.

        But to be safe, if we find no '#', then we output "0/1" (as in the sample) but the problem says the result is not 0? 

        However, the problem says: "it can be shown that the result is neither 0 nor ∞", so we assume at least one cell.

        But the input guarantee: the grid might be empty? Then we output "0/1" and move on.

 Implementation:

        We'll do:

          r0 = 0
          while r0 < R and '#' not in grid[r0]: r0+=1
          if r0 == R: # empty
             print("0/1")
             continue

        Similarly for columns.

        Then extract minimal bounding box: rows [r0, r1], cols [c0, c1].

        Then build:
          A0: set of (i, j) for i in [0, H-1], j in [0, W-1] in the minimal bounding box, where the grid0[i][j]=='#'
          border0: for each cell in A0, check if it is border (by 8 directions). We represent the cell by (i, j) relative to the minimal bounding box (so the top-left of the box is (0,0)).

        Then for each rotation (0,90,180,270):
          if rotation is 0: 
             A_rot = A0
             border_rot = border0
          else:
             define a rotation function f (which rotates a point (i,j) in the original minimal box of size H x W to a new point). Then we get a set of points. Then we might want to normalize again to a minimal bounding box? But note: the rotation function we define for 90, 180, 270 does not change the set of points, only the coordinates. However, after rotation, the minimal bounding box might change. We don't actually need the minimal bounding box for the rotated set? We only need the set of points and the border set.

             But we do not need to normalize to (0,0) because the translation (dx,dy) will account for the shift. However, note: the rotation function we use does not shift the minimal bounding box. For example, for 90: 
                 f(i,j) = (j, H-1-i)  [if we rotate the grid of size H x W clockwise by 90, then the new grid would have size W x H, and the top-left of the original (0,0) goes to (0, H-1) in the new grid? Then the minimal bounding box of the rotated set would be from min_i to max_i, min_j to max_j? 

             However, we are not normalizing. The set A_rot we build is in a coordinate system that might not start at (0,0). We want to consider the points as they are? 

             Actually, the translation (dx,dy) is defined as the shift between the two coordinate systems. But we normalized the original to (0,0). The rotated set might have negative coordinates? 

             Example: 
                 Original: (0,0), (0,1) in a 1x2 grid.
                 90 rotation: 
                     f(0,0) = (0, 0) -> (0, 0) in a 2x1 grid? 
                     f(0,1) = (1, 0) -> (1,0) in the new grid.

                 But if we define for 90: 
                     f(i,j) = (j, H-1-i) 
                 then for (0,0): (0, 0) -> (0, 0) -> then (0,0) becomes (0, 0)
                 (0,1): (0,1) -> (1, 0) -> so we get points (0,0) and (1,0). 

                 The minimal bounding box for the rotated set: rows 0 to 1, cols 0 to 0 -> so we could normalize by subtracting min_i and min_j? But note: the set we have is {(0,0), (1,0)}. 

             We do not need to normalize the rotated set because the translation (dx,dy) will adjust. The only requirement is that the two sets (original and rotated) are in the same coordinate system? Actually, they are not: the original set is in a coordinate system relative to its minimal bounding box, and the rotated set is in a coordinate system relative to the same origin? 

             But wait: we defined the original set with (0,0) at the top-left of the minimal bounding box. The rotated set we built by applying f to the original set. The rotated set might have negative coordinates? 

             How could it have negative? 
                 For 270: 
                    f(i,j) = (W-1-j, i) 
                 then if we have a point (0,0) in the original, it becomes (W-1, 0) -> which is nonnegative.

             Actually, we defined the rotation functions without shifting to a new minimal bounding box? The rotated set is defined using the original minimal bounding box and the same origin? 

             Then the rotated set might have coordinates in the range [0, max(H-1, W-1)]? 

             But note: the minimal bounding box of the rotated set might be from min_i to max_i, min_j to max_j. We could normalize by subtracting the min_i and min_j? 

             Why do we care? Because the translation (dx,dy) must be integral, and if we don't normalize, then the translation might be large? But the double loops we do (over border0 and B_rot) will still work: we are iterating over the points as they are.

             However, the translation (dx,dy) = (a.x - b.x, a.y - b.y) might be negative? And that's fine.

             But the grid sizes are small, and the coordinates are bounded by max(H, W) which is <= max(R, C) (which is bounded by about 215). So the dx and dy are in a range of about [-max_coord, max_coord]. 

             Therefore, we do not need to normalize the rotated set.

        Then we proceed as described.

 7. Finally, we reduce the fraction: 
        g = math.gcd(best_num, best_den)
        best_num //= g
        best_den //= g
        print(f"{best_num}/{best_den}")

 8. But what if there is no valid placement? The problem states that the result is neither 0 nor ∞, so there is at least one placement. And we consider all rotations and translations that yield at least one overlapping cell (which we get from the pairs (a in A0, b in B_rot) and we do the same for the denominator. So we will have at least one translation.

 9. However, we initialize best_num and best_den. How? 
        We can initialize best_num=0, best_den=1, then update when we find a fraction. But the problem says the result is not 0, so we will find at least one. But what if we find none? Then we output 0/1? But the problem says the result is not 0. So we assume we will find at least one.

        We can do: 
          best_num = 0
          best_den = 1
          for each rotation:
             ... if we find a translation, update.

          if best_num==0: then we output 0/1? But the problem guarantees at least one.

        We'll assume we always find at least one.

 10. Let's test with the sample: 
        First sample: 4x6 grid of all '#'

        Minimal bounding box: 4x6, and every cell is in the polyomino.

        How to compute border0? 
          For a cell (i,j): it is border if it has at least one neighbor (in 8 directions) that is not in the grid or not '#'. But the grid is the entire minimal bounding box? Then for a cell (i,j) in the interior: all 8 neighbors are in the grid and are '#' -> so not border. Only the boundary cells are border.

          Specifically: 
            The border0: all cells on the first row, last row, first column, last column.

          So |border0| = 4*6 - 2*2*? Actually: 
            top and bottom: 2*6 = 12
            left and right: 2*(4-2) = 4? -> total 16? But the corners are counted twice? Actually, we are counting by set, so no duplicates.

          Total border0 = 2*(4+6) - 4 = 16? 

          Alternatively: 
            top row: 6, bottom row: 6, left column (excluding the two corners already counted): 4-2=2, right column: 2 -> total 6+6+2+2 = 16.

        Then for rotation 0: 
          B_rot = A0 (the entire set)
          border_rot = border0 (the 16 cells)

          Then we do:
            trans_numer: 
                for a in border0 (16 cells) and for b in B_rot (24 cells): 16*24 = 384 iterations.
                For a given a and b: 
                    dx = a.x - b.x, dy = a.y - b.y.

                How many distinct translations? But note: the entire grid is filled, so for any a and b, we have a translation (dx,dy). Then we count for each translation the number of pairs.

                Specifically, for a fixed a, and b running over the entire grid, we get 24 translations? Then we have 16*24=384 entries.

            Similarly, trans_denom: 
                for a in A0 (24 cells) and b in border_rot (16 cells): 24*16=384 iterations.

          Then we iterate over the translations in trans_numer: 
            For translation (dx,dy) = (0,0): 
                numerator: count of a in border0 such that (a.x, a.y) in B_rot -> yes, because all a are in A0? So count = 16.
                denominator: count of b in border_rot such that (b.x, b.y) in A0 -> yes, count=16.

                fraction = 16/16 = 1.

            But the sample output is 2/1.

          How to get 2/1? 
            The problem says: maximum value of the fraction.

          Consider rotation by 0, but shift by (0,1): 
            Then the original polyomino and the copy shifted by (0,1) (down by one? or up?) 
            Let's define: 
                The original polyomino is at positions: (i,j) for i in [0,3], j in [0,5].
                The rotated copy (same rotation) is placed at (dx,dy) = (0,1): so the copy covers (i,j) for i in [0+0, 3+0], j in [0+1, 5+1] -> [0,3]x[1,6]. 
            Overlap: [0,3]x[1,5] -> 4x5 = 20 cells.

            Now, for the numerator: 
                number of cells on A’s border and inside A1: 
                    A's border: the 16 border cells of the original.
                    Which of these are inside A1? 
                        The original border cells: 
                          top row: (0,0) to (0,5): but in A1, the j starts at 1, so (0,0) to (0,0) are not in A1? 
                          Actually, the top row of the original: (0,0) to (0,5): in A1, the j must be at least 1, so only j from 1 to 5: 5 cells.
                          bottom row: (3,0) to (3,5): in A1, j from 1 to 5: 5 cells.
                          left column: (1,0) and (2,0): not in A1 -> 0.
                          right column: (1,5) and (2,5): in A1? j=5 is in [1,6] -> yes, but note: the rightmost in A1 is j=6, but our grid only goes to j=5? So (1,5) and (2,5) are in A1 -> 2.
                    Total = 5 (top) + 5 (bottom) + 2 (right) = 12? 

                But wait: the top row: (0,1) to (0,5): 5 cells; bottom row: (3,1) to (3,5): 5 cells; and the right column: we have the right column of the original is j=5, but note the original right column is (0,5), (1,5), (2,5), (3,5). The top and bottom already included (0,5) and (3,5). Then the left column: none. And the right column: we have (1,5) and (2,5) -> that's 2 more? Then total 5+5+2 = 12.

            For the denominator: 
                number of cells on A1’s border and inside A: 
                    A1 is the same polyomino but shifted by (0,1). Its border: 
                      The border of A1: 
                         top row: (0,1) to (0,6) -> but the grid only goes to j=5? Actually, we are considering the shifted set: the minimal bounding box of A1? But we are not. We are considering the entire grid? 

                    How do we represent the border of A1? 
                      The original border0 is the border of the polyomino in its own minimal bounding box. Then we shift the entire set by (0,1). The border_rot for the copy is the same as the original border0? Then we shift each border cell by (0,1). Then we get a set of points: 
                         top row: (0,1) to (0,6) -> but the minimal bounding box of A1 is [0,3]x[1,6]? Then the border of A1: 
                            top: (0,1) to (0,6) -> but in the original grid, j only goes to 5, so (0,6) is outside? So in the original grid, the border of A1 is:
                            top: (0,1) to (0,5) [because (0,6) is not in the grid?] -> but wait, the problem says the grid is the minimal bounding box? 

                    Actually, we are not representing A1 in its own minimal bounding box? We are using the same representation as the original? 

                    How did we build the border_rot for the copy? 
                         We built it for the unshifted rotated set (which is the same as the original set for rotation0) and then the shift is applied by the translation. So the border_rot we have is for the unshifted set. Then when we consider a translation (0,1), we check for a border cell b in border_rot: 
                            The corresponding point in the grid is (b.x+0, b.y+1). Then we require that this point is in A0? 
                         So for b in border_rot (the original border set of the unshifted copy): 
                            b = (0,0) -> becomes (0,1) -> in A0? yes.
                            b = (0,5) -> (0,6) -> not in A0? because A0 j in [0,5] -> no.
                         Similarly, the bottom row: 
                            b = (3,0) -> (3,1) -> in A0? yes.
                            b = (3,5) -> (3,6) -> no.

                    So we need to count: 
                         top row: (0,0) -> (0,1) -> valid? 
                         but the top row of the unshifted border_rot: 
                            (0,0) to (0,5) -> after shift: (0,1) to (0,6). Then we check in A0: only (0,1) to (0,5) are in A0? -> 5 points.
                         bottom row: (3,0) to (3,5) -> after shift: (3,1) to (3,6) -> only (3,1) to (3,5) are in A0? -> 5 points.
                         left column: (1,0) -> (1,1) -> in A0? yes; (2,0) -> (2,1) -> yes -> 2 points.
                         right column: (1,5) -> (1,6) -> not in A0; (2,5) -> (2,6) -> not in A0 -> 0.

                    Total denominator = 5+5+2 = 12.

                Then fraction = 12/12 = 1.

          How do we get 2/1? 
          Consider rotation by 180 degrees? 
            After 180: 
                A1 = { (3-i,5-j) for (i,j) in A0 }
            Then the border of A1: 
                The border of the original is the boundary. After 180, the boundary is still the boundary? So |border_rot| = 16.

            Now, consider the identity translation (0,0): 
                The original and A1: 
                  Original: (i,j) for i in [0,3], j in [0,5]
                  A1: (3-i,5-j) -> and we shift by (0,0) -> so the set is (3-i,5-j). 
                Overlap: the entire grid? 

                Numerator: 
                  a in border0: we need a to be in the set of A1? But A1 is the entire grid? So yes, but we also need to check: 
                     The condition: a is in A1? But A1 has the entire grid, so yes.
                  So numerator = 16.

                Denominator: 
                  b in border_rot: we need (b.x+0, b.y+0) to be in A0? But A0 is the entire grid, so yes. 
                  denominator = 16.

                Fraction=1.

            Now, consider a translation: 
                How about shifting A1 by (dx,dy) = (0,0)? we already did.

            How about shifting by (1,0)? 
                Then A1 is at: (3-i+1, 5-j) = (4-i, 5-j). 
                Overlap: only the rows 1 to 3? 
                But we need to compute the counts.

          Alternatively, the sample output is 2/1. How to get 2/1?

          The problem says: 
            "Find the maximum value of ..."

          After reading the problem again: 
            "Place A upon an identical copy of itself A1 in such a way that they have some overlap"

          And the fraction: 
            numerator: number of cells on A’s border and inside A1
            denominator: number of cells on A1’s border and inside A.

          Consider a translation by (0,0) but with rotation 0: 
            numerator = 16, denominator=16 -> 1.

          Consider a translation by (0,0) with rotation 180: 
            numerator: 16, denominator=16 -> 1.

          How about a translation that shifts the copy by half the grid? 
            For example, shift by (2,3) in the 4x6 grid? 
            Then the copy covers: [2,5]x[3,8]? But the original is only [0,3]x[0,5]. Overlap: [2,3]x[3,5] -> 2x3=6 cells.

          Now, the border cells of A that are in A1: 
            The border cells of A: 16 cells. Which are in the overlap? 
               top row: (0,0) to (0,5): none in [2,3]x[3,5] -> 0.
               bottom row: (3,0) to (3,5): the points (3,3), (3,4), (3,5) are in the overlap? -> 3.
               left column: (1,0) and (2,0): (2,0) is not in the overlap (j=0 not in [3,5]) -> 0.
               right column: (1,5) and (2,5): (2,5) is in the overlap? -> 1.

            total numerator = 3+1 = 4.

          For denominator: 
            The border cells of A1: the border of the copy? 
                The copy is the entire grid shifted by (2,3): so its minimal bounding box is the same as the original? Then its border is the boundary of the rectangle. But note: the copy is the entire grid, so its border is the boundary of the rectangle. The border set for the copy: the boundary of the rectangle [2,5]x[3,8]? 
                But we are representing the copy by its own minimal bounding box? Then the border_rot for the copy (if rotation0) is the boundary of the rectangle. Then we shift each border cell by (2,3) to get the absolute grid? But wait, we are not? 

            Actually, we built the border_rot for the unshifted rotated set (which is the same as the original set for rotation0). Then for a border cell b in border_rot, the point in the grid is (b.x+2, b.y+3). Then we require that point to be in A0? 

            The border_rot (unshifted) is the boundary of the original grid: 
                b = (0,0) -> (2,3) -> in A0? (which is [0,3]x[0,5]) -> (2,3) is in -> count 1.
                b = (0,1) -> (2,4) -> in -> 1.
                b = (0,2) -> (2,5) -> in -> 1.
                b = (0,3) -> (2,6) -> out -> 0.
                ... we see that only the top row with j=0,1,2 and the bottom row with j=3,4,5? 

            Actually, we need to check all 16 border cells? 

            But note: the minimal bounding box of the copy is [0,3]x[0,5] (unshifted). Then after shift by (2,3): 
                the top row: (2,3) to (2,8) -> but only j=3,4,5 are in the original grid? -> 3 points: (2,3), (2,4), (2,5) -> and they are in A0? yes.
                the bottom row: (5,3) to (5,8) -> (5,3) is below the original grid (which only has i up to 3) -> not in A0.
                left column: (3,3), (4,3) -> (3,3) is in the original? i=3 is the last row -> j=3 is in -> (3,3) -> yes; (4,3) -> i=4 is out -> no. So only one point: (3,3) -> but wait, the left column in the unshifted set: (1,0) and (2,0) -> shifted: (3,3) and (4,3) -> only (3,3) is in A0.
                right column: (1,5) -> (3,8) -> out; (2,5) -> (4,8) -> out.

            So total denominator = 3 (top) + 1 (left) = 4.

            Fraction = 4/4 = 1.

          How about a translation by (0,0) for rotation 0: we got 1, and for other shifts we got 1.

          The sample output is 2/1. 

      After rethinking: 
          The problem says the copy can be rotated. What if we rotate by 0 and then shift by (1,0)? 
             Then the copy covers: [0+1,3+1]x[0,5] = [1,4]x[0,5]. 
          Overlap with the original [0,3]x[0,5] is [1,3]x[0,5] -> 3x6=18 cells.

          Numerator: 
             border0: 16 cells.
             Which are in the copy? 
                 The copy is at [1,4]x[0,5]. 
                 The original border0: 
                    top row: (0,0) to (0,5): not in the copy (i=0 not in [1,4]) -> 0.
                    bottom row: (3,0) to (3,5): in the copy (i=3 is in [1,4]) -> 6 cells.
                    left column: (1,0) and (2,0): in the copy (i=1,2) -> 2 cells.
                    right column: (1,5) and (2,5): in the copy -> 2 cells.
                 total = 6+2+2 = 10.

          Denominator: 
             border_rot for the copy (rotation0) is the boundary of the copy's grid? 
                 The copy's grid is the same as the original, but shifted by (1,0). 
                 In its own minimal bounding box, the border is the boundary of the 4x6 grid? 
                 Then we shift the border cells by (1,0). Then we require the shifted cell to be in the original.

                 The border_rot (unshifted) for the copy: 
                    top row: (0,0) to (0,5) -> shifted: (1,0) to (1,5) -> in the original? yes -> 6 cells.
                    bottom row: (3,0) to (3,5) -> shifted: (4,0) to (4,5) -> not in the original (i=4 is out) -> 0.
                    left column: (1,0) and (2,0) -> shifted: (2,0) and (3,0) -> (3,0) is in the original? i=3 is in, j=0 is in -> yes for both? 
                         (2,0) and (3,0) are in the original? -> 2 cells.
                    right column: (1,5) and (2,5) -> shifted: (2,5) and (3,5) -> in the original? yes -> 2 cells.
                 total = 6+2+2 = 10.

          Fraction = 10/10 = 1.

      How to get 2? 

      After reading the sample output: 
          First sample: 2/1, second sample: 1/1.

      The first sample is a solid 4x6 rectangle.

      Known: for a rectangle, the best fraction is 2? 

      How about if we rotate the copy by 90 degrees? 
         Then the copy becomes 6x4. 
         Place it so that it overlaps the original? 

         Let the original be at (0,0) to (3,5). 
         The copy after 90 rotation: 
             We have a point (i,j) in the original -> becomes (j, 3-i) in the rotated set (if we use f(i,j)=(j, H-1-i) with H=4).

         Then the minimal bounding box of the rotated set is 6x4? So we have points: 
            for i in [0,5], j in [0,3]? 
         Then we can shift the rotated set by (dx,dy) = (0,0): 
            Then the rotated set covers: (0,0) to (5,3). 
         Overlap with the original [0,3]x[0,5] is [0,3]x[0,3] -> 4x4=16 cells.

         Now, border cells of the original that are in the rotated copy: 
             The border0 of the original: 
                top row: (0,0) to (0,5): in the rotated copy: only (0,0) to (0,3) are in the overlap? -> 4 cells.
                bottom row: (3,0) to (3,5): in the overlap: (3,0) to (3,3) -> 4 cells.
                left column: (1,0) and (2,0) -> in the overlap? (1,0) and (2,0) are in [0,3]x[0,3]? yes -> 2 cells.
                right column: (1,5) and (2,5) -> not in the overlap (j=5 not in [0,3]) -> 0.
                total = 4+4+2 = 10.

         For the denominator: 
             border_rot for the rotated set: 
                How did we compute border_rot for the 90 rotation? 
                   We took the original and applied the rotation. The border of the rotated set is the boundary of the 6x4 grid? 
                Then for a border cell b in border_rot, the point in the grid is (b.x+0, b.y+0) = (b.x, b.y). Then we require that point to be in the original set? 
                   The rotated set's minimal bounding box is 6x4, and the original set is 4x6. The overlap in the grid is [0,3]x[0,3] (the original grid only has i in [0,3] and j in [0,5], and the rotated set has points in [0,5]x[0,3]). 

                The border of the rotated set (6x4 grid) is:
                   top row: (0,0) to (0,3) -> 4 cells -> in the original: (0,0) to (0,3) are in? yes.
                   bottom row: (5,0) to (5,3) -> not in the original (i=5 is out) -> 0.
                   left column: (1,0) and (2,0) and (3,0) and (4,0) -> but wait, the minimal bounding box is 6x4, so the left column: i from 0 to 5, j=0 -> then we have 6 cells? But we only consider the ones in the boundary? 
                   Actually, we computed the border for the rotated set by checking 8 neighbors in its own minimal bounding box? 
                         The minimal bounding box for the rotated set is 6x4 and every cell is present? Then the border is the boundary: 
                            top: 6, bottom: 6, left: 4, right: 4 -> minus the corners counted twice -> 6+6+4+4 - 4 = 16? 

                But note: the rotated set is not the entire 6x4 grid? It is the entire grid? Yes, because the original was solid.

                So border_rot for the rotated set: 16 cells? 

                Then we need to check: 
                   for b in border_rot: 
                      the point (b.x, b.y) in the original set? 
                      The original set is [0,3]x[0,5]. 
                      The rotated set is [0,5]x[0,3]. 
                   So the border_rot set of the rotated set: 
                      top row: (0,0) to (5,0) -> in the original: only (0,0) to (3,0) -> 4 cells.
                      bottom row: (0,3) to (5,3) -> in the original: only (0,3) to (3,3) -> 4 cells.
                      left column: (0,0) and (0,1) and (0,2) and (0,3) -> already counted in top and bottom? 
                      right column: (5,0) and (5,1) and (5,2) and (5,3) -> not in the original.
                      also the non-corner parts of the left and right? 
                         Actually, we computed by 8 neighbors: so the border is the entire boundary. But we already counted the top and bottom, and the left and right? 

                   Alternatively, we did: 
                      For each cell in the rotated set: 
                         if it is on the boundary of the 6x4 grid, then it is border? 

                But the sample says for the first sample output is 2/1.

                Let's count the denominator: 
                   How many border cells of the rotated copy are in the original? 
                         top row: (0,0), (0,1), (0,2), (0,3) -> 4 cells.
                         bottom row: (5,0) to (5,3): 0.
                         left column: (1,0), (2,0), (3,0), (4,0) -> (1,0), (2,0), (3,0) are in the original? (4,0) is out -> 3 cells? 
                         right column: (1,3), (2,3), (3,3), (4,3) -> (1,3) to (3,3) are in, (4,3) out -> 3 cells.

                   But the corners: (0,0) and (0,3) are already in top row, (5,0) and (5,3) are out.

                   So total = 4 (top) + 3 (left) + 3 (right) = 10.

                Then fraction = 10/10 = 1.

      How to get 2/1? 

      After reading the sample output, the first sample is 2/1 and the second is 1/1.

      I see: in the first sample, the grid is 4x6, and if we rotate by 0 and shift by (0,0), we get 16/16=1, but if we shift by (0,0) for a 90-degree rotation, we got 10/10=1.

      The only possibility: 
         Consider the same 90-degree rotation, but shift by (0,1) for the rotated copy? 
            Then the rotated copy is at: 
               for a point (i,j) in the rotated set (which is in a 6x4 grid), we shift by (0,1) -> (i, j+1).
            Then the overlap: 
               The rotated copy covers [0,5]x[1,4] (since j+1: [0,5] for i, [0+1,3+1]=[1,4] for j).
               The original is [0,3]x[0,5]. 
               Overlap: [0,3]x[1,4] -> 4x4=16 cells.

            Numerator: border0 of the original in the overlap and in the rotated copy? 
               We require a in border0 and a in the shifted rotated set? 
               The shifted rotated set is { (i, j+1) for (i,j) in rotated_set } = { (j, 3-i+1) for (i,j) in the original }? -> no, we did not built it that way.

            How did we build the rotated set? 
               We have: for a cell (i,j) in the original minimal box, the rotated cell is (j, 3-i). 
               Then we shift by (0,1): becomes (j, 3-i+1).

            So the set is { (j, 3-i+1) for every (i,j) in the original }.

            Now, the condition for a cell a=(x,y) in the original grid to be in the shifted rotated set: 
               There exists (i,j) in the original such that:
                   x = j
                   y = 3-i+1  -> i = 3 - (y-1) = 4-y.

            So we require 0<=4-y<=3 and 0<=x<=5? -> and also (4-y, x) must be in the original? 
               But the original is a solid rectangle, so yes as long as 0<=4-y<=3 and 0<=x<=5.

            Now, the border0 of the original: 
               top: (0,0) to (0,5): 
                   (0,0): then i=4-0=4, which is >3 -> not in the original? -> not in the rotated set.
                   (0,1): i=4-1=3, j=0 -> (3,0) in the original? yes. But then the rotated set has the point (0,3) -> shifted to (0,4)? -> no, let me do it step by step.

            Let me build explicitly:
               The original cell (3,0) -> rotated: (0, 3-3=0) -> then shifted: (0,0+1)= (0,1) -> so (0,1) is in the shifted rotated set.

            So (0,1) is in the shifted rotated set.

            Similarly, (0,2) -> requires (3,0)? -> (0,1) for the rotated set? -> then shifted to (0,2)? -> wait, no:

            How the rotation and shift works for a point in the rotated copy that covers a point in the original? 
               We have a point a=(x,y) in the original grid. It is in the shifted rotated set if there exists a point in the rotated set (which is a set of points in the rotated's own coordinate system) such that when shifted by (0,1) yields (x,y). 
               That is: (x,y) = (b.x, b.y+1) for b in the rotated set? 

            But note: our representation: 
               The rotated set is in a coordinate system: for a cell b in the rotated set, the grid point is (b.x, b.y) in the global grid? 
               Then shifted by (0,1): becomes (b.x, b.y+1).

            So a=(x,y) is in the shifted rotated set if (x, y-1) is in the rotated set.

            And the rotated set is { (j, 3-i) for (i,j) in the original }.

            So (x,y) is in if there exists (i,j) in the original such that:
                x = j and y-1 = 3-i  -> i = 3 - (y-1) = 4-y.

            And (4-y, x) must be in the original -> and 0<=4-y<=3 and 0<=x<=5.

            So for (0,1): x=0, y=1 -> i=4-1=3, j=0 -> (3,0) in the original? yes.

            For the border0 cell (0,1): we have it is in the shifted rotated set.

            Similarly, (0,2): i=4-2=2, j=0 -> (2,0) in the original? yes.

            (0,3): (1,0) in the original? yes.
            (0,4): (0,0) in the original? yes.
            (0,5): i=4-5 = -1 -> invalid.

            (3,1): i=4-1=3, j=3 -> (3,3) in the original? yes.

            Now, the border0 cells in the original that are in the shifted rotated set: 
               top row: (0,0) -> not eligible (because for (0,0): y-1 = -1 -> not in the rotated set) 
                         (0,1) to (0,4) are in -> 4 cells.
               bottom row: (3,0) -> (3,0): requires (3,0) in the shifted rotated set: 
                         (3,0): then i=4-0=4, which is out -> not in.
                         (3,1): in -> (3,1) eligible.
                         ... (3,5): eligible? (3,5): i=4-5=-1 -> no.
                         only (3,1) to (3,4) are in? -> 4 cells.
               left column: (1,0) -> not in (because y-1=-1) 
                         (2,0) -> not in.
               right column: (1,5) -> not in (i=4-5=-1)
                         (2,5) -> not in.
               total = 4+4 = 8.

            Denominator: 
               border cells of the rotated copy (in its own coordinate system) such that when shifted by (0,1) are in the original.
               The border_rot for the rotated set (90-degree) is the boundary of the 6x4 grid? 
               Then shifted by (0,1): (b.x, b.y+1). 
               We require (b.x, b.y+1) to be in the original grid (0<=b.x<=5, 0<=b.y+1<=5? and also in the polyomino? but the original is the entire [0,3]x[0,5]. 
               So we require 0<=b.x<=3 and 0<=b.y+1<=5 -> b.y in [-1,4]? but b.y is in [0,3] (from the minimal bounding box) so always b.y+1 in [1,4] within [0,5] for j. Then the only constraint is b.x in [0,3].

               How many border cells of the rotated set have b.x in [0,3]? 
                 The rotated set's minimal bounding box is 6x4: 
                    border cells: 
                       top row: (0,0) to (5,0) -> only b.x in [0,3]: (0,0), (1,0), (2,0), (3,0) -> 4 cells.
                       bottom row: (0,3) to (5,3) -> 4 cells (b.x=0,1,2,3) 
                       left column: (0,1), (0,2) -> already in top/bottom? 
                       right column: (5,1), (5,2) -> b.x=5, not in [0,3] -> skip.
                    and the non-corner parts of the left and right within the sides: 
                       left column: actually, the left column is j=0: we already did.
                       right column: j=3: we already did.
                 Also, the in-between in the left and right? 
                    For the rotated set, we determined border by checking 8 neighbors in the minimal bounding box. Since the minimal bounding box is the entire 6x4 grid, then the border is the boundary: 6+6+4+4 - 4 = 16 cells.

               But we only count a border cell b in border_rot if when shifted it lands in the original grid (which we've done: only requires b.x in [0,3] because the j is always in [1,4] which is within [0,5]). 
               So we count all border cells of the rotated set that have b.x in [0,3]. 

               How many are there? 
                 top row: b.x in [0,3] -> 4 cells.
                 bottom row: 4 cells.
                 left column: for j=0, we have b.x from 0 to 5, but we already counted the top and bottom for j=0? 
                    specifically, (0,0) and (5,0) are in the top and bottom? 
                 For the left column (j=0) and not on the top/bottom: b.x in [1,4] -> then we have (1,0), (2,0), (3,0), (4,0) -> but b.x in [0,3] only: (1,0), (2,0), (3,0) -> 3 cells? 
                 Similarly, the right column (j=3) and not on the top/bottom: (1,3) to (4,3) -> only (1,3),(2,3),(3,3) -> 3 cells.

               total = 4 (top) + 4 (bottom) + 3 (left) + 3 (right) = 14? 

               But wait, the corners are counted in the top and bottom. The left and right of the sides do not include the corners.

               So total border cells in the rotated set with b.x in [0,3] is: 
                 top and bottom: 4+4 = 8.
                 left and right: 3+3 = 6.
                 total = 14.

               Then denominator = 14.

            Then fraction = 8/14 = 4/7.

          This is not 2.

      I see the sample output is 2/1, so there must be a translation that yields 2.

      How about for the 0-degree rotation and a shift by (0,0) we had 16/16=1.
      How about a shift by (0,0) for the 0-degree rotation: we had 16/16.
      How about a shift by (0,0) for the 180-degree rotation: 16/16.

      Only possibility: try 0-degree and a shift that only overlaps one cell? 
         then numerator = 1, denominator = 1.

      But we want 2/1.

      How about if we place the copy such that it overlaps only the border cells of the original that are not corners? 
         and the copy's border cells in the overlap might be half? 

      Known: for a rectangle, the convexity holds.

      After reading online: 
         It is known that for a rectangle, the optimal is 2/1.

      How to achieve it? 
         Rotate by 0 and shift by (0,0) is 1.
         How about shift by (0,0) for a 0-degree rotation: the entire thing overlaps.

         Maybe try a different rotation? 

      How about a 0-degree rotation and shift by (0,0) yields 1, but if we shift by (0,0) for the 0-degree rotation, that's the only placement? 

      I see: we might try to place the copy at a fractional shift? but the problem says integral shift.

      Another idea: 
         numerator: number of cells on A's border and inside A1.
         denominator: number of cells on A1's border and inside A.

         If we placed the copy such that the overlap is a sub-rectangle not including the entire border of the original, then the numerator might be the border of the original within the overlap, and the denominator might be the border of the copy within the overlap.

         For a rectangle, the border has two types: corners and edges. 
            The corner has 3 exposed edges (if in the overlap, it might be less) -> but in our definition, a cell is border if at least one of the 8 neighbors is not in the polyomino. In the overlap, we only consider the cell's property in its own polyomino, not in the overlap.

         So for a cell, its border property is precomputed in its own polyomino.

         Therefore, the only thing that matters is whether the cell is in the overlap.

         For a placement that overlaps only the top-left 2x2 of the 4x6 grid: 
            then for the original, the border cells in the overlap are the cells (0,0), (0,1), (1,0) (since (1,1) is not on the border of the original? 
               In the original, (1,1) is not a border cell? because it has 8 neighbors within the grid and they are all '#' -> so not border.

            So only 3 border cells in the overlap for the original.

         For the copy (0-degree, and placed at (0,0)): 
            then the overlap in the copy is the cells (0,0), (0,1), (1,0), (1,1). 
            border cells of the copy in the overlap: 
               (0,0) -> border, (0,1) -> border, (1,0) -> border, (1,1) -> not.
            so 3.

         fraction=3/3=1.

      How about if we place the copy (0-degree) at (0,0) and also at (0,5) (shifted by (0,5))? 
         Then the overlap might be empty.

      How about placing it at (0,4): 
         Then the copy covers [0,3]x[4,9] (9=4+5) overlap with the original [0,3]x[0,5] is [0,3]x[4,5] -> 4 rows x 2 columns = 8 cells.

         border0 of the original in the overlap: 
            top row: (0,4), (0,5) -> in the overlap: both.
            bottom row: (3,4), (3,5) -> both.
            left column: not in the overlap (j>=4, so j=0,5 are not in the overlap for left/right? )
            right column: (1,5), (2,5) -> in the overlap? j=5 is in [4,9] -> yes.
            So top: 2, bottom: 2, right: 2 cells (1,5) and (2,5) -> total 6.

         border0 of the copy in the overlap: 
            The copy's border is computed in its own grid: then shifted by (0,4): 
               In the overlap, the copy has cells: (0,4) to (3,5) -> 
               border cells of the copy: 
                 top row of the copy: (0,4) and (0,5) -> border.
                 bottom row: (3,4) and (3,5) -> border.
                 left column: in the copy's grid, the left column is j=0 in the copy's own grid, but in the overlap we only have j=4 and 5. 
                             shifted: the left column of the copy's grid: cells (0,0) and (1,0) and (2,0) and (3,0) -> shifted to (0,4) to (3,4) -> which are in the overlap? and are they border in the copy? 
                             In the copy's own grid, these cells are on the left boundary, so border. 
                 right column: similarly, the right boundary of the copy's grid: shifted to (0,9) to (3,9) -> not in the overlap.

               in the overlap, the border cells of the copy: 
                  (0,4) (0,5) (3,4) (3,5) (1,4) (2,4) [ from the left column: (0,4) and (3,4) are also in the top/bottom? and (1,4) and (2,4) from the left column] -> also (0,4) and (0,5) are in the top, (3,4) and (3,5) in the bottom.

               specifically: 
                  (0,4): border (top and left) -> count once.
                  (0,5): border (top and right) -> count once.
                  (3,4): border (bottom and left) -> count once.
                  (3,5): border (bottom and right) -> count once.
                  (1,4): border (left) -> count once.
                  (2,4): border (left) -> count once.
               total 6.

         fraction = 6/6=1.

      I am not seeing 2.

      After checking online: 
        In a chessboard-like manner, but the grid is solid.

      Another idea: 
         in the sample output, the first test case is 2/1, the second is 1/1.
         The first is a solid rectangle, the second is a diamond-shaped convex polyomino.

        for a solid rectangle, the maximum fraction is 2, and it is achieved when the copy is placed at a knight's move? 

      How about if we rotate by 0 and shift by (2,3) in the 4x6 grid: 
         overlap is [2,3]x[3,5] -> 2x3 = 6 cells.
         border0 of the original in the overlap: 
            cells: 
               (2,3), (2,4), (2,5) -> (2,5) is on the right border, (2,3) and (2,4) are not on the border? because in the original, the border is the boundary. 
               (3,3), (3,4), (3,5) -> (3,5) is a corner, (3,3) and (3,4) are on the bottom border.
            in the original, the cell (2,3) is not on the border? 
               because it is not on the boundary of the 4x6 grid -> so not in border0.
            Similarly, (2,4) not in border0.
            (2,5) in border0 (right border) -> count 1.
            (3,3) in border0 (bottom border) -> count 1.
            (3,4) in border0 (bottom border) -> count 1.
            (3,5) in border0 (bottom and right) -> count 1.
            total = 4.

         border0 of the copy in the overlap: 
            The copy is the same, shifted by (2,3), so in the overlap the copy's cells are (2,3) to (3,5) ( six cells) 
            border0 of the copy in its own grid: we only care about the shifted cell being in the original.
            For a cell in the copy's grid: (i,j) in the copy's own grid, the shifted cell is (i+2, j+3) = (i+2, j+3) in the global grid.
            Then we require (i+2, j+3) in the original grid? -> and the cell (i,j) in the copy's own grid is a border cell of the copy? 

            The copy's own grid is 4x6, and the cell (0,0) in the copy's grid corresponds to (2,3) in the global grid.
            The border0 of the copy: the boundary of the 4x6 grid.

            In the overlap: 
               the only cells of the copy that are in the overlap are: 
                  (0,0) -> (2,3) -> in the overlap and in the original? yes. Is (0,0) a border cell in the copy? yes.
                  (0,1) -> (2,4) -> in overlap, and border? yes (top row) -> count.
                  (0,2) -> (2,5) -> in, border? yes.
                  (1,0) -> (3,3) -> in, border? In the copy's grid, (1,0) is on the left border -> border.
                  (1,1) -> (3,4) -> in, and in the copy's grid, (1,1) is not on the border? -> no, because it has all 8 neighbors within the copy's grid and they are '#' -> not a border cell.
                  (1,2) -> (3,5) -> in, and (1,2) in the copy's grid: on the right border? -> no, because the copy's grid has width 6, so j=2 is not the right border (which is j=5) -> not a border cell.
               also (0, anything beyond 2) -> not in the overlap.

            So we have: (0,0), (0,1), (0,2), (1,0) -> 4 cells.

         fraction = 4/4=1.

      I am out of ideas. 

      The intended solution might be: 
         for a rectangle, the best is 2, and it is achieved when the copy is rotated by 0 and then shifted by (0,0) and also by ( something) but not. 

      Fortunately, the sample might be small. 

      Let me try the sample with the known answer 2/1: 
         Input: 
            4 6
            ######
            ######
            ######
            ######

         Output: 2/1.

      How about if we try a 0-degree rotation and a shift by (0,0) and also try a shift by (0,0) for a 0-degree rotation: we get 16/16.
      then try a shift by (0,0) for a 90-degree rotation: 10/10.
      then try a shift by (0,0) for a 180-degree: 16/16.
      then try a shift by (0,0) for a 270: 10/10.

      try a shift by (0,1) for 0-degree: we did and got 10/10.
      try a shift by (0,1) for 90: we got 8/14.

      try a shift by (1,0) for 0: we got 10/10.

      try a shift by (1,1) for 0: 
         overlap: [1,3]x[1,5] -> 3x5 = 15 cells.
         border0 of the original in the overlap: 
            top row of the original: (0,.) -> not in.
            bottom: (3,1) to (3,5) -> in.
            left: (1,0) (2,0) -> not in.
            right: (1,5) (2,5) -> in.
            -> bottom: 5 cells, right: 2 cells, and also the cell (3,0) is not in, (3,5) is in and counted in bottom and right? -> so total = 5+2 = 7.
         border0 of the copy in the overlap: 
            for a cell in the copy's grid (0,0) -> shifted to (1,1) -> in the overlap.
            we then need to see which of the copy's border cells ( in its own grid) when shifted are in the overlap and in the original.
            border0 of the copy: boundary of the 4x6 grid.
            in the overlap: 
               copy's cells that are in the overlap: 
                  in the copy's grid: rows 0 to 2 ( because shift by (1,0) -> then i>=1 for the global) -> and within the overlap of the original, which is [0,3]x[0,5] (global) -> and the copy's grid starts at (0,0) in its own grid, shifted to (1,1) for (0,0) in the copy's grid) -> wait, the shift is (1,1): then a cell (i,j) in the copy's grid becomes (i+1, j+1) in the global grid.
               overlap in the global grid: [1,3]x[1,5] -> so in the copy's grid: i in [0,2] and j in [0,4].
            border0 of the copy: 
               boundary cells in the copy's grid: 
                 top: (0,0) to (0,5) -> in the overlap: (0,0) to (0,4) -> 5 cells.
                 bottom: (3,0) to (3,5) -> in the overlap: (3,0) to (3,4) -> 5 cells? -> but the copy's grid only has i=0..3, and the overlap in the copy's grid is i=0..2, so the bottom row (i=3) is not in the overlap.
                 left: (1,0), (2,0) -> in overlap: (1,0) becomes (2,1) in global? within [1,3]x[1,5] -> yes; (2,0) -> (3,1) -> in.
                 right: (1,5) -> becomes (2,6) -> not in.
                      (2,5) -> (3,6) -> not in.
            and the non-corner of the left and right within the body: 
                 left: for j=0, i=1 and 2: we have.
            total = 5 (top) + 2 (left) = 7.

         fraction = 7/7=1.

      I am not able to achieve 2.

 Given the complexity, and the constraints on the total R^3+C^3 being 10^7, we will implement the O(n^2) per rotation method and hope that the actual test cases have small area.

 In the sample, the first test case has area=24, so 24^2 = 576, then for two dictionaries (border0 * area and area * border_rot) -> 16*24 + 24*16 = 768, which is acceptable.

 And the fraction for the first sample must be found to be 2/1 by the 
 1. We must reduce the fraction: if we find 16/8, then 16/8=2/1.

 How to get 16/8? 
   numerator = 16, denominator = 8.

   In the first sample, for a 0-degree rotation and a shift by (0,0): we have 16/16.
   for a shift by (0,0) in a 0-degree rotation, we have 16/16.

   try a shift by (0,0) in a 0-degree rotation: we have 
        num = trans_numer[(0,0)] = 16
        den = trans_denom[(0,0)] = 16

   try a shift by (0,1) in 0-degree: 
        for the original's border0 cell (0,0): then for b in the entire set, we need (0,0) = (b.x+0, b.y+1) -> b = (0,-1) -> not in.
        for (0,1): then b = (0,0) -> in. 
        ... eventually, we let the computer do it.

 We will run the sample through the code.

 Given time, we will output the code and hope that in the sample it outputs 2/1 for the first.

 If not, we will debug.

 But the problem sample output is 
       2/1
       1/1

 so we must achieve that.

 for the first sample, after running the code for all rotations and translations, the best fraction is 2/1.

 How? 
   We might find a translation (dx,dy) such that 
        numerator = 16, denominator = 8.

   For example, if we place the copy at (0,0) and also at (0,0) for a 0-degree rotation, we get 16/16.
   for a 0-degree rotation and a shift by (0,0) for the copy, we get 16/16.

   for a 0-degree rotation and a shift by (0,0) for the copy: 
        the overlap is the entire 4x6.
        then for the numerator: 
             a in border0: there are 16, and for each a, we need (a.x-0, a.y-0) in the copy's set? -> in, so 16.
        for the denominator: 
             b in border_rot: 16, and (b.x+0, b.y+0) in the original -> in, so 16.

   how about a shift by (0,0) for a 90-degree rotation: 
        border0 = 16, the rotated set's entire set has 24 points.
        for a in border0: 
            for b in the rotated set: 
                dx = a.x - b.x, dy = a.y - b.y.
            for example, a = (0,0) in border0: 
                b in the rotated set: 
                   the rotated set is { (j, 3-i) for (i,j) in range(4) in i and range(6) in j }
                   for example, b = (0,3) [ which corresponds to the cell (0,0) in the original after rotation: wait, 
                         cell (0,0) in the original -> becomes (0,3-0=3) = (0,3) in the rotated.
                so for a = (0,0) and b = (0,3): dx=0, dy=0-3 = -3.
        then for (0,0) in border0, we will have an for (0,0) in border0 and b=(0,3) in the rotated set: dx=0, dy=-3.
        then for this translation (0,-3): 
            how many a in border0 have (a.x - 0, a.y - (-3)) = (a.x, a.y+3) in the rotated set? 
               a = (0,0): (0,3) in the rotated set? in. 
               a = (0,1): (0,4) in the rotated set? in. 
               ...
               a = (0,5): (0,8) -> not in.
               a = (3,0): (3,3) in the rotated set? in.
               ...
            specifically, only the border cells with j such that j+3 < the height of the rotated set? 
               the rotated set has i in [0,5] and j in [0,3] ( because it is 6x4) -> then a.y+3 must be <=3 -> a.y<=0? -> only the j=0 cells.
            wait, we have a.y in [0,5], then a.y+3 might be up to 8, which is beyond the rotated set's j (0..3).

            So only the border cells with a.y<=0? only the ones with a.y=0: 
               top row: (0,0), and the bottom row: (3,0) -> and the left and right at j=0: the left and right at j=0 are (1,0) and (2,0) -> and the top and bottom already include (0,0) and (3,0) -> so 4 cells.

            So for this translation, numerator = 4.

        Similarly, for the denominator: 
            for b in border_rot and a in the entire original set: 
               dx=0, dy=-3: then we require (b.x+0, b.y+ (-3)+something wait: 
               our condition: 
                  for a in the entire set and b in border_rot: 
                      dx = a.x - b.x, dy = a.y - b.y = 0 and -3.
                  then for a given b in border_rot, the condition for the denominator is: 
                         (b.x+0, b.y+(-3)) in the original? 
                  for b = (0,3): becomes (0,0) in the original? in.
                  for b = (0,0): becomes (0,-3) -> not in.
                  ...
               only when b.y>=3 and the cell (b.x, b.y-3) in the original.

        This is not 8.

   I think we must trust the code to try all.

 Given the time, we output the code.

 Steps for the code for one test case:

   Read R, C, grid.
   Find minimal bounding box.
   If empty: output "0/1", continue.
   Build A0 (set of cell coordinates in the box, with (0,0) at (r0,c0) of the box)
   Build border0: for each cell in A0, check if it is border by 8 directions.

   best_num = 0
   best_den = 1

   for rotation in [0,90,180,270]:
        if rotation==0: 
             A_rot = A0
             border_rot = border0
        else if rotation==90:
             A_rot = set( (j, H-1-i) for (i,j) in A0 )
             border_rot = set( (j, H-1-i) for (i,j) in border0 )
        else if rotation==180:
             A_rot = set( (H-1-i, W-1-j) for (i,j) in A0 )
             border_rot = set( (H-1-i, W-1-j) for (i,j) in border0 )
        else if rotation==270:
             A_rot = set( (W-1-j, i) for (i,j) in A0 )
             border_rot = set( (W-1-j, i) for (i,j) in border0 )

        Then:
             trans_numer = defaultdict(int)
             for a in border0:
                 for b in A_rot:   # note: not border_rot, because for the numerator condition: we require b in the entire rotated set (A_rot)
                     dx = a[0] - b[0]
                     dy = a[1] - b[1]
                     trans_numer[(dx,dy)] += 1

             trans_denom = defaultdict(int)
             for a in A0:   # the entire set of the original
                 for b in border_rot:   # only the border of the rotated set
                     dx = a[0] - b[0]
                     dy = a[1] - b[1]
                     trans_denom[(dx,dy)] += 1

             for (dx,dy) in trans_numer:
                 if (dx,dy) in trans_denom:
                     num = trans_numer[(dx,dy)]
                     den = trans_denom[(dx,dy)]
                     if best_num * den < best_den * num:   # then we have a larger fraction: because best_num/best_den < num/den  -> best_num * den < best_den * num
                         best_num = num
                         best_den = den

   Then reduce best_num/best_den by gcd, and output.

 Let's hope sample1 yields 2/1.

 If not, we might need to debug.

 Given the complexity and the sample, we hope it works.

 Note: The area might be up to 40000 (if R=200, C=200) then the double loop is 40000 * 40000 = 1.6e9 per rotation -> 6.4e9 for 4 rotations, which is too heavy in Python.

 But the constraint: the sum of R^3+C^ over test cases is 10^7.

 In the worst-case, the area might be up to 460 (if R=46, C=46 -> area=2116) then the double loop is 2116 * 2116 = 4.5e6 per dictionary, and two dictionaries per rotation: 2 * 4.5e6 = 9e6 per rotation, then 4 * 9e6 = 36e iterations? 

 But note: the double loop for border0 and A_rot: 
     border0 size might be about O(sqrt(n))? or O(n) in the worst-case (entire set is border). 
     In the worst-case, border0 size = n, and A_rot size = n, so the double loop is n^2.

 Therefore, if the area is 2116, then n=2116, and n^2 = 4.5e6, which is acceptable in Python if we only have a few test cases.

 But the sum of R^3+C^3=10^7, and for a test case with R=46, C=46, we have R^3+C^3=46^3+46^3 = about 200000, and 10^7 / 200000 = 50 test cases. Then total work: 50 * 4 * (2116)^2 = 50 * 4 * 4.5e6 = 900e6 iterations, which might be borderline in Python (about 10 seconds in Pyton might be borderline in online judges for 1 second, but the problem has 4 seconds).

 But note: the worst-case area might be smaller.

 Given the time, we output the code.

 Let's run the sample1 in the code in our head:

   solid 4x6 grid.

   A0 = {(i,j) for i in [0,3], j in [0,5]} -> 24 points.
   border0 = the 16 boundary cells.

   for rotation0:
        A_rot = A0 (24 points)
        border_rot = border0 (16 points)

        trans_numer: 
            for a in border0 (16), for b in A_rot (24): 
                in particular, consider a = (0,0) and b = (0,0): then dx=0,dy=0 -> count (0,0) once.
                a = (0,0) and b = (0,1): dx=0, dy=-1.
                ...
            in particular, the identity shift (0,0) will be: 
                for a in border0: for b in A_rot that equals a: only one b for a, namely b=a.
                so count for (0,0) in trans_numer = 16.

        trans_denom:
            for a in A0 (24) and for b in border_rot (16): 
                for a = (0,0) and b = (0,0): dx=0,dy=0 -> count for (0,0) +=1.
                for a = (0,0) and b = (0,1): dx=0, dy=-1.
                ...
                identity shift (0,0): 
                   count = number of a in A0 such that there exists b in border_rot with a = b? 
                   in other words, a must be in border_rot, and then for a in border_rot, the only b that can yield (0,0) is b=a.
                   so count = 16.

        So for (0,0): 16/16.

        Now, is there a shift with 16/8? 
           we need to find a shift (dx,dy) such that the numerator=16 and the denominator=8.

        How about (0,0) in 0-degree: 16/16.
        How about (0,0) in 90-degree: 
             A_rot = {(j, 3-i) for i in [0,3], j in [0,5]} = {(0,3), (0,2), (0,1), (0,0), (1,3), ... } 
             How many (a in border0) such that there exists b in A_rot with a = (b.x+0, b.y+0)? 
                   -> we need a in border0 and a in A_rot? -> but A_rot is the entire set of the rotated copy, which is the set of points in the 6x4 grid? in the global grid of the rotated set, and we haven't normalized, so it is exactly the set of points of the rotated polyomino in the global grid.

             In fact, the rotated set in the global grid is the set of points: (j, 3-i) for (i,j) in the original grid.
             The condition for a cell a in border0 to be in the rotated set (when the copy is placed at (0,0)) is: a is in the set {(j,3-i)}.

             For example, the cell (0,0) in the original: is it in the rotated set? 
                 a = (0,0): we need to check if there exists (i,j) such that (0,0) = (j,3-i) -> then j=0, 3-i=0 -> i=3.
                 and (i=3, j=0) in the original? yes.
             So (0,0) is in.

             Similarly, every cell in the original is in the rotated set? 
                 For any (x,y) in the original, we solve: 
                     x = j, y = 3-i -> i = 3-y, j = x.
                 and (3-y, x) in the original? 
                    0<=3-y<=3 -> 0<=y<=3, and 0<=x<=5 -> and the original is solid, so yes.

             Therefore, the entire border0 (16 cells) are in.

             So for the shift (0,0) in 90-degree: 
                 numerator = 16.

             For the denominator: 
                 for a in A0 (24) and b in border_rot ( which is the border of the rotated set) -> and we need the shift (0,0) -> 
                     condition: for a in A0 and b in border_rot: 
                         with dx=0,dy=0: then we require (b.x+0, b.y+0) in A0? -> but b is in the rotated set's border, and the point is (b.x, b.y) in the global grid.

                 How many b in border_rot are there? 
                    border_rot for the rotated set: the boundary of the 6x4 grid? -> 6*2+4*2 - 4 = 16.

                 And then we also need (b.x, b.y) in the original set? 
                    But the rotated set's grid is [0,5]x[0,3] (i from 0 to 5, j from 0 to 3), and the original set is [0,3]x[0,5]. 
                    The condition: b = (x,y) in the rotated set means: x in [0,5], y in [0,3].
                    We require (x,y) in the original set: then x in [0,3] and y in [0,5] -> always true for y in [0,3] and x in [0,5] is not bounded by x in [0,3] for the original? 
                         the original has i in [0,3] (x in [0,3]) and j in [0,5] (y in [0,5]), so we require x in [0,3].

                 How many border cells of the rotated set have x in [0,3]? 
                    the rotated set's border: 
                       top row: x in [0,5] -> in the original: x in [0,3]: 4 cells (x=0,1,2,3) 
                       bottom row: x in [0,5]: but y=3 (bottom row), and x in [0,3]: 4 cells.
                       left column: y=0, and x in [0,5] -> we need to exclude the corners? but the left column for x in [0,3] (excluding the ones in the top and bottom) -> x in [1,4] -> then in [0,3]: x=1,2,3 -> 3 cells? 
                       right column: y=3, but wait the right column is y=3? and we already did the bottom row? 
                       Actually, the border is the boundary. We have:
                          top: (0,0)..(5,0) -> then for x in [0,3]: 4 cells.
                          bottom: (0,3)..(5,3) -> 4 cells.
                          left: (0,1), (0,2) -> included in top/bottom? 
                          right: (5,1), (5,2) -> not in [0,3] for x.
                          and the non-corner of the left and right within the side: 
                                left: we've done in top and bottom for y=0 and y=3, and for the left we don't have anything else.
                                right: similarly.

                       Alternatively, we might have computed by the 8-connectivity in the rotated set's grid: 
                             for a cell in the rotated set: it is border if it has at least one of the 8 neighbors missing in the rotated set's grid? 
                             but the rotated set's grid is the entire rectangle, so the only missing neighbors are outside the grid.

                       Therefore, the border is the boundary of the rectangle.

                       Then the left column: for y=0, x from 0 to 5 -> already in top and bottom for x=0 and x=5? 
                       and similarly for y=3.

                       For the left column (y=0), the cells with x in [1,4] are not in the top/bottom -> they are part of the left border? -> then we should have 
                             left: for y=0, x in [1,4] -> 4 cells, and similarly right: for y=3, x in [1,4] -> 4 cells.
                       total = 6 (top) + 6 (bottom) + 4 (left) + 4 (right) - 4 (because the four corners are counted twice) = 16.

                 So we only count the ones with x in [0,3]: 
                    top: 4 cells (x=0,1,2,3) 
                    bottom: 4 cells.
                    left: for y=0 and x in [1,4]: but x in [0,3] for the condition -> x in [1,3] -> 3 cells.
                    right: for y=3 and x in [1,4]: -> 3 cells.
                 total = 4+4+3+3 = 14.

                 Therefore, for shift (0,0) in 90-degree: 
                    numerator = 16
                    denominator = 14.

                 fraction = 16/14 = 8/7.

        So the best might be 16/8 somewhere else.

        How about a shift by (0,0) in 0-degree: 16/16.
        How about a shift by (0,0) in 180: 
             similar to 0: 16/16.
        How about 270: 16/14.

        not 16/8.

        How about a non-zero shift in 0-degree: 
             try ( dx=0, dy=1) in 0-degree: 
                 numerator = number of a in border0 such that (a.x-0, a.y-1) in A_rot ( the entire set of the copy) -> 
                     a = (0,0): (0,-1) not in -> 0.
                     a = (0,1): (0,0) in -> count 1.
                     a = (0,2): (0,1) in -> count 1.
                     a = (0,3): (0,2) in -> count 1.
                     a = (0,4): (0,3) in -> count 1.
                     a = (0,5): (0,4) in -> count 1.
                     a = (3,0): (3,-1) not in.
                     a = (3,1): (3,0) in -> count 1.
                     ... -> 
                     bottom row: (3,1)..(3,5): 5 cells.
                     also the right border: (1,5): becomes (1,4) in -> count 1.
                           (2,5): count 1.
                 total = 5 (top) + 5 (bottom) + 2 (right) = 12.

                 denominator = for a in A0 and b in border_rot: 
                      dx=0,dy=1.
                      then for a in A0 and b in border_rot: 
                            requires (a.x, a.y) = (b.x+0, b.y+1) -> a = (b.x, b.y+1)
                            and we require a in A0 and b in border_rot.
                            then b = (a.x, a.y-1)

                      count = number of a in A0 such that (a.x, a.y-1) is in border_rot.

                      a = (0,0): (0,-1) not in.
                      a = (0,1): (0,0) in border_rot? yes.
                      a = (0,2): (0,1) in.
                      ... for the entire set: 
                      the condition: a.y>=1 and (a.x, a.y-1) in border_rot.

                      border_rot is the boundary of the 4x6 grid.

                      For a cell a = (i,j) in the original, the cell (i,j-1) is in border_rot if it is on the boundary.

                      How many a in A0 have a.y>=1 and (i,j-1) in border_rot? 
                         This is exactly the border_rot cell that are not on the bottom row? 
                         because if b = (i,j) is in border_rot, then a = (i, j+1) will be counted.

                      Specifically, the border_rot cells that have j>=0 and j<5 (so that a.y = j+1 is in [0,5]) and also a must be in A0 -> which it is.

                      The border_rot has:
                         top row: j=0: -> then a = (i,1) for i in [0,3] -> 4 cells.
                         bottom row: j=5: then a = (i,6) -> not in A0.
                         left column: i=0, j in [1,4] -> a = (0, j+1) for j in [1,4] -> then a = (0,2)..(0,5) -> 4 cells.
                         right column: i=3, j in [1,4] -> a = (3,2)..(3,5) -> 4 cells.

                      and the non-corner parts of the left and right within the body: 
                         already included.

                      total = 4 (top) + 4 (left) + 4 (right) = 12.

                 fraction = 12/12 = 1.

        We for sure haven't found 16/8.

        How about shift (0,0) in a 0-degree rotation is the only with 16, but then we need a shift that yields 8 in the denominator.

        We might try a shift by (0,0) in the 0-degree rotation, but in the denominator, we might have a different count? 
           In the denominator: we had 16 for (0,0) in 0-degree.

        How about a shift by (0,0) in a 0-degree rotation for the numerator, and a shift by (0,0) in a 0-degree rotation for the denominator: we got 16/16.

        unless we have a shift in a different rotation that has numerator=16 and denominator=8.

        I think we must run the code on the sample.

 Given the time, we output the code and hope that the intended solution is correct.

 If the sample does not yield 2/1, we might need to not use the entire rotated set for the numerator, but only the border of the rotated set for the numerator? 

        The problem: 
          numerator: number of cells on A’s border and inside A1.

          "inside A1" means: the cell is part of the copy? 

          So for a cell a in the original grid, it is in A1 if the copy covers that cell.

          How do we check that? 
             In our approach: for the copy placed at (dx,dy) (which is the shift for the rotated set), a cell a in the original is in the copy if and only if there exists a cell b in the rotated set such that a = (b.x+dx, b.y+dy).

          This is equivalent to: (a.x-dx, a.y-dy) in the rotated set.

          So our method for the numerator is: 
             for a in border0: we and for b in the entire rotated set, we consider the shift (dx,dy) = (a.x-b.x, a.y-b.y). 
          then we count one for a and b yielding that shift.

          But note: for a fixed a, there might be multiple b in the rotated set such that a = b+ (dx,dy). 
          However, the set of b is the entire rotated set, and a might be covered by the copy even if it is matched by one b.

          And we are counting the number of a in border0 that are in the copy, not the number of pairs.

          But our method: 
             for a fixed a, and for every b in the rotated set, we consider the translation that would put b at a. 
             then for a fixed a, it will be counted in every translation (dx,dy) = (a.x-b.x, a.y-b.y) for which b in the rotated set.

          This is not what we want.

          We want for a fixed translation (dx,dy), to count the a in border0 that are in the copy.

          In our aggregation, for a fixed translation (dx,dy), the count in trans_numer is the number of pairs (a,b) such that (dx,dy)= (a.x-b.x, a.y-b.y) and a in border0 and b in the rotated set.

          But for a fixed a, there might be several b that yield the same translation? 
             for a fixed a and a fixed (dx,dy), the b is uniquely determined: b = (a.x-dx, a.y-dy).
          So if that b is in the rotated set, then a will be in the copy for that translation.

          Therefore, for a fixed (dx,dy), the number of a in border0 that are in the copy is exactly the number of a in border0 for which (a.x-dx, a.y-dy) is in the rotated set.

          And that is what we are counting in the double loop: 
             for a in border0 and for b in the rotated set, we are essentially doing: 
                 for each a, and for each b, we consider the translation that would put b at a, and then we a's that yield that translation are counted.

          But note: for a fixed translation (dx,dy), the condition for a is: (a.x-dx, a.y-dy) in the rotated set, and a in border0.
          and we are counting the number of a (for this translation) that satisfy that condition.

          However, in the double loop, we are not iterating by translation first. Instead, we are for each a and b, we 
             know that if we use the translation (dx,dy) = (a.x-b.x, a.y-b.y), then this a will be counted for that translation.

          And because for a fixed a and for a fixed (dx,dy), there is exactly one b that can work (namely b = (a.x-dx, a.y-dy)), then the for loop will count a once for that (dx,dy) for each b that equals (a.x-dx, a.y-dy)? 

          But note: we iterate over all b in the rotated set. For a fixed a and a fixed (dx,dy), there is at most one b (because the set might not have duplicates) that equals (a.x-dx, a.y-dy). 

          Therefore, the count in trans_numer for (dx,dy) is exactly the number of a in border0 for which (a.x-dx, a.y-dy) in the rotated set.

          Similarly, the count in trans_denom for (dx,dy) is exactly the number of b in border_rot for which (b.x+dx, b.y+dy) in the original set.

          So the method is correct.

 Given the complexity, we hope that in the sample a for the 0-degree rotation with a non-zero shift or for a different rotation we get 16/8.

 If not, we might need to that the sample answer is 2/1 from a different interpretation.

 Given the time, we output the code.

 Note: the second sample is provided, and we hope it yields 1/1.

 Let's do the second sample by hand for the identity shift and 0-degree: 
        The polyomino is symmetric, so border0 in the original and in the copy (0-degree) should be the same.
        then for (0,0) we get numer = |border0|, denom = |border0|.

        so 1/1.

 Therefore, output as above.

 If the first sample does not yield 2/1 in our code, we might need to debug, but for now we output.