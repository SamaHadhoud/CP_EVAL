We are given T test cases. For each test case, we are given R and C, and an R x C grid of characters '#' and '.'.

The problem involves a convex polyomino A. We are to place an identical copy A1 (rotated by a multiple of 90 degrees) on top of A such that they overlap (at least one cell) and then compute:

   numerator = number of cells on A's border that lie inside the overlapping region with A1
   denominator = number of cells on A1's border that lie inside the overlapping region with A

Then, we wish to maximize the fraction (numerator/denominator) over all possible placements (translations and rotations by 0, 90, 180, 270 degrees) that yield an overlap.

Important note: The polyomino is convex. This convexity is defined by the property that the intersection of any horizontal or vertical line with the polyomino is a connected segment.

Constraints: T up to 10^5, but the sum of R^3 + C^3 over test cases is <= 10^7.

Observation:
Since the grid is not too large (because R^3+C^3 is bounded by 10^7 per file, meaning R and C are at most about 215 since 215^3 ~ 10 million) but note: the sum of R^3 + C^3 for all test cases is <= 10^7, so the individual test cases must be small.

However, note that the problem says "the sum of R^3 + C^3 in a file is no more than 10^7". This means that if we have multiple test cases, the sum of (R^3 + C^3) for each test case is bounded by 10^7. Since T can be up to 10^5, the typical test case must be very small. But note: worst-case T could be 10^5, but then each test case would have R^3+C^3 <= 100, so R and C would be at most 4 (since 4^3=64, 5^3=125). However, the sample input has R=4 and R=20. Therefore, we must design an efficient solution.

But note: the bound is on the sum of R^3 + C^3 for the entire file. We cannot iterate over all rotations and translations for each test case naively.

However, we note that the polyomino is convex. This convexity will help us in representing the polyomino in a compact way.

Key ideas:

1. Preprocessing the polyomino:
   - We are going to represent the polyomino by its bounding box. However, because of convexity, we can represent the polyomino by the leftmost and rightmost column for each row, or similarly for columns.

   But note: the convexity condition: for any horizontal line, the intersection is a contiguous segment. Similarly for vertical.

   Therefore, we can represent the polyomino by two arrays:
        left_boundary[i] = the minimum column index in row i that has a '#'
        right_boundary[i] = the maximum column index in row i that has a '#'

   However, we must also consider that the grid might not have all rows from 0 to R-1 containing the polyomino. We should trim the grid to the minimal bounding box.

   Similarly, we can represent the polyomino in four different rotations: 0°, 90°, 180°, 270°.

   For each rotation, we can compute the minimal bounding box and the left and right boundaries for each row.

2. What is the border of the polyomino?
   - A cell (i, j) is on the border if not all of its 8 neighbors are present. However, note the definition: "not all of its 8 adjacent cells are other squares". This means that if at least one of the 8 neighbors is not part of the polyomino, then the cell is on the border.

   Therefore, we can precompute for the original polyomino (and for each rotation) a boolean grid or a set of border cells.

   However, note that the grid size is bounded by R and C (with R, C up to about 215 at worst individually, but the sum of R^3+C^3 over test cases is 10^7). But note: 10^7 is the total for the file, so worst-case we might have several test cases with R and C around 100? Actually, 10^7 = 10000000, and if R and C are about 100, then R^3+C^3 = 1000000+1000000 = 2000000, so we can have at most 5 such test cases? But the problem says the sum of R^3+C^3 for the entire file is 10^7, so worst-case we have one test case with R and C such that R^3+C^3 <= 10^7, and then many small ones.

   However, the problem states: "the sum of R^3 + C^3 in a file is no more than 10^7". This means that for each test case, we compute R^3 + C^3 and then sum over test cases. So we can have multiple test cases as long as the sum of these cubes is <= 10^7.

   Therefore, we can iterate over the grid for each test case without too much worry, but we must be careful with the placement step.

3. Placement:
   We have to consider 4 rotations. For each rotation, we have the original polyomino A and the rotated copy A1. We then consider all translations (dx, dy) such that the two polyominos overlap. The translation is integral and must place at least one cell overlapping.

   For a fixed rotation, let the original polyomino be represented by a set of points (i, j) and the rotated one by a set of points (i', j') (which is a rotation of the original). Then the placement of A1 is shifted by (dx, dy): so a point (x, y) in A1 (the rotated one) corresponds to (x-dx, y-dy) in the original grid? Actually, we have to be cautious.

   Alternatively, we can represent the rotated polyomino in its own grid, then when we overlay, we consider the overlapping region.

   However, the problem is that we are to count:

        numerator: for each cell in A that is on the border of A and is also in the overlapping region (i.e., the same cell exists in A1 at the shifted location) then we count 1 if that cell is a border cell of A.

        denominator: for each cell in A1 that is on the border of A1 and is also in the overlapping region (i.e., the same cell exists in A at the inverse shift) then we count 1 if that cell is a border cell of A1.

   Note: because the polyomino is convex, the border condition is independent per polyomino.

   But note: the overlapping region is the set of cells that are present in both A and the shifted A1.

   However, the fraction is defined as:

        numerator = | { cells c in A: c is on border of A and c is covered by A1 } |
        denominator = | { cells d in A1: d is on border of A1 and d is covered by A } |

   But note: the placement: when we shift A1 by (dx, dy), then a cell (i, j) in A (the original) is covered by A1 if and only if the cell (i, j) in the original grid is also a cell of A1 when A1 is placed at (dx, dy). However, because we have rotated A1, we must map the cell in A to the corresponding cell in A1.

   Actually, let us fix the original polyomino A. Then we consider a rotated version of A, say rot(A). Then we place rot(A) by shifting by (dx,dy). Then the overlapping condition is that a cell (x,y) in A is covered by rot(A) if (x,y) is in the set: A ∩ (rot(A) shifted by (-dx, -dy))? Actually, the shifted rot(A) covers the original grid at positions (x', y') = (x0, y0) + (dx,dy) for each cell (x0,y0) in rot(A). Then the overlapping cells are the set:

        { (x,y) in A such that (x-dx, y-dy) is in rot(A) }

   Similarly, the same cell (x,y) in A corresponds to the cell (x-dx, y-dy) in rot(A). Therefore, the border cell of A at (x,y) is counted in the numerator, and the border cell of rot(A) at (x-dx,y-dy) is counted in the denominator.

   However, note: the border status of a cell in rot(A) is the same as the border status of the corresponding cell in the original A? Actually, when we rotate the entire polyomino, the border status of a cell might change because the neighbors are also rotated. But we precomputed the border for the original and for each rotation independently.

   Therefore, for each rotation, we precompute:
        - the set of cells (in the minimal bounding box) for the rotated polyomino
        - the border information for the rotated polyomino

4. How to iterate?
   For each rotation (0°, 90°, 180°, 270°), we generate the rotated polyomino and its border set.

   Then we consider translations (dx,dy) such that the two polyominos overlap. The translation (dx,dy) must be such that the bounding boxes overlap. The range for dx: if the original polyomino has rows [r1, r2] and the rotated one has rows [r1', r2'], then dx must be in [r1 - r2', r2 - r1']? Actually, we can let dx be from - (height_rot - 1) to (height_orig - 1) and similarly for dy.

   But note: the grid sizes: the original has R rows and C columns. The rotated polyomino: for 0°: R0 = R, C0 = C; for 90°: R90 = C, C90 = R; etc.

   The number of translations: the original grid has R rows and C columns, the rotated grid has R' rows and C' columns. Then dx can be from - (R'-1) to (R-1) and dy from - (C'-1) to (C-1). So the number of translations is about (R+R')*(C+C'). For one rotation, this is about O(R*C * R'*C')? Actually, the number of dx values is (R + R' - 1) and dy is (C + C' - 1). So the total number of translations for one rotation is about (R+R')*(C+C'). Since R and C are bounded (by about 200) then (R+R')*(C+C') is about 400*400 = 160000 per rotation. Then for 4 rotations, 640000 per test case.

   However, the constraint says the sum of R^3 + C^3 over test cases is <= 10^7. How many test cases? The worst-case number of test cases T is 10^5, but then each test case must have R^3+C^3 <= 100, so R and C at most 4. Then (R+R')*(C+C') <= (4+4)*(4+4)=64, and for 4 rotations: 256 per test case. Then 10^5 test cases would be 256 * 10^5 = 25.6e6, which is acceptable.

   But what if we have one test case with R=100? Then R^3+C^3 = 1000000 + 1000000 = 2000000, and then the next test case must be small. However, the total of R^3+C^3 over test cases is 10^7, so we can have at most 5 test cases with R=100? Actually, 5 * (100^3+100^3) = 5 * 2000000 = 10^7.

   For a test case with R=100, the rotated polyomino at 0°: R0=100, C0=100. Then the translations: dx from -99 to 99 (199 values) and dy from -99 to 99 (199 values) -> 199*199 = 39601 per rotation, then 4 rotations: 158404 per test case. Then 5 such test cases: 5*158404 = 792020, which is acceptable.

   Therefore, we can iterate over 4 rotations and all possible translations.

5. Algorithm for one test case:

   Step 1: Read R, C and grid.

   Step 2: Trim the grid to minimal bounding box? Actually, we can represent the polyomino by:

        rows: from r_min to r_max (the topmost row with '#' to the bottommost)
        for each row i in [r_min, r_max]: 
            left_boundary[i] = min{ j | grid[i][j]=='#' }
            right_boundary[i] = max{ j | grid[i][j]=='#' }

        Similarly, we can represent the set of cells as a set of coordinates (relative to the bounding box) and also precompute the border.

   Step 3: Precompute the original polyomino as a set of points and border points.

        We can represent the polyomino by a set S0 of (i, j) for which grid[i][j]=='#', and then the border:

            border0 = set()
            for each (i,j) in S0:
                for each neighbor (dx,dy) in the 8 directions: 
                    if (i+dx, j+dy) is not in S0, then (i,j) is border -> mark and break.

        But note: the problem says "not all of its 8 adjacent cells are other squares", so if at least one neighbor is missing, then border.

        We can precompute a grid for the original, but we have the minimal bounding box. We can create a 2D boolean array for the polyomino and then check the 8 neighbors.

        However, the grid is at most 100x100? Actually, worst-case R and C can be 100, so 100*100=10000 cells, and 8 neighbors: 80000 per test case for one rotation. Then for the original and 3 rotations: 4 * 80000 = 320000 per test case. Then 5 test cases (with R=C=100) would be 1.6e6, which is acceptable.

   Step 4: Generate the 4 rotations.

        Rotation 0: same as original.

        Rotation 90: rotate 90 degrees clockwise. 
            How? For a point (i, j) in the original grid (with the minimal bounding box: rows from r_min to r_max, columns from c_min to c_max), then the rotated point in the new grid is: 
                i90 = j - c_min   [but note: we want to represent the rotated polyomino in its own minimal bounding box]
                j90 = (r_max - r_min) - i   ??? 

            Actually, we can do:

                Original grid: rows [0, H-1] and columns [0, W-1] (after trimming to minimal bounding box). Then:
                    Rotation 90: new row = j, new col = H - 1 - i.

            But we then have to re-trim the rotated polyomino to its minimal bounding box? Actually, we can compute the minimal bounding box of the rotated set.

        Alternatively, we can generate the set of points for the rotated polyomino without trimming? Actually, we will represent each rotated polyomino by:

            Set of points (in the coordinate system of the original grid? But when we shift, we are going to use integer shifts. We can represent the rotated polyomino in a coordinate system that is relative to the original? Actually, we don't care about the absolute coordinates for the rotated one; we only care about the relative positions.

            We can define the top-left of the minimal bounding box of the rotated polyomino as (0,0). Then we store the set of points relative to that.

        Steps for generating a rotation:

            Let S be the set of points (i, j) in the original minimal bounding box (with i in [0, H-1], j in [0, W-1]).

            Rotate each point (i, j) to get (i', j'):

                0°: (i, j) -> (i, j)
                90°: (i, j) -> (j, H-1-i)
                180°: (i, j) -> (H-1-i, W-1-j)
                270°: (i, j) -> (W-1-j, i)

            Then we let the set of points in the rotated polyomino be the set of transformed points.

            Then we can find the minimal bounding box for the rotated set? Actually, we don't need to: we can compute the boundaries for the rotated set:

                min_i = min{ i' for (i',j') in the rotated set }
                max_i = max{ i' }
                min_j = min{ j' }
                max_j = max{ j' }

            Then we shift the entire set so that the top-left is at (0,0): subtract (min_i, min_j) from each point.

            Then the new set: for each point (i', j') -> (i' - min_i, j' - min_j)

            Then the bounding box of the rotated polyomino is [0, max_i-min_i] x [0, max_j-min_j].

            Also, we precomputed the border for the original set. How about for the rotated set? We can compute the border for the rotated set from the original border? Actually, no: because the border condition depends on the neighbors in the rotated polyomino. Therefore, we must compute the border for the rotated set by checking the 8 neighbors in the rotated set.

            However, note: the rotated set is just a rotation of the original. The connectivity by edges is preserved, but the 8 neighbors? The 8 neighbors in the original grid are rotated as well. Therefore, the border status of a cell is preserved under rotation? Actually, yes: because the entire set is rotated, so the neighbors of a cell in the rotated set are exactly the rotations of the neighbors in the original set. Therefore, if a cell was border in the original, then in the rotated set it is also border? 

            But wait: the border condition is defined by the 8 neighbors. If in the original, a cell had a missing neighbor at (i+dx, j+dy), then in the rotated set, the rotated cell will have a missing neighbor at the rotated position of (i+dx, j+dy). Therefore, the border status is preserved.

            Therefore, we can simply rotate the border set as well: if (i,j) is border in the original, then the rotated point is border in the rotated set.

            Therefore, we can generate the set of points for the rotated polyomino and the set of border points by applying the same rotation to the original set of points and the original set of border points.

        However, note: when we rotate, we are also changing the grid. The minimal bounding box might change, and the relative positions of neighbors are preserved, so the border property is preserved.

        Therefore, for each rotation, we can:

            S_rot = { rotate(p) for p in S_original }
            border_rot = { rotate(p) for p in border_original }

        But we must also shift the rotated set to the minimal bounding box? Actually, we can store the set of points and border points in a normalized coordinate system (with the top-left of the minimal bounding box at (0,0)). Then when we shift, we will use integer shifts.

        Alternatively, we can store the set of points and border points without shifting? Then when we consider translation (dx,dy), we have to account for the offset of the minimal bounding box. Actually, we can represent the rotated polyomino by:

            H_rot = max_i - min_i + 1
            W_rot = max_j - min_j + 1
            Set of points: relative to (min_i, min_j) -> so the point (i', j') in the rotated set is stored as (i' - min_i, j' - min_j)

        Then when we place the rotated polyomino at translation (dx,dy) in the original grid (which is also normalized by its minimal bounding box), then the point (x,y) in the original polyomino (which is at (x, y) in the original normalized coordinates) will be overlapped by the rotated polyomino at (dx, dy) if and only if:

            The rotated polyomino has a point at (x - dx, y - dy) in its normalized grid? Actually, no: the translation (dx,dy) is in the grid of the original? We have to align the coordinate systems.

        How to align:

            Let the original polyomino be defined on a grid: the top-left of its minimal bounding box is at (0,0). So a cell at (i,j) in the original corresponds to (i, j) in the normalized grid.

            The rotated polyomino (after normalization) has top-left at (0,0) in its own grid.

            Then when we place the rotated polyomino by shifting by (dx,dy) in the original normalized grid, then a cell (x,y) in the rotated polyomino is placed at (x+dx, y+dy) in the original normalized grid.

            Therefore, the overlapping condition: a cell (i,j) in the original polyomino is covered by the rotated polyomino if and only if (i-dx, j-dy) is a point in the rotated polyomino (and note: (i-dx, j-dy) must be nonnegative and within the bounding box of the rotated polyomino? Actually, we stored the rotated polyomino as a set of points, so we can check if (i-dx, j-dy) is in S_rot.

        However, note: the rotated polyomino set S_rot is stored in normalized coordinates. So the point (i-dx, j-dy) must be in the set S_rot? But the normalized coordinates of the rotated polyomino are nonnegative, so if (i-dx, j-dy) is negative, it's not in the set.

        Therefore, for a translation (dx,dy), we can compute:

            numerator = 0
            denominator = 0

            For each cell (i,j) in the original polyomino (in normalized coordinates) that is a border cell:
                Let (x, y) = (i-dx, j-dy)
                If (x,y) is in S_rot (the set of the rotated polyomino), then this cell is overlapped and is on the border of A -> add 1 to numerator.

            For each cell (i,j) in the rotated polyomino (in normalized coordinates) that is a border cell of the rotated polyomino:
                Let (x, y) = (i+dx, j+dy)   [because the rotated polyomino placed at (dx,dy) has a cell (i,j) at (dx+i, dy+j) in the original grid, so to check if that cell is covered by the original polyomino, we check (dx+i, dy+j) in the original set? 
                Actually, the original set has a cell at (dx+i, dy+j) if and only if that point is in S_original.

            But wait: the original polyomino is defined on normalized grid [0, H_orig-1] x [0, W_orig-1]. The point (dx+i, dy+j) might be outside? Then we don't count.

            However, note: the overlapping condition is symmetric. We can also express the overlapping region as the set of points that are in both the original and the shifted rotated polyomino.

            Actually, the above two loops count the same overlapping region? But they are from two perspectives. And note: the condition for the denominator: the border cell of the rotated polyomino that lies in the original polyomino.

            But note: the point (dx+i, dy+j) in the original grid must be within [0, H_orig-1] and [0, W_orig-1] to be in the original set.

            However, we can avoid iterating twice? Actually, we can iterate once over the overlapping cells. But we have to count two different sets: one for the border cells of A that are overlapped, and one for the border cells of A1 that are overlapped.

            Alternatively, we can:

                overlapping_cells = S_original ∩ { (x+dx, y+dy) for (x,y) in S_rot }   [this is the set of cells in the original grid that are overlapped]

                Then:
                    numerator = | { cell in overlapping_cells such that cell is in border_original } |
                    denominator = | { cell in overlapping_cells such that the corresponding cell in the rotated polyomino is in border_rot } |

                How to get the corresponding cell? 
                    For a cell (i,j) in the original that is overlapped: 
                        the corresponding cell in the rotated polyomino is (i-dx, j-dy) (which is in the normalized grid of the rotated polyomino).

                Therefore, we can do:

                    numerator = 0
                    denominator = 0
                    for each (i,j) in overlapping_cells (which we can iterate by iterating over the original set and checking if (i-dx, j-dy) is in S_rot):
                        if (i,j) is in border_original -> then add 1 to numerator.
                        if (i-dx, j-dy) is in border_rot -> then add 1 to denominator.

            But note: the border_rot set is defined for the rotated polyomino in its normalized grid. And (i-dx, j-dy) is exactly the normalized coordinate for the rotated polyomino.

            However, we must note: the border_rot set is stored as a set of points in the normalized grid of the rotated polyomino. So we can check.

        Therefore, for a fixed rotation and fixed (dx,dy), we can:

            num = 0
            den = 0
            for each (i,j) in S_original:
                x = i - dx
                y = j - dy
                if (x,y) in S_rot:   # then (i,j) is overlapped
                    if (i,j) in border_original: num += 1
                    if (x,y) in border_rot: den += 1

            Then we consider the fraction = num/den.

        However, note: the problem says "number of cells on A’s border and inside A1" and "number of cells on A1’s border and inside A". This matches.

        But note: we must avoid division by zero? The problem states: "It can be shown that the result is neither 0 nor ∞". But we must avoid placements that yield den=0? However, the problem says they must have some overlap. But if there is overlap, then den might be zero? Actually, if the overlapping region does not contain any border cell of A1, then den=0. But the problem states "it can be shown that the result is neither 0 nor ∞", meaning that for the placements we consider, the denominator is not zero and the fraction is defined? Actually, the problem says "print the result as a reduced fraction", and it is guaranteed not to be 0 or ∞. Therefore, we can assume that for the placements that yield the maximum, the denominator is positive.

        However, we must skip placements that have den=0? Actually, the problem says "within the unit squares that form a polyomino", and we are only considering placements with overlap. But it is possible that the overlapping region has no border cell of A1? Then that placement is not considered? But the problem says "find the maximum value", and if there is no placement that yields a positive denominator, then the problem guarantee is broken. So we assume there is at least one placement with positive denominator.

        Therefore, for each rotation and each (dx,dy) that yields at least one overlapping cell, we compute the fraction and update the maximum.

        But note: the same fraction might be achieved by multiple placements, and we want the maximum fraction.

6. How to represent sets?

        We are dealing with normalized grids that are at most 100x100, so the set of points can be represented by a 2D boolean array for each rotation? Or by a set data structure? 

        For the rotated polyomino, we can represent:

            S_rot: a 2D boolean grid of size H_rot x W_rot, where grid_rot[i][j] = True if the normalized point (i,j) is in the polyomino.

            Similarly, border_rot: a 2D boolean grid of the same size.

        Then for a given (dx,dy), we iterate over the original polyomino: for each (i,j) in the original, we compute (x,y) = (i-dx, j-dy). Then we check if (x,y) is in the bounding box of the rotated polyomino: 0<=x<H_rot and 0<=y<W_rot, and then check grid_rot[x][y]. Similarly, we can check border_rot[x][y] for the denominator.

        How to iterate over the original polyomino: we have a list of points? Or we can also represent the original by a 2D grid. Actually, we have the original normalized grid as a 2D array of size H_orig x W_orig.

        Therefore, we can precompute:

            For the original (rotation0):
                grid0: H_orig x W_orig, and border0: H_orig x W_orig.

            For each rotation r in [0,90,180,270]:
                we compute:
                    H_r, W_r
                    grid_r: 2D array of size H_r x W_r, where grid_r[i][j] = True if the point (i,j) (in the normalized grid) is part of the polyomino.
                    border_r: 2D array of the same size.

        Then for each rotation r and for each translation (dx,dy) (dx from -H_r+1 to H_orig-1, dy from -W_r+1 to W_orig-1), we do:

            num = 0
            den = 0
            for i in range(H_orig):
                for j in range(W_orig):
                    if not grid0[i][j]: continue
                    x = i - dx
                    y = j - dy
                    # check if (x,y) is in the grid_r
                    if x >=0 and x < H_r and y>=0 and y < W_r and grid_r[x][y]:
                        # then (i,j) is overlapped
                        if border0[i][j]:
                            num += 1
                        if border_r[x][y]:
                            den += 1
            # If there is no overlap, then we skip? Actually, we require at least one overlap. But the problem says "they have some overlap", so we skip if num==0? Actually, we can skip if num==0 because then there is no overlap. But note: we started the loops such that we only consider (dx,dy) that might yield at least one overlap? Actually, we iterate over all dx,dy and then if we get num>0, then we consider.

            Then if den==0, we skip? But the problem guarantee says the result is not infinity and not zero? Actually, we are to maximize the fraction, and we know there is at least one placement with positive denominator. So we only consider placements with den>0.

            Then we compute the fraction = num/den, and update the maximum fraction.

        But note: the fraction must be stored as a reduced fraction? Actually, we are to output the maximum fraction as a reduced fraction. However, we are iterating and comparing fractions. How to compare fractions? We can avoid floating point by comparing num1*den2 and num2*den1? But the fractions might be large? The number of overlapping border cells is at most the number of border cells, which is at most 10000? Actually, worst-case 100*100=10000, so num and den are <= 10000. Then the product is at most 100e6, which fits in an integer.

        Therefore, we can:

            keep a variable best_num, best_den for the maximum fraction.

            For a candidate (num, den) with den>0:
                if best_num * den < num * best_den:   # then candidate > best
                    best_num = num
                    best_den = den

            Then at the end, we reduce the fraction.

        But note: we must consider all rotations and all translations.

7. Complexity:

        For one rotation: 
            Number of translations: (H_orig + H_r - 1) * (W_orig + W_r - 1) = O( (H_orig+H_r)*(W_orig+W_r) )
            For each translation, we iterate over the entire original grid: which has H_orig * W_orig points.

            So total for one rotation: O( (H_orig+H_r)*(W_orig+W_r) * H_orig*W_orig )

        This is O(n^4) per rotation? And n=100? Then (200*200*100*100) = 4000000 per rotation? Then 4 rotations: 16e6 per test case. Then 5 test cases: 80e6, which is acceptable in C++ but in Python? The problem time limit is 4 seconds per test? Actually, the problem time limit is 4.0 seconds per file? But the constraint says the sum of R^3+C^3 is 10^7, which is the entire file, but we are doing an O( (H_orig+H_r)*(W_orig+W_r)*H_orig*W_orig) per test case, which for R=C=100 is 16e6 per test case, and then 5 test cases: 80e6 operations, which in Python might be borderline? But note: 80e6 operations in Pyton might take a few seconds? We must hope that the test cases are small.

        But wait: the constraint says the sum of R^3+C^3 is 10^7. How does that relate to the sizes? 

            For a test case: R and C are the input dimensions. Then we trim to minimal bounding box: let H_orig = number of rows that have at least one '#'? and similarly W_orig. Then H_orig <= R, W_orig<=C.

            Then the actual grid we use is H_orig x W_orig.

            The rotated polyomino: 
                for 0°: H_r = H_orig, W_r = W_orig.
                for 90°: H_r = W_orig, W_r = H_orig.
                etc.

            Then the inner loop is H_orig * W_orig per translation, and the number of translations for one rotation is (H_orig + H_r) * (W_orig + W_r). 

            Therefore, the total work for one test case and one rotation is: (H_orig + H_r) * (W_orig + W_r) * (H_orig * W_orig)

            Since H_orig <= R, W_orig<=C, and similarly for the rotations, we can bound:

                H_orig, W_orig, H_r, W_r <= max(R, C)

            So the work per test case per rotation is O( max(R,C)^4 ). 

            And the sum over test cases of (R^3+C^3) <= 10^7.

            But note: R and C are the input dimensions, and the minimal bounding box might be smaller. However, worst-case the minimal bounding box is the entire R x C.

            Therefore, we must be cautious: for a test case with R=C=100, the work per rotation is (100+100)*(100+100)*100*100 = 200*200*10000 = 400000000 = 400e6 per rotation? Then 4 rotations: 1.6e9 operations per test case. Then 5 test cases: 8e9 operations, which is too high.

        Therefore, we need to optimize.

        Alternative approach:

            Instead of iterating over all translations and then over the entire grid, we can use convolution? Or we can iterate only over the translations that yield at least one overlap? But we are already iterating over translations that yield overlap by the bounding box.

            Actually, we can use the following:

                We want to compute for a fixed rotation:

                    For translation (dx,dy), 
                        num[dx,dy] = sum_{i,j} [ grid0[i][j] and grid_r[i-dx][j-dy] and border0[i][j] ]
                        den[dx,dy] = sum_{i,j} [ grid0[i][j] and grid_r[i-dx][j-dy] and border_r[i-dx][j-dy] ]

                This is a 2D convolution? But not exactly: because the kernel is not fixed. Actually, we are correlating two binary images, but then also multiplying by a mask (border0 and border_r).

            However, we can break it into two separate convolutions? 

                Let A[i][j] = 1 if grid0[i][j] and border0[i][j] else 0.
                Let B[x][y] = 1 if grid_r[x][y] else 0.

                Then num[dx,dy] = sum_{i,j} A[i][j] * B[i-dx][j-dy]   [if we adjust the indices: but note the translation: we have to shift B by (dx,dy)].

                Similarly, let C[i][j] = 1 if grid0[i][j] else 0.
                Let D[x][y] = 1 if grid_r[x][y] and border_r[x][y] else 0.

                Then den[dx,dy] = sum_{i,j} C[i][j] * D[i-dx][j-dy]

            But note: the convolution is defined as: 
                (A * B)[dx,dy] = sum_{i,j} A[i][j] * B[i+dx][j+dy]

            We have: 
                num[dx,dy] = sum_{i,j} A[i][j] * B[i-dx][j-dy] 
                           = sum_{i,j} A[i][j] * B'[dx-i][dy-j]   where B'[i][j]=B[-i][-j]? 

            This is a convolution of A and B' (with B' flipped).

            Similarly for den.

            The convolution can be done by FFT in O(n^2 log n) for an n x n grid? But n=200? Then n^2 log(n^2) = 40000 * log(40000) ~ 40000*16 = 640000, which is acceptable.

            However, the problem states the entire file sum of R^3+C^3 is 10^7. How many test cases? We cannot use FFT for each rotation and each test case? Because 4 rotations per test case, and FFT for a grid of size (H_orig+ H_r) x (W_orig+W_r) is O( (H_orig+H_r)*(W_orig+W_r) * log(...) ). For R=C=100, the grid size is 200x200, then FFT would be O(40000 * log(40000)) per convolution? And we need two convolutions per rotation? Then 8 convolutions per test case? Then 8 * 40000 * 16 = 5.12e6 per test case per rotation? Then 4 rotations: 20.48e6 per test case? Then 5 test cases: 102.4e6, which is acceptable.

            But note: we have to do this for T test cases, and the constraint on the entire file is the sum of R^3+C^3, not the work. However, the worst-case total work for FFT might be acceptable.

        However, implementing FFT in Python might be slow? And we have to do complex numbers? Or we can use integer convolution? 

        Alternatively, since the minimal bounding box might be small, we can use a direct convolution? The direct convolution for a grid of size (H_orig x W_orig) and (H_r x W_r) is O( H_orig * W_orig * H_r * W_r ). For R=C=100, that is 100^4 = 100000000 per convolution? Then two convolutions per rotation: 200000000 per rotation? 4 rotations: 800000000 per test case? Then 5 test cases: 4e9, which is too high.

        Therefore, we need FFT? But note: the grid sizes are not too big (max about 100) but the convolution size is (H_orig+H_r) x (W_orig+W_r) which is 200x200. We can do direct convolution for 200x200? 

            The convolution for two 2D arrays of size (n1 x m1) and (n2 x m2) by direct method: the output is (n1+n2-1) x (m1+m2-1) and each output element requires n1*m1 operations? Actually, no: we slide the smaller one over the bigger one? Actually, the direct convolution without FFT is O( (n1+n2-1)*(m1+m2-1) * (n2*m2) )? That is not efficient.

        Alternatively, we can use nested loops over the translation and then over the original grid? But we already know that is O( (H_orig+H_r)*(W_orig+W_r) * H_orig*W_orig) and that was 1.6e9 for 100x100, which is too high.

        We must optimize the inner loop: instead of iterating over the entire original grid for each translation, we can iterate only over the cells that are in the original polyomino? The number of cells in the original polyomino is the area, say A. Then the work per translation is O(A). Then total for one rotation: O( (H_orig+H_r)*(W_orig+W_r) * A ). For R=C=100, the area A is at most 10000? Then 200*200 * 10000 = 400e6 per rotation, 1.6e9 for 4 rotations per test case, and 5 test cases: 8e9, which in C++ might be borderline in 1 second per 1e9 operations, but in Python it is too slow.

        Therefore, we need a better method.

        Insight: the set of translations that yield at least one overlap is sparse? Actually, no: we are already iterating over translations that are in the bounding box.

        Alternate insight: we can iterate over the cells of the original polyomino and for each cell, we consider the translations (dx,dy) that would make that cell overlap with the rotated polyomino. For a fixed cell (i,j) in the original, the translation (dx,dy) must be such that (i-dx, j-dy) is in the rotated polyomino. Then dx = i - x, dy = j - y, for some (x,y) in the rotated polyomino. Then we can:

            For one rotation, 
                For each cell (i,j) in the original polyomino:
                    For each cell (x,y) in the rotated polyomino:
                        dx = i - x
                        dy = j - y
                        then in the translation (dx,dy), the cell (i,j) is overlapped.

                Then we can accumulate:
                    num[dx,dy] += 1 if (i,j) is border_original
                    den[dx,dy] += 1 if (x,y) is border_rot

            But note: the same translation (dx,dy) will be hit by many (i,j) and (x,y).

        The total work is O( |S_original| * |S_rot| ). For R=C=100, |S_original| = 10000? Then 10000 * 10000 = 100e6 per rotation, and 4 rotations: 400e6 per test case, and 5 test cases: 2000e6 = 2e9, which is acceptable in C++ but in Python? 2e9 iterations in Python might take 20 seconds? We need to be faster.

        However, note: the polyomino is convex. The area of a convex polyomino is at most R*C, but the minimal bounding box is R*C, but the actual number of cells is the area. But convex polyominoes can have area up to R*C. 

        But worst-case: the entire grid is filled, so area = R*C. Then the work per rotation is (R*C) * (R*C) = (R*C)^2. For R=C=100, that is 10000^2 = 100e6 per rotation? Then 4 rotations: 400e6 per test case. Then 5 test cases: 2000e6, which is 2e9, and in Python we hope to do 1e7 per second? then 2e9 is 200 seconds. That is too high.

        Therefore, we must use a different approach.

        We can use a hash map for the translations:

            Let count_num = defaultdict(int)
            count_den = defaultdict(int)

            Then for each cell (i,j) in the original and for each cell (x,y) in the rotated polyomino:
                dx = i - x
                dy = j - y
                count_num[(dx,dy)] += 1 if (i,j) is border_original else 0
                count_den[(dx,dy)] += 1 if (x,y) is border_rot else 0

            Then we iterate over the keys in the dictionary, and for each key (dx,dy) that has count_num[.]>0 (meaning at least one overlap) and count_den[.]>0, we compute the fraction.

        The number of keys in the dictionary: it is the number of distinct (dx,dy) that come from (i-x, j-y) for (i,j) in S_original and (x,y) in S_rot. The number of distinct (dx,dy) is at most |S_original| * |S_rot|, but we are not iterating over distinct ones, we are iterating over all pairs.

        The work is the same as above: O(|S_original| * |S_rot|). Which is O( (R*C)^2 ) per rotation, and that is 100e6 per rotation for R=C=100, which is 400e6 for 4 rotations per test case, and 5 test cases: 2000e6 = 2e9 iterations, which is too slow in Python.

        We need to reduce the work per test case.

        Another idea: iterate by dx, and for each dx, use a sweep in dy? 

        However, note: the convexity might help? The polyomino is convex, so the set of points in the original and in the rotated are contiguous in each row.

        Specifically, for a fixed row i in the original, the cells are from left0[i] to right0[i]. Similarly, for the rotated polyomino in row x, the cells are from left_r[x] to right_r[x].

        Then for a fixed dx = i - x, then dy = j - y must be such that j in [left0[i], right0[i]] and y in [left_r[x], right_r[x]], and then j = y + dy.

        Therefore, for fixed i and x, then dy = j - y must be in [ left0[i] - right_r[x], right0[i] - left_r[x] ].

        And for each dy in that interval, the number of cells (j,y) that satisfy j = y+dy is the overlap in the segment: 

            j must be in [ max(left0[i], left_r[x]+dy), min(right0[i], right_r[x]+dy) ]
            and also y = j - dy must be in [left_r[x], right_r[x]].

        But note: for fixed i,x,dy, the number of j is: 
            L = max(left0[i], left_r[x] + dy)
            R = min(right0[i], right_r[x] + dy)
            then if L<=R, the number of j is R - L + 1.

        Then for the border: not every cell is border. We cannot use the segment of the row for border cells? The border cells might be scattered.

        Therefore, we cannot use this to count the border cells easily.

        Given the time, and the fact that the sum of R^3+C^3 is 10^7, which implies that most test cases are small, we can use the double loop over the cells for small test cases, and for larger ones use the convolution with FFT? But the problem says the sum of R^3+C^3 is 10^7, which is not directly the area.

        Let's bound the work for the double loop over cells for one test case:

            Work = 4 * (area_original * area_rot) = 4 * (area)^2, since area_original = area_rot = area.

            And area <= R*C.

            And the sum of R^3+C over test cases is 10^7.

            But note: R^3+C^3 for a test case is at least R*C? Not necessarily: if R=100, C=100, then R^3+C^3=2e6, while area=10000.

            We are doing 4 * (10000)^2 = 400e6 per test case, and the cost for this test case in the sum is 100^3+100^3=2e6, and we can have at most floor(10e6/2e6)=5 such test cases, then total work = 5 * 400e6 = 2000e6 iterations, which in Pyton might be 200 seconds? That is too slow.

        Therefore, we must use the FFT convolution method.

        Steps for one rotation using FFT for convolution in 2D:

            We have two 2D arrays: A (from the original: border cells) of size H_orig x W_orig, and B (from the rotated: the entire polyomino) of size H_r x W_r.

            We want to compute:
                num[dx,dy] = sum_{i,j} A[i][j] * B[i-dx][j-dy]   [but note: when i-dx or j-dy is out of bounds, we get 0]

            This is correlation. We can do:

                Pad A to size (H_orig+H_r-1) x (W_orig+W_r-1) with zeros.
                Flip B horizontally and vertically to get B_flipped: B_flipped[i][j] = B[H_r-1-i][W_r-1-j] for 0<=i<H_r, 0<=j<W_r.

                Then the correlation is the same as convolution of A and B_flipped.

            Similarly for den: 
                Let C be the entire original polyomino (1 where cell is present), and D be the border of the rotated polyomino.

                Then den[dx,dy] = sum_{i,j} C[i][j] * D[i-dx][j-dy]

                = convolution of C and (flipped D).

            We can use FFT to compute the convolution in O( (H_orig+H_r-1)*(W_orig+W_r-1) * log((H_orig+H_r-1)*(W_orig+W_r-1)) ).

            The size of the FFT is (H_orig+H_r-1) x (W_orig+W_r-1).

        How to do 2D FFT? 
            We can do 1D FFT on each row and then 1D FFT on each column.

        Given the constraints on the total sum of R^3+C^ being 10^7, and the number of test cases is up to 10^5, but the actual number of test cases that are large is at most 5 (because 100^3+100^3=2e6, and 10^7/2e6=5), we can do FFT for the few large test cases and for the small ones use the double loop over cells.

        Specifically, we can:

            For each test case:
                Compute the minimal bounding box for the original.
                Compute the area = number of cells.

                If area is small (say <= 200), then use the double loop over cells for the 4 rotations.
                Else, use FFT for the 4 rotations.

            The threshold 200: then area^2 = 40000 per rotation, 4 rotations = 160000 per test case, and if we have many test cases with area<=200, then 10^5 test cases * 160000 = 16e9, which is too high.

        Given the entire file sum of R^3+C^3<=10^7, the maximum area in a test case is bounded by R*C, and R^3+C^3>= R*C (only if R and C are at least 1). Actually, no: for R=1, C=100, then R^3+C^3 = 1+1000000=1000001, while area=100. 
        But the work for the double loop is 4 * area^2. For R=1, C=100, area=100, then work=40000 per test case. 
        How many test cases with R^3+C^3 = X can we have? The sum of X over test cases is 10^7.

        The work for the double loop for a test case is 4 * (R*C)^2.
        And we know R*C <= (R^3+C^3) because: 
            by AM>=GM: (R^3 + C^3) >= 2 * R^{3/2} * C^{3/2} = 2 (R*C)^{3/2}, 
            so (R*C)^{3/2} <= (R^3+C^3)/2, 
            so R*C <= ( (R^3+C^3)/2 )^{2/3}.

        For a test with R^3+C^3 = X, then area = R*C <= (X/2)^{2/3}.

        Then the work per test case is 4 * (X/2)^{4/3}.

        Then the total work over test cases: sum_{test cases} 4 * (X/2)^{4/3}.

        And we know sum_{test cases} X = 10^7.

        By Holder's inequality, the total work is at most 4 * (10^7) * ( (max (X/2)^{4/3-1} ) )? We can bound by assuming all X are about the same.

        Alternatively, we can worst-case: the maximum X is 10^7 (if there is only one test case), then R*C <= (10^7/2)^{2/3} = (5e6)^{2/3} ~ (5e6)^0.666. 5e6 is 5000000, then (5000000)^{2/3} = (5000000)^{0.666} ~ 5000 (since 5000^3=125e9, then (5000^3)^{2/3}=5000^2=25e6, which is greater than 5e6, so we try 292: 292^3=24.8e6, then (24.8e6)^{2/}=24.8e6^{2/3} = (24.8e6)^0.666 ~ (24.8e6)^{2/3} = (24.8)^{2/3} * (1e6)^{2/3} = about 2.9 * 100 = 290? and then (5e6)^{2/3} = (5)^{2/3} * (1e6)^{2/3} = about 3 * 100 = 300. So area <= 300.

        Then the work per test case is 4 * (300)^2 = 4*90000 = 360000.

        Then for the entire file, if there is one test case with X=10^7, work=360000.

        If there are many test cases, say T=10^5, then the sum of X=10^7, so the average X=100, then area for each test case is at most (100/2)^{2/3} = (50)^{2/3} ~ 13.5, then work=4*(13.5)^2 ~ 729 per test case, then total work=10^5 * 729 = 72.9e6, which is acceptable.

        Therefore, we can use the double loop over cells for all test cases.

        Algorithm for one test case:

            Read R, C, grid.

            Find the minimal bounding box for the grid: 
                rows = []
                for i in range(R): if there is '#' in grid[i], then include.
                then let r0 = first row with '#', r1 = last row with '#', c0 = first col with '#', c1 = last col with '#'.
                H = r1 - r0 + 1, W = c1 - c0 + 1.

            Extract the grid in [r0:r1+1, c0:c1+1] as a 2D array, call it grid0.

            Precompute the set of points for the original and border for the original:

                S0 = set()
                border0 = set()
                for i in range(H):
                    for j in range(W):
                        if grid0[i][j]=='#':
                            S0.add((i,j))
                            # check 8 neighbors: if any of the 8 directions is not in the grid0 or is '.', then border.
                            is_border = False
                            for dx in [-1,0,1]:
                                for dy in [-1,0,1]:
                                    if dx==0 and dy==0: continue
                                    ni, nj = i+dx, j+dy
                                    if 0<=ni<H and 0<=nj<W:
                                        if grid0[ni][nj]!='#':
                                            is_border = True
                                    else:
                                        is_border = True
                            if is_border:
                                border0.add((i,j))

            Generate the 4 rotations:

                rotations = [0, 90, 180, 270]
                For each rot in rotations:
                    if rot==0: 
                        S_rot = S0
                        border_rot = border0
                        # and the bounding box: [0,0] to [H-1, W-1]
                        H_rot = H
                        W_rot = W
                    else:
                        # Apply rotation to every point in S0 and border0.
                        if rot==90:
                            transform = lambda i,j: (j, H-1-i)
                        if rot==180:
                            transform = lambda i,j: (H-1-i, W-1-j)
                        if rot==270:
                            transform = lambda i,j: (W-1-j, i)
                        S_rot = set()
                        border_rot = set()
                        for (i,j) in S0:
                            p = transform(i,j)
                            S_rot.add(p)
                            if (i,j) in border0:
                                border_rot.add(p)
                        # Now find the minimal bounding box for S_rot:
                        if not S_rot: 
                            # skip, but guaranteed at least one cell?
                            continue
                        min_i = min(x for (x,y) in S_rot)
                        max_i = max(x for (x,y) in S_rot)
                        min_j = min(y for (x,y) in S_rot)
                        max_j = max(y for (x,y) in S_rot)
                        # Shift to (0,0):
                        S_rot_shifted = set()
                        border_rot_shifted = set()
                        for (x,y) in S_rot:
                            new_x = x - min_i
                            new_y = y - min_j
                            S_rot_shifted.add( (new_x, new_y) )
                        for (x,y) in border_rot:
                            new_x = x - min_i
                            new_y = y - min_j
                            border_rot_shifted.add( (new_x, new_y) )
                        S_rot = S_rot_shifted
                        border_rot = border_rot_shifted
                        H_rot = max_i - min_i + 1
                        W_rot = max_j - min_j + 1

            Then for this rotation, 
                We want to consider all translations (dx,dy) that are integers.
                dx can be from -H_rot+1 to H-1? Actually, the normalized grid for the original is [0, H-1] and for the rotated is [0, H_rot-1]. 
                In the normalized grid, the original cell (i,j) will have the rotated cell (i-dx, j-dy) in the normalized grid of the rotated, but we must have (i-dx, j-dy) in S_rot.

                We will use a dictionary: count_num = defaultdict(int), count_den = defaultdict(int)

                For each cell (i,j) in S0:
                    For each cell (x,y) in S_rot:
                        dx = i - x   # in the normalized grid of the original and the shifted rotated grid, respectively.
                        dy = j - y
                        if (i,j) in border0:
                            count_num[(dx,dy)] += 1
                        if (x,y) in border_rot:
                            count_den[(dx,dy)] += 1

                Then for each (dx,dy) in the union of keys of count_num and count_den:
                    if count_num[dx,dy] > 0 and count_den[dx,dy] > 0:
                        fraction = count_num[dx,dy] / count_den[dx,dy]   (but we will compare as integers)
                        update best_fraction if count_num[dx,dy] * best_den > best_num * count_den[dx,dy] (then it's greater)

            End for rotation.

            Then output the best_fraction as reduced fraction.

        But note: the same translation (dx,dy) might appear in multiple rotations? Yes, but we are iterating over rotations and updating the best_fraction over all rotations.

        Finally, reduce the fraction by gcd.

        However, note: the fraction might be the same from different rotations, but we only need the maximum.

        We must initialize best_num=0, best_den=1.

        After all rotations and translations, if we found no valid placement, then it is not possible, but the problem guarantee says it is not 0 or inf.

        Complexity: for one rotation, the work is |S0| * |S_rot|. Since |S0| = area, |S_rot| = area, then  area^2 per rotation, and 4 rotations: 4 * area^2.

        And as we argued, the area is bounded by ( (R^3+C^3)/2 )^{2/3}. And the sum of (R^3+C^3) over test cases is 10^7, so the total work is sum_{test cases} 4 * (area)^2 = 4 * ( (X/2)^{4/3} ) for X = R^3+C^3 of the test case.

        And we have sum_{test cases} X = 10^7.

        We hope that the constant factors and the bound on area will make it run in time.

        Let's test with sample: 
            Sample 1: 4x6 grid, all '#' -> area=24.
            Then work per test case = 4 * (24)^2 = 4*576 = 2304.

            Sample 2: 20x20 grid, but the polyomino is not full: the area is about 20*20 - 4 triangles? but actually, the area is 2*(1+3+5+7+9+10+10+10+10+10+10+10+9+7+5+3+1) ? 
                But the grid is symmetric: 
                rows: 
                    row0: 2
                    row1: 6
                    row2: 10
                    row3: 14
                    row4: 16
                    row5: 16
                    row6: 18
                    row7: 18
                    row8: 18
                    row9: 20
                    row10: 20
                    row11: 18
                    row12: 18
                    row13: 18
                    row14: 16
                    row15: 16
                    row16: 14
                    row17: 10
                    row18: 6
                    row19: 2

                Sum = 2+6+10+14+16+16+18+18+18+20+20+18+18+18+16+16+14+10+6+2 = 256.

                Then work = 4 * (256)^2 = 4 * 65536 = 262144.

            Then if we have 5 such test cases: 5 * 262144 = 1310720, which is acceptable.

        Therefore, we implement the double loop.

        Steps for one test case:

            Read T, then for each test case:
                R, C
                grid = [ input().strip() for _ in range(R) ]

            Find minimal bounding box: 
                r0 = 0
                while '#' not in grid[r0]: r0 += 1
                r1 = R-1
                while '#' not in grid[r1]: r1 -= 1
                # columns:
                c0 = min( j for i in range(R) for j in range(C) if grid[i][j]=='#')
                c1 = max( j for i in range(R) for j in range(C) if grid[i][j]=='#')

                H = r1 - r0 + 1
                W = c1 - c0 + 1
                grid0 = [ row[c0:c1+1] for row in grid[r0:r1+1] ]

            Build S0 and border0 as described.

            rotations = [0,90,180,270]
            best_num = 0
            best_den = 1

            for rot in rotations:
                if rot==0:
                    S_rot = S0
                    border_rot = border0
                    H_rot = H
                    W_rot = W
                else:
                    if rot==90:
                        f = lambda i,j: (j, H-1-i)
                    elif rot==180:
                        f = lambda i,j: (H-1-i, W-1-j)
                    elif rot==270:
                        f = lambda i,j: (W-1-j, i)
                    S_rot = set()
                    border_rot = set()
                    for (i,j) in S0:
                        x,y = f(i,j)
                        S_rot.add( (x,y) )
                        if (i,j) in border0:
                            border_rot.add( (x,y) )
                    # Now we shift to minimal bounding box for S_rot
                    if not S_rot: 
                        continue
                    min_i = min(x for (x,y) in S_rot)
                    max_i = max(x for (x,y) in S_rot)
                    min_j = min(y for (x,y) in S_rot)
                    max_j = max(y for (x,y) in S_rot)
                    # shift: subtract (min_i, min_j)
                    S_rot_shifted = set()
                    border_rot_shifted = set()
                    for (x,y) in S_rot:
                        nx = x - min_i
                        ny = y - min_j
                        S_rot_shifted.add( (nx,ny) )
                    for (x,y) in border_rot:
                        nx = x - min_i
                        ny = y - min_j
                        border_rot_shifted.add( (nx,ny) )
                    S_rot = S_rot_shifted
                    border_rot = border_rot_shifted
                    H_rot = max_i - min_i + 1
                    W_rot = max_j - min_j + 1

                # Now iterate over every cell in S0 and every cell in S_rot to generate translations (dx,dy)
                count_num = {}
                count_den = {}
                for (i,j) in S0:
                    for (x,y) in S_rot:
                        dx = i - x
                        dy = j - y
                        key = (dx,dy)
                        if key not in count_num:
                            count_num[key] = 0
                            count_den[key] = 0
                        if (i,j) in border0:
                            count_num[key] += 1
                        if (x,y) in border_rot:
                            count_den[key] += 1

                # Now for this rotation, consider each key that has count_den[key] > 0 (because the problem guarantee, and we require den>0)
                for key in count_num:
                    if count_den.get(key,0) > 0:
                        num_val = count_num[key]
                        den_val = count_den[key]
                        # Compare: if best_num * den_val < num_val * best_den, then update
                        if best_num * den_val < num_val * best_den:
                            best_num = num_val
                            best_den = den_val

            # After all rotations, reduce the fraction best_num/best_den
            g = gcd(best_num, best_den)
            best_num //= g
            best_den //= g
            print(f"{best_num}/{best_den}")

        We need a gcd function.

        Note: It is possible that the same translation (dx,dy) appears in multiple rotations? And we are iterating and updating the best fraction. That's fine.

        However, note: the same physical placement might be represented in different rotations? But we are iterating by rotation and then by translation.

        But note: a placement by rotation0 and translation (dx,dy) is different from rotation90 and translation (dx,dy). They are different placements.

        Therefore, we consider them separately.

        Let's test on the sample:

            Sample 1: 4x6, all '#' -> a rectangle.

            The border: 
                The border cells are all cells on the edge: 
                    top row: 6 cells
                    bottom row: 6 cells
                    left and right (excluding top and bottom): 2 * (4-2) = 4
                    total border = 6+6+4 = 16.

            How many border cells in the original: 16.

            Now, we try placement: same rotation (0°) and translation (0,0): then overlap is the entire polyomino.

                numerator = number of border cells of A that are in the overlap = 16.
                denominator = number of border cells of A1 that are in the overlap = 16.

                fraction = 1.

            But the sample output is 2/1.

            Therefore, there must be a placement that yields 2/1.

            What placements are there? 

            Consider a placement where we shift the copy to the right by 1 column.

            Then the overlap is the first 5 columns.

            For the original A, the border cells that are in the overlap: 
                The entire border of the original has 16 cells, but the rightmost column is not overlapped? 
                Actually, the shifted A1 covers columns 1 to 6 (if we shifted by 1 to the right) and the original is at columns 0 to 5. 
                Then the overlap is columns 1 to 5? 

            Alternatively, we can shift by (0,1): then the copy covers columns 1 to 6, and the original covers columns 0 to 5, so overlap is columns 1 to 5: a 4x5 rectangle.

            The border cells of A that are in the overlap: 
                In the original, the border cells are:
                  top row: [0,0] to [0,5] -> in overlap: [0,1] to [0,5] -> 5 cells (the first cell is not overlapped)
                  bottom row: similarly 5 cells.
                  left column: the entire left column is at column0, which is not overlapped? -> so no cell from left column in the overlap.
                  right column: the entire right column is at column5, which is overlapped? -> 2 cells (the top and bottom in the right column are already counted in the top and bottom rows) -> so the middle two: but wait, the border condition: the right column is border, but in the overlap? 
                  Actually, the cell (0,5) is counted in the top row, (1,5) is border? 
                  But note: the border condition: a cell is border if any of the 8 neighbors is missing. For the cell (1,5) in the original: 
                      it has a neighbor to the right? In the original, at (1,6) is not present? So (1,5) is border. But in the overlap, the copy A1 is placed at (0,1) meaning that the copy's column0 corresponds to the original's column1? 
                  The overlap in the original is the region [0,1] to [3,5] (if the grid is 4x6: rows0..3, cols0..5). Then the cell (1,5) is in the overlap.

                  Actually, the entire rectangle [0,1] to [3,5] is overlapped.

            How many border cells of A are in the overlap?

                The border cells in the original that are in columns 1 to 5:

                    Top row: [0,1] to [0,5]: 5 cells (all border) -> but the cell (0,1) to (0,5) are border? yes, because top row is border.
                    Bottom row: [3,1] to [3,5]: 5 cells.
                    Left column: (1,0) and (2,0) are not in the overlap? 
                    Right column: (0,5) and (3,5) are already counted in the top and bottom rows. 
                    The inner part: (1,5) and (2,5): these are border because they are on the right edge? and (1,0) and (2,0) are not in the overlap.

                    Additionally, the left edge of the overlap: column1? 
                      The cells (0,1) and (3,1) are already counted in the top and bottom rows.
                      The cells (1,1) and (2,1): are they border? 
                         For (1,1): 
                            It has a neighbor to the left: (1,0) which is in the original? but in the overlap? the overlap does not include (1,0) because the copy is shifted to the right by 1. But the border condition is defined on the entire polyomino, not the overlap. 
                         In the original polyomino, the cell (1,0) exists? (the entire grid is filled) -> so (1,1) has a left neighbor (1,0) which is present, but does it have a top-left neighbor? (0,0) is present, top: (0,1) present, top-right: (0,2) present, right: (1,2) present, bottom: (2,1) present, bottom-left: (2,0) present, left: (1,0) present. 
                         So (1,1) is not a border cell? 

                    Therefore, the border cells in the overlap are: 5 (top) + 5 (bottom) + 2 (the right column: (1,5) and (2,5))? 
                        But (1,5) and (2,5) are not already counted? 
                        Actually, the top row includes (0,5) and the bottom row includes (3,5). The right column has the two cells (1,5) and (2,5). 
                        So total = 5+5+2 = 12.

            Now, for the denominator: the border cells of A1 that are in the overlap.

                A1 is the same as A, but shifted by (0,1). In the coordinate system of the original, the copy A1 has cells at (i, j+1) for (i,j) in the original.

                The border cells of A1: the entire border? So 16 cells.

                Now, the overlap in the original grid is the region that is in both A and A1: which is columns 1 to 5.

                For A1, a border cell is a cell that is on the border of A1. Then we require that cell to be in the overlap, i.e., the cell (i, j+1) must be in the original A? 
                    The original A has columns 0 to 5, so the cell (i, j+1) is in the original A if 0<=j+1<=5 -> j from 0 to 4.

                So the border cells of A1 that are in the overlap are:

                    The border cells of A1 that are in columns 1 to 5 (in the original grid) and rows 0 to 3.

                But how are the border cells of A1 defined? 
                    The polyomino A1 is a 4x6 rectangle, so its border cells are:
                        top: (0,0) to (0,5) in A1's own coordinate? Then shifted by (0,1) in the original grid: (0,1) to (0,6) -> but in the overlap we only have (0,1) to (0,5) -> 5 cells.
                        bottom: (3,0) to (3,5) in A1 -> in the original: (3,1) to (3,6) -> in the overlap: (3,1) to (3,5) -> 5 cells.
                        left: (1,0) and (2,0) in A1 -> in the original: (1,1) and (2,1) -> both in the overlap.
                        right: (1,5) and (2,5) in A1 -> in the original: (1,6) and (2,6) -> not in the original grid (which only goes to column5), so not in the overlap.

                Therefore, the denominator = 5+5+2 = 12.

                Then the fraction = 12/12 = 1.

            Why sample output is 2/1?

            Let me read the sample output: 
                2/1
                1/1

            The first test case is a 4x6 full grid.

            What placement yields 2/1? 

            Consider a placement where we rotate by 0° and shift by (0,0): then we get 16/16=1.

            Consider a placement where we rotate by 0° and shift by (0,2): then overlap is columns 2 to 5: 4 columns.

                numerator: border cells of A in the overlap:
                    top row: 4 cells (columns 2,3,4,5)
                    bottom row: 4 cells
                    right column: (1,5) and (2,5) -> 2 cells
                    total = 4+4+2 = 10.

                denominator: border cells of A1 (shifted by (0,2)) in the overlap:
                    A1 is at columns 2 to 7. The overlap with the original (columns 0 to 5) is columns 2 to 5.
                    border cells of A1 that are in the overlap:
                         top: (0,2) to (0,5): 4
                         bottom: (3,2) to (3,5): 4
                         left: (1,2) and (2,2) are in the overlap? 
                         right: (1,7) and (2,7) are not in the overlap.
                    so denominator = 4+4+2 = 10.

                fraction=1.

            Try a placement with rotation 0° and shift by (0, -1) (to the left by 1): 
                Then A1 covers columns -1 to 4.
                Overlap: columns 0 to 4.

                numerator: 
                    top: 5 cells (0,0) to (0,4)
                    bottom: 5 cells
                    left column: (1,0) and (2,0) -> 2 cells (because the left column is now covered by the copy? but in the original, the left column is border and is in the overlap: yes, because the overlap includes column0).
                    and the right column at column5 is not in the overlap.
                    total = 5+5+2 = 12.

                denominator:
                    A1 is at columns -1 to 4. The border cells of A1 that are in the overlap (columns0 to4) in the original:
                         top: 5 cells (0,0) to (0,4) in the original -> which for A1 are at (0,1) to (0,5) in A1's own grid? 
                             Actually, the shift is (0,-1): a cell (x,y) in A1 is placed at (x, y-1) in the original.
                             So to be in the overlap, the cell in the original must be in [0,4] for columns. 
                             The top row of A1: (0,0) in A1 -> (0,-1) in original (not in overlap), (0,1) in A1 -> (0,0) in original, (0,2)->(0,1), ... (0,5) in A1 -> (0,4) in original -> 5 cells.
                         bottom: 5 cells.
                         left: in A1, the left column is at y=0, placed at (1, -1) and (2,-1): not in the overlap.
                         right: in A1, the right column is at y=5, placed at (1,4) and (2,4) -> which are in the overlap? 
                             But the right column of A1 is border? 
                             The cell (1,5) in A1 is at (1,4) in the original -> which is in the overlap. Similarly (2,5) in A1 is (2,4) in the original -> in the overlap.
                         so denominator = 5+5+2 = 12.

                fraction=1.

            What if we use a 180° rotation? 

            When we rotate the copy 180°, and place it at (0,0) (so aligned with the original), then the overlap is the entire grid.

            For the numerator: the border cells of A in the overlap: 16.
            For the denominator: the border cells of the rotated copy in the overlap: 
                The rotated copy is also a 4x6 rectangle, and its border cells are also 16.
            fraction=1.

            What if we shift the 180° rotated copy by (0,0) -> aligned, then try (0,1)? 

            The 180° rotation: a cell (i,j) in the original becomes (3-i,5-j) in the rotated copy.
            Then when we place the rotated copy by (0,1) in the original grid, the cell (i,j) in the original grid will be covered by the rotated copy if and only if the rotated copy has a cell at (i, j) and also the rotated copy's cell at (3-i,5-j) is placed at (3-i+0, 5-j+1) in the original grid? Actually, we have to be careful.

            Alternatively, the placement: 
                The rotated copy is represented in its own normalized grid. We then shift it by (dx,dy). 
                How we did: 
                  We have the rotated set in its normalized grid (shifted to (0,0)). Then the cell (x,y) in the normalized grid of the rotated poly is placed at (x+dx, y+dy) in the original normalized grid.

                But then the overlap: a cell (i,j) in the original grid is covered if (i-dx, j-dy) is in the rotated set.

            For the 180° rotation: 
                Without shift: 
                    (i,j) in the original -> in the rotated set we have (3-i,5-j) [in the unshifted rotated grid] but then we shifted the rotated set to (0,0)? 
                    How did we shift the rotated set? 
                        The rotated set from 180°: 
                          min_i = min(3-i for i in [0,3]) = 0? 
                          max_i = 3? 
                          So we shift by (0,0): the normalized grid is the same.

                So the rotated set in normalized grid is: {(3-i,5-j) for (i,j) in the original}.

            Now, if we shift the rotated copy by (dx,dy), then the cell (i,j) in the original is covered if (i-dx, j-dy) is in the rotated set, i.e., (i-dx, j-dy) = (3-i0,5-j0) for some (i0,j0) in the original, but actually we have the entire set.

            Specifically, we require that there exists a cell (i0,j0) in the original such that 3-i0 = i-dx and 5-j0 = j-dy.

            Or: i0 = 3 - (i-dx) = 3-i+dx
                j0 = 5 - (j-dy) = 5-j+dy

            And (i0,j0) must be in the original grid, i.e., in [0,3]x[0,5].

            For the shift (dx,dy) = (0,0): then i0=3-i, j0=5-j, which is in the original.

            For shift (dx,dy) = (0,1): 
                i0 = 3 - i + 0 = 3-i
                j0 = 5 - j + 1 = 6-j
                But j0 must be in [0,5] -> 6-j in [0,5] -> j in [1,6] -> but j is in [0,5] -> so j0=6-j in [1,6] -> but j0 must be at most 5, so j0=6 only when j=0? then j0=6, which is out of bounds.

            We must try (0,1) in the normalized grid.

            How about (dx,dy) = (0,1): 
                then for (i,j) = (0,0) in the original: 
                    we check (x,y) = (0-0, 0-1) = (0,-1) -> not in the rotated set.

            Let me do the overlap region: 
                The rotated copy is placed at (0,1) in the original grid: so the top-left of the rotated copy's normalized grid is at (0,1) in the original grid.
                The rotated copy is a 4x6 grid, so it covers rows [0,3] and columns [1,6] in the original grid.

                The original grid is [0,3]x[0,5]. Overlap: [0,3]x[1,5] -> a 4x5 grid.

            Now, for the numerator: border cells of A in the overlap: 
                top row: 5 cells (0,1..5)
                bottom row: 5 cells
                right column: (0,5) and (3,5) are counted in the top and bottom; (1,5) and (2,5) -> 2 cells.
                left column: (0,0) is not in the overlap; (1,0) and (2,0) not in the overlap; (3,0) not in the overlap.
                total = 5+5+2 = 12.

            For the denominator: border cells of the rotated copy in the overlap: 
                The rotated copy is a 4x6 grid, but we rotated 180°: so the border cells are the same as the original: 16 cells.
                But which ones are in the overlap (which is the region [0,3]x[1,5] in the original grid)?

                The rotated copy's normalized grid: 
                  cell (0,0) in the rotated copy -> placed at (0+0,0+1) = (0,1) in the original.
                  cell (0,5) in the rotated copy -> placed at (0,6) -> not in the overlap.
                  cell (3,0) in the rotated copy -> placed at (3,1) in the original.
                  cell (3,5) in the rotated copy -> placed at (3,6) -> not in the overlap.

                The border cells of the rotated copy in the overlap:
                  In the rotated copy, the border cells are:
                    top row: (0,0) to (0,5) -> in the overlap: (0,1) to (0,5) -> 5 cells? 
                        but (0,0) is at (0,1) in the original? -> (0,0) in the rotated copy is placed at (0,1) in the original -> that's in the overlap.
                        (0,1) in the rotated copy -> (0,2) in the original -> in the overlap.
                        ... (0,5) in the rotated copy -> (0,6) -> not in the overlap.
                    so only (0,0) to (0,4) in the rotated copy are in the overlap? -> 5 cells? 
                        (0,0): (0,1)
                        (0,1): (0,2)
                        (0,2): (0,3)
                        (0,3): (0,4)
                        (0,4): (0,5)
                        (0,5): (0,6) -> not
                    so 5 cells.

                  bottom row: (3,0) to (3,5) -> placed at (3,1) to (3,6) -> in the overlap: (3,1) to (3,5) -> 5 cells.
                  left column: in the rotated copy, left column is (1,0) and (2,0) -> placed at (1,1) and (2,1) -> in the overlap.
                  right column: in the rotated copy, (1,5) and (2,5) -> placed at (1,6) and (2,6) -> not in the overlap.

                total = 5+5+2 = 12.

            fraction=1.

            How to get 2/1? 

            The sample output for the first test is 2/1.

            After rethinking: the problem says: 
                numerator: number of cells on A’s border and inside A1.
                denominator: number of cells on A1’s border and inside A.

            What if we place the copy A1 (0° rotation) shifted by (1,0) (down by 1)? 

            Overlap: rows 1 to 3, columns 0 to 5.

            For A's border in the overlap: 
                top row: row0 is not in the overlap -> so no cell from the top row.
                bottom row: row3: 6 cells.
                left column: (1,0) and (2,0) -> 2 cells.
                right column: (1,5) and (2,5) -> 2 cells.
                and the new top row in the overlap: row1: are they border? 
                    (1,0) and (1,5) are border (already counted) and (1,1..4): 
                    (1,1) has all 8 neighbors? so not border.
                total = 6 + 2 + 2 = 10.

            For A1's border in the overlap: 
                A1 is shifted by (1,0): so placed at row1..4 (but the original only has rows0..3), so rows1..3.
                In the overlap: rows1..3, columns0..5.

                The border cells of A1 in the overlap:
                    In A1, the border cells are the entire border of the 4x6 grid.
                    But we only have rows1..3: 
                         top row of A1 (row0 in A1) is at (1,0) to (1,5) in the original -> in the overlap.
                         bottom row of A1 (row3 in A1) is at (4,0) to (4,5) -> not in the overlap.
                         left column: (1,0) and (2,0) in the overlap, and (3,0) in A1 is at (4,0) -> not.
                         right column: (1,5) and (2,5) in the overlap, and (3,5) -> not.
                    so only the top row of A1 and the left and right (excluding the bottom) are in the overlap: 
                         top row: 6 cells.
                         left: (2,0) -> we have (1,0) and (2,0) -> but (1,0) is in the top row? -> in the top row we have (1,0) to (1,5). Then the left column: (2,0) and (3,0) -> but (3,0) is not in the overlap, so only (2,0) and similarly only (2,5) for the right.

                    Actually, the top row includes (1,0) and (1,5). The left column also includes (2,0) and the right includes (2,5).

                    total = 6 (top row) + 2 (left and right of the non-top rows) = 8? 
                         because (1,0) and (1,5) are in the top row, and (2,0) and (2,5) are additional.

                So 6 + 2 = 8.

            Fraction = 10/8 = 5/4.

            Not 2.

            What if we shift to the right and down? 

            After checking online: the sample might be the full grid 4x6. The official solution might have a known answer.

            Known from the sample output: 2/1.

            Insight: try a placement with a different rotation. How about 90°.

            90° rotation: 
                transform: (i,j) -> (j, 3-i)   [if the original has H=4, then H-1-i = 3-i]

            Then the set becomes: 
                The grid becomes 6x4.

            Now, if we place the 90° rotated copy with shift (0,0): then the to-be-placed cell (0,0) of the rotated copy goes to (0,0) in the original.

            The overlap might be only the cell (0,0) if the grids are not aligned properly? 

            To have maximum overlap, we might shift so that the entire grid is covered? 

            Let me coordinate-transform the original grid of 4x6 to a 6x4 grid for the rotated copy.

            Example: the cell (0,0) in the original becomes (0,3) in the rotated copy? 
                for 90°: (i,j) -> (j, H-1-i) = (0, 3) -> so the normalized grid for the rotated copy will be from (0,0) to (5,3)? 
                But we have to shift to minimal bounding box: min_i=0, min_j=0, so no shift.

            Then when we place the rotated copy by (dx,dy), the cell (i,j) in the original is covered if (i-dx, j-dy) is in the rotated set.

            Specifically, for (dx,dy)=(0,0): 
                (i,j) in the original is covered if (0,3) is in the rotated set? 
                But the rotated set has the cell (0,3) (which is the rotation of (0,0)) -> yes.

            But the overlap is only the cells that are in the original and whose rotated image is in the rotated set at the same time. 
                The cell (0,0) in the original is in the overlap if (0,0) in the rotated set? -> (0,0) in the rotated set is the rotation of which cell? 
                    (i,j) such that (j,3-i) = (0,0) -> j=0, i=3 -> so the cell (3,0) in the original.

            This is getting complicated.

            Alternatively, we can try a specific shift: 
                Let the normalized grid for the rotated copy be 6x4. 
                We place it at (dx,dy) in the original grid's normalized grid (4x6).

                The overlap: 
                    We require (i,j) in [0,3]x[0,5] for the original and (x,y) in [0,5]x[0,3] for the rotated copy, and (x,y) = (i-dx, j-dy).

                This is a system: 
                    x = i - dx
                    y = j - dy
                    0<=x<6, 0<=y<4.

                For example, if we choose (dx,dy) = (0,0), then the overlap is the set of (i,j) in the original such that (i,j) is also in the rotated set? 
                    But the rotated set in the normalized grid is the set of (j,3-i) for (i,j) in the original.

                So the overlap is the set of (i,j) in the original for which (i,j) = ( some j0, 3-i0 ) for some (i0,j0) in the original.

                For the full grid, the overlap is the set of (i,j) such that i in [0,3] and j in [0,5] and also j in [0,3] and 3-i in [0,5] -> always true, but also (i,j) = (j0,3-i0) for some (i0,j0). 
                    This means that i = j0 and j = 3-i0, and i0 in [0,3], j0 in [0,5] -> so j = 3-i0 in [0,3] and i in [0,5]. 
                    But i = j0 must be in [0,5] and the original has i in [0,3] -> so i in [0,3], and j = 3-i0 in [0,3] -> i0 in [0,3] (which it is).

                So the overlap is the set of (i,j) = (j0, 3-i0) for some (i0,j0) in the original. But note: not every (i,j) in the overlap region is necessarily in the rotated set: we need (i,j) to be in the set of the rotated copy.

                Specifically, the rotated set is { (j,3-i) for (i,j) in the original }.

                So the cell (i,j) in the original is in the overlap if (i,j) is in the rotated set. 
                Example: (0,0) in the original: is it in the rotated set? 
                    The rotated set has (0,3) -> not (0,0).
                (0,3) in the rotated set, so the cell (0,3) in the original grid is in the overlap? 
                    But we require (i,j) in the original to be (0,3) -> then (0,3) is in the original? yes.
                    and (0,3) in the original is in the rotated set? 
                        because the rotated set has (j,3-i) for (i,j) in the original: for (3,0) in the original: rotated is (0,3-3)= (0,0) -> not (0,3).
                How to get (0,3) in the rotated set? 
                    (0,3) = (j,3-i) -> then j=0, 3-i=3 -> i=0.
                    So the cell (0,0) in the original becomes (0,3) in the rotated set.
                    Therefore, the rotated set does not contain (0,3) (as a cell in its normalized grid) unless there is a cell (0,0) in the original.

                But it does: the rotated set does contain (0,3) because the cell (0,0) in the original is rotated to (0,3).

                Therefore, the cell (0,3) in the original grid is not in the rotated set? 
                  In the rotated set, the cell (0,3) is present, but when we place the rotated copy at (0,0), the cell (0,3) in the rotated copy's grid is placed at (0+0,3+0)=(0,3) in the original grid. 
                  So the cell (0,3) in the original grid is covered.

                How to see the set of overlap? 
                  We need the cell (0,3) in the original grid and the cell (0,3) in the rotated copy at (0,0) cover the cell (0,3) in the original grid.

                Therefore, the overlap is the set of cells (i,j) in the original grid for which the cell (i,j) is also in the set of the rotated copy. 
                  But the rotated copy's set in the original grid is { (x,y) such that (x-dx, y-dy) in rotated set } = { (x,y) such that (x,y) in rotated set } since (dx,dy)=(0,0) and the rotated set is not shifted in this placement? 
                  Actually, we shifted the rotated set to its own normalized grid, so the set of cells of the rotated copy in the original grid is { (x+0, y+0) for (x,y) in rotated set } = rotated set.

                So overlap = S0 ∩ S_rot.

                For the full grid, S0 = {(i,j) for i in [0,3], j in [0,5] }
                S_rot = {(j,3-i) for i in [0,3], j in [0,5] } = { (j,3-i) for j in [0,5], i in [0,3] } = [0,5]x[0,3] (since 3-i in [0,3]).

                So the overlap is [0,3]x[0,5] ∩ [0,5]x[0,3] = [0,3]x[0,3] (because in the original grid, j in [0,3] and i in [0,3] and in the rotated set the x in [0,5] and y in [0,3], but in the original grid we have i in [0,3] and j in [0,3] from the intersection).

                So a 4x4 grid.

            For the numerator: border cells of A in the overlap (4x4 grid at [0,3]x[0,3]):
                The border cells of A in the overlap are: 
                    top row: 4 cells
                    bottom row: 4 cells
                    left column: 2 cells (i=1,2 at j=0) 
                    right column: 2 cells (i=1,2 at j=3) 
                total = 4+4+2+2 = 12.

                But wait, the cell (0,0) has all 8 neighbors in the overlap? 
                  In the overlap region, the cell (0,0) in the original: 
                    neighbors: (0,1), (1,0), (1,1) are in the overlap? 
                  But the overlap only goes to (3,3), so (0,0) is border because of the neighbor (0,-1) and (-1,0) which are not in the polyomino at all? 
                  -> The border condition is defined on the entire polyomino, not the overlap. 
                  In the entire polyomino, the cell (0,0) is border because (0,-1) is not present.
                  So we count it.

                Therefore, the border cells in the overlap are: 
                    the entire outline of the 4x4 grid: 
                      top row: 4 cells
                      bottom row: 4 cells
                      left column: 4-2 = 2 cells (because the top and bottom are already counted) -> wait, typically we count the corners only once.
                  But our definition: a cell is border if any of the 8 neighbors is missing. 
                    The cell (0,0) is border: count.
                    (0,1): border? in the entire polyomino, the neighbor (0,2) is present, (1,0) present, (1,1) present, ... but the neighbor (0,-1) is missing -> border.
                    (0,2): similarly, (0,3) is present, (0,1) present, (1,2) present, ... but (0,4) is present? -> wait, the overlap is only to j=3, but the entire polyomino has j=4? 
                    The entire polyomino has j in [0,5], so for (0,2) in the overlap: 
                       it has a neighbor at (0,3) (present), (0,1) (present), (1,2) (present), ... and also (0,2) has a neighbor ( -1,2) missing? -> no, it has a neighbor (0,3) present. 
                    The cell (0,2) in the entire polyomino: 
                       it has a neighbor at (0,3) (present), (0,1) (present), (1,2) (present), (1,1) (present), (1,3) (present), (0,1) (present), and ( -1, anything) is missing? -> the cell (0,2) is on the top edge, so it has no top neighbor -> so it is border.

                  Therefore, the entire top row and bottom row are border. 
                  The left column: (1,0) and (2,0) are border? 
                     (1,0): in the entire polyomino, it has a neighbor at (0,0) (present), (0,1) (present), (1,1) (present), (2,0) (present), (2,1) (present), (0,-1) missing -> border.
                  Similarly, (1,3) in the overlap: it is not on the edge of the entire polyomino? -> the entire polyomino has columns up to 5, so (1,3) has a neighbor at (1,4) (present) -> but wait, the cell (1,4) is in the entire polyomino, so (1,3) is not on the border of the entire polyomino? 
                     Let's check: 
                         cell (1,3): 
                             has a neighbor at (0,2), (0,3), (0,4), (1,2), (1,4), (2,2), (2,3), (2,4) -> all should be present in the entire polyomino? 
                             -> it is not on the border.

                  Therefore, in the overlap for the original A, the border cells are:
                      all cells in the first row and last row and first column, and the last column only the corners are already counted, and the last column has cells (0,3) and (3,3) counted in the top and bottom, and the cell (1,3) and (2,3) are not border.

                  Specifically, the only border cells in the overlap are:
                      the entire first row: (0,0) to (0,3): 4 cells.
                      the entire last row: (3,0) to (3,3): 4 cells.
                      the first column: (1,0) and (2,0): 2 cells.
                  What about the last column? 
                      (0,3) and (3,3) are in the first and last row.
                      (1,3): not border in the entire polyomino? -> as argued, not.
                      (2,3): not.
                  total = 4+4+2 = 10.

            For the denominator: border cells of A1 ( the rotated copy) in the overlap: 
                A1 is the rotated set, and we placed it at (0,0) in the original grid.
                The overlap in the original grid is [0,3]x[0,3] (4x4), which in the rotated copy's own cells means: 
                    A1's cell (x,y) placed at (x,y) in the original grid is in the overlap if (x,y) in [0,3]x[0,3].
                The border cells of A1: defined on the entire rotated polyomino, which is 6x4. 
                In the overlap region (4x4) for the original grid, which corresponds to A1's cells in [0,3]x[0,3] (because placed at (0,0)), 
                we need the border cells of A1 in its own structure that are in this region.

                The cell (0,0) in A1: in the entire rotated polyomino (6x4) -> 
                    it is a corner: missing top-left and left and top -> so border.
                (0,1): border.
                (0,2): border.
                (0,3): border.
                (1,0): border.
                (1,3): border.
                (2,0): border.
                (2,3): border.
                (3,0): border.
                (3,1): in the entire rotated polyomino, does it have all neighbors? 
                    It is in the and of the rotated polyomino: the rotated polyomino is 6x4, so (3,1) is not on the border? 
                    Check: the rotated polyomino is full, so (3,1) has all 8 neighbors within the 6x4 grid? 
                        neighbors: (2,0) to (4,2) -> which are within [0,5]x[0,3]? 
                        (3,1) has a neighbor (4,1) -> present, (2,1) present, (3,0) present, (3,2) present, (2,0) present, (2,2) present, (4,0) present, (4,2) present.
                    So (3,1) is not a border cell.
                Similarly, (3,2) is not.

                Therefore, the border cells in the overlap for A1 are: 
                    (0,0) to (0,3) -> 4 cells.
                    (1,0), (1,3) -> 2 cells.
                    (2,0), (2,3) -> 2 cells.
                    (3,0) -> 1 cell.   [ (3,1) and (3,2) are not border; (3,3) is border? 
                        (3,3): has a neighbor (4,3) -> which is in the rotated polyomino? the rotated polyomino is 6x4, and (4,3) is within bounds -> present. 
                        also (3,2) present, (2,3) present, (4,2) present, (2,2) present, etc. 
                        so (3,3) is not on the border? 

                So only the left column: (0,0),(1,0),(2,0),(3,0) and the right column only (0,3),(1,3),(2,3) [ (3,3) is not counted because not border] 
                and the top row: (0,0)..(0,3) already counted, and the bottom row: (3,0) counted and (3,3) not counted.

                Specifically, we have: 
                    (0,0), (0,1), (0,2), (0,3), (1,0), (1,3), (2,0), (2,3), (3,0) -> 9 cells.

            Fraction = 10/9.

            This is not 2/1.

            After more thought, I found a known solution to a similar problem: 
                https://github.com/ackoroa/UVa-Solutions/blob/master/UVa%2012279%20-%20Digital%20Search%20again/UVa%2012279%20-%20Digital%20Search%20again.cpp
            might not be the same.

            Or the sample might be: 
                Input: 4x6 of all '#' -> output 2/1.

            Another idea: try a placement with 0° and shift by (0,3) ( to the right by 3) for the 4x6 grid.

            Overlap: 3 columns (3..5) -> 4x3.

            Numerator: border cells of A in the overlap: 
                top row: 3 cells (0,3), (0,4), (0,5)
                bottom row: 3 cells
                right column: (1,5) and (2,5) -> 2 cells.
                total = 3+3+2 = 8.

            Denominator: border cells of A1 in the overlap: 
                A1 is shifted to the right by 3: 
                    top row: (0,3) to (0,5) in the overlap -> 3 cells.
                    bottom row: (3,3) to (3,5) -> 3 cells.
                    right column: (1,5) and (2,5) in the overlap -> 2 cells.
                    left column: (1,3) and (2,3) in the overlap, but are they border in A1? 
                         in A1, the left column is at j=3, and for the cell (1,3) in A1: in the entire polyomino, it has a left neighbor at j=2? which is not present in the overlap? 
                         but in the entire polyomino of A1, the left neighbor of (1,3) is (1,2) -> which is not in the overlap, but it is in the polyomino? -> the entire polyomino is 4x6, so (1,2) is in the polyomino -> so (1,3) is not a border cell of A1.
                Therefore, only the top, bottom, and right are border in the overlap: 3+3+2 = 8.

            Fraction = 8/8=1.

            I give up. The known sample output is 2/1 for the 4x6 grid. 

            Perhaps the intended solution is to use 0° and a shift of (0,0) for the first test and the sample might be 
                Input: 
                   2
                   4 6
                   ######
                   ######
                   ######
                   ######
                   20 20
                   ... (as given) 
                and the output:
                   2/1
                   1/1

            and the first test case might be not the full grid? 
                But the sample input says "4 6" and then 4 lines of 6 '#'.

            Or the border cell definition: the problem says "not all of its 8 adjacent cells are other squares". In the full grid, inner cells are not on the border. 
                For a full 4x6 grid, the border cells are only the outer cells. 
                number of border cells = 4*6 - (4-2)*(6-2) = 24 - 2*4 = 16.

            Then in the placement of the sample solution for the first test case: 
                numerator = 12, denominator = 6 -> 2/1.

            How to get 12 and 6? 
                (0,0) in the border0: 12
                (0,0) in the border_rot: 6

            We need to find a placement where the overlapping region contains 12 border cells of A and 6 border cells of A1.

            Try a placement with 0° and shift by (0,0) for a 2x3 rectangle within the 4x6? 

            Finally, we note that the we must output 2/1 for the first sample, and 1/1 for the second. 
            Since we have the double loop and we try everything, we trust that it will work.

            We output the code as described.

            Note: the second sample is a cross, and the sample output is 1/1.

        Let's hope.

        We'll run the sample through the code.

        For the first sample: 4x6 full grid.

        Steps:

          minimal bounding box: H=4, W=6.

          border0: 
            for each cell in the grid, if it is on the edge then border, else not.
            The edge: i=0 or i=3 or j=0 or j=5.

            So border0 = 16 cells.

          Then for each rotation: we try 0°, 90°, 180°, 270°.

          For 0°: 
             S_rot = S0, border_rot = border0.
             then we do double loop over S0 (24 cells) and S0 (24 cells) -> 24*24 = 576 iterations per rotation.

          For a translation (dx,dy) = (0,0): 
             for each cell in S0: 
                 for each cell in S0: 
                    dx = i - x, dy = j - y.
                    then for the cell (i,j) in the border0 -> add to count_num[ (0,0) ]: for each (x,y) in the loop, if (i,j) is border, we add 1 for every (x,y). 
                    similarly for border_rot: if (x,y) in border0, then add 1 for every (i,j) in the loop.

             Specifically, for (0,0): 
                 count_num[ (0,0) ] = 16 * 24 = 384   [ because for each of the 24 (x,y) in the rotated set, and for each (i,j) in the border0 (16 cells), we add 1 for the cell (i,j) in the border0.
                 count_den[ (0,0) ] = 24 * 16 = 384.

             fraction = 384/384 = 1.

          For (0,0) in the 0° rotation, we have fraction=1.

          For (dx,dy) = (0,1) in 0°: 
             count_num[ (0,1) ] = for each cell in S0: 
                 for each cell in S0: 
                    dx = i - x, dy = j - y = 1 -> only when j-y=1.
                    and if (i,j) in border0: then add 1.
             How many pairs (i,j) in border0 and (x,y) in S0 such that j-y=1 and also the cell (x,y) must be in the rotated set (which it is) and also the translation is (0,1) -> then we require j-y=1.

             But we are iterating over all (x,y) in S0, for a fixed (i,j) in border0, then dy = j-y = 1, so y = j-1.

             For a fixed (i,j) in border0, how many (x,y) in S0 such that y = j-1? 
                 in the full grid, in row x there is one cell with y = j-1, and there are 4 choices for x.

             So for a fixed (i,j) in border0, there are 4 cells (x,y) such that y = j-1.

             Then count_num[ (0,1) ] = (number of (i,j) in border0) * 4 = 16 * 4 = 64.

             Similarly, count_den[ (0,1) ] = for each (i,j) in S0 and (x,y) in border0 such that j-y=1 -> 
                 for each (x,y) in border0, and for each (i,j) in S0, if j-y=1, then add 1 if (x,y) in border0.
                 = (number of (x,y) in border0) * (number of (i,j) in S0 such that j is free, but for a fixed (x,y), we need j = y+1, and j in [0,5] and then there are 4 choices for i) 
                 = 16 * 4 = 64.

             fraction = 64/64 = 1.

          We try (0,0) in 90°: 
             The rotated set is 6x4, and area=24.
             For (dx,dy) = (0,0): 
                 count_num = for (i,j) in border0 (16 cells) and for (x,y) in the rotated set (24 cells) such that dx=i-x=0, dy=j-y=0 -> only when (i,j) = (x,y) in the normalized grid? 
                    but the rotated set has different structured: we need to see if (i,j) = (x,y) and (x,y) in the rotated set.
                 How many (i,j) in border0 for which there exists (x,y) in the rotated set with i=x and j=y? 
                    count_num[ (0,0) ] = for each (i,j) in border0, and for each (x,y) in the rotated set, if i-x==0 and j-y==0.
                    = for each (i,j) in border0, if (i,j) is in the rotated set, then there is at least one cell (x,y)=(i,j) in the rotated set, and in fact, there is exactly one.
                    So count_num[ (0,0) ] = number of (i,j) in border0 that are in the rotated set.

                 What is the rotated set for 90°: 
                    (i,j) in the original -> (j,3-i) in the rotated set.
                 So the set of cells in the rotated set: { (j,3-i) for i in [0,3], j in [0,5] } = a 6x4 grid.

                 The border0: cells in the original with i=0,3 or j=0,5.
                 Now, which of these are in the rotated set? 
                    The rotated set has cells ( x in [0,5], y in [0,3] ).
                 cell (0,0) in border0: (0,0) in the rotated set? 
                    The rotated set has (0,3) (from (0,0) in the original), not (0,0).
                 cell (0,0) in the original is not in the rotated set.

                 cell (0,5) in the original: in the rotated set is (5,3) -> which is in the rotated set. 
                    so (0,5) in the original is not the same as (5,3) in the rotated set? 
                    When we do (dx,dy)=(0,0), we require the cell (0,5) in the original to be covered by the rotated set at cell (0,5) in the rotated set? 
                    But the rotated set does not have a cell at (0,5) in the rotated set's own grid? 
                         in the rotated set's grid, the cell (0,5) might be out of bounds (because the rotated set is 6x4)? -> no, the rotated set's grid is [0,5]x[0,3], so (0,5) is not in the grid.

                 Therefore, no cell in the border0 will be counted in the 
                    count_num[ (0,0) ] = number of (i,j) in border0 that are in the rotated set = 0.

                 Similarly, count_den might be >0, but then the fraction is 0, and we skip because we only consider den>0 and the fraction might be 0 but then we skip.

             So we don't update.

          We need to find a placement that yields 2/1. 
          Given the complexity, we output the code and hope that it is 2/1 for the first sample in the judge's test.

        Given the time, we output the code as described.

        Note: for the second sample, the area is 256, then work = 4 * (256)^2 = 262144 per test case, which is acceptable.

        Let's hope.

        We'll run the first sample by hand for a specific cell in the rotated set for 0° and a shift of (0,0): we know it yields 1.

        But the sample output is 2/1.

        One more try: 
          in the first sample, try the placement: 
             rotation = 0°, and shift = (0,0) -> fraction=1.
          then try: 
             rotation = 0°, and shift = (0,1) -> fraction=1.
          ...

          try: shift = (1,1) in 0°: 
             count_num = number of (i,j) in border0 and (x,y) in the 
                conditions: dx=1, dy=1: 
                    for (i,j) in border0 and (x,y) in the set, and i-x=1, j-y=1.
                    then for (i,j) in border0, the number of (x,y) is the number of (x,y) in the set such that x = i-1, y = j-1.
                    in the full grid, that is 1 if (i-1, j-1) is in the set, which it is if 0<=i-1<4 and 0<=j-1<6.
                    for (i,j) in border0: 
                         if i>=1 and j>=1: then there is one cell (x,y) = (i-1, j-1) in the set.
                    How many border0 cells have i>=1 and j>=1? 
                         The border0: 
                             i=0: j in [0,5] -> 6 cells, but these have i=0, so i-1<0 -> not.
                             i=3: j in [0,5] -> 6 cells, and i=3>=1, and j>=1: for j in [1,5] -> 5 cells.
                             j=0: i in [1,2] (because the corners are counted in i=0 and i=3) -> 2 cells, and j=0: not j>=1.
                             j=5: i in [1,2] -> 2 cells, and j=5>=1 -> but also need i>=1, which it is.
                         so total = 5 (from i=3) + 2 (from j=5) = 7.
                    count_num = 7.

             count_den = for (i,j) in the set and (x,y) in border0, such that i-x=1 and j-y=1.
                    = for (x,y) in border0, the number of (i,j) in the set such that i = x+1, j = y+1.
                    = for (x,y) in border0: if x+1 in [0,3] and y+1 in [0,5], then there is one cell.
                    which means: x in [0,2] and y in [0,4].
                    In border0: 
                         i=0: then x in [0,2] -> and j in [0,5] and y in [0,4] -> then for x=0, y in [0,4] -> 5 cells.
                         i=3: then x+1=4 -> out of bounds, skip.
                         j=0: then x in [0,2] and y=0 in [0,4] -> then valid: for x in [0,2] -> 3 cells.
                         j=5: then y+1=6 -> out of bounds, skip.
                    total = 5+3 = 8.
             fraction = 7/8.

          not 2.

        Given the time, we output the code and hope online judge is not the sample.

        Or the sample input might be not a full grid? 
            The sample input: 
                4 6
                ######
                ######
                ######
                ######

            The sample output: 2/1.

        After the contest, we can debug.

        For now, we output the code as described.

        Note: the sample input provided in the problem has two test cases, and we must output:
           2/1
           1/1

        We hope that our double loop will find 2/1 for the first test.

        One more idea: the first test might be the full grid 4x6, and the placement that yields 2/1 might be a 180° rotation with a specific shift.

        Specifically, shift by (0,0) might yield a fraction of 1, but shift by (0,2) might yield 2/1.

        We do 180°: 
            transform: (i,j) -> (3-i,5-j)

            then the rotated set is also 4x6.

            try shift (0,2): 
                conditions: for (i,j) in the border0 and (x,y) in the rotated set such that (i-x = 0, j-y = 2) 
                   -> x = i, y = j-2.
                and (x,y) in the rotated set.

                count_num = number of (i,j) in border0 such that (i, j-2) in the rotated set.
                   = number of (i,j) in border0 with j-2 in [0,5] and also (i, j-2) is in the rotated set? 
                   in the full grid, if (i,j) in the set, then (i, j-2) is in the set if j-2>=0.
                   for (i,j) in border0: 
                         if j>=2, then (i,j-2) is in the set.
                   How many border0 cells have j>=2? 
                         i=0: j in [0,5] -> 6 cells, but j>=2 -> 4 cells.
                         i=3: 4 cells.
                         j=0: 2 cells -> j<2, skip.
                         j=5: 2 cells -> j>=2 -> valid.
                   total = 4+4+2 = 10.

                count_den = number of (i,j) in the set and (x,y) in border_rot such that (i-x=0, j-y=2) 
                         = number of (x,y) in border_rot such that (x,y) = (i, j-2) and (x,y) in border_rot, and (i,j) in the set.
                         = number of (x,y) in border_rot and (i,j) = (x, y+2) in the set, and also (x,y) in border_rot.
                         = number of (x,y) in border_rot with y+2 in [0,5] and (x,y+2) in the set (which is always true in the full grid) and (x,y) in border_rot.
                         = number of (x,y) in border_rot with y+2<=5, i.e., y<=3.
                   border_rot for the 180° rotated set: 
                         The border_rot = { (3-i,5-j) for (i,j) in border0 } 
                         = { (3-i,5-j) for i in [0,3], j in [0,5] with i=0 or i=3 or j=0 or j=5 }
                         = { (3,5-j) for j in [0,5] }   // for i=0
                                 and { (0,5-j) for j in [0,5] }   // for i=3
                                 and { (3-i,5) for i in [1,2] }   // for j=0
                                 and { (3-i,0) for i in [1,2] }   // for j=5
                         = the same as border0: 16 cells.

                   Now, how many of these have y<=3? 
                         for (3,5-j): j in [0,5] -> y=5-j, so we need 5-j<=3 -> j>=2: -> j in [2,5] -> 4 cells.
                         for (0,5-j): j in [0,5] -> 4 cells (j>=2).
                         for (3-i,5): i in [1,2] -> y=5, which is not<=3 -> 0.
                         for (3-i,0): i in [1,2] -> y=0<=3 -> 2 cells.
                   total = 4+4+2 = 10.

                fraction = 10/10 = 1.

         still not 2.

        Given the time, we output the code.

        Note: the problem says the first sample output is 2/1, so it must be found in one of the placements.

        We might have a bug in the double loop: 
            for (i,j) in border0: we are adding 1 for every (x,y) in the rotated set, but that is not what we want.

        We should only add 1 for the specific (x,y) that yields the translation (dx,dy)= (i-x, j-y) for the cell (i,j) to be overlapped.

        But in the double loop, we are. 
            The condition is: for a cell (i,j) in the border0, and for a cell (x,y) in the rotated set, we consider the translation (dx,dy) = (i-x, j-y), and then we add 1 to count_num for that translation if (i,j) is border0.
            and similarly for count_den: add 1 to count_den for that translation if (x,y) is border_rot.

        This is because the cell (i,j) in the original will be covered by the cell (x,y) in the rotated set when the rotated set is shifted by (dx,dy) = (i-x, j-y), because then the cell (x,y) in the rotated set is placed at (x+dx, y+dy) = (x+(i-x), y+(j-y)) = (i,j) in the original.

        Therefore, the code is as described.

        We hope the judge's test for the first sample is not the full grid, or there is a placement that yields 2/1.

        If not, we might need to output 2/1 for the first sample specifically.

        Given the constraints and the complexity analysis, we output the code.

        For the second sample, the output is 1/1.

        Let's do the second sample briefly: 
           it is a cross, and the sample output is 1/1.

        We trust the code will work.

        We'll gcd for the fraction reduction.

        Code structure for the entire file:

            import math
            from collections import defaultdict

            def main():
                T = int(input().strip())
                for _ in range(T):
                    data = input().split()
                    if not data: 
                        continue
                    R = int(data[0]); C = int(data[1])
                    grid = []
                    for i in range(R):
                        grid.append(input().strip())
                    # find minimal bounding box
                    # rows
                    r0 = 0
                    while r0 < R and '#' not in grid[r0]:
                        r0 += 1
                    if r0 == R:
                        # empty grid, but guaranteed at least one cell, so skip
                        # but guaranteed not empty.
                        pass
                    r1 = R-1
                    while r1 >=0 and '#' not in grid[r1]:
                        r1 -= 1
                    # columns
                    c0 = C
                    c1 = -1
                    for i in range(R):
                        for j in range(C):
                            if grid[i][j]=='#':
                                if j < c0:
                                    c0 = j
                                if j > c1:
                                    c1 = j
                    if c0 > c1:
                        # empty
                        pass
                    H = r1 - r0 + 1
                    W = c1 - c0 + 1
                    grid0 = []
                    for i in range(r0, r1+1):
                        grid0.append(grid[i][c0:c1+1])

                    # Build S0 and border0
                    S0 = set()
                    border0 = set()
                    # Directions for 8 neighbors
                    directions = [(-1,-1), (-1,0), (-1,1),
                                  (0,-1),           (0,1),
                                  (1,-1),  (1,0),   (1,1)]
                    for i in range(H):
                        for j in range(W):
                            if grid0[i][j]=='#':
                                S0.add((i,j))
                                is_border = False
                                for dx,dy in directions:
                                    ni, nj = i+dx, j+dy
                                    if 0<=ni<H and 0<=nj<W:
                                        if grid0[ni][nj]!='#':
                                            is_border = True
                                            break
                                    else:
                                        is_border = True
                                        break
                                if is_border:
                                    border0.add((i,j))

                                   
                    rotations = [0, 90, 180, 270]
                    best_num = 0
                    best_den = 1
                    for rot in rotations:
                        if rot == 0:
                            S_rot = S0
                            border_rot = border0
                            H_rot = H
                            W_rot = W
                        else:
                            if rot == 90:
                                f = lambda i, j: (j, H-1-i)
                            elif rot == 180:
                                f = lambda i, j: (H-1-i, W-1-j)
                            elif rot == 270:
                                f = lambda i, j: (W-1-j, i)
                            S_rot = set()
                            border_rot = set()
                            for (i,j) in S0:
                                x,y = f(i,j)
                                S_rot.add( (x,y) )
                            for (i,j) in border0:
                                x,y = f(i,j)
                                border_rot.add( (x,y) )
                            if not S_rot:
                                continue
                            min_i = min(x for (x,y) in S_rot)
                            max_i = max(x for (x,y) in S_rot)
                            min_j = min(y for (x,y) in S_rot)
                            max_j = max(y for (x,y) in S_rot)
                            S_rot_shifted = set()
                            border_rot_shifted = set()
                            for (x,y) in S_rot:
                                nx = x - min_i
                                ny = y - min_j
                                S_rot_shifted.add( (nx,ny) )
                            for (x,y) in border_rot:
                                nx = x - min_i
                                ny = y - min_j
                                border_rot_shifted.add( (nx,ny) )
                            S_rot = S_rot_shifted
                            border_rot = border_rot_shifted
                            H_rot = max_i - min_i + 1
                            W_rot = max_j - min_j + 1

                        count_num = defaultdict(int)
                        count_den = defaultdict(int)
                        for (i,j) in S0:
                            for (x,y) in S_rot:
                                dx = i - x
                                dy = j - y
                                key = (dx, dy)
                                if (i,j) in border0:
                                    count_num[key] += 1
                                if (x,y) in border_rot:
                                    count_den[key] += 1

                        for key in count_num:
                            if count_den[key] > 0:
                                num_val = count_num[key]
                                den_val = count_den[key]
                                if best_num * den_val < num_val * best_den:
                                    best_num = num_val
                                    best_den = den_val

                    if best_num == 0 and best_den == 1:
                        # should not happen, but in case no placement found, output 0/1? but problem guarantee not.
                        # try to output 0/1, but the problem guarantee not.
                        best_num = 0
                        best_den = 1
                    # Reduce the fraction
                    g = math.gcd(best_num, best_den)
                    best_num //= g
                    best_den //= g
                    print(f"{best_num}/{best_den}")

            if __name__ == '__main__':
                main()

        We hope it passes.