 We are going to precompute all numbers `n` (with non-decreasing digits) up to 10^18 such that `n^2` also has non-decreasing digits.
 Steps:
 1. Generate all numbers with non-decreasing digits (base 10) up to 10^18. Note: The count of such numbers is about C(18+10-1, 10-1) = C(27,9) which is about 4.6 million? Actually, that formula is for combinations with repetition. But note: we are generating numbers with up to 18 digits. The total count is about 18-digit numbers: it's the number of non-decreasing sequences of digits (each from '0' to '9') but note: we don't allow leading zeros. Actually, we start from 1 to 9 for the first digit. The total count is C(18+9, 9) - 1? Actually, the formula for non-decreasing sequences of length k (with digits in 1..9 for the first, then 0..9 for others? but note: we require non-decreasing and the first digit is non-zero) is: 
     count = C(18+10-1, 10-1) - C(17+10-1, 10-1) [if we consider numbers with exactly 18 digits and subtract those starting with 0?] Actually, we can generate without zeros at the front by starting with 1..9 and then appending digits from last_digit to 9.

 However, we are generating by BFS and we avoid leading zeros by starting from 1..9. The total numbers are about 4.6 million? Actually, the formula is: 
     count = C(18+9, 9) = 4686825, which is acceptable? But note: we are only generating numbers with non-decreasing digits, and then we check their squares. However, 4.6 million is acceptable in a BFS? But note: we are generating numbers up to 10^18, which is 18 digits. The total states are 18 * 10 * ...? Actually, we are generating by state: (current number, last digit, length) but we break when length>18. The total states: for each length from 1 to 18, and for each last digit from 0 to 9? But we start with 1..9. The total number of states is the same as the total numbers with non-decreasing digits? which is about 4.6 million? Actually, 18 digits: the count is the same as the number of multisets of digits (with non-decreasing order) of size from 1 to 18, and the first digit non-zero.

 However, note that the problem states: there are infinitely many for base 10, but in the range [1,10^18] we have a finite set. We can generate all such numbers and then check the square.

 But note: the square of a number up to 10^18 is 10^36, which is 36 digits. We can use __int128 to store the square? But 10^36 is about 120 bits, so __int128 (128 bits) is enough.

 However, 4.6 million numbers is acceptable to check? We do 4.6 million squares? And each square we convert to a string of up to 36 digits? That is acceptable in C++.

 But note: the actual number of non-decreasing numbers in base10 up to 10^18 is: 
     It is the number of non-decreasing sequences of digits (each from 0 to 9) of length 1 to 18, but without leading zeros. Actually, we can model: 
        Let f(len, d) = number of sequences of length `len` ending with digit `d`? But we don't need to count, we need to generate.

 Alternatively, we can generate by DFS or BFS. We use BFS.

 However, 4.6 million might be too heavy for BFS? Actually, the total states are about 4.6 million, which is acceptable in C++ if we do it once.

 But note: the problem says T up to 10^5, so we precompute the list of valid n, then answer each query by binary search.

 However, we must note: the actual valid n (that also have n^2 non-decreasing) are very few! According to the sample: 
     For X=5: 5 numbers -> all n from 1 to 5? 
        n=1: 1 -> 1 (sorted) -> valid
        n=2: 2 -> 4 -> valid
        n=3: 3 -> 9 -> valid
        n=4: 4 -> 16 -> 1 then 6 -> not sorted? because 1<=6 is true? -> sorted? Actually, 16: 1<=6 -> sorted -> valid
        n=5: 5 -> 25: 2<=5 -> valid -> so 5.

     But then X=8: 7. Why 7? Then 6: 6->36: sorted? 3<=6 -> valid -> 6
               7: 7->49: 4<=9 -> valid -> 7
               8: 8->64: 6<=4? no -> invalid -> so 7.

     Then 13: 9 -> 81: 8<=1? no -> invalid; 10: 100 -> 1,0,0 -> not non-decreasing? because 1>=0 but then 0>=0 -> actually, 100: 1,0,0 -> 1>=0 -> but then 0>=0: but the digits are [1,0,0]: the first digit 1, then 0 which is less -> so not non-decreasing. 
        Actually, 10: digits are [1,0] -> decreasing? so 10 is not sorted. Then 11: 121 -> 1,2,1: 1<=2 then 2>=1 -> not sorted. 12: 144 -> 1,4,4: 1<=4 and 4<=4 -> sorted -> so 12 is valid? Then 13: 169: 1<=6 and 6>=9? no -> invalid.

        So the valid n up to 13: 1,2,3,4,5,6,7,12 -> 8 numbers? but sample output is 9.

        Let me list the sample output: 
            Input: 5 -> 5
                    8 -> 7
                    13 -> 9

        So what are the 9 for 13? 
            n=1:1 -> valid
            n=2:2 -> valid
            n=3:3 -> valid
            n=4:4 -> valid
            n=5:5 -> valid
            n=6:6 -> valid
            n=7:7 -> valid
            n=11: 11 -> 121: 1<=2 -> then 2>=1 -> not sorted -> invalid
            n=12:12 -> 144: sorted -> valid
            n=13: invalid -> so that's 8? 

        But wait: the sample output for 13 is 9. Then we must be missing one.

        What about n=10? invalid? n=8: invalid? but we had 7 at 8.

        Then what about n=0? no, n positive.

        How about n=9? 9 -> 81: 8 and 1 -> 8>=1 -> invalid.

        Then what about n=111? but 111>13.

        Actually, the sample output says 9 for 13. So we must have 9 valid numbers <=13.

        Let me recount: 
            n=1: valid
            n=2: valid
            n=3: valid
            n=4: valid
            n=5: valid
            n=6: valid
            n=7: valid
            n=8: invalid? (because 64: 6>4) -> invalid -> skip.
            n=9: invalid (81: 8>1) -> invalid.
            n=10: invalid (digits: [1,0] -> 1>0 -> invalid) -> also n^2=100: digits [1,0,0] -> 1>0 -> invalid.
            n=11: n=11: digits [1,1] -> non-decreasing. Then n^2=121: [1,2,1] -> 1<=2 (ok), but 2>=1 -> not non-decreasing? -> invalid.
            n=12: [1,2] -> non-decreasing. 144: [1,4,4] -> 1<=4 and 4<=4 -> valid -> 8th number.
            n=13: [1,3] -> non-decreasing. 169: [1,6,9] -> 1<=6 and 6<=9 -> valid? -> 9th number? 

        But wait: 169: 1,6,9 -> non-decreasing? yes. So 13 is valid? Then the output for 13 is 9.

        So the list: 1,2,3,4,5,6,7,12,13 -> 9.

        However, we see that 13: the number 13 has digits [1,3] which is non-decreasing? yes. Then 13^2=169 -> [1,6,9] is non-decreasing? yes.

        So why did I think 169: 1<=6 and 6<=9 -> yes.

        Therefore, 13 is valid.

        Correction: 13 is valid.

        So we must generate and check.

        The problem: the sample input 5 -> 5, 8 -> 7 (because n=8 is invalid, so 1..7 are all valid? but note: n=1,2,3,4,5,6,7: that's 7) and 13 -> 9.

        Therefore, we must generate all n (with non-decreasing digits) and check n^2.

        However, note: we don't need to generate all numbers from 1 to X, but only the numbers that have non-decreasing digits? Why? Because if n does not have non-decreasing digits, then we don't care? But the problem requires both n and n^2 to be non-decreasing. So we can skip any n that is not non-decreasing.

        Therefore, we generate only the numbers that are non-decreasing in base10 (which is a small set) and then for each such n, we check if n^2 is non-decreasing. Then we store the n that passes.

        Then for each test case, we count the stored valid n that are <= X.

        How many such n are there? We generated 4.6 million candidates? But then we check their squares? Actually, the set of n with non-decreasing digits is about 4.6 million? Let me compute: 
            The formula: for numbers with exactly k digits: it is the number of non-decreasing sequences of k digits starting with 1..9? Actually, we can use stars and bars: 
                We have k positions, and we choose digits d1, d2, ... dk such that 1<=d1<=d2<=...<=dk<=9? Actually, no: we can have 0? But note: we don't allow leading zeros. So d1 in [1,9] and d2,...,dk in [d1,9]. Then we can do a change of variables: 
                Let a1 = d1, a2 = d2 - d1, ..., ak = dk - d_{k-1}? Actually, we can map to nonnegative integers: 
                Let b1 = d1 - 1, b2 = d2 - d1, ..., bk = dk - d_{k-1}. Then we require b1>=0, b2>=0, ... bk>=0 and 
                    d1 = 1 + b1
                    d2 = 1 + b1 + b2
                    ...
                    dk = 1 + b1 + b2 + ... + bk
                and we require dk <= 9 -> 1 + b1+...+bk <= 9 -> b1+...+bk <= 8.

                Then the number of sequences for fixed k is the number of nonnegative solutions to b1+...+bk <= 8? 
                    = C(8+k, k)   [by stars and bars: the number of nonnegative solutions to b1+...+bk <= 8 is C(8+k, k)].

            Then total for k from 1 to 18: 
                total = sum_{k=1}^{18} C(8+k, k) 
            = C(9,1) + C(10,2) + ... + C(26,18)

            We can compute: 
                k=1: C(9,1)=9
                k=2: C(10,2)=45
                k=3: C(11,3)=165
                ... and so on.

            Actually, the total is C(27,9) - 1? Why? Because the formula for the sum of C(8+k, k) for k=0 to 18 is C(27,9) [by the hockey-stick identity: sum_{k=0}^{n} C(r+k,k) = C(r+n+1, n)]? 
            But note: our k starts at 1, and we don't include k=0. Also the identity: 
                sum_{k=0}^{m} C(n+k, n) = C(n+m+1, n+1) 
            Then: 
                sum_{k=0}^{18} C(8+k, 8) = C(8+18+1, 9) = C(27,9) = 4686825.

            Then subtract k=0: C(8,8)=1? so 4686825 - 1 = 4686824.

            That is about 4.68 million, which is acceptable.

        However, note: we are generating with BFS and we break when the number exceeds 10^18? Actually, we are generating by length: we stop at length=18. And we break in the inner loop if next_num > maxX? But maxX=10^18, and we are generating only up to 18 digits. The numbers we generate are at most 10^18, so we don't generate beyond.

        But note: 10^18 is 1 followed by 18 zeros -> 19 digits? Actually, 10^18 is 1e18 -> 19 digits? 
            Actually, 10^0=1 -> 1 digit, 10^1=10 -> 2 digits, so 10^18 is 19 digits.

        Correction: the problem says n up to 10^18, which is 1 followed by 18 zeros -> 19 digits. But our generation: we are generating numbers from 1 to 10^18. So we must generate numbers with 1 to 19 digits? However, note that 10^18 is the upper bound. The largest number we can have is 10^18, which has 19 digits? Actually, 10^18 is 1 followed by 18 zeros -> 19 digits.

        But the problem: X<=10^18, so we must generate numbers with up to 19 digits? However, the number of digits of n is at most 19.

        Therefore, we must extend the BFS to 19 digits.

        The formula: total numbers with non-decreasing digits and up to 19 digits: 
            = sum_{k=1}^{19} C(8+k, k) = C(8+19+1, 19) - C(8,0)? Actually, by the identity: 
                sum_{k=0}^{19} C(8+k,8) = C(8+19+1, 9) = C(28,9) = 3108105? Actually, no: the identity is C(n+k+1, n+1) = C(27,9) for k=18? For k=19: 
                total = C(27,9) [for k=0 to 18] and then k=19: C(8+19,8)=C(27,8) -> so total for k=0 to 19 is C(28,9). 
            Then without k=0: C(28,9) - 1 = 3108105 - 1 = 3108104.

        But wait: the identity: 
            sum_{k=0}^{m} C(n+k, n) = C(n+m+1, n+1)
            So for n=8, m=19: 
                total = C(8+19+1, 8+1) = C(28,9) = 3108105? 
            Then without k=0: 3108105 - 1 = 3108104.

        However, we can generate and check 3.1 million numbers? That is acceptable.

        But note: the problem says that the set of valid n (for which both n and n^2 are sorted) is very sparse. Actually, in the entire range up to 10^18, there are only about 110 such numbers? (as per known results: the OEIS sequence A028820 and A028821, but for base 10: the sequence of n such that n and n^2 are sorted is known to be finite? Actually, the problem says infinitely many for base 10, but that is for the entire set of positive integers. However, in our finite range [1,10^18] we have a finite set. And it's known that the largest such n is 1151570... (but we are generating and checking, so we'll see).

        Actually, we are going to generate all non-decreasing n (3.1 million) and then check their squares. The square for a 19-digit number is 38 digits, which is within __int128? 
            __int128: 128 bits -> 128/ log2(10) ≈ 38.5 digits -> so 38 digits is the max? Actually, 10^38-1 has 38 digits and is about 126 bits? 
            But 10^36 is 1e36 -> 37 digits? 
            The square of a 19-digit number: the largest 19-digit number is 10^19-1, and (10^19-1)^2 = 10^38 - 2*10^19 + 1, which is a 38-digit number? Actually, 10^38 has 39 digits? 
                Actually: 
                    10^1: 1 digit -> 10^2=100: 3 digits? 
                    (10^k)^2 = 10^(2k) -> has 2k+1 digits? Actually, 10^2k has 2k+1 digits? 
                    10^1: 10 -> 2 digits -> 10^2=100 -> 3 digits -> so 10^k has k+1 digits? 
                    Then (10^19-1) is 19 digits? then its square: 
                        (10^19-1)^2 = 10^38 - 2*10^19 + 1 -> 
                        10^38 has 39 digits? 
                        10^38: 1 followed by 38 zeros -> 39 digits.

            Therefore, we need to handle numbers up to 39 digits? But __int128 max: 
                __int128: 2^127-1 ≈ 1.7e38 -> which has 39 digits? so it can represent 10^38? Actually, 10^38 is 1e38, which is less than 2^127 (which is about 1.7e38). So yes.

        However, to be safe: we can use string conversion for the square? But we are using __int128 to compute the square and then convert to string? That is acceptable for 3.1 million numbers? 
            The conversion to string for a 39-digit number: 39 steps per number -> 3.1e6 * 39 ≈ 120 million operations? which is acceptable in C++ (within a few seconds).

        But note: the problem says T up to 10^5, and we are precomputing the list of valid n. The precomputation is done once.

        Steps:

          Precomputation:
            valid_n = vector<ull>()
            maxX = 1000000000000000000ULL (10^18) but note: we are generating n up to 10^18? Actually, we are generating numbers with non-decreasing digits and <= 10^18? Actually, we break when the next number would be > maxX? 

          How we generate:
            We start with digits 1..9 (each as a starting number).
            Then for each number, we try to append d from last_digit to 9, and if the new number (current*10+d) is <= maxX, then we push it.

          However, note: maxX is 10^18, which is 1e18. The largest number we can generate is 999...9 (19 nines) -> that is 10^19-1? which is greater than 10^18. So we must avoid generating numbers beyond 10^18.

          We can break when current has 18 digits and then we can only append digits that do not make the number exceed 10^18? But 10^18 is 1 followed by 18 zeros. The largest 18-digit number is 10^18-1? Actually, 10^18 is 19 digits? 
          Actually: 
            10^0 = 1 -> 1 digit.
            10^1 = 10 -> 2 digits.
            ...
            10^18 = 1 followed by 18 zeros -> 19 digits.

          Therefore, we are generating numbers with 1 to 19 digits? But we must not generate numbers > 10^18? 

          We can do: 
            We start with numbers of length 1 (1..9) -> then we generate numbers of length 2, then 3, ... up to 19. 
            But note: the number 10^18 is 1 followed by 18 zeros -> which has non-decreasing digits? Actually: [1,0,0,...,0] -> 1 followed by zeros -> but then the second digit (0) is less than the first (1) -> so it is not non-decreasing. Therefore, we don't need to generate numbers that start with 1 and then have zeros? because non-decreasing requires that the next digit is at least 1? So we can skip any number that would have a zero after a non-zero? Actually, we generate by the last digit: if the last digit is d, then we can only append d..9. So zeros are only appended if the last digit is 0? and we never have a last digit 0 unless we started with 0? but we start with 1..9. Therefore, we never generate a number that has a zero after a non-zero? because we start with 1..9 and then we only append digits >= the last digit. Therefore, we never generate 10, 20, ...? 

          Actually, we do generate numbers that have zeros? only if we have a last digit 0? but we never set last digit to 0? because we start with 1..9 and then we append at least the last digit. So we never generate 10? because to generate 10: we must start with 1 and then append 0? but 0 is less than the last digit (1) -> so we skip. 

          Therefore, we are only generating numbers that are strictly non-decreasing and without any drop? and without zeros at the beginning? so we never generate 10. 

          But wait: what about numbers that start with 1 and then 1? then we have 11, then we can append 0? no, because the last digit is 1 and we append from 1 to 9. So we never append 0.

          Therefore, all our numbers are composed of digits 1..9 and non-decreasing. 

          Then how do we get 10? We don't. And 100? we don't.

          But note: the number 10 is not non-decreasing? so we don't care. And the problem: we only consider n that are non-decreasing. So we skip 10.

          Therefore, we generate numbers that are non-decreasing and composed of digits in 1..9? Then the maximum number of digits is 18? because the largest number we can generate with non-decreasing digits and without zeros is 999...9 (18 nines) -> because 10^18 is 19 digits and we are not generating 19-digit numbers? 

          Actually: 10^18 has 19 digits? but we are generating numbers with non-decreasing digits and without zeros? then the largest number is 999...9 (18 nines) -> which is 10^18-1? which is less than 10^18. But wait: we can generate 19-digit numbers? if we start with 1 and then 18 nines? but 1 followed by 18 nines is 10^19-10? which is 19 digits? and that is greater than 10^18? so we break.

          Therefore, we are generating numbers with 1 to 18 digits? 

          But what about 19-digit numbers? The smallest 19-digit number is 10^18? which we must consider? but 10^18 is not non-decreasing? because it has a 1 followed by zeros. So we skip.

          Therefore, we only generate numbers with 1 to 18 digits? Then the total numbers: 
            = sum_{k=1}^{18} C(8+k, k) = C(26,9) = 4686825? (by the identity: sum_{k=0}^{18} C(8+k,8)=C(26,9)? 
            Actually: 
                sum_{k=0}^{18} C(8+k,8) = C(8+18+1, 9) = C(27,9)=4686825.
            Then subtract k=0: 1 -> total = 4686824.

          So about 4.68 million numbers.

        However, we must consider: the problem says X up to 10^18, so we must include n=10^18? but 10^18 is not non-decreasing? so we skip. Therefore, the maximum n we generate is 999...9 (18 nines).

        But note: what if we generate a number that is 19 digits? We are stopping at length=18? 
            Our BFS: we start with length=1, then we generate up to length=18? then we stop at length=18? because we break when len>=18? Actually, the code:

                if (len < 18) {
                    for (int d = last; d <= 9; d++) {
                        ull next_num = cur * 10ULL + (ull)d;
                        if (next_num > maxX) break;
                        q.push(make_tuple(next_num, d, len+1));
                    }
                }

          So we don't generate numbers beyond length 18? But we are generating numbers of length 18? and then we stop. So we generate 1..18 digits.

        Correction: we generate numbers of length 1 to 18.

        Then total = 4686824? which is acceptable.

        But note: we must check the squares for 4.68 million numbers? and each square is computed and then converted to string? and then we check the string? 

          The square: we use __int128: 
            cur is up to 10^18-1 -> then cur*cur is about 10^36 -> which is 36 digits? Actually, (10^18-1)^2 is about 10^36, which is 37 digits? 
                Actually: 
                  10^18-1: 18 nines -> (10^18-1)^2 = 10^36 - 2*10^18 + 1 -> which is 36 digits? 
                  10^36 has 37 digits? -> no: 
                    10^0: 1 -> 1 digit.
                    10^1: 10 -> 2 digits.
                    ... 
                    10^36: 1 followed by 36 zeros -> 37 digits.

          But we are using __int128: which is 128 bits -> max about 3.4e38 -> which has 39 digits? so 10^36 is 37 digits, which is representable.

          Then we convert to string: 37 digits per number -> 4.68e6 * 37 = 173.16e6 operations? which is acceptable.

        Then we store the valid_n (the n that pass) in a sorted list? Actually, the BFS does not generate in increasing order? So we sort at the end.

        Then for each test case, we do a binary search (log(size of valid_n)) to count how many valid_n <= X.

        How many valid_n? We expect about 100? Actually, from known results: 
            The OEIS sequence A028820: numbers n such that n is (base 10) non-decreasing and n^2 is non-decreasing. 
            The known terms: 
                1, 2, 3, 4, 5, 6, 7, 12, 13, 15, 16, 17, 34, 35, 37, 38, 67, 83, 106, 107, 116, 117, 167, 183, 334, 335, 337, 367, 383, 587, 667, 1633, 1667, 3334, 3335, 3337, 3367, 3383, 3667, 4833, 6667, 16667, 33334, 33335, 33337, 33367, 33667, 36667, 66667, 166667, 333334, 333335, 333337, 333367, 333667, 336667, 366667, 666667, 1666667, 3333334, 3333335, 3333337, 3333367, 3333667, 3336667, 3366667, 3666667, 6666667, 16666667, 33333334, 33333335, 33333337, 33333367, 33333667, 33336667, 33366667, 33666667, 36666667, 66666667, 166666667, 333333334, 333333335, 333333337, 333333367, 333333667, 333336667, 333366667, 333666667, 336666667, 366666667, 666666667, 1666666667, 3333333334, 3333333335, 3333333337, 3333333367, 3333333667, 3333336667, 3333366667, 3333666667, 3336666667, 3366666667, 3666666667, 6666666667, 16666666667, 33333333334, 33333333335, 33333333337, 33333333367, 33333333667, 33333336667, 33333366667, 33333666667, 33336666667, 33366666667, 33666666667, 36666666667, 66666666667, 166666666667, 333333333334, ... 

        But note: we are only going up to 10^18. The list above goes beyond? 

        Actually, we can run the precomputation and count the valid_n we get? 

        However, the problem says T up to 10^5, so we can store the valid_n in a vector and then sort it. The size of valid_n is expected to be about 110? (from known sequences: the sequence A028820 has about 100 terms below 10^18). 

        Therefore, the precomputation:

          Generate all non-decreasing n (with 1 to 18 digits) -> 4.68 million numbers.
          For each n:
            nsq = (lll)n * n;
            Convert nsq to string s.
            Check if s is non-decreasing: for i from 0 to len(s)-2: if s[i] > s[i+1] -> break and skip.
            Else, push n to valid_n.

          Then sort valid_n.

        Then for each test case: 
            Read X -> use upper_bound in valid_n to get the first element > X, then the index = that - begin.

        But note: the valid_n might be small (about 110 elements) so we can even do a linear scan? But we have T up to 10^5, so we want O(log(110)) per query -> we use binary search.

        However, we can precompute the sorted list of valid_n once.

        Let's run the sample:

          For X=5: valid_n that are <=5: [1,2,3,4,5] -> 5.
          For X=8: [1,2,3,4,5,6,7] -> 7. (note: 8 is not valid because 64 -> 6>4 -> invalid, so not in valid_n)
          For X=13: [1,2,3,4,5,6,7,12,13] -> 9.

        But note: we must include n=12 and n=13? 
          n=12: 12 -> 144: sorted? yes -> valid.
          n=13: 13 -> 169: sorted? yes -> valid.

        Therefore, the code.

        However, note: the precomputation must include n=1,2,...,7,12,13, etc.

        But note: n=15: 
          n=15: digits [1,5] -> non-decreasing. 
          n^2=225: [2,2,5] -> 2<=2 and 2<=5 -> sorted -> valid.

        So we must generate and check.

        We'll run the code for the sample and hope it matches.

        One more: n=16: 16 -> 256: 2<=5 and 5<=6 -> sorted -> valid.

        Then the list for X=16: 1,2,3,4,5,6,7,12,13,15,16 -> 11.

        We'll precompute and store all valid n.

        Implementation note: 
          We use BFS by length? We can also use DFS? But BFS is natural.

          We use a queue: 
            Start with d from 1 to 9 -> push (d, d, 1) 
            Then for each state (cur, last, len):
               if len<18: 
                 for d from last to 9:
                    next = cur*10 + d
                    if next <= maxX (10^18) -> push (next, d, len+1)

          But note: the number of states is about 4.68 million? and we do a loop for each state: the inner loop runs (9-last+1) times? worst-case last=0? but we start at last>=1. The inner loop runs at most 9 times per state? so total operations 4.68e6 * 9 = 42 million? which is acceptable.

        Let me code accordingly.

        But note: the condition "if next_num > maxX" -> we break? Actually, we break the inner loop? 
            Because if we have a number `cur` and we are appending d, and if `cur*10 + d` > maxX, then any larger d would also be greater? because d is increasing. So we break.

          Example: cur = 100000000000000000 (17 zeros) -> then cur*10 + d: for d=0 -> 1000000000000000000 (18 digits) -> which is 10^18? but note: 10^18 is 1 followed by 18 zeros -> which is 19 digits? 
          Actually: 
            cur = 100000000000000000 -> 18 zeros? no: 100000000000000000 has 18 digits? 
            Then cur*10 = 1000000000000000000 -> 19 digits -> which is 10^18 -> and then we add d? then it becomes 1000000000000000000 + d -> which is 10^18 + d? which is greater than 10^18? 
          But maxX=10^18 -> so we break for d>=0? because 1000000000000000000 is already 10^18? and then adding d? actually, we do:
            next_num = cur * 10 + d
            If cur is 100000000000000000 (which is 10^17) -> then next_num = 10^17 * 10 + d = 10^18 + d -> which is >10^18 for any d>=0? 

          Actually, 10^18 is the upper bound? so we want n<=10^18.

          Therefore, we break the inner loop as soon as we get a next_num > maxX? and then the rest d (larger) would be even bigger? so we break.

        We do:

          for d from last to 9:
            next_num = cur*10 + d
            if next_num > maxX: break
            else: push

        This is efficient.

        Let me run the precomputation and see how many valid_n we get? and if the sample matches.

        However, we must note: the sample numbers: 1,2,3,4,5,6,7,12,13,15,16,17,34, etc. 

        We'll store the valid_n and then output for the sample.

        But note: the problem says T up to 10^5, so we must be efficient in the query.

        We'll precompute the vector `valid_n` and then sort it. Then for each test case, we do:

          pos = upper_bound(valid_n.begin(), valid_n.end(), X) - valid_n.begin();

        Then output pos.

        Now, we run the sample:

          T=3, then X=5 -> output 5, X=8 -> output 7, X=13 -> output 9.

        We hope it works.

        One more: if X=1, then output 1.

        Let me check: 
            n=1: valid -> so valid_n includes 1? 
            n=1: digits [1] -> non-decreasing -> then 1^2=1 -> non-decreasing -> valid.

        Therefore, we include 1.

        We code accordingly.

        Note: we must use unsigned long long for n (since n up to 10^18). And __int128 for the square.

        If the compiler does not support __int128? Then we need an alternative. But the problem says memory limit 1024MB, and we are storing 4.68e6 numbers of unsigned long long -> about 4.68e6 * 8 = 37.44 MB? and then the squares we compute and then discard? 

        However, without __int128, we can use a string for the square? But then we have to compute the square as a string? which is O(d^2) per number? and d=18 -> 18^2=324 per number -> 4.68e6 * 324 ≈ 1.5e9 operations? which might be borderline in C++? but we can try to use a 128-bit integer if available. 

        We use #ifdef for __int128.

        We write a to_string for __int128.

        We assume the compiler supports __int128? The problem says memory 1024MB and time 1.0s per test? but we precompute once. The precomputation: 4.68e6 * (cost of square and conversion) -> we hope the conversion to string is efficient.

        We write the code as described.

        Let me run the precomputation and see the count of valid_n? and then we can compare with known terms.

        Known terms (from OEIS A028820, but note: the problem requires both n and n^2 to be non-decreasing, and OEIS A028820 is exactly that) -> the terms up to 10^18: 
            The OEIS sequence: 
               1, 2, 3, 4, 5, 6, 7, 12, 13, 15, 16, 17, 34, 35, 37, 38, 67, 83, 106, 107, 116, 117, 167, 183, 334, 335, 337, 367, 383, 587, 667, 1633, 1667, 3334, 3335, 3337, 3367, 3383, 3667, 4833, 6667, 16667, 33334, 33335, 33337, 33367, 33667, 36667, 66667, 166667, 333334, 333335, 333337, 333367, 333667, 336667, 366667, 666667, 1666667, 3333334, 3333335, 3333337, 3333367, 3333667, 3336667, 3366667, 3666667, 6666667, 16666667, 33333334, 33333335, 33333337, 33333367, 33333667, 33336667, 33366667, 33666667, 36666667, 66666667, 166666667, 333333334, 333333335, 333333337, 333333367, 333333667, 333336667, 333366667, 333666667, 336666667, 366666667, 666666667, 1666666667, 3333333334, 3333333335, 3333333337, 3333333367, 3333333667, 3333336667, 3333366667, 3333666667, 3336666667, 3366666667, 3666666667, 6666666667, 16666666667, 33333333334, 33333333335, 33333333337, 33333333367, 33333333667, 33333336667, 33333366667, 33333666667, 33336666667, 33366666667, 33666666667, 36666666667, 66666666667, 166666666667, 333333333334, ... 
            The sequence has 110 terms? 

        We'll generate and store the 110 numbers? and then answer the queries by binary search.

        We run the code and hope it matches.

        However, note: the problem says that the precomputation is done once.

        We'll write the code accordingly.

        One more note: the number 0? we skip because n>=1.

        Let's run the sample.

        We'll output the code.

        Note: We assume the compiler supports __int128.

        If not, we can use a different method? but the problem says memory 1024MB and time 1.0s for the entire program? and we precompute once? so we can use a bigint? but we don't need to: 128 bits is enough.

        We write the code as described.

        We hope the sample passes.

        We'll test with the sample.

        For n=1..13: 
          n=1: valid -> push 1
          n=2: valid -> push 2
          n=3: valid -> push 3
          n=4: valid -> push 4
          n=5: valid -> push 5
          n=6: valid -> push 6
          n=7: valid -> push 7
          n=8: not non-decreasing? no, wait: the digits of 8 are [8] -> non-decreasing? yes. Then n^2=64: [6,4] -> 6>4 -> invalid -> skip.
          n=9: [9] -> 81: 8>1 -> invalid -> skip.
          n=10: skipped because we don't generate numbers with zeros? and 10 is not non-decreasing? so we skip.
          n=11: [1,1] -> non-decreasing? yes. Then 121: [1,2,1] -> 1<=2 -> then 2>=1 -> invalid -> skip.
          n=12: [1,2] -> non-decreasing? yes. 144: [1,4,4] -> 1<=4, 4<=4 -> valid -> push 12.
          n=13: [1,3] -> non-decreasing? yes. 169: [1,6,9] -> 1<=6, 6<=9 -> valid -> push 13.

          Then valid_n: [1,2,3,4,5,6,7,12,13] -> 9 elements.

        So for X=13: output 9.

        Therefore, the code should work.

        We write the code accordingly.

        Note: we must not forget to sort the valid_n vector? because the BFS might not generate in increasing order? 
            Actually, the BFS by length: 
                First: length1: 1..9 -> then length2: 11,12,...,19,22,...,29, ... -> then length3: 111,112,... 
            So the numbers are generated in increasing order? Actually, no: 
                The queue: 
                    We start with 1,2,...,9 -> then we process 1 -> then we generate 11,12,...,19 -> then 2 -> then 21,22,...,29 -> but 11 is less than 2? no, 11 is greater than 2. 
            So the numbers are generated in increasing order? 
                First: 1 -> then 2 -> then 3 ... then 9 -> then 11,12,...,19 -> then 21,22,...,29 -> but 11 is 11, which is greater than 9? so the queue is FIFO: 
                    We start with 1,2,...,9 -> then we pop 1 -> generate 11,12,...,19 -> then pop 2 -> generate 21,22,...,29 -> then pop 3 -> ... then pop 9 -> then pop 11 -> then 12 -> ... 
            So the generated order: 1,2,3,...,9, then 11,12,...,19, then 21,22,...,29, then 31, etc. 
            But 10 is skipped? because we don't generate 10. 

            The numbers: 1,2,...,9, then 11,12,...,19, then 22,23,...,29, ... 
            Then 111,112,...,119, then 122,123,...,129, etc.

            This is increasing? 
                1,2,...,9, then 11 (which is >9) -> so increasing.

            Therefore, the BFS generates in increasing order? Then we don't need to sort? 

            But we are storing in a vector as we generate: then the vector is increasing? Then we can skip the sort? 

            However, we break the inner loop by d from last to 9? and we push in increasing order? so the queue is increasing? 

            Actually, the queue: 
                We start with 1,2,...,9 -> then we pop 1 -> push 11,12,...,19 -> then pop 2 -> push 21,...,29 -> then pop 3 -> push 31..39 -> ... then pop 9 -> then pop 11 -> push 111,112,...,119 -> then pop 12 -> push 122,...,129 -> ... 
            The queue is increasing? 
                The first part: 1,2,...,9 -> then 11,12,...,19 -> then 21,...,29 -> ... 91,...,99 -> then 111,112,...,119 -> ... 
                But note: 19 is less than 21? -> 19<21 -> so after 19 we have 21? 
                Actually: the queue: 
                  initial: [1,2,3,...,9]
                  then after processing 1: we append [11,12,...,19] -> queue becomes [2,3,...,9,11,12,...,19]
                  then we pop 2 -> then we append [22,23,...,29] -> then the queue becomes [3,4,...,9,11,12,...,19,22,23,...,29]
                  Then 3: then [33,...,39] -> ... 
                  Then 9: then [99] -> then 11: then [111,112,...,119] -> then 12: [122,...,129] -> ... 

            Therefore, the vector valid_n is in increasing order? 

            But note: we are checking n in increasing order? and we push n when we check? so the vector valid_n is in increasing order? 

            Then we don't need to sort? 

            However, the problem: we are storing as we generate? and the generation is in increasing order? so we can avoid the sort.

            But to be safe: we can sort the valid_n? since it's only 110 elements.

            Alternatively, we can store and then sort? but 110 elements is negligible.

        We'll sort anyway? because we are going to do binary search? and we want the vector to be sorted.

        Actually, the BFS is in increasing order? so we can rely on that? But the problem: we break when next_num>maxX? and then we skip? so the order might be preserved? 

        However, we break the inner loop? and we do a BFS? it remains increasing? 

        But let me be cautious: we'll sort the vector.

        Code:

          Precomputation:
            vector<ull> valid_n;
            queue<tuple<ull, int, int>> q; // (current, last_digit, len)
            for (d=1 to 9) push (d, d, 1)

            while (q not empty):
                pop (cur, last, len)
                compute nsq = (lll)cur * cur
                convert nsq to string -> s
                if (is_sorted(s)) then valid_n.push_back(cur)

                if len<18:
                    for d from last to 9:
                        next = cur*10 + d
                        if next > maxX: break
                        else: push (next, d, len+1)

            sort(valid_n.begin(), valid_n.end());

        Then process T test cases.

        We run the sample: 
          valid_n for n from 1 to 13: [1,2,3,4,5,6,7,12,13] -> then sort: [1,2,3,4,5,6,7,12,13] -> then for X=13: we get 9.

        We output the code.

        Note: the sample input 8: then we must output 7? 
          valid_n: [1,2,3,4,5,6,7] -> 7 numbers that are <=8? (because 8 is not valid, and 9 is not valid, and 10 not generated, 11 not valid, 12>8) -> so 7.

        So it matches.

        We output the code accordingly.

        Note: we use unsigned long long for n? and __int128 for nsq.

        Let me compile: we need to check __int128.

        We write:

          #ifdef __SIZEOF_INT128__
          typedef __int128 lll;
          #else
          #error "__int128 is not supported"
          #endif

        And a to_string for lll.

        We hope it works.

        We'll run the code on the sample.

        But note: the problem constraints: T up to 10^5, and X up to 10^18.

        We precompute the valid_n once, then each query is O(log(valid_n.size()) which is about log2(110) = 7.

        So 10^5 * 7 = 700000 operations? which is acceptable.

        We write the code.

        Let me test the sample:

          Input: 
            3
            5
            8
            13

          Output: 
            5
            7
            9

        We hope so.

        We run the code on the sample.

        We'll run locally if possible.

        But if not, we trust the logic.

        Code:

          #include <iostream>
          #include <vector>
          #include <queue>
          #include <algorithm>
          #include <string>
          #include <tuple>
          #include <cctype>
          using namespace std;

          typedef unsigned long long ull;
          #ifdef __SIZEOF_INT128__
          typedef __int128 lll;
          #else
          #error "__int128 is not supported"
          #endif

          string to_string(lll num) {
              if (num == 0) return "0";
              string s;
              while (num) {
                  s = char('0' + (num % 10)) + s;
                  num /= 10;
              }
              return s;
          }

          bool is_sorted(const string& s) {
              for (int i = 0; i < (int)s.size() - 1; i++) {
                  if (s[i] > s[i+1])
                      return false;
              }
              return true;
          }

          int main() {
              vector<ull> valid_n;
              const ull maxX = 1000000000000000000ULL; // 10^18

              queue<tuple<ull, int, int>> q; // (current number, last digit, length)
              for (int d = 1; d <= 9; d++) {
                  q.push(make_tuple(d, d, 1));
              }

              while (!q.empty()) {
                  auto [cur, last, len] = q.front(); q.pop();
                  lll nsq = (lll)cur * cur;
                  string sq_str = to_string(nsq);
                  if (is_sorted(sq_str)) {
                      valid_n.push_back(cur);
                  }

                  if (len < 18) {
                      for (int d = last; d <= 9; d++) {
                          ull next_num = cur * 10ULL + (ull)d;
                          if (next_num > maxX) 
                              break;
                          q.push(make_tuple(next_num, d, len+1));
                      }
                  }
              }

              sort(valid_n.begin(), valid_n.end());

              int T;
              cin >> T;
              while (T--) {
                  ull X;
                  cin >> X;
                  auto it = upper_bound(valid_n.begin(), valid_n.end(), X);
                  cout << (it - valid_n.begin()) << '\n';
              }
              return 0;
          }

        We run the sample: 
          T=3, X=5 -> we get 5? 
          X=8 -> 7? 
          X=13 -> 9?

        We hope so.

        But note: the sample includes n=1 to 7 and then 12,13 -> so for X=13, we have 9 numbers? yes.

        We output the code.

        One more note: the problem says "The first line is a positive integer T", so we read T.

        We write the code accordingly.

        We hope it passes.

        But note: the precomputation: 4.68e6 states -> and for each state we do a square and a string conversion? and the square conversion to string: for a number of up to 37 digits? and we do a check for non-decreasing? 

        The BFS: we use a queue? the queue will store states (cur, last, len). The memory: 4.68e6 * (sizeof(tuple<ull, int, int>)) = 4.68e6 * (8+4+4) = 4.68e6 * 16 = 74.88 MB? and then the vector valid_n: 110 * 8 = 880 bytes? negligible.

        The time: 4.68e6 * (cost of square and conversion) -> the multiplication: one multiplication per state? and then conversion: about 37 steps per state -> 4.68e6 * 37 ≈ 173.16e6 operations? and the inner loop: about 9 iterations per state -> 4.68e6 * 9 = 42.12e6? total operations: 173.16e6 + 42.12e6 = 215.28e6? which is acceptable in C++ in a few seconds? 

        Then we sort 110 elements: negligible.

        Then the queries: 10^5 queries, each a binary search over 110 elements -> 10^5 * log2(110) ≈ 10^5 * 7 = 700000 comparisons? which is acceptable.

        Therefore, we output the code.