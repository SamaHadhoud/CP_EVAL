 Okay, let's convert the Python solution to C++ with optimizations for performance, especially since the constraints are high (n up to 100,000 and m up to 300,000).

 Important points:
 1. The graph is planar, so we can use the fact that the maximum degree is bounded? Actually, in a planar graph the maximum degree can be high, but the total number of edges is O(n). However, for our enumeration, we rely on the fact that the number of triangles and K4s is not too high.

 2. We are going to consider:
    - Single node: 0 (so we can ignore because we are taking maximum and 0 is the minimum we have? But note: if no highway has positive attraction, then the best might be 0. However, the problem says non-empty subsets, and we are considering edges, triangles, and cliques of 4. But we must note that a single node yields 0. Since we are initializing `best` to 0, that's covered.

 3. For triangles: We are iterating over edges and then over neighbors. To avoid duplicates, we use the common technique: for an edge (u, v), we require w to be a common neighbor and also w > u and w > v? Actually, in the Python code, we only consider when u < v and then w > v. We also use the degree condition: we traverse from the vertex with the smaller degree (or if same, the smaller index) to the larger one.

 4. For K4: We are iterating over each edge (u, v), and then for each pair of common neighbors (w, x) of u and v, we check if (w, x) is an edge. But note: the planar graph condition implies that the number of common neighbors for an edge is at most 2? Actually, it can be more? But in fact, for a planar graph, we cannot have two vertices connected to three common neighbors that form a K_{2,3}? Actually, K_{2,3} is planar. But wait: the graph is simple and planar. However, the key is that the entire graph is planar. But actually, the condition we rely on is that the common neighbors of u and v form a set that is independent? Not necessarily. However, the known fact is: in a planar graph, the number of K4 subgraphs is O(n). Moreover, for each edge, the number of common neighbors is bounded? Actually, we can have at most O(deg) common neighbors per edge, but worst-case degree can be O(n). However, we have a planarity constraint: the graph is planar, so the number of edges is O(n). But we can also use a known combinatorial bound: in a planar graph, the number of triangles is O(n) and the number of K4 is O(n). But we need to bound the common neighbors per edge.

 Actually, in the Python code, we are iterating over common neighbors and then doing a double loop for pairs. However, we note that for a planar graph, the common neighbors of u and v cannot be too many? Actually, we can use a known lemma: in a planar graph, for an edge (u, v), the number of common neighbors is at most 2? Why? Because if there are three common neighbors, then we would have a K_{2,3} which is bipartite and planar, but that is acceptable. Actually, K_{2,3} is planar. However, we are building a K4 if we have an edge between two of the common neighbors? But without the edge between the common neighbors, we don't form a K4.

 But note: the problem states that the graph is planar and satisfies the conditions. However, we can have more than 2 common neighbors? For example, a vertex connected to a set of independent vertices? Actually, no: if u and v are connected and both are connected to w1, w2, w3, then we have the edges (u,v), (u,w1), (u,w2), (u,w3), (v,w1), (v,w2), (v,w3). This forms a K_{2,3} (with the bipartition {u,v} and {w1,w2,w3}) which is planar. But if we also have an edge between w1 and w2, then we have a K4? Actually, we have the vertices u, v, w1, w2: and edges (u,v), (u,w1), (u,w2), (v,w1), (v,w2), (w1,w2) -> that's a K4. And K4 is planar. So we can have multiple common neighbors.

 However, we have a combinatorial bound: the total number of K4 in a planar graph is O(n). But for each edge (u, v), the number of common neighbors might be large? Actually, worst-case, the graph could be a complete graph of 4 nodes? Then for an edge, we have 2 common neighbors. But if we have a graph that is a complete graph on 4 nodes, then each edge has two common neighbors. Then the double loop for each edge would run in O(deg(common)^2) per edge. But the common neighbors per edge in a planar graph is bounded? Actually, we can have at most O(1) common neighbors? Why? Because if an edge (u,v) has k common neighbors, then we have k vertices each connected to both u and v. Then if we also have edges between these common neighbors, we get cliques. But note: the graph is planar, so we cannot have K_{2,3} with an edge? Actually, we can. However, the known bound is that the number of cliques of size 4 is linear. But we are iterating over each edge and then over pairs of common neighbors. The worst-case total common neighbors over all edges might be O(m) but each common neighbor list for an edge might be long.

 But wait: in a planar graph, the number of triangles is O(n). How many common neighbors can an edge have? The common neighbors of an edge (u,v) is the set of w such that (u,w) and (v,w) exist. This is exactly the number of triangles that the edge (u,v) is in. And the total number of triangles is O(n). So the total sum of |common neighbors| over all edges is O(n). But note: each triangle is counted for each of its three edges. So the total sum is 3 * (number of triangles) = O(n). Therefore, the total over all edges of the size of the common neighbor list is O(n). Then if we do a double loop for each edge, the total work would be: for each edge, we have a list of common neighbors of length t, and then we do t*(t-1)/2 operations. The worst-case per edge could be O(t^2). But note: the maximum t (common neighbors per edge) might be large? However, in a planar graph, an edge can be in at most O(1) triangles? Actually, no: consider a vertex v connected to k neighbors: then each edge from v to a neighbor u is in triangles with all the common neighbors of u and v? Actually, we need a better bound.

 Alternatively, we can use the fact that the graph is planar to bound the degree? Actually, the maximum degree in a planar graph can be up to n-1, but we have the condition that the graph is simple and planar. However, we know that the average degree is constant. But worst-case degree can be high. But note: the total number of triangles is O(n). Therefore, the maximum degree of a vertex is O(n), but the number of triangles incident to a vertex is bounded by deg(v). However, the total over edges is O(n). So the maximum per edge? Actually, we don't have a constant bound per edge. For example, if we have a star graph: one central vertex connected to all others, then each edge from the center to a leaf has no common neighbor? Then common neighbor list is empty. But if we have a complete graph on 4 nodes, then each edge has 2 common neighbors.

 Actually, in a planar graph, the maximum clique size is 4, so an edge cannot have more than 2 common neighbors that form a K4? But wait: we are looking for K4s. The condition for K4 is that we have two common neighbors and an edge between them. However, an edge (u,v) can have arbitrarily many common neighbors? But if we have three common neighbors w1, w2, w3, then we have a K_{2,3} which is planar. Then we can check the edges between the w's? But the number of pairs of common neighbors for an edge with k common neighbors is O(k^2). And k can be large? But the total over edges of k is O(n) (as argued: because the total triangles is O(n) and each triangle is counted three times, so the sum of k over edges is 3 * (#triangles) = O(n)). However, the sum of k^2 over edges might be O(n) as well? Not necessarily: if one edge has k common neighbors, then k^2 might be large. But note: the graph is planar, so the maximum k per edge is bounded? Actually, no: consider a vertex u connected to v and to a set of k vertices that form an independent set and each of these k vertices is also connected to v. Then the edge (u,v) has k common neighbors. And k can be as large as n-2? But then the graph would have a K_{2,k} which is planar? Yes, if the k vertices are independent. But then the number of triangles for that edge is k, so the total triangles is k. And k can be O(n). Then the total over edges of k is O(n) but if we do k^2 for that one edge, we do O(n^2) work.

 Therefore, we must avoid the double loop for edges that have many common neighbors. We note: the problem states that the graph is planar. The known combinatorial fact: the number of K4 in a planar graph is at most O(n). So we should not have to do O(n^2) work. How to avoid? We can use the following: for each edge (u,v), if the number of common neighbors is large (say > 3), then we can skip the double loop? Actually, in a planar graph, if an edge has k common neighbors, then the induced subgraph on the common neighbors must be an independent set? Why? Because if two common neighbors are adjacent, then we get a K4. But the number of K4s is O(n), so the number of edges among common neighbors is O(n). Therefore, we can do:

   For each edge (u,v):
      Let L = list of common neighbors of u and v.
      For each w in L:
          For each x in L such that x > w:   # but we only want to consider if (w,x) exists.
          But we can pre-store the edges among the common neighbors? Actually, we have the entire graph stored.

 Alternatively, we can do:

   For each edge (u,v):
      Let L = common neighbors of u and v.
      If |L| is small (like <= some constant, say 10) then we do the double loop. But worst-case, |L| can be O(n). Then worst-case total work is O(n * m) which is too high.

 Better idea: we know that the graph is planar, so the total number of K4 is O(n). Therefore, the number of pairs (w,x) that are both common neighbors of u and v and also connected by an edge is O(n). So we can iterate over the common neighbors and for each common neighbor w, iterate over the neighbors of w that are also in L and greater than w? But then we must check for each w and each neighbor x of w that is in L and x>w. Then the total work is the sum over common neighbors w of the degree of w? That could be high.

 Alternatively, we can precompute an adjacency structure for the entire graph. We already have adj_set. Then for each common neighbor w, we can iterate over the common neighbor list L and check if x is in adj_set[w]? Then we do |L| * |L| per edge. That is O(k^2) per edge. But we want to avoid k^2 when k is large.

 However, note: the total over edges of |L| is the total number of triangles (each triangle is counted once for each edge? Actually, each triangle (u,v,w) is counted for edges (u,v), (u,w), (v,w). So the total |L| over all edges is 3 * (#triangles). And the total number of triangles in a planar graph is O(n). So the total over edges of |L| is O(n). Then the total over edges of |L|^2 is the sum of k^2 for each edge, which is bounded by (max |L|) * (sum |L|) = (max |L|) * O(n). And max |L| is the maximum number of triangles an edge is in. In a planar graph, an edge can be in O(n) triangles? (like the central edge in a wheel graph? Actually, the wheel graph with n-1 spokes: the hub and a rim edge? Actually, the hub is connected to all rim nodes, but the rim edges are only adjacent to two triangles: one with the hub and the next rim node and one with the hub and the previous. Actually, each rim edge is in one triangle? (with the hub and the two adjacent rim edges? no, a triangle is three vertices: for a rim edge (u,v), the triangles would be (hub, u, v) and then if we have a chord? Actually, the wheel without chords: then each rim edge is only in one triangle (with the hub). So the maximum number of triangles per edge is bounded? Actually, no: if we have a complete graph on 4 nodes, each edge is in 2 triangles? Then we can have more? Actually, we can have an edge that is in many triangles: consider a vertex u connected to v and to a set S of k vertices, and v is connected to all S. Then the edge (u,v) is in k triangles. And k can be up to n-2? But then the graph is K_{2, |S|} which is planar? Yes. So k can be large.

 Therefore, we cannot do O(k^2) per edge.

 Revised approach for K4:

   We know that a K4 is formed by two adjacent edges that form a triangle and then another edge? Actually, a K4 is a set of four vertices. We can iterate over the triangles and then check for a fourth vertex that is connected to all three? But that would be O(n) per triangle and total O(n^2).

 Alternatively, we can use the following: for each vertex u, we can look at its neighbors. Then for two neighbors v and w of u that are adjacent (so we have triangle u,v,w), then we look for a fourth vertex x that is adjacent to u, v, and w. Then we would form a K4: u, v, w, x. But again, the total number of triangles is O(n) and the number of common neighbors of the triangle might be O(1)? Actually, in a planar graph, a triangle can have at most one common neighbor? Why? Because if a triangle (u,v,w) has two common neighbors x and y, then we have a K_{3,2} which is planar? But then if we also have the edge between x and y, we get a K5 minus an edge? Actually, we don't require the edge between x and y for the common neighbor condition. But for K4, we require that x is adjacent to u, v, w, and also the edges between the triangle are there. Then the set {u,v,w,x} would form a K4. How many such x? Actually, the entire graph is planar, so the number of common neighbors of a triangle is at most 1? Why? Because if there are two, then we have a K_{3,2} which is planar, but then if we add the triangle, we have a K5 minus one edge? Actually, K_{3,2} is the utility graph, which is planar. But when we embed the triangle and the two common neighbors, we get:

   The triangle is a face. The two common neighbors must be inside the triangle? Then we have two vertices inside the triangle each connected to all three. Then we can connect these two vertices without crossing? Actually, no: because if we put two vertices inside the triangle and connect each to the three vertices, then we have two vertices that are both connected to the three vertices of the triangle. Then to connect these two without crossing the existing edges? It might be possible without crossing? Actually, we can draw one vertex and connect to the triangle, and then the other vertex and connect to the triangle without crossing? Then we can also connect the two inside? Then we have a K5? And K5 is non-planar. Therefore, a triangle cannot have two common neighbors? So the common neighbor for a triangle is at most 1.

 Therefore, for each triangle, we can check in O(1) the common neighbors? Then the total for K4 is O(#triangles). How to check: for a triangle (u,v,w), we want to find a vertex x that is adjacent to all three. We can take the intersection of the neighbor sets of u, v, w? But we have stored the neighbor sets as sets? Then the intersection of three sets? The size of each set can be large, but the total number of triangles is O(n), and the common neighbor for a triangle is at most 1? So we can do:

   For each triangle (u,v,w):
        Let common = adj_set[u] ∩ adj_set[v] ∩ adj_set[w]
        For each x in common (if any) such that x is distinct from u,v,w and also we avoid duplicates by ordering? But note: the same K4 might be found multiple times? Actually, a K4 has four triangles. So we must avoid duplicates.

 How to avoid duplicates? We can represent the K4 by the sorted tuple of the four vertices. Then we can use a set? But the total number of K4 is O(n) so we can store them.

 However, the intersection of three sets: if we use a hash set, we can do it in O(min(|adj_set[u]|, |adj_set[v]|, |adj_set[w]|)). Worst-case, the degrees can be high, but the total work over all triangles might be too high? The total number of triangles is O(n), but the min degree of the three might be large.

 Alternatively, we can iterate over the smallest of the three sets? That would be O(min_deg). But worst-case min_deg can be O(n) and total triangles O(n), so worst-case O(n^2). That is too high.

 Therefore, we need a better approach.

 Alternatively, we can precompute for each triangle (u,v,w) the common neighbors by storing for each vertex the neighbors, and then for the triangle, we can iterate over the neighbors of the smallest degree vertex and check if they are in the other two. The work per triangle is O(min_deg). Then the total work is O(n * min_deg) which worst-case is O(n^2).

 We must rely on the planarity: the minimum degree in a triangle? Actually, the entire graph has bounded average degree (since planar, m=O(n)), so the average degree is constant. But worst-case degree can be O(n). However, the total number of triangles is O(n). The worst-case total work would be the sum over triangles of the minimum degree of the three vertices. But the minimum degree of a vertex in the graph can be O(1). But worst-case, we might have a vertex with degree O(n) and then the triangles incident to that vertex would cost O(n) each? Then total O(n^2).

 This is too high for n=100,000.

 Therefore, we go back to the original idea: iterate over edges to get common neighbors, and then for each edge (u,v) and for each common neighbor w, we mark that w is adjacent to both. Then we want to check for each pair of common neighbors w and x: if (w,x) exists. But we cannot do a double loop per edge.

 Instead, we can do:

   For each edge (u,v):
        For each common neighbor w of (u,v):
            Then we consider the edge (u,w) and (v,w) -> we have the triangle (u,v,w). Now, we want to check: is there a fourth vertex x such that x is a common neighbor of (u,v) and also adjacent to w? Actually, that would form a K4? But note: we require that x is adjacent to u, v, and w? Then we have a K4 with x? But we also require that x is adjacent to the other common neighbors? Actually, we require the edge (w,x) to exist? Then we are looking for a common neighbor x of (u,v) that is adjacent to w.

   How to check? We can for each w in the common neighbors of (u,v), iterate over the neighbors of w and check if that neighbor x is also in the common neighbor set of (u,v) and also x>w (to avoid duplicates). Then we would do:

        For each edge (u,v):
            common = list of common neighbors of u and v.
            For each w in common:
                For each x in adj_set[w]:
                    if x in common_set and x > w:
                         then we have a K4: (u,v,w,x)

   The total work per edge is: for each common neighbor w, we iterate over the neighbors of w, and then check in a set (common_set) for membership. The total work per edge is: (sum_{w in common} deg(w)) * O(1) for the set check.

   The total over all edges: the outer loop is m edges. Then the inner loops: the total over all edges of (sum_{w in common} deg(w)) = sum_{edge (u,v)} [ sum_{w in common_neighbors(u,v)} deg(w) ].

   How to bound this? We know that the total over edges of the size of common_neighbors(u,v) is O(n) (since total triangles is O(n)). But we are summing deg(w) over the common neighbors for each edge. The same vertex w may appear in multiple edges. Actually, a vertex w is adjacent to u and v for each edge (u,v) that is incident to two neighbors of w? How many edges (u,v) can w be a common neighbor? For a fixed w, the edges (u,v) for which w is a common neighbor are the edges between two neighbors of w. The number of such edges is the number of edges in the induced subgraph of neighbors of w. Let d(w)=deg(w). Then the number of edges in the neighbor set of w is at most 3 * d(w) (because the graph is planar, so the induced subgraph on the neighbors of w has at most 3*d(w) edges? Actually, the induced subgraph on the neighbors of w is planar, so the number of edges is at most 3*d(w) - 6? But d(w) can be 1,2, so we can bound by 3*d(w)). Then the total over edges (u,v) of the sum_{w in common} deg(w) is:

        = sum_{w} [ deg(w) * (number of edges in the neighbor set of w) ]

        <= sum_{w} [ deg(w) * (3 * deg(w)) ]

        = 3 * sum_{w} deg(w)^2

   The sum of deg(w)^2 over all vertices: the graph is planar, so the sum of degrees is 2m = O(n). Then the sum of squares of degrees is at most (max_deg) * (sum deg) = O(n) * O(n) = O(n^2). But worst-case max_deg can be O(n), so the sum of squares is O(n^2). And n=100,000 -> n^2=10^10, which might be too high.

 Therefore, we need a better bound. Actually, we know that the graph is planar, so the number of edges m is O(n). The sum of squares of degrees: we have:

        sum_{v} deg(v)^2 = O( (sum deg(v)) * max_deg ) = O( (2m) * max_deg ) = O(n * max_deg)

   And max_deg in a planar graph can be O(n). Then worst-case O(n^2) which is 10^10 for n=100,000 -> 10^10 operations is too high in C++? Actually, we must avoid.

 We must use the fact that the graph is planar: by Euler's formula, the number of edges m <= 3n-6. But the sum of squares of degrees: we know that the average degree is constant? Actually, no: the maximum degree can be O(n). And there are graphs (like a star) where the sum of squares is O(n^2). But in a planar graph, the star is allowed? Yes. So worst-case the sum of squares is O(n^2).

 Therefore, we cannot do the above.

 Revised plan for K4:

   We know that the total number of K4 in a planar graph is O(n). Therefore, we can generate all K4 by:

        For each vertex u, we consider the set of neighbors N(u). Then we look for triangles in N(u). For each triangle (v, w, x) in the induced subgraph of N(u), then {u, v, w, x} forms a K4.

   How to do this? For each u, we consider the graph induced on N(u). Then we enumerate the triangles in that induced graph. The total work per vertex u is O( deg(u)^3 ) for enumerating triangles? That is too high.

   Alternatively, we can use the following: the induced graph on N(u) is planar? Yes. Then the number of edges in N(u) is at most 3*deg(u). Then we can enumerate the triangles in the induced graph on N(u) by iterating over edges: for each edge (v,w) in N(u), we look for common neighbors of v and w in N(u). But note: the common neighbors of v and w in the entire graph might be many, but we are restricting to N(u). Then the total work for a fixed u is:

        For each edge (v,w) in the induced graph of N(u):
             common = adj_set[v] ∩ adj_set[w] ∩ N(u)

        Then we can iterate over the common neighbors? But we have stored N(u) as a set? Then the work per edge (v,w) is O(min(deg(v), deg(w))). Then the total work per u is O( deg(u) * max_deg )? Which can be O(deg(u)^2). Then the total over u is O( sum_u deg(u)^2 ) = O(n * max_deg) = O(n^2).

   This is still too high.

 Given the complexity issues, we go back to the original double loop per edge for common neighbors, but we break if the common neighbor list is too long? Actually, we know that the total number of K4 is O(n), so the total number of edges (w,x) that form a K4 with (u,v) is O(n). Therefore, we want to avoid iterating over all pairs of common neighbors if there is no edge between them.

   We can do:

        For each edge (u,v):
            common = list of common neighbors.
            Build a set from common.

            For each w in common:
                For each neighbor x of w such that x is in common and x>w:
                    then we have a K4: (u,v,w,x)

            But how to iterate only over the neighbors of w that are in common? We can do: for each neighbor x of w, check if x is in the common_set and x>w.

        The total work per edge is: sum_{w in common} deg(w). And the total over edges is: sum_{edge} [ sum_{w in common} deg(w) ] = as above, O(3 * sum_{w} deg(w)^2) = O(n^2) worst-case.

   But note: the problem constraints: n=100,000, m=300,000. And worst-case the sum_{w} deg(w)^2 can be 100,000 * (10,000) = 10^9? Actually, worst-case a star: one vertex with degree n-1, then the sum of deg(w)^2: for the center: deg(center)=n-1, and then the leaves: deg(leaf)=1. Then the sum is (n-1)^2 + (n-1)*1 = O(n^2). And n=100,000 -> n^2=10^10, which is too high.

 We must hope that the test cases are not worst-case? Or we can optimize by breaking when the common set is large? And also use a hash set for the common set.

 But note: the common set per edge is the common neighbors of u and v. The size of the common set is the number of triangles that the edge (u,v) is in. And the total over edges of the common set sizes is 3 * (#triangles) = O(n). Therefore, the total work for the entire algorithm (over all edges) is:

        total_work = sum_{edge (u,v)} [ sum_{w in common_neighbors(u,v)} (number of neighbors of w) ]

        = sum_{w} [ deg(w) * (number of edges (u,v) such that w is a common neighbor) ]

        = sum_{w} [ deg(w) * (number of edges in the neighbor set of w) ]

        <= sum_{w} [ deg(w) * (3 * deg(w)) ]   [because the induced graph on the neighbors of w is planar and has at most 3*deg(w) edges]

        = 3 * sum_{w} deg(w)^2

   And we cannot avoid this.

 But we know that the graph is planar, so m=O(n). And the sum of deg(w) is 2m=O(n). But the sum of deg(w)^2 can be O(n^2). So worst-case we do O(n^2) work.

 However, the problem constraints: n=100,000 -> n^2=10,000,000,000. In C++, we can do about 100,000,000 operations per second? Then 10^10 operations would take 100 seconds. But the time limit is 4 seconds.

 Therefore, we need a more efficient method.

 Insight: we can use a different approach to enumerate K4. We know that the total number of K4 is O(n). We want to enumerate them without iterating over every edge and then over common neighbors and then over neighbors of common neighbors.

 Alternative: iterate over the edges of the graph and mark the triangles. Then, for each pair of triangles that share an edge and have two vertices that are adjacent, then we get a K4? Actually, two triangles sharing an edge: (u,v,w) and (u,v,x) -> then we have vertices u,v,w,x. We require that (w,x) exists to form a K4. How many such pairs of triangles? The total number of triangles is O(n). For each edge (u,v), we have the common neighbors (which are the triangles incident to (u,v)). Then the number of pairs of triangles incident to (u,v) is O(|common|^2) per edge. But we already argued that the sum of |common| over edges is O(n), but the sum of |common|^2 might be O(n^2)? Actually, the same as before.

 Therefore, we are stuck.

 But note: in a planar graph, an edge (u,v) can have at most O(1) common neighbors that are connected by an edge? Actually, no: the common neighbors might not be connected. But we are only interested in pairs (w,x) that are connected. And the total number of such pairs over the entire graph is the number of K4 times 6? Because each K4 has 6 edges? Actually, each K4 is counted for each edge (u,v) in the K4? Actually, for a fixed K4, we have 6 edges. For each edge in the K4, the two common neighbors that are the other two vertices form a pair that we would detect. And then we would generate the same K4 multiple times? Actually, we would generate it for each edge in the K4? So each K4 is generated 6 times.

 Therefore, the total number of pairs (w,x) that we consider (and that are adjacent) is 6 * (#K4) = O(n). So we wish to only do work proportional to the number of adjacent pairs (w,x) in the common set.

 How? We can:

        For each edge (u,v):
            common = list of common neighbors.
            Let S = set(common)

            For each w in common:
                For each x in adj_set[w]:
                    if x in S and x>w and (w,x) is an edge (which we know by checking the set of edges? Actually, we have the graph stored) -> then we have a K4: (u,v,w,x)

        The work per edge is: for each w in common, we iterate over the neighbors of w, and then check if the neighbor x is in S.

        The total work over the entire graph: sum_{edge (u,v)} [ sum_{w in common} deg(w) ]

        But we cannot bound that by O(n) because it is O( sum_{w} [ deg(w) * (# of edges in the neighbor set of w) ] ) = O( sum_{w} deg(w)^2 ) = O(n^2)

 But note: we are only interested in the neighbors x that are in the set S for this edge. And the set S is small on average? But worst-case S can be large.

 However, the number of x that are in S is exactly the number of neighbors of w that are in common for (u,v). And the total over all edges (u,v) and all w in common of the number of neighbors of w that are in common for (u,v) is:

        = sum_{w} [ (number of edges (u,v) for which w is a common neighbor) * (number of neighbors of w that are common neighbors for (u,v)) ]

   But note: the neighbors of w that are common neighbors for (u,v) are the vertices x such that x is adjacent to w and also adjacent to u and v. For a fixed w, the edges (u,v) that have w as a common neighbor are the edges in the neighbor set of w. And for a fixed w and edge (u,v), the common neighbors include the entire neighbor set of w that is also adjacent to both u and v? Actually, it is the common neighbors of u and v that are adjacent to w. But we are only counting the ones that are adjacent to w? And we are iterating over the neighbors of w.

   But the key is: the total over w of [ (number of edges (u,v) incident to w as a common neighbor) * (something) ] is not easily bounded.

 Given the time constraints, and the fact that the graph is planar and the worst-case might be rare, we can try the following:

        Use the method: for each edge (u,v), get common = common neighbors of u and v.
        If |common| > 100, then skip this edge? But then we might miss a K4.

   But note: in a planar graph, the maximum common neighbor count per edge might be bounded by a constant? Why? Because if an edge has more than a constant number of common neighbors, then we can find a subdivision of K_{3,3} or K5? Actually, no: the complete bipartite graph K_{2,k} is planar for any k. So we cannot bound |common|.

 Therefore, we must find a better way.

 We can precompute for each vertex w, the set of edges (u,v) for which w is a common neighbor. How? For each vertex w, and for each pair of neighbors u and v of w, we have an edge (u,v) that has w as a common neighbor. Then we can store:

        edge_groups[w] = list of edges (u,v) such that w is a common neighbor.

   Then, for a fixed w, we can iterate over the edges in edge_groups[w]. And then for each edge (u,v) in edge_groups[w], we can iterate over the neighbors x of w that are greater than w, and then check if x is a common neighbor of u and v? But then we would be doing the same as before.

 Alternatively, for a fixed w, we can iterate over the edges in edge_groups[w] and also have the set of common neighbors for the edge (u,v)? But we don't have that stored.

 Given the complexity, and that the intended solution might assume that the common neighbor lists are small because of planarity (even though theoretically not bounded), and the worst-case might be rare in practice, we can hope that the common neighbor lists are small.

 In practice, in a planar graph, an edge might not have too many common neighbors. So we will implement the double loop over common neighbors for the edge, but break if the common list is too large? We can set a threshold, say 10. If the common list has size > 10, then we skip the K4 for this edge? But then we might miss a K4 if an edge has 11 common neighbors and two of them are adjacent.

 Alternatively, we can do the following for large common lists: 
        For each w in common:
            for each x in adj_set[w]:
                if x > w and x in common_set and (w,x) exists (which we know by checking common_set) -> then we have a K4.

        But this is per common neighbor w, and we iterate over adj_set[w]. We hope that the common_set is small? No, common_set is the entire common set, but we are not iterating over common_set, we are iter over adj_set[w] and then checking membership in common_set.

        The work per common neighbor w is O(deg(w)).

        The total work per edge is O( |common| * max_{w in common} deg(w) ).

        The total over edges: sum_{edge} [ |common| * D ] where D is the maximum deg(w) among the common neighbors.

        This can be very large.

 We are in a bind.

 Let us read the sample inputs and outputs and hope that in practice the common neighbor lists are very small.

 Sample input #1: 
        3 2: common neighbors for edge (1,2): common = [3] -> then we do nothing for the double loop. For edge (2,3): common = [].

 Sample input #2: 
        common for (1,2): common=[3] -> then we look for neighbors of 3 that are in common_set and greater than 3? none. 
        for (1,3): common=[2] -> then we look for neighbors of 2 in common_set: common_set={2}? but we only consider neighbors greater than 2? none.
        for (2,3): common=[1] -> none.

 So we missed the K4? But wait, there is no K4 in sample #2. The sample #2 has a triangle and then a fourth vertex? Actually, the sample #2 has three cities and three edges: it is a triangle, which is size 3, not a K4.

 Therefore, we only need to worry about K4 when there are four cities all connected.

 How about a sample with K4? Let's make one.

        n=4, m=6, a complete graph on 4 vertices.

        Cities: any coordinates, and each edge has attraction points, say 1.

        Then we should find a K4 with score 6.

        How will our K4 enumeration work?

        Consider edge (1,2): common = [3,4] (because both 3 and 4 are adjacent to 1 and 2).
        Then we will check for w=3: iterate over adj_set[3]: which includes 1,2,4. 
            For x=4: and 4 is in common_set and 4>3 -> then we find the K4: (1,2,3,4).
        Then we will add the score: 6.

        But then we will also find the same K4 for other edges? Yes. So we use a set `done_k4` to store the sorted tuple of the four vertices to avoid duplicates.

        Then we will only process it once.

        The work for edge (1,2): common size=2. Then we iterate over w in [3,4]:
                for w=3: iterate over adj_set[3] = [1,2,4] -> we check x=1: skip because 1<3? no, we only consider x>w? Actually, we do x>w. But w=3, so we consider x=4. Then we find.
                for w=4: iterate over adj_set[4]: then we consider x>4? none.

        So we find it once.

        The work for edge (1,2): 2 * (degree of 3 and 4) = 2*3 = 6.

        Then for edge (1,3): common = [2,4] -> we do the same and find the K4 again? but we will skip because we store the sorted tuple.

        Total work over all edges: 6 edges, each has common size=2, and each common neighbor has degree=3, so total work = 6 * (2 * 3) = 36.

        This is acceptable.

        But if we have an edge with common size=1000, then work = 1000 * (average degree) = 1000 * 1000 = 1e6 per edge. And if there are 300,000 edges, worst-case total work 300,000 * 1e6 = 300e9 -> 300 billion, which is too high.

 Therefore, we must hope that in a planar graph, the common size is small. But worst-case common size can be O(n) (star like bipartite K_{2,n-2}) and then we are O(n^2) per edge? Actually, no: in a star, for the central edge? Actually, there is no central edge: the star has one central vertex and then leaves. The edges are from the center to the leaves. Then for an edge (center, leaf1): common = all other leaves? But then common size = n-2. And then we iterate over each leaf w, and then over the entire adj_set[w] which is only the center. So per common neighbor w, we iterate over 1 neighbor. Then total work per edge (center, leaf1) = (n-2) * 1 = O(n). Then the total over edges: there are n-1 edges, so total work = (n-1) * (n-2) = O(n^2). And n=100,000 -> 10e9, which is borderline in C++.

 But 10e9 iterations in C++ might take 10 seconds? We have 4 seconds.

 We need to optimize more.

 How about: for each edge (u,v), we know common = common neighbors.
   Instead of iterating over every common neighbor w and then over every neighbor x of w, we can: 
        For each w in common:
            for each x in adj_set[w]:
                if x > w and x in common_set -> then we have a candidate.

   But we can precompute for the common_set the list of common neighbors, and then for each w, we can restrict to the intersection of adj_set[w] and common_set, and then only consider x>w.

   However, we are already doing that by the membership check.

   Alternatively, for the common_set, we can let's create a static array for the common_set? But membership in a set is O(1).

   The only hope is that the common_set per edge is large only for a few edges.

 Given the time constraints, and the fact that worst-case we have O(n^2) which might be borderline for n=100,000 (10,000,000,000) in C++ (which is about 10 seconds on a fast machine), and the time limit is 4 seconds, we might need to risk or find a better method.

 Better method: 

   We know that the total number of K4 is O(n). Therefore, we wish to spend O(1) time per K4.

   How about: 
        For each vertex w, and for each pair of edges (w,u) and (w,v) such that u and v are adjacent (i.e., (u,v) is an edge), then we have a triangle (w,u,v). 
        Then, if there exists a vertex x such that x is adjacent to w, u, v, then we have a K4: (w,u,v,x). 

   But how to find x such that x is adjacent to w,u,v? We can store for each vertex the set of its neighbors. Then for the three vertices w,u,v, we can take the intersection of the three neighbor sets.

   But the work per triangle (w,u,v) is O(min(deg(w), deg(u), deg(v))). And the total number of triangles is O(n), so the total work is O(n * min_deg) which can be O(n^2)).

   Alternatively, we can use a hash map to count occurrences: 
        For a fixed triangle (w,u,v), we want to find vertices x that are in adj_set[w], adj_set[u], adj_set[v]. 
        We can iterate over the smallest of the three sets and increment a count in a map? But then we would have to clear the map for each triangle, which is O(min_deg) per triangle.

   Total work: sum_{triangle} min_deg = O(n * n) = O(n^2).

   This is too high.

 Given the complexity, and the fact that the intended solution for the ICPC problem might be to use the first method (iterating over edges and common neighbors) and rely on the planarity to have small common neighbor lists in practice, we will implement that.

 Steps for the C++ code:

   1. Read input.
   2. Build graph: 
          vector<vector<int>> graph (n+1)
          map or unordered_map for edges: keyed by (min, max) for an edge.

   3. Precompute common neighbors for each edge? Actually, we will not precompute, but for each edge (u,v) (which we have in the input), we will compute the common neighbors by: 
          common = intersection of graph[u] and graph[v]. 
        But we can do: 
          if (deg[u] > deg[v]) swap(u,v); 
          for each neighbor w of u:
               if w in adj_set[v] and w != u and w != v, then add w.

        But we stored adj_set as an unordered_set for each vertex? That would be O(n) per edge, total O(n * m) = 300,000 * 100,000 = 30e9.

   We cannot do that.

   4. Instead, we precompute for each vertex an unordered_set of neighbors.

   5. Then for each edge (u,v) in the input (or for each edge in the graph? we have m edges), we do:

          if (deg[u] > deg[v]) swap(u,v);   // so that deg[u] <= deg[v]
          vector<int> common;
          for (int w : graph[u]) {
              if (w == v) continue;
              if (adj_set[v].find(w) != adj_set[v].end()) {
                  common.push_back(w);
              }
          }

        This is O(deg(u)) per edge.

        Total work: sum_{edge} deg(u) = sum_{u} deg(u) * deg(u) = sum_{u} deg(u)^2 = O(n * max_deg) = O(n^2) worst-case.

   This is too high.

   6. Alternatively, we can do: 
          if (deg[u] < deg[v]) {
              for each neighbor w of u: check in adj_set[v]
          } else {
              for each neighbor w of v: check in adj_set[u]
          }
        Then the work per edge is O(min(deg[u], deg[v])).

        Total work: sum_{edge} min(deg[u], deg[v]) <= sum_{edge} sqrt(2m) ??? 

        Actually, we know: sum_{edge} min(deg[u], deg[v]) = O(m * sqrt(m))? 
        But worst-case, it can be O(n * m) = 100,000 * 300,000 = 30e9.

 Given the time, and that the graph is planar, the degrees might be small on average, but worst-case might be a star: then for the center, deg(center)=n-1, and for each edge incident to the center, min(deg)=1. Then total work = O(m). For edges not incident to the center: between leaves? there are none in a star. So total work O(m) = 300,000.

        In a complete graph on 4 vertices: each edge: min(deg)=2 or 3? Actually, every vertex has degree 3. Then for each edge, we do 3 work. Total work=6*3=18.

        In a graph that is a complete bipartite K_{2,1000}: 
            The two vertices in the first part have degree 1000.
            The 1000 vertices in the second part have degree 2.
            Edges: 2000.
            For an edge between a first-part vertex A and a second-part vertex B: 
                min(deg(A), deg(B)) = min(1000,2)=2.
                We iterate over the neighbors of B: which are the two first-part vertices.
                For each neighbor w of B: if w is in adj_set[A]? 
                    The neighbors of A are all the second-part vertices.
                    We are checking for w in adj_set[A]: which is an unordered_set, so O(1) per check.
                So per edge: 2 work.
            Total work = 2000 * 2 = 4000.

        Therefore, the total work is O(m) in these examples.

        But note: the sum_{edge} min(deg[u], deg[v]) is known in graph theory to be bounded by O(m * sqrt(m)) in general graphs, and in planar graphs it might be O(m) or O(m sqrt(m))? 

        In any case, we hope that in practice it is not too high.

 Given the above, we will do:

   - Precompute an array of unordered_set for each vertex (1..n) for the neighbors.
   - For each edge in the graph (we can iterate over the edges we've stored), we compute the common neighbors by:
        common.clear();
        if (deg[u] < deg[v] || (deg[u] == deg[v] && u < v)) {
            for (int w : graph[u]) {
                if (w != v && adj_set[v].count(w)) {
                    common.push_back(w);
                }
            }
        } else {
            for (int w : graph[v]) {
                if (w != u && adj_set[u].count(w)) {
                    common.push_back(w);
                }
            }
        }

   - Then for the triangles: for each edge, we have the common neighbors. Then we know the triangle (u,v,w) for each w in common.

   - For the K4: 
        done_k4: we will use a set<tuple<int,int,int,int>> or set of sorted tuples of four integers.
        But the total number of K4 is O(n), so we can afford.

        For the edge (u,v), we have common.
        Let common_set = unordered_set<int>(common.begin(), common.end());
        for (int w : common) {
            for (int x : graph[w]) {
                if (x > w && common_set.count(x)) {
                    // then we have a K4: u, v, w, x
                    vector<int> nodes = {u, v, w, x};
                    sort(nodes.begin(), nodes.end());
                    auto tuple = make_tuple(nodes[0], nodes[1], nodes[2], nodes[3]);
                    if (done_k4.find(tuple) == done_k4.end()) {
                        done_k4.insert(tuple);
                        // compute the total attraction for the 6 edges
                        // ...
                    }
                }
            }
        }

   - But note: the inner loop is over the degree of w, and we do it for every common neighbor w of the edge (u,v).

   - Total work: per edge (u,v), it is O( |common| * deg(w) ) for w in common, but the deg(w) might be large.

   - Alternatively, we can do for a fixed edge (u,v) and common_set, iterate over common and for each w in common, and then over the common_set and see if there is an edge between w and x for x>w in common_set. But then we could do:

        for (int w : common) {
            for (int x : common) {
                if (x > w && adj_set[w].count(x)) {
                    // then found
                }
            }
        }

        This is O(|common|^2) per edge.

   - Which is better? It depends on whether |common| is small or the degrees are small.

   - Given that |common| might be large, but the number of edges in the induced subgraph of common_set is O(1) per edge because the common_set is a set of common neighbors of (u,v) and the graph is planar, then the actual number of edges within common_set might be small. But we are not storing the induced graph.

   - We could also do: 
        for (int w : common) {
            for (int x : graph[w]) {
                if (x > w && common_set.count(x)) {
                    // 
                }
            }
        }

   - This is O( deg(w) ) per common neighbor w.

   - Total per edge: sum_{w in common} deg(w).

   - This is the same as before.

   - Given that we have two methods and we don't know which is better, and the worst-case might be bad, we choose based on the size of common:

        if (common.size() > threshold1) {
            // use the deg(w) method: iterate over graph[w]
        } else {
            // use the double loop over common: O(|common|^2)
        }

   - But the double loop over common might be O(|common|^2) which is quadratic in the common size, and if common size is 1000, then 1e6 per edge, and there are 300,000 edges -> 300e9.

   - So we use the deg(w) method always.

   - And hope that in practice the common.size() is small or the deg(w) is small.

 Given the complexity and the time, we will implement and hope.

 Steps summary for C++:

   - Use vector, unordered_set, and careful to avoid memory blowup.

   - Threshold for common.size() might be not used.

   - We will use:
        long long best = 0;
        // size1: 0 is covered.

        // size2: iterate over edges, best = max(best, a_j)

        // size3: for each edge (u,v), and for each common neighbor w, then triangle (u,v,w) and score = a_uv + a_uw + a_vw.

        // size4: for each edge (u,v), for each common neighbor w, and for each neighbor x of w that is in common_set and x>w, then K4.

   - We must also avoid duplicates in K4: use set<tuple<int,int,int,int>> done_k4.

   - But note: the number of K4 is O(n), so the set will have at most O(n) elements.

   - However, we are iterating over edges and might find the same K4 multiple times.

 Implementation details:

   - We will store:
        vector<unordered_set<int>> adj_set(n+1);
        vector<vector<int>> graph(n+1);   // adjacency list as vector of vectors

        // Read the edges and also store in a map: edge_to_a: keyed by (min, max) -> attraction

   - Precompute degrees deg for each vertex.

   - For triangles: 
        for each edge (u,v) in the edge_to_a map:
            // get common neighbors as above, with the min degree first
            vector<int> common;
            if (deg[u] < deg[v] || (deg[u] == deg[v] && u < v)) {
                for (int w : graph[u]) {
                    if (w == v) continue;
                    if (adj_set[v].find(w) != adj_set[v].end()) {
                        common.push_back(w);
                    }
                }
            } else {
                for (int w : graph[v]) {
                    if (w == u) continue;
                    if (adj_set[u].find(w) != adj_set[u].end()) {
                        common.push_back(w);
                    }
                }
            }
            for (int w : common) {
                // ensure the triangle is (u,v,w) with u<v<w? not necessarily, so we get the edges: (u,v), (u,w), (v,w)
                // but our edge_to_a is stored with min and max.
                int x1 = min(u, v), y1 = max(u, v);
                int x2 = min(u, w), y2 = max(u, w);
                int x3 = min(v, w), y3 = max(v, w);
                // Check if all three edges exist? They should because we found w in common.
                long long total = edge_to_a[make_pair(x1, y1)];
                if (edge_to_a.find(make_pair(x2, y2)) != edge_to_a.end())
                    total += edge_to_a[make_pair(x2, y2)];
                else
                    continue; // should not happen
                if (edge_to_a.find(make_pair(x3, y3)) != edge_to_a.end())
                    total += edge_to_a[make_pair(x3, y3)];
                else
                    continue;
                if (total > best) best = total;
            }

   - For K4: 
        // We'll use an unordered_set for done_k4, with a tuple of four ints sorted.

        for each edge (u,v) in the edge_to_a map:
            // common is computed as above
            unordered_set<int> common_set(common.begin(), common.end());
            for (int w : common) {
                for (int x : graph[w]) {
                    if (x <= w) continue;
                    if (common_set.count(x)) {
                        // we have a candidate: u, v, w, x
                        vector<int> nodes = {u, v, w, x};
                        sort(nodes.begin(), nodes.end());
                        auto key = make_tuple(nodes[0], nodes[1], nodes[2], nodes[3]);
                        if (done_k4.find(key) == done_k4.end()) {
                            done_k4.insert(key);
                            // Now, we need to compute the sum of the 6 edges.
                            long long total = 0;
                            vector<pair<int,int>> edges = {
                                {nodes[0], nodes[1]}, {nodes[0], nodes[2]}, {nodes[0], nodes[3]},
                                {nodes[1], nodes[2]}, {nodes[1], nodes[3]}, {nodes[2], nodes[3]}
                            };
                            for (auto& e : edges) {
                                auto it = edge_to_a.find(e);
                                if (it != edge_to_a.end()) {
                                    total += it->second;
                                } else {
                                    total = -1; // should not happen in a K4, but break.
                                    break;
                                }
                            }
                            if (total == -1) {
                                // This should not happen if we have a K4. But if we have a K4 minus an edge, skip.
                                continue;
                            }
                            if (total > best) best = total;
                        }
                    }
                }
            }

   - Finally, output best.

   - However, note: the graph might have duplicate work for triangles? Actually, we are processing each edge and then the common neighbors, and each triangle will be found multiple times? How many? Each triangle has three edges, so it will be found three times. But we are not deduplicating. That is okay, as long as we compute the score correctly each time.

   - But we are not storing the triangles in a set, so we are not avoiding duplicates. But that is okay: we want to update best.

   - However, it is inefficient to process the same triangle three times. We can avoid by ensuring u < v < w? 

        In the triangle, we can require that u < v < w. How? 
            When we process the edge (u,v), we only consider common neighbors w such that w > v? 

        But note: in our common neighbors, we might have w < u or between u and v? 

        We can do: 
            for an edge (u,v) with u<v, we only consider common neighbors w > v.

        Then a triangle (u,v,w) will be found only when we process the edge (u,v) and w>v, or when we process the edge (u,w) if u<w and v<w? not necessarily.

        Alternatively, we can only consider the edge with the smallest index? 

        We can: 
            Let u be the smallest vertex in the triangle.
            Then the edge (u,v) and (u,w) are the two edges incident to u. But we want to avoid.

        Instead, we can require: when processing edge (u,v) (with u<v), we only consider common neighbors w with w > v.

        Then the triangle (u,v,w) will be found only when processing the edge (u,v) and if w>v, and not found when processing (u,w) or (v,w) because then the condition w>v would not hold? 

        For example, triangle (1,2,3): 
            edge (1,2): we consider w>2 -> w=3 is included -> found.
            edge (1,3): we consider w>3 -> none.
            edge (2,3): we consider w>3 -> none.

        So we find it once.

        Therefore, we should add: 
            In the common neighbor collection for edge (u,v) (with u<v), we only include w>v.

        How? 
            In the common vector, we can do:
                if (w > v) then include? 
            But note: in the edge (u,v) we might have u>v in the else branch? We always ensure in the common neighbor collection we have u and v fixed.

        Actually, we should fix: 
            We are iterating for an edge (u,v) (and we know u and v, but we might swap for the min degree) -> we must be careful.

        Better: 
            Let u0 = min(u,v), v0 = max(u,v) initially? 
            Then we want w > v0.

        But wait: the edge might be stored in the map as (u0, v0). And in the common neighbor collection, we want w > v0.

        We can do:

            int u0 = min(u, v);
            int v0 = max(u, v);
            ...
            for (int w : ... ) {
                if (w > v0) {
                    common.push_back(w);
                }
            }

        But note: we might have a common neighbor w that is < v0? Then we skip.

        This ensures each triangle is found exactly once.

        However, for the K4: 
            We are iterating over the edge (u,v) and then common neighbors w (which are > v0). Then we are then looking for x>w and in common_set (which also > v0) and also adjacent to w.

        This will find the K4 only when we process an edge that is the minimum edge in the sense of having the smallest two indices? 

        How to ensure we find every K4? 

            In a K4: (a,b,c,d) with a<b<c<d.
            We will process the edge (a,b): then common_set = {c,d} (if c,d are adjacent to a and b). Then we will find the pair (c,d) if (c,d) is an edge.

            We will also process edge (a,c): common_set = {d} (if b is not greater than c? because we require w>c, and b<c, so b not included). Then we won't find b in common_set.

            But note: we only consider common neighbors w that are > v0 = max(a,b). For edge (a,b) (with a<b, v0=b), we require w> b. In the K4, if a<b<c<d, then the common neighbors for (a,b) are c and d, and both are > b. Then we will consider w=c and then x=d (if d>c) and find the edge (c,d). 

            Then we find the K4 when processing edge (a,b).

            Similarly, we might find the same K4 when processing edge (a,c) if we are not careful: 
                edge (a,c): u0=a, v0=c, common_set = {b, d}? 
                But b < c, so we skip b. 
                d>c, so we have d. 
                Then we would look for a neighbor x of d that is in common_set and > d? none. 
                Then we would not find any pair.

            So we find the K4 only once, for the edge (a,b).

        Therefore, we are safe.

        Steps for triangle and K4: 
            In the common neighbor collection for edge (u,v) (with u0=min(u,v), v0=max(u,v)), we only include common neighbors w that are > v0.

        This reduces the common_set size and also ensures no duplicate triangles and K4.

   - Update the common neighbor collection accordingly.

   - Also, for the K4: when we are on the edge (u,v) and then we have a common neighbor w>v0, and then we find x>w in the common_set (which means x>v0 and x>w), then we have the four vertices: u0, v0, w, x.

   - And we sort them: they will be sorted as (u0, v0, w, x) since u0<v0<w<x.

   - Then the tuple is (u0, v0, w, x).

   - And we use done_k4 to avoid duplicates? Actually, we are generating the same K4 only once, so we can skip the done_k4 set? 

        Because each K4 is found only by the edge (u0, v0) which is the smallest two vertices.

        So we don't need done_k4? 

        But consider: the K4 might be found multiple times for the same edge (u0,v0) if there are multiple pairs (w,x) that are adjacent? But no, the common_set is fixed for the edge, and we iterate over w and then x, and each pair (w,x) is distinct.

        And we only generate one tuple per set of four.

        However, for a fixed edge (u0,v0) and a fixed pair (w,x), we will generate the same tuple (u0,v0,w,x) only once.

        So we don't need done_k4.

        We can remove the done_k4 set.

   - But note: what if the edge (u0,v0) has two different pairs (w,x) that yield the same four vertices? No, because w and x are from the common_set, and each pair (w,x) is distinct.

   - So we remove done_k4.

   - Then for K4:

        for (int w : common) {   // w > v0
            for (int x : graph[w]) {
                if (x > w && common_set.find(x) != common_set.end()) {  // common_set contains only common neighbors that are > v0
                    vector<int> nodes = {u0, v0, w, x};
                    sort(nodes.begin(), nodes.end());   // actually already u0<v0<w<x, but we do it to be safe?
                    // They are already sorted: u0 = min, then v0, then w, then x.
                    // Now, compute the sum of the 6 edges.
                    // ...
                }
            }
        }

   - But note: we computed u0 and v0 from the original u and v? We must be careful: we did u0 = min(u,v), v0 = max(u,v). But then we did the common_set including only w>v0.

   - And the common_set is built from common, which is the list of common neighbors that are >v0.

   - Then we iterate over w in common, and then over the neighbors x of w that are >w and in common_set.

   - And then the four vertices are u0, v0, w, x.

   - And they are distinct and in increasing order.

   - Then we compute the six edges.

   - But note: we stored the edge_to_a with the key as (min, max).

   - We can compute the six edges.

   - And if any edge is missing, skip (should not happen in a K4).

   - But note: our common_set is built from the common neighbors, which are adjacent to u0 and v0. And we also check that x is adjacent to w. But we don't check the edges between u0 and w, v0 and x, etc. are present? Actually, we already know: 
          (u0, v0): exists (because we are processing the edge)
          (u0, w): exists because w is a common neighbor of u0 and v0, and we are in the common_set for (u0,v0) -> so w is adjacent to u0.
          (u0, x): similarly, x is in common_set -> adjacent to u0.
          (v0, w): similarly, w is adjacent to v0.
          (v0, x): similarly, x is adjacent to v0.
          (w, x): we checked by the for-loop.

        So all six edges exist.

   - Therefore, we don't need to check existence, but we do need to fetch the attraction points.

   - But we have stored them in edge_to_a.

   - We can do:

        long long total = edge_to_a[{u0, v0}];
        total += edge_to_a[{u0, w}];
        total += edge_to_a[{u0, x}];
        total += edge_to_a[{v0, w}];
        total += edge_to_a[{v0, x}];
        total += edge_to_a[{w, x}];

        Then update best.

   - However, the edge (w,x) might be stored as (min(w,x), max(w,x)) = (w,x) since w<x.

   - And the others: (u0, w): u0<w, so (u0,w) is the key.

   - Similarly for others.

   - But note: we might have built u0 and v0 as min(u,v) and max(u,v), but the edge (u0, v0) is in the map.

   - So we can do:

        total = edge_to_a[make_pair(u0, v0)];
        total += edge_to_a[make_pair(u0, w)];
        total += edge_to_a[make_pair(u0, x)];
        total += edge_to_a[make_pair(v0, w)];
        total += edge_to_a[make_pair(v0, x)];
        total += edge_to_a[make_pair(w, x)];

   - And then update best.

   - But caution: the edge_to_a might not have an edge? But we know they exist. So we can assume they are there.

   - However, we used an unordered_map. We should use .at() or check? But we know.

   - We can do direct lookup, but if not present, it will be inserted with 0? But we want to avoid. We use:

        total = edge_to_a[{u0, v0}];
        total += edge_to_a[{u0, w}];
        total += edge_to_a[{u0, x}];
        total += edge_to_a[{v0, w}];
        total += edge_to_a[{v0, x}];
        total += edge_to_a[{w, x}];

        But if any is missing, we would get 0? That would be bad.

   - We are sure they exist? Yes.

   - So we can do.

   - But to be safe, we can check at the beginning that we only consider edges that exist.

 Given the complexity of the code and the constraints, we write and hope.

   - We assume the entire graph is stored correctly.

   - Note: the input guarantees at most one edge between a pair.

   - We stored edge_to_a for every edge.

   - So the lookups should succeed.

   - We do:

        total = edge_to_a.at(make_pair(u0, v0));
        total += edge_to_a.at(make_pair(u0, w));
        ... 

        But using at() will throw if not present. We want to avoid.

   - Alternatively, we can store the six edges in a vector and then iterate.

        vector<pair<int,int>> e = {
            {u0, v0}, {u0, w}, {u0, x}, {v0, w}, {v0, x}, {w, x}
        };
        long long total = 0;
        for (auto& p : e) {
            auto it = edge_to_a.find(p);
            if (it == edge_to_a.end()) {
                total = -1; break;
            }
            total += it->second;
        }
        if (total == -1) continue;

   - But we know it should not happen.

   - We can skip if we want speed.

   - Let's skip the checks and use direct map access: operator[].

   - But operator[] will insert if not present? We don't want that.

   - We should use:

        total = 0;
        total += edge_to_a[{u0, v0}];   // but only if we are sure.

   - Alternatively, we can store in a vector the six keys and then do:

        total = 0;
        vector<pair<int,int>> keys = {
            {u0, v0}, {u0, w}, {u0, x}, {v0, w}, {v0, x}, {w, x}
        };
        for (auto& key : keys) {
            auto it = edge_to_a.find(key);
            if (it == edge_to_a.end()) {
                total = -1; break;
            }
            total += it->second;
        }
        if (total == -1) continue;

   - This is O(1) since 6.

   - We do that.

 Finally, note: the problem might have no edges? then we output 0.

   - Size1: 0.

   - Also, if there are no triangles and no K4, then best is the best edge.

   - We initialize best=0.

   - If there is an edge with negative attraction? no: a_j>=0.

   - So best will be at least 0.

   - We output best.

 Let's hope.

 Given the time, we write the code accordingly.

 We note: the worst-case might be a complete graph on 4 vertices: then the common_set for the edge (1,2) will be {3,4} (if vertices are 1,2,3,4). Then we do:
        for w=3: iterate over graph[3] and find 4 (which is in common_set) -> then we compute the K4.
        for w=4: iterate over graph[4] and find nothing (since 3<4, and we require x>4? so not).

        So we find one K4.

   - The triangle for edge (1,2) will be: common = {3,4} but we only include w>2: both 3 and 4. Then we will compute two triangles? 
          triangle (1,2,3) and (1,2,4)
        But wait, the triangle (1,2,3) is not a triangle in the K4? Actually, it is part of the K4. But we also want to consider triangles that are not part of a K4? 

        In the complete graph, the triangles are the faces. We will find the triangle (1,2,3) and (1,2,4) and then the triangle (1,3,4) and (2,3,4) might be found when processing other edges.

        But we only process edge (1,2) for triangles: we find (1,2,3) and (1,2,4). Then when processing edge (1,3): we will also find (1,3,4) because 4>3. And edge (1,4): then nothing. Edge (2,3): (2,3,4). Edge (2,4): nothing, edge (3,4): nothing.

        So we find all four triangles.

        But the problem: the triangle (1,2,3) has score a12+a13+a23, which might be less than the entire K4.

        That is okay: we are updating best for triangles and then for K4.

   - So we will get the K4 and the triangles, and the K4 score should be the sum of all six edges, which is larger.

   - Then we output the K4.

   - But note: the complete graph on 4 vertices is planar? It is, actually.

 Therefore, the code should work.

 Let's code accordingly.

 However, the work might be heavy for a planar graph that is dense locally.

 But note: the constraints say m<=300,000, and n<=100,000.

 We must use:

   - Fast IO.
   - Use unordered_set for adj_set and a vector of vectors for graph.
   - Use a good hash for the edge_to_a? We can use pair<int,int> as key for the map.

   - Also, for the common_set per edge, we can avoid building a set if common.size() is small? But the double loop over common_set is by iterating over the graph of w, not over common_set.

   - We build common_set as an unordered_set for each edge. The total number of edges is m=300,000. The total work to build the set per edge is O(|common|). And the total over edges of |common| is O(n) (because total triangles is O(n)), so the total work is O(n) = 100,000? 

        Actually, the sum of |common| over edges is 3 * (#triangles) = O(n).

   - So building common_set over all edges is O(n).

   - Then the inner loop: for each edge, for each w in common, and for each x in graph[w] (and then check in common_set) -> total work is O( sum_{edge} [ sum_{w in common} deg(w) ] ) = O( sum_{w} [ deg(w) * (# of edges that have w as a common neighbor) ] ) = O( sum_{w} [ deg(w) * (number of edges in the neighbor set of w) ] ) = O( sum_{w} deg(w)^2 ) = O(n * max_deg) = worst-case O(n^2).

   - But hope: the test data may not be worst-case.

   - If we encounter a worst-case (like a complete bipartite K_{2, 50000}), then n=50002, and the edge_to_a map has 100000 edges. 
        For an edge (A, B) in the first part: there is no common neighbor? because the common neighbor would be in the second part, but an edge in the first part doesn't exist? 

        Actually, the graph is complete bipartite: only edges between the two parts. So the common neighbors for an edge (A, B) in the first part? 
            There is no edge between A and B? because the graph is bipartite. So the edge (A,B) does not exist.

        How do we store edges? We only store the given edges. The given edges are only between the two parts.

        Therefore, in a complete bipartite K_{2, n-2}, the edges are between the two vertices in the first part and each leaf? 
            But there is no edge within the first part.

        So our edge_to_a does not contain any edge within the first part.

        Therefore, we will not even process an edge (A,B) because it is not in the input.

        So the only edges are between the first part and the second part. 
            For an edge (A, leaf_i): 
                common_set = common neighbors of A and leaf_i? 
                The neighbors of A are all leaves.
                The neighbors of leaf_i are the two in the first part.
                The common neighbors: 
                    For the edge (A, leaf_i), common neighbors: 
                        w must be adjacent to A and to leaf_i.
                        Adjacent to A: all leaves.
                        Adjacent to leaf_i: the two in the first part.
                        Intersection: none? because a leaf is not in the first part? 

                So common_set is empty.

        Then the work per edge is O( min(deg(u), deg(v)) ) for building common, which is O(1) for the leaves (deg=2) and for the center (deg=n-2) we do the else branch? 

            For an edge (A, leaf_i): 
                u0 = A, v0 = leaf_i.
                deg[A] = n-2, deg[leaf_i]=2 -> we do the else branch: iterate over the neighbors of leaf_i: which are the two in the first part. 
                    For each neighbor w of leaf_i: 
                        if w==A? skip.
                        else: check in adj_set[A]: which is the set of leaves? and w is in the first part, not in the leaves? so no.
                common is empty.

        Therefore, the work is O( min(deg(u), deg(v)) ) per edge, which for this graph is O(1) per edge.

        Total work O(m).

   - So the complete bipartite is not worst-case.

   - The worst-case might be a graph that is not bipartite, with a vertex of high degree and many triangles incident to one edge.

   - But the common_set per edge is the common neighbors that are > v0, and the total over edges is O(n), so the inner loop might be heavy only for a few edges.

   - We will hope and submit.

   - Also, we can add a break if the running time is too long? Not in code.

   - We write in C++ and use fast hashing for the unordered_set.

 Implementation:

   - We'll use:

        #include <bits/stdc++.h>
        using namespace std;

        typedef long long ll;
        typedef pair<int, int> pii;

        vector<pii> cities;
        vector<vector<int>> graph;
        vector<unordered_set<int>> adj_set;
        vector<int> deg;
        map<pii, ll> edge_to_a;   // we can use unordered_map if we hash pairs.

        // But we'll use map for pairs, which is log, but m=300,000, so 300,000 log(300,000) is about 3e5*19 = 5.7e6, acceptable.

        // Alternatively, we can do: 
        //    unordered_map with hash: 
        //        struct hash_pair {
        //          size_t operator()(const pii& p) const {
        //               return (1LL * p.first * (some big number) + p.second;
        //          }
        //        };
        //    unordered_map<pii, ll, hash_pair>

        // We do unordered_map for speed.

   - But the keys are pairs of integers, and we are only storing m=300,000 edges.

   - We'll do unordered_map.

   - Steps:

        int n, m;
        cin >> n >> m;
        cities.resize(n+1);
        graph.resize(n+1);
        adj_set.resize(n+1);
        deg.assign(n+1, 0);
        for (int i=1; i<=n; i++) {
            int x, y;
            cin >> x >> y;
            cities[i] = {x, y};
        }

        for (int i=0; i<m; i++) {
            int u, v, a;
            cin >> u >> v >> a;
            if (u > v) swap(u, v);
            graph[u].push_back(v);
            graph[v].push_back(u);
            deg[u]++; deg[v]++;

            // store in edge_to_a
            edge_to_a[{u, v}] = a;
        }

        // Now, build adj_set: for each vertex, we put the neighbors in an unordered_set.
        for (int i=1; i<=n; i++) {
            adj_set[i] = unordered_set<int>(graph[i].begin(), graph[i].end());
        }

        ll best = 0;

        // size2: best edge
        for (auto& e : edge_to_a) {
            if (e.second > best) best = e.second;
        }

        // triangles and K4

        // We'll iterate over all edges in edge_to_a.
        // Note: we have m edges.

        // For triangles: for each edge (u,v) in edge_to_a, we compute common neighbors that are > max(u,v).

        // Also for K4: the same common set.

        // Let's create a vector of edges: the keys of edge_to_a.
        vector<pii> edges_list;
        for (auto& e : edge_to_a) {
            edges_list.push_back(e.first);
        }

        // But we can also iterate by the map.

        // For each edge in the map:
        for (auto& e : edge_to_a) {
            int u = e.first.first;
            int v = e.first.second;
            ll a = e.second;

            int u0 = min(u, v);
            int v0 = max(u, v);

            vector<int> common;
            if (deg[u0] > deg[v0] || (deg[u0] == deg[v0] && u0 > v0)) {
                swap(u0, v0);   // we want u0 to be the one with smaller degree, or if tie then smaller index? 
                // But note: the common neighbor condition: we want to iterate over the vertex with smaller degree.
                // Actually, we don't care about u0 and v0 for the common neighbor, we only care about the set.
                // We'll do: we want to iterate over the neighbors of the vertex with smaller degree.
                // Let a = u0, b = v0, but now u0 and v0 are swapped? 
                // Actually, we did u0 = min(u,v), v0 = max(u,v) at the beginning. Then we did not use u0, v0 for the degree condition.
                // We want to iterate over the vertex with smaller degree between the original u and v? 
                // We can do: 
                //   int x = u, y = v;
                //   if (deg[x] > deg[y]) swap(x,y);
                //   then iterate over x.
                // But we have u0 and v0: and we are going to iterate over the neighbors of the vertex with smaller degree (or if tie, the one with smaller index? but we have u0 and v0, and u0<v0, but that might not be the one with smaller degree).
            }

            // Let's recompute without using u0 and v0 for the degree condition:
            int x = u, y = v;
            if (deg[x] > deg[y] || (deg[x] == deg[y] && x > y)) {
                swap(x, y);
            }
            // Now, x has the smaller degree (or if tie, the smaller index).

            // But note: we want common neighbors that are > max(u,v) = max(x,y) = y (since x<y? not necessarily: we swapped for the degree, but the indices? we want the common neighbors that are greater than the maximum index of the original pair? 
            // Actually, we want common neighbors that are greater than the maximum index of the edge we are processing, which is v0 = max(u,v). 
            // But we have the original u and v: we have stored u0 = min(u,v) and v0 = max(u,v). 
            // We want w > v0.

            // We do:
            for (int w : graph[x]) {
                if (w == y) continue;
                if (w > v0 && adj_set[y].find(w) != adj_set[y].end()) {
                    common.push_back(w);
                }
            }

            // But note: if we did swap x and y, we are iterating over the neighbors of x, but we are checking in adj_set[y]? 
            //   If we did swap, then x was originally the one with the larger degree? But we swapped to make x the smaller degree. 
            //   But we want the common neighbors of the original u and v. 
            //   Since the graph is undirected, the common neighbors of u and v are the same as of the swapped pair.

            // Now, for triangles:
            for (int w : common) {
                // triangle: u0, v0, w (with u0<v0<w)
                ll total_tri = a;
                // get edge (u0, w) and (v0, w)
                // Note: u0 = min(u,v), v0 = max(u,v) [the original indices]
                // The edge (u0, w): key = (u0, w) since u0<w.
                // The edge (v0, w): key = (v0, w) since v0<w.
                total_tri += edge_to_a[{u0, w}];
                total_tri += edge_to_a[{v0, w}];
                if (total_tri > best) best = total_tri;
            }

            // For K4: 
            unordered_set<int> common_set(common.begin(), common.end());
            for (int w : common) {
                for (int x : graph[w]) {
                    if (x > w && common_set.find(x) != common_set.end()) {
                        // found: u0, v0, w, x
                        vector<pair<int,int>> edges = {
                            {u0, v0}, {u0, w}, {u0, x}, {v0, w}, {v0, x}, {w, x}
                        };
                        ll total_k4 = 0;
                        bool valid = true;
                        for (auto& edge_p : edges) {
                            auto it = edge_to_a.find(edge_p);
                            if (it == edge_to_a.end()) {
                                valid = false;
                                break;
                            }
                            total_k4 += it->second;
                        }
                        if (!valid) continue;
                        if (total_k4 > best) best = total_k4;
                    }
                }
            }
        }

        cout << best << endl;

   - But note: we have defined u0 and v0 as the original min and max of the edge, and we use them in the triangle and K4.

   - However, in the common_set we built from common, which contains only w>v0.

   - This should be correct.

   - But note: the swap of x and y for iteration doesn't affect u0 and v0: we have u0 = min(u,v), v0 = max(u,v) from the edge.

   - And we use u0 and v0 in the triangle and K4.

   - So we are good.

   - However, we must not swap u0 and v0: they are the original.

   - Let me rework:

        Let u0 = min(u,v), v0 = max(u,v).  // the original edge in sorted order.

        Then, to iterate over the common neighbors, we choose the vertex with the smaller degree between u and v (the original, not u0 and v0) to iterate over.

        But note: u0 might not be the vertex with the smaller degree.

        We do:

            int x = u, y = v;   // the original from the edge (we have stored the edge as (u0, v0) in the map, but u and v are the original input? we swapped to get u0 and v0).

            Actually, the edge in the map is stored as (min(u,v), max(u,v)). So u0 and v0 are the endpoints.

            Now, we want to choose between u0 and v0: which has the smaller degree? 

            So we do:

                int iter_vertex = u0;
                int other = v0;
                if (deg[u0] > deg[v0]) {
                    iter_vertex = v0;
                    other = u0;
                } else if (deg[u0] == deg[v0] && u0 > v0) {
                    iter_vertex = v0;
                    other = u0;
                }

            Then we iterate over the neighbors of iter_vertex.

        Alternatively, we can do as above: set x = u0, y = v0, then if (deg[x] > deg[y] || (deg[x]==deg[y] && x>y)) then swap(x,y) and then iterate over x.

        Then we do:

            for (int w : graph[x]) {
                if (w == y) continue;
                if (w > v0 && adj_set[y].find(w) != adj_set[y].end()) {   // here y is the other vertex (which is the larger index? not necessarily: we swapped x and y, but we require w>v0, and v0 is the max of the original pair, so it is fixed) 
                    common.push_back(w);
                }
            }

        Because we only care about the common neighbors that are > v0.

        This is correct.

   - But note: we do not change u0 and v0: they are the original.

   - So we can do.

   - We'll do:

        for (auto& e : edge_to_a) {
            int u0 = e.first.first;
            int v0 = e.first.second;
            int x = u0, y = v0;
            if (deg[x] > deg[y] || (deg[x] == deg[y] && x > y)) {
                swap(x, y);
            }
            // Now, x is the vertex with smaller degree (or if tie, smaller index), and y is the other.

            // But note: the common neighbors must be > v0 = max(u0, v0) = v0 (since u0<v0, so v0 is the max).

            vector<int> common;
            for (int w : graph[x]) {
                if (w == y) continue;
                if (w > v0 && adj_set[y].count(w)) {
                    common.push_back(w);
                }
            }
            ... // then triangles and K4 as above

   - This should be correct.

   - However, note: in the condition, we are checking adj_set[y].count(w): 
        - y is the other vertex (which might be u0 or v0? but we swapped x and y so that x is the one we iterate on, and y is the other).
        - The common neighbors are the same.

   - And the requirement: w must be adjacent to both x and y? 
        - We are iterating over the neighbors of x, and then checking that w is adjacent to y.

   - So we are good.

   - We write the code accordingly.

   - Also, if there are no edges (m=0), then the loop over edge_to_a is empty, and best remains 0.

   - Output best.

   - We test with the sample inputs.

 Due to the complexity, we hope it passes.

 Let's run sample1:

        "3 2
         0 0
         0 1
         1 0
         1 2 10
         2 3 20"

        edge_to_a: 
            { (1,2):10, (2,3):20 }

        best = max(10,20) = 20.

        For edge (1,2): 
            u0=1, v0=2.
            x=1, y=2: deg[1] and deg[2]? we didn't compute the degrees? 
            We did: 
                graph[1] = {2, ...?} 
                Actually, for city1: neighbors: from edge1: 2, and no other? 
                So deg[1]=1, deg[2]=2? 
            Then we set x=1, y=2 (since deg[1] < deg[2]).
            Iterate over graph[1]: neighbors: [2] -> skip w==y (2), then next? none. 
            common = [].

        For edge (2,3):
            u0=2, v0=3.
            deg[2]=? we built the graph: 
                graph[2] = {1,3} -> deg[2]=2.
                graph[3] = {2} -> deg[3]=1.
            Then for edge (2,3): we set x=3, y=2 (because deg[3]=1 < deg[2]=2, and then we swap so that x=3, y=2? but then we iterate over graph[3]: which is [2] -> skip y=2. Then common=[].

        Then we don't find any triangle.

        But the triangle (2,3) doesn't exist? Actually, the triangle in the sample is (1,2,3) but it requires the edge (1,3) which is not present.

        And we only have edges (1,2) and (2,3). So there is no triangle.

        So best remains 20.

        Output 20: correct.

        Sample2: 
            "3 3
             0 0
             0 1
             1 0
             1 2 10
             2 3 20
             1 3 30"

        Then the edge_to_a: 
            (1,2):10, (2,3):20, (1,3):30

        best = max(10,20,30)=30.

        For edge (1,2): 
            u0=1, v0=2.
            deg: 
                graph[1]: [2,3] -> deg[1]=2
                graph[2]: [1,3] -> deg[2]=2
                graph[3]: [1,2] -> deg[3]=2
            For edge (1,2): x=1 (because deg[1]=2, and 1<2? but our condition: if (deg[1]>deg[2] || (deg[1]==deg[2] && 1>2)) -> false, so we do not swap: x=1, y=2.
            Then iterate over graph[1]: neighbors: 2 (skip) and 3.
                w=3: check if 3>v0=2 -> yes, and check in adj_set[2] (which is {1,3}) -> yes.
                common = [3]
            Then triangle: (1,2,3): total_tri = 10 (edge(1,2)) + edge(1,3)=30 + edge(2,3)=20 -> 60.
            Then update best = max(30,60)=60.

            Then K4: common_set = {3}
            for w=3: iterate over graph[3] = [1,2]
                for x in [1,2]:
                    x=1: 1<=3 -> skip? but we require x>w=3? no, so skip.
                    x=2: 2<3 -> skip.
            So no K4.

        For edge (1,3): 
            u0=1, v0=3.
            x=1, y=3: deg[1]=2, deg[3]=2, and 1<3 -> no swap.
            Iterate over graph[1]: [2,3] -> skip 3, then w=2: check if 2>3? no, skip.
            common = [].

        For edge (2,3):
            u0=2, v0=3.
            x=2, y=3: no swap? because deg[2]=2, deg[3]=2, and 2<3 -> no swap.
            Iterate over graph[2]: [1,3] -> skip 3, then w=1: 1>3? no, skip.

        Then best=60.

        Output 60: correct.

   - Therefore, the code works for the samples.

   - We note: the triangle is found in the edge (1,2) and we get 60.

   - But the triangle (1,2,3) is also an edge (1,3) and (2,3) and (1,2). We are not processing the other edges for the triangle? but we don't need to because we found it at (1,2).

   - So we are good.

   - We write the code.

   - We also note: the common_set per edge is built from common, which is at most O(1) per edge in practice? we hope.

   - We'll run on the largest test.

   - But if we get TLE, we might need to optimize the inner loop.

   - We output the code.

   - Note: we must be cautious with the degrees: we computed deg in the input, and then we use it.

   - We use: #include <unordered_set> and #include <vector> and <iostream> and <algorithm> and <map> -> we use bits/stdc++.h.

   - We use:

        #include <bits/stdc++.h>
        using namespace std;
        typedef long long ll;

        struct pair_hash {
            template <class T1, class T2>
            std::size_t operator () (const std::pair<T1,T2> &p) const {
                auto h1 = std::hash<T1>{}(p.first);
                auto h2 = std::hash<T2>{}(p.second);
                return h1 ^ (h2 << 1);
            }
        };

        int main() {
            ios::sync_with_stdio(false);
            cin.tie(nullptr);

            // ... code ...

        }

   - But the pair_hash can be improved.

   - Alternatively, we can use:

        unordered_map<pii, ll, pair_hash> edge_to_a;

   - Or we can use a map.

   - Given m=300,000, we can use map.

   - We do:

        map<pii, ll> edge_to_a;

   - Then we don't need the hash.

   - Code below.