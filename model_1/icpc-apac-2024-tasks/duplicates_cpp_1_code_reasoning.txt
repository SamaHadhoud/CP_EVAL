 Okay, we are going to follow the editorial guidelines.

 Steps for each test case:
 1. Read n and the matrix.
 2. Identify bad rows: a row is bad if it has n distinct elements (i.e., it is a permutation of 1..n).
 3. Identify bad columns similarly.
 4. The minimum number of modifications required is the maximum of the counts of bad rows and bad columns. Why?
    - We can fix one bad row and one bad column with a single modification at their intersection. So we fix min(r, c) pairs that way.
    - Then we have |r-c| bad rows (or bad columns) left. Each requires one modification.

 5. How to fix?
    - For the first min(r, c) pairs: we take the i-th bad row and i-th bad column and modify the element at (bad_row[i], bad_col[i]).
        We choose a value for that cell that breaks the permutation in both the row and the column. The idea: we can set it to 1, unless the original was 1 then we set to 2? Actually, we need to break the distinctness. But note: we can set any value that is already present in the row or in the column? Actually, we don't have to worry about the entire row and column because we are going to break the distinctness by introducing a duplicate.

    However, note: we are allowed to set to any integer between 1 and n. We can choose any value that is not the current one? Actually, we can set to any value. But we must break the row and the column.

    Important: if we set the value to a number that is already in the row, then the row will have a duplicate (unless we are unlucky and the value we set is the same as the original and we are replacing the only occurrence? Actually, we are replacing the current value). 

    Actually, let's think: the row has distinct elements. We are changing one element. We want to make the row have a duplicate. How? We set the value to a number that already exists elsewhere in the row. Similarly for the column.

    But note: we can choose a value that is already present in the row? Then the row will have two of that value -> duplicate. Similarly, if we set the value to one that is already present in the column? Then the column will have a duplicate.

    However, we have to break both at once. How? We can set the value to a number that is already present in the row OR in the column? Actually, we don't need it to be in both. If we set it to a number that is in the row, then the row becomes non-distinct. Similarly, if we set it to a number that is in the column, the column becomes non-distinct. But we want to break both.

    We can do:
      Option 1: choose a value that is already in the row (so the row gets broken) and then the column? Even if the column does not break at this step, note that the column might have been broken by the introduction of this value? Actually, if the value we set is already in the column? Then the column breaks. Otherwise, the column might still be distinct? But then we have broken only the row.

    We must break the column too? Actually, we are only modifying one cell. We are responsible for breaking the row and the column at that cell.

    How about: we choose a value that is already present in the row? Then the row has a duplicate. But the column: if the value we set is already present in the column (at some other row), then the column becomes broken. But what if the value we set is not present in the column? Then the column now has an extra value? Actually, the column originally was a permutation. Then we change one value to a value that is not in the column? Then the column becomes: missing the original value and having a duplicate of the new value? Actually, no: we are replacing one element. So the column will have the new value and the rest of the n-1 values. But if the new value was not in the column, then the column now has the new value and all the old values except the original one. Then the column becomes distinct? So we haven't broken the column.

    Therefore, we must choose a value that is already present in the column? Then the column will have two of that value. Similarly, if we choose a value that is already in the row, the row breaks.

    Actually, we don't necessarily have to break both with the same value? We can break the row by having the new value equal to an existing value in the row, and break the column by having the new value equal to an existing value in the column? But the same value must do both? 

    How about: we choose a value that is already present in the row? Then the row breaks. Then the column: we are introducing a value that is already in the row? But we don't know about the column. Similarly, if we choose a value that is already in the column, then the column breaks and we don't know about the row.

    We need a value that is already present in the row OR we need to choose a value that is already present in the column? Actually, we can choose a value that is present in the row and then hope that the column breaks? That might not happen.

    Alternative approach: we can break both by making the new value equal to an existing value in the row and then also make sure it is equal to an existing value in the column? But we don't have control over both.

    Actually, note: the row has all distinct values. Similarly the column. We are changing one element at (i, j). We can set it to a value that already appears in the row? Then the row has two of that value -> duplicate. Now what about the column? The column originally had distinct values. We are replacing one element. The new value in the column is v. If v already appears in the column at a different row? Then the column breaks. But what if v does not appear elsewhere in the column? Then the column remains distinct? So we break the row but not the column.

    Therefore, we need a value that appears in the row and also appears in the column (at a different position). But what if such a value does not exist? Actually, the row has n distinct values and the column has n distinct values. The intersection of the row and the column? The current element is common. The row has the set R and the column has the set C. The element at (i,j) is x. Then R and C share at least x. But they might share more? Actually, they might not: for example, if the row is [1,2,3,4] and the column is [1,5,6,7] and we are at (0,0)=1. Then if we change 1 to 2? Then the row becomes [2,2,3,4] -> broken. The column becomes [2,5,6,7] -> which is distinct? But 5,6,7 are distinct and 2 is new? Actually, the column now has 2 and 5,6,7 -> distinct. So the column is not broken.

    Therefore, we must set to a value that is already present in the column? Then the column breaks. Then the row? We set the value to v which is in the column. But if v is not in the row? Then the row becomes: we replace the current element with v. Since the row originally had distinct values, and v is not in the row, then the row remains distinct? Then we break the column but not the row.

    So we must break both? How? Actually, note: we are allowed to set any value between 1 and n. We can set it to any value we want. We don't have to set it to a value that is already in the row or column? We can set it to a value that is not in the row? Then the row becomes: it loses one value and gains a new one -> distinct? Then the row remains distinct? So we haven't fixed the row.

    Therefore, we must set it to a value that is already in the row to break the row? Similarly, we must set it to a value that is already in the column to break the column? But we can only set one value. How can we break both?

    Insight: The row has n distinct values. The set of values in the row is R. The column has n distinct values, set C. The current element is x. Then R ∩ C contains at least x. Let S = R ∩ C. Then |S| might be 1 or more.

    What if we set the element to a value v that is in R? Then the row breaks because now there are two v's (one at the original position and one we set). Similarly, if we set to a value that is in C, then the column breaks.

    But to break both, we need v to be in R and also in C? Then the row will break because we are introducing a duplicate of v (if v was already in the row at another column? yes, because we are setting at (i,j) and the row i has v at some other column j'? and we are setting (i,j) to v -> duplicate at (i,j) and (i,j')). Similarly, the column will break because we are setting (i,j) to v and the column j has v at some other row i''? then we get a duplicate at (i,j) and (i'',j).

    But note: we cannot set v to the current value x? Because then we are replacing x by x -> no change. So we must choose v ≠ x and v in R ∩ C.

    However, is R ∩ C always having at least two elements? Actually, the sets R and C both have n elements, and they share at least x. But what if they share only x? Then we cannot choose any other element? Then we are stuck.

    Example: 
        Row: [1,2,3,4] -> R = {1,2,3,4}
        Column: [1,5,6,7] -> C = {1,5,6,7}
        Then R ∩ C = {1}. Only 1 is common. But the current element is 1. Then we cannot set to 1? So we must set to a value that is in R but not in C? Then the row breaks (because we set 1 to 2 -> then the row becomes [2,2,3,4] -> broken) but the column becomes [2,5,6,7] -> distinct? So the column is not broken.

    Then how to break the column? We cannot break both with one modification? 

    Actually, we can break both with one modification: by setting to a value that is already in the row and then also in the column? But in this example we don't have such a value (except 1). How about we set to 5? Then the row becomes [5,2,3,4] -> distinct? because 5 is new -> so the row remains distinct? Then we break the column: because the column becomes [5,5,6,7] -> broken? But wait: the row becomes distinct? So we haven't broken the row.

    Therefore, we need a different strategy.

    Alternate idea from the editorial: the editorial sample code does:

        if a != 1: set to 1
        else: set to 2

    Why is that? 

    The goal is to break the row and the column. The row: if we set the cell to 1, then if the row already had a 1 (which it must have because the row is a permutation) at a different column, then we have two 1's -> duplicate. Similarly, if the column already had a 1 at a different row, then we have two 1's in the column -> duplicate.

    But what if the row does not have a 1? Then we are introducing 1 and the row becomes distinct? Actually, the row has distinct values and we are replacing one value by 1. Then the row remains distinct? So we haven't broken the row.

    Similarly, the column: if the column does not have a 1? Then we haven't broken the column.

    However, note: the row is a permutation of 1..n -> so it must have a 1? Similarly, the column must have a 1? Then setting to 1 would break both? Because the row already has a 1 at some other column? and the column already has a 1 at some other row? Then we are introducing a second 1 in the row and a second 1 in the column.

    But what if the current element is 1? Then we set it to 2. Then the row: we replace 1 by 2. The row already has a 2? So now we have two 2's? Actually, the row originally had distinct values: 1,2,...,n. So if we change the 1 to 2, then we have two 2's? So the row breaks. Similarly, the column: we replace 1 by 2. The column had a 2? Then we have two 2's -> breaks.

    Therefore, the strategy is: set to 1 unless the current element is 1, then set to 2.

    Why is that safe?
      - The row is a permutation -> contains every number from 1 to n. So it contains 1 and 2? Actually, if n>=2, which it is (n>=3 per constraints). So the row has a 1 and a 2. Similarly, the column has a 1 and a 2.

    Therefore, if we set a non-1 element to 1:
        In the row: we are replacing a non-1 element with 1 -> then the row now has two 1's (because there was already one 1 elsewhere) -> duplicate -> breaks the row.
        In the column: similarly, we are replacing an element with 1 -> the column already had a 1 -> becomes two 1's -> breaks the column.

    If the current element is 1, then we set to 2:
        In the row: replacing 1 with 2 -> the row already had a 2 -> becomes two 2's -> breaks the row.
        In the column: replacing 1 with 2 -> the column already had a 2 -> becomes two 2's -> breaks the column.

    So this strategy always breaks both the row and the column in one modification.

    But note: what if the row or column does not have a 1? Actually, they must because they are permutations of [1, n]. So this works.

 6. For the remaining bad rows (if any) after the pairs: we fix each remaining bad row by modifying an element in the row. We choose the first column (column index 0) to modify? Why? Because we might have already fixed some columns? Actually, we want to avoid breaking a fixed column? But note: the column might be fixed already? Then we don't want to break it again? However, we are allowed to break the row without breaking the column? Actually, we are only required to break the row. We don't care if the column remains broken? Actually, the column might be good already? Or it might be bad? But we have already fixed all bad columns in the pairing step? Actually, no: we only fixed the first min(r,c) bad columns. The remaining bad columns are fixed in the next step. So when we fix a bad row after the pairing step, we are only concerned with breaking the row.

    How to break the row? We can set an element to a value that is already in the row. We choose the first column (j=0) arbitrarily? But note: we must avoid breaking a column that we haven't fixed? Actually, we haven't fixed all bad columns yet? We are going to fix the remaining bad columns in the next step. So we don't want to break a column that is already good? Actually, we are allowed to break a column that is already good? Because the condition is that every column must have duplicates. If a column already has duplicates, then we can leave it alone? Actually, we can break it again? But having more duplicates is okay.

    However, if we break a column that is already good (i.e., already has duplicates) by introducing an extra duplicate? Then it remains good. So it's safe.

    Therefore, we can set any element in the row to any value that is already in the row? But we have to be cautious: if we set an element that is in the row, then we break the row. But what about the column? We don't care? Actually, we don't have to worry about the column because we are going to fix the remaining bad columns anyway? But note: we are going to fix the remaining bad columns by modifying the first row? So if we modify a cell that is in a bad column? Then we break that column? Actually, we break the row and the column? But the column might be one of the bad columns that we are going to fix? Then we are effectively fixing two things? Actually, we are not: we are only going to fix the remaining bad columns in the next step by modifying the first row. So if we modify a cell in a bad column that we haven't fixed yet, then we break that column? That's good because then that column becomes fixed? Then we might reduce the number of bad columns? But we have already computed the bad columns and the count for the next step.

    However, we are going to fix the remaining bad columns by modifying the first row? So if we modify a cell in a bad column at a row that is not the first row, then we break that column? Then we have one less bad column? But we have already computed the list of bad columns and we are going to fix the remaining ones by the count? Actually, we are going to fix the bad columns that were left after pairing. So if we break a bad column by modifying a cell in a row that is not the first row, then we have reduced the bad columns? Then we might not need to fix that column again? But our plan is to fix the remaining bad columns by modifying the first row? Then if we break one in this step, then we are overcounting? Actually, we are not: because we have a list of bad columns at the beginning. We fixed some by pairing. Then we fix the remaining by modifying the first row? But if we break one by modifying a non-first row and non-paired column? Then that column becomes good? Then when we go to fix the remaining bad columns, we skip that one? Actually, we have the list of bad columns from the beginning and we are iterating over the remaining ones (from the original list) without updating? That might cause a problem: we might break a column that we are going to fix again? Or we might break a column that we are not going to fix? Actually, we are going to fix the remaining bad columns by the list we computed initially? So if we break one in the step for bad rows, then when we fix the bad columns we break one that is already fixed? Then the column becomes broken again? Actually, no: we are modifying one cell. The column becomes fixed? Then we don't need to fix it again? But our list of bad columns for the next step is the original list? So we are going to try to fix a column that is already fixed? That might cause an unnecessary modification? And we might break the row again? 

    Therefore, we must avoid breaking a column that is in the list of bad columns? Actually, we are going to fix the remaining bad columns by modifying the first row? So if we break a bad column in the step for bad rows, then we don't need to fix it again? But we don't know which column we break? And we have a fixed list of bad columns to fix in the next step? Then we might fix a column that we have already fixed? Then we break the column twice? That is acceptable? Actually, the condition is that the column must have duplicates? If we break it once, it has duplicates? Then we don't need to break it again? But we are going to break it again? Then we are modifying an already broken column? That is not necessary? So we are doing an extra modification? Then the total modifications might be more than the minimum?

    How to avoid? We can fix the remaining bad rows and bad columns without interfering? The editorial sample code does:

        For remaining bad rows: modify the first column (index0) of that row.
        For remaining bad columns: modify the first row (index0) of that column.

    Why is that safe?
        - The first column: we are modifying the first column for the bad rows. But note: the first column might be fixed already? Then we break it again? But that's okay: if it was fixed, it has duplicates, and we are introducing another duplicate? Then it remains fixed? Actually, we are replacing one value by another? Then we might break the duplicates? Actually, we are setting the value to one that is already present in the row? But we don't care about the column? Actually, we do: we are setting the value to one that is already in the row? But we don't check the column? 

    Actually, the editorial sample code in Python does:

        For a remaining bad row (i_row) at column0:
            a = X[i_row][0]
            col0 = [X[ii][0] for ii in range(n)]
            S = set(col0) without a? Then if there's any element left, pick one? But wait: the set of the entire column without a? Then if we set to a value that is in S, then the column becomes: we remove a and add v, but if v is already in the column (so in S) then the column now has two v's? Then the column becomes broken? So we break the row and the column? But we only intended to break the row? Actually, we break the column as well? But the column might be already fixed? Then we are breaking it again? That's okay.

        However, what if the column is not broken? Then we break it? That's good? Then we fix a column that we didn't know about? Actually, no: we computed the bad columns initially. Then we fixed min(r,c) of them? Then we are left with the rest. But we are modifying a column that might be one of the remaining bad columns? Then we fix it? Then we don't need to fix it again? But our plan is to fix the remaining bad columns by modifying the first row? Then we might fix the same column twice? 

    Actually, the problem is: we are modifying the first column for a bad row. Then if the first column is one of the bad columns that we are going to fix? Then we fix it here? Then when we fix the bad columns, we fix it again? Then we do an extra modification? 

    How to avoid? We can note that the first column might be bad? Then we are going to fix it in the column step? Then we are going to set the first row of that column? But we are also setting the current row of that column? Then we break the column twice? Then we do two modifications? But the minimum is max(r,c). Actually, we are already counting the modifications: we are doing one for each remaining bad row and one for each remaining bad column? So the total is k (from the pairs) + (r-k) + (c-k) = r + c - k = max(r,c) + min(r,c) - k? Actually, k = min(r,c) -> total = r + c - min(r,c) = max(r,c). So the total number of modifications is max(r,c). But if we break a column in the row step, then we break one of the bad columns? Then we don't need to break it again? But we have already counted that column in the initial list? Then we are going to break it again in the column step? Then the column step would break it again? Then we break one column twice? Then the column is broken? But we break it twice? Then we have two modifications for that column? Then the total modifications become max(r,c) + (number of columns we broke in the row step)? That would be more.

    Therefore, we must avoid breaking a column that is still bad? Actually, we can break a column that is bad in the row step? Then we fix that column? Then we remove it from the list of bad columns? But we have already computed the list of bad columns? We cannot update the list? And we are going to fix the remaining bad columns by the initial count? 

    Alternatively, we can fix the remaining bad rows without affecting any column that is still bad? How? We can choose a column that is already fixed? Then we break the row without affecting the column? Actually, the column is already fixed: it has duplicates? Then we can set the value to one that is already in the row? Then the row breaks? And the column: if we set the value to one that is already in the column? Then we introduce a duplicate? But the column already has duplicates? Then it remains fixed? So it's safe.

    How to choose such a column? We can choose any column that is not bad? Or any column that is already fixed? But we don't know which columns are fixed? Actually, we computed the bad columns initially. Then we fixed min(r,c) of them? The rest are still bad? Then the columns that are not in the bad list? are fixed? Actually, no: the initial bad list is the set of columns that are permutations. After we fix a bad column by breaking it, it becomes fixed? Then it is no longer bad? But we don't update the bad list? 

    Actually, we do not update the matrix as we go? We are only storing the modifications? Then the bad list we computed initially is fixed? Then we are going to fix the remaining bad columns by modifying the first row? So we are going to break them? Then we don't care if we break a bad column in the row step? Because we are going to break it again? Then we break it twice? Then the column is broken? Then the condition holds? Then it's okay? And the total modifications is max(r,c)? So even if we break the same column twice, we are doing two modifications? Then the total modifications would be more than max(r,c)? 

    Therefore, we must choose a column that is not going to be fixed in the column step? But note: the column step only fixes the columns that are in the initial bad list and that we haven't fixed in the pairing step? Then if we break a column that is in the initial bad list and that we haven't fixed in the pairing step? Then we break it in the row step? Then we don't break it in the column step? How? We are iterating over the list of bad columns from the initial list? Then we break it twice? 

    Actually, we are storing the modifications and then outputting them? The matrix is not updated until we output the modifications? So we cannot update the matrix as we go? Then we are simulating modifications? Actually, no: the modifications are independent? Because we are modifying distinct cells? 

    How about: we fix the remaining bad rows by modifying the first column? And the remaining bad columns by modifying the first row? Then the cells we modify for the remaining bad rows are at (bad_row_i, 0) and for the remaining bad columns at (0, bad_col_j). These are distinct? Because the first row is row0 and the first column is column0? The cell (0,0) might be modified twice? 

    Actually, if we have a remaining bad row and a remaining bad column, then we are going to modify (i,0) for a row i (which is not the first row? because the first row might be bad? then we would have fixed it in the pairing step? Actually, the pairing step: we fixed the first min(r,c) bad rows and bad columns? Then the remaining bad rows do not include the first row? Actually, we don't know: the bad rows are in a list. The first row might be in the bad rows and might be fixed in the pairing step? Or it might be in the remaining? Similarly, the first column might be fixed in the pairing step? Or in the remaining? 

    Then if we have a remaining bad row i (which is not in the first min(r,c) bad rows) and we modify (i,0). Then if the first row is a bad row? Then it was fixed in the pairing step? Then we don't modify the first row in the bad row step? Similarly, for the column: we modify (0, j) for a bad column j that is not in the pairing step? Then if the first column is a bad column? Then it was fixed in the pairing step? Then we don't modify the first column again? 

    But what if the first row is a bad row and we fixed it in the pairing step? Then when we fix the remaining bad columns, we modify (0, j) for j in the remaining bad columns? Then the first row might be modified again? Then we break the row? But the first row was already fixed? Then we break it again? Then the row remains fixed? So it's okay? 

    However, the total modifications: we are doing one modification for each remaining bad row and one for each remaining bad column? Then the total is k + (r-k) + (c-k) = r+c - k = max(r,c) + min(r,c) - k? Actually, k = min(r,c) -> max(r,c). So the total is max(r,c). 

    But note: the modifications we do in the remaining bad rows step might break a column that is in the remaining bad columns? Then we break that column? Then we don't need to break it in the column step? But we break it in the column step anyway? Then we break the same column twice? Then we do two modifications? Then the total modifications would be more? 

    Actually, we are breaking the column in the row step? Then when we break it again in the column step, we break a column that is already broken? Then we do an extra modification? Then the total modifications would be more than max(r,c).

    How to avoid? We can avoid by choosing a column that is not bad? But we don't know which columns are bad? Actually, we have the list of bad columns. Then for a remaining bad row, we can choose a column that is not in the list of bad columns? Then we break the row without breaking a bad column? Then the column remains fixed? And then we break the bad columns in the column step? 

    How? For a remaining bad row i, we look for a column j that is not in the bad_cols list? Then we set X[i][j] to a value that is already in the row? Then the row breaks? And the column j is already fixed? Then we don't break it? Actually, we set the value to one that is already in the column? Then we break the column? But the column is already fixed? Then it becomes broken again? Then it remains fixed? 

    Actually, we don't need to worry about the column: if the column is already fixed (i.e., it has duplicates) then setting a value that is already present in the column adds another duplicate? Then the column remains fixed? So it's safe.

    Therefore, we can choose any column? But we want to avoid breaking a bad column? Actually, we don't care: if we break a bad column, then we fix it? Then we don't need to fix it in the column step? But we don't update the list? Then we fix it again? Then we do two modifications? 

    Alternatively, we can update the bad columns list? But the problem: we are not actually updating the matrix? We are only outputting modifications? Then we cannot update the bad columns list? 

    Therefore, we must choose a column that is not bad? Then we break the row without affecting the column? Then the column remains fixed? Then we break the bad columns in the column step? 

    How to do? We have the initial list of bad columns. Then for a remaining bad row, we choose a column that is not in bad_cols? Then we set X[i][j] to a value that is already in the row? Then the row breaks? And the column is fixed? Then we are safe.

    But what if we cannot find such a column? Actually, the number of columns that are not bad is n - (number of bad columns) = n - c. Since c <= n, and n>=3, we have at least n - c >= 0? Actually, we have at least one? Because c <= n, but we are in the step for remaining bad rows? and we are only doing (r - k) modifications? and k = min(r,c). Then the remaining bad rows = r - k. The number of columns that are not bad is n - c. Since k = min(r,c) and r>k (so r>c) -> then n - c >= 1? Actually, n>=3 and c<=n, so n-c>=0. But if c=n? Then n-c=0? Then there is no column that is not bad? Then we cannot choose one? 

    Then what? We have to choose a bad column? Then we break the column? Then we fix the column? Then we have fixed one bad column? Then we should remove it from the list? But we are not updating the list? Then we are going to break it again in the column step? Then we do two modifications? Then the total becomes more? 

    Alternatively, we can update the list of bad columns? But we are not actually updating the matrix? We are outputting modifications? Then we can simulate the effect? Actually, we cannot because the modifications are independent? 

    Actually, the editorial sample code does not update the matrix? It uses the original matrix to compute the set of values? Then it sets a value that is already in the column? Then if the column is bad, then we break it? Then we don't need to break it again? But we are going to break it again in the column step? Then we break it twice? 

    How about: we do the modifications in the following order? 
        - First, the pairing step: we modify the intersections of bad rows and bad columns? Then we break both the row and the column? Then we remove them from the bad lists? 
        - Then for the remaining bad rows: we break them by modifying a column that is already fixed? How to know? We can avoid the columns that are still bad? 

    Actually, after the pairing step, we have:
        bad_rows_remaining = r - k
        bad_cols_remaining = c - k

    Then the columns that are not bad initially and not fixed by the pairing step? Actually, the pairing step fixed k bad columns? Then the remaining bad columns are c - k. The fixed columns are n - (c - k) = n - c + k.

    Then we can choose any column that is fixed? Then we break the row without affecting the column? 

    How to choose a fixed column? We can choose any column not in bad_cols (the original list) that we haven't fixed? Actually, we haven't fixed any non-bad column? They are fixed already? Then we can choose any column that is not in the original bad_cols? Then we break the row? 

    But note: the pairing step modified some columns? Then the columns that were originally bad might be fixed? Then we can choose a column that is not in the original bad_cols? 

    Actually, the modifications we do in the pairing step break the column? Then the column becomes fixed? Then we can consider it fixed? Then we can choose any column that is not in the remaining bad_cols? But the remaining bad_cols are the ones that we are going to fix in the column step? Then we can avoid them? 

    How? We can choose a column that is not in the original bad_cols? Then we break the row without breaking the column? Then we don't break a column that we are going to fix? 

    Actually, the original bad_cols list is fixed? Then the columns that are not in bad_cols are fixed? Then we can choose any such column? 

    For a remaining bad row, we choose a column j that is not in bad_cols? Then we set the value to one that is already in the row? Then the row breaks? And the column remains fixed? 

    But what if there is no such column? Then all columns are bad? Then n = c? Then the number of remaining bad rows = r - k = r - min(r, n) = r - min(r, n). Since n = c and r <= n? Then k = min(r, n) = r? Then there are no remaining bad rows? Contradiction? So we are not in that step? 

    Therefore, we can do:

        For the remaining bad rows: 
            j = find a column that is not in bad_cols (the original list). Since the number of such columns is n - c, and we are in the case r>c? then n-c>=1? Actually, n>=3, and c<=n, so n-c>=0? But if c=n, then we are not in the remaining bad rows? Because then k = min(r, c)=min(r, n)=r? Then we don't have remaining bad rows.

        Similarly, for the remaining bad columns: 
            i = 0? Actually, the editorial sample code uses the first row? Then we set the value to one that is already in the row? Then we break the column? And the row? The first row: we don't know if it is bad? But note: the first row might be bad? Then we fixed it in the pairing step? Then we don't modify it again? Or it might be good? Then we break it? Then we break a row that was good? Then the row becomes broken? Then we have to fix it? 

    Actually, the editorial sample code in Python does:

        For remaining bad rows: modify the first column (j=0) -> so we set X[i_row][0] to a value that is already in the column (the entire column without the current value) OR if not available, then 1 or 2? Actually, the Python code:

            col0 = [X[ii][0] for ii in range(n)]
            S = set(col0)
            if a in S: S.discard(a)
            if S: 
                v = next(iter(S))
            else:
                if a != 1: v=1
                else: v=2

        This sets the value to one that is already present in the column? Then the column becomes: if we set to v, then the column now has two v's? Then the column becomes fixed? 

        Then if the column was originally bad? Then we fix it? Then we reduce the number of bad columns? But we don't update the list? Then we break a column that we are going to fix again? 

    To avoid the extra modification, we must avoid breaking a column that is in the list of remaining bad columns? 

    Since we are going to fix the remaining bad columns by modifying the first row? Then if we break a column that is in the remaining bad columns by modifying a row that is not the first row? Then we fix it? Then we don't need to fix it again? Then we should remove it from the list? But we cannot update the list? 

    Alternatively, we can note: the modifications we output are independent? The problem: we are outputting the modifications? Then when we output a modification for a column that is in the remaining bad columns, we fix it? Then we don't need to output a modification for that column? But we have already computed the list of remaining bad columns? Then we output modifications for all of them? Then we output two modifications for the same column? 

    Therefore, we must avoid breaking a column that is in the list of remaining bad columns? 

    How? For the remaining bad rows, we choose a column that is not in the original bad_cols? Then we break the row? And we don't break a column that we are going to fix? 

    Similarly, for the remaining bad columns, we choose a row that is not in the original bad_rows? Then we break the column? And we don't break a row that we are going to fix? But we have fixed all bad rows? Then we break a row that was good? Then we break it? Then we have to fix it? 

    Actually, we have already fixed the bad rows? Then we break a row that was good? Then we break it? Then we have to fix it? 

    Therefore, we must avoid breaking a row that was good? 

    How? For the remaining bad rows: we break the row by modifying a column that is good? Then the row becomes bad? Actually, we break the row to make it have duplicates? Then we fix the row? So it becomes good? Then we are done.

    For the remaining bad columns: we break the column by modifying a row that is good? Then we break the row? Then the row becomes bad? Then we have to fix it? 

    Therefore, we must avoid breaking a row that is good? 

    Actually, we are not: we are breaking the row? Then we fix the row? Then we are done? But we break the row? Then we fix the row? Then the row becomes good? Then we are done? 

    But note: we are only modifying one cell? Then we break the row? Then the row becomes non-permutation? Then we have fixed the row? So we are done with that row? 

    Similarly, for a column: we break the column? Then we fix the column? Then we are done? 

    So the problem is: when we fix a remaining bad row by modifying a column that is in the remaining bad columns? Then we break the row and the column? Then we fix the row and the column? Then we don't need to fix that column again? Then we can skip it in the column step? But we have already planned to fix it? Then we do an extra modification? 

    Therefore, the best is to avoid breaking a column that is in the remaining bad columns? 

    How? For the remaining bad rows: choose a column that is not in the original bad_cols? Then we break the row? And the column remains fixed? Then we are safe? 

    For the remaining bad columns: choose a row that is not in the original bad_rows? Then we break the column? And the row remains fixed? Then we are safe? 

    But note: the first row: we are using it for the column step? Then we break the column? And we break the first row? But the first row might be good? Then we break it? Then we have to fix it? 

    Actually, we break the first row? Then we break a good row? Then we have to fix it? 

    Therefore, we must avoid breaking a good row? 

    How? We can break the column by modifying the first row? But we set the value to one that is already in the column? Then the column breaks? And the first row? We set the value to v? Then if v is already in the first row? Then the first row breaks? Then we have to fix it? 

    Actually, we are only allowed to break the column? We don't want to break the first row? 

    Therefore, we must set the value to one that is already in the column but not in the first row? Then the column breaks? And the first row: we replace the value by v? Then if v is not in the first row? Then the first row remains distinct? Then we haven't broken it? But what if the first row was good? Then it remains good? 

    But what if v is in the first row? Then the first row now has two v's? Then we break it? 

    How to avoid? We can choose v to be one that is not in the first row? But we don't know? 

    Alternatively, we can choose a row that is not in the original bad_rows? Then we break the column? And the row remains good? 

    But we are using the first row for the column step? Then we break the first row? Then we have to fix it? 

    Given the complexity, we will follow the editorial sample code: 

        For the remaining bad rows: modify the first column.
        For the remaining bad columns: modify the first row.

    And hope that the total modifications is max(r,c) and it works.

    Why might it work? 
        - The cell (0,0) might be modified twice? Then we output two modifications for the same cell? Then the last modification wins? But the problem: we are outputting a list of modifications? The problem does not specify the order of application? Then we must output modifications that are independent? 

    How about: we output the modifications for the pairing step first? Then for the remaining bad rows? Then for the remaining bad columns? Then if the same cell is modified twice, the last one wins? Then the first modification is overwritten? Then the first modification is wasted? Then we might not break the row or the column? 

    Therefore, we must ensure that we are not modifying the same cell twice? 

    In the pairing step: we modify (bad_rows[i], bad_cols[i]) for i in range(k).
    In the bad rows step: we modify (bad_rows[i], 0) for i in range(k, r).
    In the bad columns step: we modify (0, bad_cols[j]) for j in range(k, c).

    Can (bad_rows[i], 0) be the same as (0, bad_cols[j])? Only if bad_rows[i]==0 and bad_cols[j]==0? That is, if the first row is a bad row and the first column is a bad column? Then if the first row is in the first min(r,c) bad rows? Then it is fixed in the pairing step? Then we don't do the bad rows step for the first row? Similarly, the first column is fixed in the pairing step? Then we don't do the bad columns step for the first column? 

    Therefore, the cells modified in the bad rows step are (i,0) where i is a bad row that is not in the first k? and similarly for the bad columns step: (0,j) for j not in the first k bad columns? 

    Can (i,0) be the same as (0,j)? Only if i==0 and j==0? Then we have a cell (0,0) being modified in both steps? 

    When can that happen? 
        - If the first row is a bad row and it is not in the first k bad rows? Then k = min(r,c). Since the first row is a bad row, then it is in bad_rows. Then if it is not in the first k, that means there are at least k+1 bad rows? and k = min(r,c)=c, then r>c. 
        - Similarly, the first column is a bad column and not in the first k? then c>r? 

    But we are in the bad rows step only if r>c? and in the bad columns step only if c>r? They cannot happen at the same test case? Because if r>c, then c>r is false? 

    Therefore, in a given test case, we either have r>c (then we do bad rows step and not bad columns step for the same cell? actually we do both steps? but bad columns step only if c>r? then in a test case we do either bad rows step or bad columns step? but not both? 

    Actually, we do both steps: 
        - First, the pairing step for min(r,c) pairs.
        - Then, if there are remaining bad rows (r> min(r,c) = c), then we do the bad rows step for r-c rows.
        - Then, if there are remaining bad columns (c> min(r,c)=r), then we do the bad columns step for c-r columns.

    And since r>c and c>r cannot happen at the same time, we never do both the bad rows step and the bad columns step in the same test case? 

    But wait: r> min(r,c) means r>c, and c> min(r,c) means c>r. They are mutually exclusive? So we never do both steps? 

    Therefore, we never modify (0,0) twice? 

    Also, the cells modified in the pairing step are at (bad_rows[i], bad_cols[i]) for i in range(k). The bad_rows[i] and bad_cols[i] are from the lists. The bad rows step modifies (i,0) for i in bad_rows[k:]. The bad_cols step modifies (0,j) for j in bad_cols[k:].

    Can a cell (i,0) be modified in the pairing step? Only if 0 is in bad_cols and i is in the first k bad rows? Then if the first column is bad and we are in the pairing step, then we might have modified (i,0) for some i in the first k bad rows? Then in the bad rows step, we modify (i,0) for i in the remaining bad rows? Then if the first column is bad, then we might modify the same cell twice? 

    Example: 
        n=3, 
        bad_rows = [0,1] -> r=2
        bad_cols = [0,1] -> c=2
        k = min(2,2)=2.
        Then we modify:
          (0,0) and (1,1) in the pairing step.
        Then there are no remaining bad rows or bad columns? Then we don't do the bad rows step or bad columns step.

    Another example:
        bad_rows = [0,1,2] -> r=3
        bad_cols = [0,1] -> c=2
        k = 2.
        Then we modify (0,0) and (1,1) in the pairing step.
        Then we have one remaining bad row: row2.
        Then we modify (2,0) in the bad rows step.

        Is (2,0) modified in the pairing step? Only if 0 is in the bad_cols and 2 is in the first k bad rows? But k=2, so the first two bad rows are 0 and 1. Then 2 is not in the first k? Then we haven't modified (2,0) in the pairing step.

    Therefore, the only potential conflict is if the cell (i,0) is modified in the pairing step and then we try to modify it in the bad rows step? That can happen if i is in the first k bad rows and also in the remaining bad rows? But i cannot be in both? 

    Similarly, the cell (0,j) modified in the pairing step and then in the bad columns step? cannot happen.

    Therefore, the modifications are on distinct cells.

    Then we can output the modifications as described.

    Steps for one test case:

        bad_rows = []
        for i in range(n):
            if the row i has n distinct elements? then append i to bad_rows.

        bad_cols = []
        for j in range(n):
            col = [X[i][j] for i in range(n)]
            if distinct and covers 1..n? then append j.

        r = len(bad_rows), c = len(bad_cols)
        k = min(r,c)
        modifications = []

        for i in range(k):
            i_row = bad_rows[i]
            j_col = bad_cols[i]
            a = X[i_row][j_col]
            if a != 1:
                v = 1
            else:
                v = 2
            modifications.append((i_row, j_col, v))

        for i in range(k, r):
            i_row = bad_rows[i]
            j_col = 0
            a = X[i_row][j_col]
            col0 = [X[ii][j_col] for ii in range(n)]
            S = set(col0)
            # We want to choose a value that is in col0, but we can change the current cell to one of the existing values in the column (so that the column has a duplicate) and also we break the row? 
            # Actually, we want to break the row? We can set to any value that is already in the row? But we are not using the row's values? We are using the column's values? 
            # Why column? Because we want to break the column? Actually, we don't care about the column? We only care about breaking the row? 
            # But the sample code breaks the column as well? 
            # How to break the row? We want the row to have a duplicate? We can set the value to one that is already in the row? 
            # But the sample code uses the column's values? 
            # Actually, the sample code in the editorial uses the column's values? 
            # But the problem: if we set to a value that is already in the row, then the row breaks? 
            # Why not do that? 

            # Let's change: we will break the row by setting to a value that is already in the row? 
            # How? 
            #   row_i = X[i_row]
            #   S_row = set(row_i) 
            #   But we are going to change one element? Then we can set it to a value that is in the row? 
            #   But the current element is a. Then if we set it to a value v that is in the row and v is not at this position? Then we have two v's? 
            #   But what if v is the only occurrence? Then after changing, we remove a and add v? Then if v was already in the row, then we have two v's? 
            #   So we need a value v that is in the row and v != a? 
            #   And v must appear at least once in the row at a different column? 
            #   Since the row is a permutation, every value appears exactly once? Then if we set to v that is in the row, then v != a, and then the row will have two v's? 

            # Therefore, we can do:
            #   row_i = X[i_row]
            #   S_row = set(row_i)
            #   S_row.discard(a)   # because we are replacing a
            #   Then if S_row is not empty, choose any v in S_row.
            #   But if the row is a permutation, then after removing a, we have n-1 distinct values? Then S_row has n-1 elements? which is non-empty (since n>=3, then n-1>=2) -> so we can choose any v.

            # But wait: what if we set to v? Then the column: we are setting the column j_col to v. Then the column: originally had distinct values? Then we replace a by v. Then if v was not in the column, then the column becomes distinct? Then we haven't broken the column? 
            #   But we are not required to break the column? 
            #   Actually, the column might be good already? Then we don't care? 
            #   Or it might be bad? Then we are not fixing it? 

            # But we are going to fix the bad columns in the next step? Then we will fix it later? 

            # Therefore, we can break the row without affecting the column? 

            # But the sample code breaks the column? 

            # Given the complexity, we will follow the sample code: break the column by setting to a value that is in the column (so that the column has a duplicate) and hope that the row is also broken? 
            #   Actually, the row: we are setting the value to v. Then if v is in the row? Then the row breaks? 
            #   But what if v is not in the row? Then the row becomes distinct? Then we haven't broken the row? 

            # How to ensure the row breaks? 
            #   We can choose v that is in the column and also in the row? 
            #   Then the row breaks and the column breaks? 
            #   But the row is a permutation? It has all values? Then v is in the row? 
            #   So we can choose any v that is in the column (and automatically in the row)? 

            # Therefore, we can do: 
            #   v = any value in the column (other than the current a) -> then since the row has all values, v is in the row? 
            #   Then the row will have two v's? 
            #   And the column will have two v's? 
            #   Then we break both? 

            # But wait: the column might not have v at another cell? Actually, we are setting the current cell to v, and the column already had v at a different row? Then we have two v's? 

            # Therefore, we can do as in the sample code: 
            #   col0 = [X[ii][0] for ii in range(n)]
            #   S = set(col0)
            #   if a in S: 
            #       S.discard(a)
            #   if S is not empty: choose any v in S -> then v is in the column (and in the row, because the row has everything) -> then we break both.
            #   if S is empty? then the column had only a? but that's impossible because the column has n elements? and we only removed a? then S should be non-empty? 

            # Actually, the column has n elements. We create a set -> size at most n. Then we remove a? Then the size becomes |set(col0)|-1 if a was in the set? But if a was not in the set? then we don't remove. So S is the set of the column without a? Then if the column has n distinct elements, then after removing a, the set size is n-1? which is non-empty? 

            # But what if the column is not distinct? Then it might have duplicates? Then the set size might be less than n? Then after removing a, it might be empty? 
            #   Example: column = [1,1,2] for n=3? Then set = {1,2}. Then if a=1, we remove 1 -> set={2} -> non-empty.
            #   if a=3, then we don't remove 3? but 3 is not in the set? so set={1,2} -> non-empty.
            #   Therefore, S is non-empty.

            # So we can always choose v in S.

            # But the sample code also has an else branch? Then it sets to 1 or 2? That might be for safety? 

            # We'll do as in the sample code.

            col0 = [X[ii][j_col] for ii in range(n)]
            S = set(col0)
            if a in S:
                S.discard(a)
            # S should be non-empty, but in case?
            if S:
                v = next(iter(S))
            else:
                # This should not happen? but if it does, use 1 or 2.
                if a != 1:
                    v = 1
                else:
                    v = 2
            modifications.append((i_row, j_col, v))

        for j in range(k, c):
            j_col = bad_cols[j]
            i_row = 0
            a = X[i_row][j_col]
            row0 = X[0]
            S = set(row0)
            if a in S:
                S.discard(a)
            if S:
                v = next(iter(S))
            else:
                if a != 1:
                    v = 1
                else:
                    v = 2
            modifications.append((i_row, j_col, v))

    Then output the number of modifications and the list.

    But note: the sample input has a sample output. We must match.

    Let's run the first sample:

        Input: 
          4
          3 2 1 1
          2 1 3 4
          1 3 3 1
          4 4 4 2

        Identify bad rows and columns:

          Row0: [3,2,1,1] -> has duplicate (1) -> not bad.
          Row1: [2,1,3,4] -> distinct? and covers 1..4? -> bad.
          Row2: [1,3,3,1] -> has duplicates -> not bad.
          Row3: [4,4,4,2] -> duplicates -> not bad.

          So bad_rows = [1] -> r=1.

          Columns:
          Col0: [3,2,1,4] -> distinct? 3,2,1,4 -> distinct? and covers 1..4? -> bad.
          Col1: [2,1,3,4] -> distinct? -> bad.
          Col2: [1,3,3,4] -> duplicate (3) -> not bad.
          Col3: [1,4,1,2] -> duplicate? 1 appears twice? -> not bad.

          bad_cols = [0,1] -> c=2.

          Then k = min(1,2)=1.

          Pairing: 
             i=0: bad_row[0]=1, bad_col[0]=0 -> modify (1,0): current value = X[1][0]=2.
                2 != 1 -> set to 1.
                modifications: (1,0,1)  (0-indexed: row1, col0 -> becomes 1)

          Then remaining bad_cols = c - k = 1 -> j=1 (which is bad_cols[1]=1).
          Then for j=1: 
                i_row=0, j_col=1 -> current value = X[0][1]=2.
                row0 = [3,2,1,1] -> set = {3,2,1}
                a=2 -> remove 2 -> S={3,1} -> pick 3? 
                then set (0,1) to 3? 

          Then modifications: 
                2
                2 1 1   -> row2 (1-indexed) is row1 in 0-indexed? 
                1 2 3   -> row1 (1-indexed) is row0 in 0-indexed? and col2 (1-indexed) is col1 in 0-indexed? 

          But the sample output:
                2
                2 1 1
                4 2 3

          What? 

          Our modification: 
                (1,0) -> row1 (0-indexed) becomes row1: [1, 1, 3, 4] -> duplicate? yes.
                (0,1) -> set to 3: then row0: [3,3,1,1] -> duplicate? yes.

          Then column0: [3,1,1,4] -> 1 and 1 -> duplicate? -> not bad? 
          Column1: [3,1,3,4] -> 3 and 3 -> duplicate? -> not bad.

          Why sample output has:
                2
                2 1 1   -> (2,1): row2 (1-indexed) and column1 -> 0-indexed: (1,0) -> row1, col0 -> same as our first.
                4 2 3   -> row4 (1-indexed) and column2 (1-indexed) -> 0-indexed: (3,1) -> set to 3.

          What does that do?
                Original row3 (0-indexed row3): [4,4,4,2] -> becomes [4,3,4,2] -> then row3: [4,3,4,2] -> duplicate (4) -> good.
                Column1 (0-indexed col1): [2,1,3,3] -> then 1 and 3 and 3 -> duplicate? 
                But what about column0? 
                  col0: [3,2,1,4] -> becomes [3,1,1,4] after the first modification? then duplicate? 
                Actually, the first modification: (1,0) from 2 to 1 -> so col0: [3,1,1,4] -> duplicate.

          And the second modification: (3,1) from 4 to 3 -> then col1: [2,1,3,3] -> duplicate.

          Why did the sample output not modify (0,1)? 

          How did they get the bad rows and columns?
          In the sample, they fixed:
                row1: [2,1,3,4] becomes [1,1,3,4] -> duplicate? yes.
                row3: [4,4,4,2] becomes [4,3,4,2] -> duplicate? yes.

          And columns: 
                col0: [3,1,1,4] -> duplicate? yes.
                col1: [2,1,3,3] -> duplicate? yes.

          Why did they not fix col0 and col1 by the pairing step? 
          They had bad_rows = [1] and bad_cols = [0,1]? 
          Then they fixed two cells: one for the pair and one for the remaining bad column? 

          In our solution, we fixed the remaining bad column by modifying the first row? But the sample fixed by modifying the last row? 

          Why is our solution valid? The problem allows any set of modifications that achieve the goal? 

          But the sample output has:
                2
                2 1 1   -> row2, col1 -> 0-indexed: row1, col0 -> set to 1.
                4 2 3   -> row4, col2 -> 0-indexed: row3, col1 -> set to 3.

          We did:
                (1,0) to 1 and (0,1) to 3.

          Both are valid? 

          However, the problem says: minimum number of modifications? and we have 2, which is minimum? and we achieved the goal? 

          But the sample output is different? 

          How to match? The problem says: if there are multiple solutions, output any.

          Therefore, we can output our solution.

    However, the sample input has 5 test cases. We must output the sample output for the sample? Actually, the problem says: "if there are multiple solutions, you can output any of them".

    But the sample output for the first test case is:
        2
        2 1 1
        4 2 3

    We output:
        2
        2 1 1   -> (row2=1-indexed row1? no: we output 1-indexed)

    How do we output?

        Our modifications: 
          (1,0,1) -> row1 (0-indexed) -> output row1+1 = 2, col0+1=1 -> "2 1 1"
          (0,1,3) -> row0+1=1, col1+1=2 -> "1 2 3"

        Then our output:
            2
            2 1 1
            1 2 3

        But the sample output is:
            2
            2 1 1
            4 2 3

        So we must output 1-indexed indices.

        Why the sample output has "4 2 3"? 
          That is: row4, column2, value 3.

        How did they get that? 
          They fixed the cell (3,1) in 0-indexed: row3, col1.

        Why did they choose that? 
          Their method: 
             bad_rows = [1] (0-indexed row1) -> r=1
             bad_cols = [0,1] (0-indexed col0 and col1) -> c=2
             k=1 -> they fix (bad_rows[0], bad_cols[0]) = (1,0) -> set to 1? -> output (2,1,1) in 1-indexed? 
             Then for the remaining bad columns: one column (col1) -> they fix by modifying the first row? 
                 but they didn't. They modified (3,1) -> which is the last row and the second column.

        How did they choose (3,1)? 
          They might have chosen a different strategy: they fixed the remaining bad columns by modifying a row that is not the first? 

        But the editorial sample code in Python uses for the remaining bad columns: (0, j) -> the first row.

        Why did they use (3,1) in the sample? 

        The problem: the sample output might be generated by a different method? 

        Given the problem allows any solution, we output our solution.

    But the sample input has 5 test cases. The sample output for the third test case is 0, which we can do.

    Let's do the second test case in the sample:

        n=3
        Matrix:
          1 3 1
          2 1 3
          3 2 2

        Rows:
          Row0: [1,3,1] -> duplicate? yes.
          Row1: [2,1,3] -> distinct? -> bad.
          Row2: [3,2,2] -> duplicate? -> not bad.

        bad_rows = [1]

        Columns:
          Col0: [1,2,3] -> distinct? -> bad.
          Col1: [3,1,2] -> distinct? -> bad.
          Col2: [1,3,2] -> distinct? -> bad.

        bad_cols = [0,1,2] -> c=3.

        k = min(1,3)=1.

        Pairing: fix (1,0): X[1][0]=2 -> set to 1? (because 2 != 1) -> modification: (1,0,1) -> 0-indexed.

        Then remaining bad_cols = 2: columns 1 and 2 (0-indexed indices 1 and 2) in the list bad_cols[1:].

        Then for j=1: (0-indexed j=1) -> we modify (0,1): 
              a = X[0][1]=3
              row0 = [1,3,1] -> set = {1,3} -> remove 3? -> S={1} -> then v=1.
              then set (0,1) to 1.

        Then for j=2: (0-indexed j=2) -> we modify (0,2): 
              a = X[0][2]=1
              row0 = [1,3,1] -> set = {1,3} -> remove 1? -> S={3} -> then set to 3.

        Then modifications:
              (1,0,1) -> 1-indexed: (2,1,1)
              (0,1,1) -> (1,2,1)
              (0,2,3) -> (1,3,3)

        Then output:
              3
              2 1 1
              1 2 1
              1 3 3

        But the sample output for the second test case is:
              3
              2 1 3   -> (2,1,3) in 1-indexed? 
              2 2 3   -> (2,2,3)
              3 3 3   -> (3,3,3)

        Why? 

        How did they fix?
          They did 3 modifications at (2,1), (2,2), (3,3).

        Why is our solution not matching? 

        However, our solution is also valid: 
          After modifications:
            Row0: [1,1,3] -> [1,1,3] -> duplicate? yes.
            Row1: [1,1,3] -> duplicate? yes.
            Row2: [3,2,2] -> duplicate? yes.

            Columns:
              Col0: [1,1,3] -> duplicate? yes.
              Col1: [1,1,2] -> duplicate? yes.
              Col2: [3,3,2] -> duplicate? yes.

        So it is valid.

        The problem allows any solution.

    Therefore, we will output our solution.

    But note: the sample input says the second test case output is:
        3
        2 1 3
        2 2 3
        3 3 3

    We output:
        3
        2 1 1   -> row2, col1, value1
        1 2 1   -> row1, col2, value1
        1 3 3   -> row1, col3, value3

    In 1-indexed.

    We must be cautious: the sample input matrix for the second test case:

        Original:
          1 3 1
          2 1 3
          3 2 2

        After our modifications:
          row1 (0-indexed row0): becomes [1,1,3] -> because we changed col1 to 1 and col2 to 3.
          row2 (0-indexed row1): becomes [1,1,3] -> because we changed col0 to 1? and col1 and col2 unchanged? 
          row3 (0-indexed row2): unchanged: [3,2,2]

        Then the matrix:

          1 1 3
          1 1 3
          3 2 2

        Then column0: [1,1,3] -> duplicate? yes.
        column1: [1,1,2] -> duplicate? 1 and 1 -> yes.
        column2: [3,3,2] -> duplicate? 3 and 3 -> yes.

        So it's valid.

    We'll code accordingly.

    However, note: the constraints say the sum of n^2 across test cases <= 10000, and n<=100, t<=1000, but the sum of n^2<=10000, so the total n is small.

    We'll implement as described.

    Steps:

        for t test cases:
          read n
          read n lines of n integers

          bad_rows = []
          for i in range(n):
              row = matrix[i]
              if sorted(row) == sorted(range(1, n+1))? -> but that is expensive? 
              Actually, we can check distinct and then if the set is of size n? 
              But the numbers are between 1 and n. Then if distinct and size n, then it is a permutation? 

          Similarly for columns.

          Then:
            r = len(bad_rows)
            c = len(bad_cols)
            k = min(r, c)

            modifications = []

            for i in range(k):
                i_row = bad_rows[i]
                j_col = bad_cols[i]
                a = matrix[i_row][j_col]
                if a != 1:
                    v = 1
                else:
                    v = 2
                modifications.append((i_row, j_col, v))

            for i in range(k, r):
                i_row = bad_rows[i]
                j_col = 0
                a = matrix[i_row][j_col]
                col0 = [matrix[x][j_col] for x in range(n)]
                S = set(col0)
                if a in S:
                    S.remove(a)   # discard doesn't throw, but we know a is in col0? but maybe not if there are duplicates? 
                if S:
                    v = next(iter(S))
                else:
                    if a != 1:
                        v = 1
                    else:
                        v = 2
                modifications.append((i_row, j_col, v))

            for j in range(k, c):
                j_col = bad_cols[j]
                i_row = 0
                a = matrix[i_row][j_col]
                row0 = matrix[0]
                S = set(row0)
                if a in S:
                    S.remove(a)
                if S:
                    v = next(iter(S))
                else:
                    if a != 1:
                        v = 1
                    else:
                        v = 2
                modifications.append((i_row, j_col, v))

            Then output:
                m = len(modifications)
                then for each mod: (i, j, v) in 1-indexed: i+1, j+1, v.

    Note: we must be cautious when removing from set: if a is not in S, then we skip removal? 

    But the set S is from the entire column (or row). The value a is the current value at (i_row, j_col) for the column, or (i_row, j_col) for the row? 
        For the column: the set S is built from the entire column. Then a is one of the elements? So a must be in S? 
        Similarly for the row.

    Therefore, we can always remove a? 

    But what if the column has duplicates? Then the set S might not have a? 
        Example: column = [1,2,2] -> set = {1,2}. Then a = 2? Then we remove 2 -> S={1}. 
        But what if a is 3? Then we try to remove 3? which is not in the set? Then we don't. Then S={1,2}. 

    So we should use:
        if a in S:
            S.remove(a)

    But note: the set might not contain a? if the column has duplicates and a is one of the duplicates? then the set has a? 

    Actually, the set is built from the column, and a is an element in the column? Then a must be in the set? 

    Therefore, we can do:

        S = set(col0)
        S.remove(a)   # because a is present

    But wait: what if the column has duplicates? Then the set has unique values, and a is one of them? Then we remove it? 

    But then we are left with the other values? 

    So we can do:

        S = set(col0)
        S.discard(a)   # this is safe: if a is in S, remove it, else do nothing.

    Then if S is non-empty, choose one.

    But we know the column has at least two distinct values? Because if the column is bad, then it has n distinct values? Then if we remove a, we have n-1 distinct values? which is non-empty? 
    But if the column is not bad? then it might have duplicates? Then the set size is less than n? Then after removing a, it might be empty? 
        Example: column = [1,1,1] for n=3. Then set = {1}. Then remove a (which is 1) -> set is empty.

    How can we be in the bad_rows step for a row that is bad? and then we are modifying the column? The column might be good? 

    Actually, we are in the bad_rows step only for a row that is bad? and we are modifying the first column? The column may or may not be bad? 

    But if the column is good? then it has duplicates? Then we can set the value to one that is already in the column? Then we break the row? 

    But the row is bad: we break it by setting the value to one that is already in the row? 

    However, we are setting to a value that is in the column? not necessarily in the row? 

    Then if we set to a value that is not in the row? then the row becomes distinct? Then we haven't fixed the row? 

    Therefore, we must set to a value that is in the row? 

    But we are not checking the row? 

    Therefore, we should change the method for the remaining bad rows and columns:

        For a remaining bad row i_row:
            We want to break it. We can choose any column j and set it to a value that is already in the row (at a different column). 
            How about: we choose j such that we set to a value that is already in the row? 
            Then we break the row.

            And we don't care about the column.

        Similarly for a remaining bad column: set to a value that is already in the column (at a different row).

        Then:

          for a remaining bad row i_row:
            row_i = matrix[i_row]
            S_row = set(row_i)
            # We are going to change one element at (i_row, j). We can choose any column j? 
            # But we want to break the row: set to a value that is already in the row? 
            #   But the row has distinct values? Then every value appears once? 
            #   We are going to change an element at j from a to v. Then if v is in the row, then the row will have two v's? 
            #   But what if we choose j and set to v that is in the row? and v is not a? 
            #   Then the row has: we remove a and add v? Then if v was already in the row (at another column), then we have two v's? 
            #   So we need v in the row and v != a? 
            #   And we can choose any column j? 
            #   But we want to avoid making a good column bad? 
            #   Actually, we can choose any column? 

            # How about: we choose j = 0? 
            a = matrix[i_row][0]
            # Then we need v in the row and v != a? 
            #   The row has n distinct values? Then there are n-1 choices for v? 
            #   Then we choose v = the first value in the row that is not a? 

            # But what if the column was good? Then after modification, it remains good? 
            #   Because we are setting the column to v? Then if v was already in the column? Then the column becomes broken? 
            #   Or if it is not, then the column remains good? 
            #   But we don't care? 

            # Actually, we care only to break the row.

            # Therefore, we can do:
            v = None
            for candidate in row_i:
                if candidate != a and candidate != matrix[i_row][0]? 
                But we are going to change the first column? Then after changing, the row will have v at two places: one at the first column and one at the place where candidate originally was? 
                So we can choose any candidate that is not a? 
                But note: the candidate might be at the first column? Then we are setting the first column to candidate, and there is another column with candidate? 

            # Actually, we can choose any value that appears in the row (at a column other than 0) and that is not a? 
            #   But the row is distinct, so every value appears once. 
            #   Then we can choose any value in the row that is not a? 
            #   Then set v = any value in the row that is not a? 

            # How to get such a value? 
            #   We can iterate the row and pick the first value that is not a? 
            #   But note: the row has at least two values? so there is at least one value that is not a? 

            for j_col in range(1, n):   # skip column0? no, we are going to set column0? 
                if matrix[i_row][j_col] != a:
                    v = matrix[i_row][j_col]
                    break
            # But what if we don't find? then the entire row is a? 
            #   Then we choose v= (a+1) mod n? but we are allowed only 1..n? 
            #   But the row is a permutation? then it has distinct values? then we must have at least one value not a? 

            # So we can do:
            #   v = next(x for x in row_i if x != a)

            # But the row has n values? and one of them is a? then there are n-1 values not a? 

            # Then we set the first column to v.

            modifications.append((i_row, 0, v))

        Similarly for a bad column j_col:
            We choose the first row? 
            col_j = [matrix[i][j_col] for i in range(n)]
            a = matrix[0][j_col]
            # Then we pick a value in the column that is not a? 
            for i in range(1, n): 
                if matrix[i][j_col] != a:
                    v = matrix[i][j_col]
                    break
            modifications.append((0, j_col, v))

        But note: what if the column is bad? then it has distinct values? then we will find v.

        Then the total modifications is still max(r,c).

        Why did we choose the first row for the column? and first column for the row? 
          To avoid the same cell being modified twice? 
          In the bad rows step: we modify (i,0) for i in bad_rows[k:].
          In the bad columns step: we modify (0,j) for j in bad_cols[k:].
          And we know that in one test case, we only do one of these steps? 

        But the first row might be in the bad_rows? then it was fixed in the pairing step? so we won't modify it again? 

        Therefore, we can do:

          for i in range(k, r):
              i_row = bad_rows[i]
              a = matrix[i_row][0]
              # find a value v in the row (any value that is not a) -> pick the first one we find in the row (from column1 to columnn-1)
              v = None
              for j in range(1, n):
                  if matrix[i_row][j] != a:
                      v = matrix[i_row][j]
                      break
              # But if we don't find? (shouldn't happen) then use 1 if a != 1 else 2.
              if v is None:
                  if a != 1:
                      v = 1
                  else:
                      v = 2
              modifications.append((i_row, 0, v))

          for j in range(k, c):
              j_col = bad_cols[j]
              a = matrix[0][j_col]
              v = None
              for i in range(1, n):
                  if matrix[i][j_col] != a:
                      v = matrix[i][j_col]
                      break
              if v is None:
                  if a != 1:
                      v = 1
                  else:
                      v = 2
              modifications.append((0, j_col, v))

        This is simpler.

        Let's test on the first sample with this method:

          Test case1: 
            bad_rows = [1] (0-indexed)
            bad_cols = [0,1] (0-indexed)

            k=1: 
                modification1: (1,0) -> a = matrix[1][0]=2 -> set to a value in row1 that is not 2? 
                    row1 = [2,1,3,4] -> look at columns 1,2,3: 
                         column1: 1 -> not 2 -> choose v=1.
                then modification: (1,0,1)

            Then for bad_cols: j from 1 to 2 (0-indexed indices 1 and 2) -> but wait, bad_cols[1] is 1, bad_cols[2] is 2? 
            Then for j_col=1 (0-indexed1): 
                a = matrix[0][1] = 2? 
                then look in the column1 for row1 and below: 
                    row1: matrix[1][1]=1 -> which is not 2? -> then v=1.
                then set (0,1) to 1 -> modification: (0,1,1)

            Then for j_col=2 (0-indexed2): 
                a = matrix[0][2]=1
                then look in the column2 for row1 and below: 
                    row1: 3 -> not 1 -> v=3.
                set (0,2) to 3 -> modification: (0,2,3)

            Then we have three modifications? but the minimum is 2? 

            Why? because we are in the bad_cols step for the remaining bad_cols = 2? 
            But we fixed two bad_cols? 

            But the minimum is max(r,c)=max(1,2)=2. We did 3 modifications? 

            Why? because the first modification (1,0) fixed the row and also fixed the column0? 
            Then after that, column0 is no longer bad? Then we have only one bad column left? 
            But our list of bad_cols is fixed at the beginning? Then we have two bad_cols to fix? 

            How to avoid? We can update the matrix as we simulate? 
            Or we can use the new method only for the remaining bad rows and columns? and hope that one modification might fix a column? 

            But the problem: we are not actually changing the matrix? we are only outputting modifications? 

            And the total number of modifications is the number of modifications we output? 

            But the minimum is max(r,c) = 2, and we output 3? that is not minimum.

        Therefore, we cannot do that.

        We must do as in the sample code: use the value from the column for the row step? and hope that the value is in the row? 

        But as reasoned: the row has all values, so any value we choose from the column is in the row? 

        Then we break the row and the column? 

        So we'll go back to the sample code method.

        For the remaining bad row:
            j_col=0
            a = matrix[i_row][0]
            col0 = [matrix[i][0] for i in range(n)]
            S = set(col0)
            S.discard(a)   # safe with discard
            if S: 
                v = next(iter(S))
            else:
                v = 1 if a!=1 else 2

            This v is in the column? so the column will have a duplicate? 
            And the row: since the row has all values, v is in the row? then the row will have two v's? 

        Therefore, we break both.

        And we do one modification.

        Similarly for the bad column.

        And the total modifications is max(r,c).

    We'll implement that.

    Let's run the first sample again for the remaining bad_cols:

        After the pairing step, we have one modification: (1,0,1)

        Then for the remaining bad_cols (indices 1 and 2 in the bad_cols list): 
            j=1: 
                i_row=0, j_col=1: a = matrix[0][1] = 2.
                row0 = [3,2,1,1] -> set = {3,2,1} -> remove 2? -> {3,1} -> v=3.
                Then we set (0,1) to 3.

            j=2: 
                i_row=0, j_col=2: a = matrix[0][2]=1.
                row0 = [3,3,1,1] -> wait, we haven't applied modifications? 
                But we are using the original matrix? 

        How can we use the original matrix? 

        The problem: we are not allowed to change the matrix? we are only outputting modifications? 

        But we are using the matrix to compute the set for the row? 

        However, note: we are not applying the modifications in the simulation? 

        Therefore, for the column step for j=2, we use the original row0: [3,2,1,1] -> set = {1,2,3} -> remove a=1 -> {2,3} -> then v=2? 

        Then modification: (0,2,2)

        Then we have modifications: 
            (1,0,1), (0,1,3), (0,2,2)

        Then the matrix after modifications:

            row0: [3,3,2,1] -> then duplicates? 
            row1: [1,1,3,4] -> duplicates? 
            row2: [1,3,3,1] -> duplicates? 
            row3: [4,4,4,2] -> duplicates? 

            Columns:
                col0: [3,1,1,4] -> duplicates? 
                col1: [3,1,3,4] -> duplicates? 
                col2: [2,3,3,4] -> duplicates? 
                col3: [1,4,1,2] -> duplicates? 

        But col2: [2,3,3,4] -> has 3 twice? -> good.
        col3: [1,4,1,2] -> has 1 twice? -> good.

        Why row0: [3,3,2,1] -> has two 3's? -> good.

        Then it is valid.

        But the minimum is max(1,2)=2, and we did 3? 

        Why? because we fixed two bad_cols? but we should have fixed one in the pairing step and one in the column step? total 2.

        But our list of bad_cols had 2 columns? and we fixed both? 

        How many modifications for the bad_cols step? 
            we did for j in range(k, c) = range(1,2) -> j=1 and j=2? 
            But the list bad_cols = [0,1,2]? 
            Then k=1, then j from 1 to 2? -> two modifications.

        But the minimum number of modifications is the maximum of r and c = 2? 
        and we did 1 (pairing) + 2 (columns) = 3.

        That's not minimum.

        The pairing step fixed one row and one column? 
        Then we have one row left and one column left? but max(r, c) = max(0,1) for the remaining? 
        Actually, after the pairing step, we have:
            bad_rows_remaining = r - k = 0
            bad_cols_remaining = c - k = 2
        Then the total modifications = k + (r-k) + (c-k) = 1 + 0 + 2 = 3.

        But the minimum is max(r, c)=2? 

        Why is the minimum max(r,c)=2? 
          Because we can fix the two bad_cols with two modifications? and we don't need to fix the rows? 

        But can we fix two bad_cols with two modifications? and leave the rows alone? 
          The rows are already fixed? 

        But our method in the pairing step: we fixed one row and one column? 
        Then we have two columns left? then we fix them with two modifications? 

        total=3.

        But the sample output for the first test case is 2 modifications.

        How? 
          They fixed two modifications: one fixed one row and one column? 
          and the second fixed one row and one column? 

          Specifically: 
             (1,0) fixed row1 and col0.
             (3,1) fixed row3 and col1.

          How did they know that (3,1) would fix col1? 
          Because after the first modification, the matrix is:

            row0: [3,2,1,1] 
            row1: [1,1,3,4]   -> fixed: duplicate at col0 and col1? 
            row2: [1,3,3,1] 
            row3: [4,4,4,2] 

          then they fixed (3,1): changed from 4 to 3? 
            row3: [4,3,4,2] -> fixed: duplicate (4)
            col1: [2,1,3,3] -> fixed: duplicate (3)

          then they fixed two rows and two columns with two modifications.

        Therefore, the minimum number of modifications is the maximum of the initial bad_rows and bad_cols? 

        But our method does not account for the fact that one modification might fix one row and one column even if they are not paired initially? 

        However, we are pairing in the order of the lists? 

        In the first sample, we paired bad_rows[0]=1 and bad_cols[0]=0. 
        Then the remaining bad_cols are [1,2]. 
        Then we fixed the remaining bad_cols by modifying the first row? 

        But what if we had paired bad_rows[0] with bad_cols[1]=1? 
        Then the first modification: (1,1) -> set to 1? 
           then row1: [2,1,3,4] -> becomes [2,1,3,4] -> wait, we set the second element to 1? -> [2,1,3,4] becomes [2,1,3,4] -> still distinct? 
           -> no, because we set the second element to 1? then row1: [2,1,3,4] -> distinct? -> not fixed.
        Why? because the row1 originally had 1 at column1? then after setting to 1, we have two 1's? 
           -> no, the row1 originally had [2,1,3,4] -> then at (1,1) we change 1 to 1? -> no change.

        Therefore, we must set to a value that is not the current value? 

        In the pairing step: we set to 1 if the current value is not 1, else 2. 
        Then if we paired (1,1): current value = 1, then we set to 2. 
           then row1: [2,2,3,4] -> duplicate? yes.
           col1: [2,2,3,4] in the column? -> 
               col1: [2,2,3,4] -> [2,2,3,4] -> duplicate? yes.

        Then the matrix after one modification: 
           row0: [3,2,1,1] 
           row1: [2,2,3,4] 
           row2: [1,3,3,1] 
           row3: [4,4,4,2] 

        Then the bad_cols? 
           col0: [3,2,1,4] -> distinct? -> bad.
           col1: [2,2,3,4] -> duplicate? -> good.
           col2: [1,3,3,4] -> duplicate? -> good.
           col3: [1,4,1,2] -> duplicate? -> good.

        Then we have one bad_col (col0) left.

        Then we do the bad_cols step: 
            j=0: 
               i_row=0, j_col=0: a = 3.
               row0 = [3,2,1,1] -> set = {1,2,3} -> remove 3? -> {1,2} -> choose 1.
               then set (0,0) to 1.

        Then the matrix:
           row0: [1,2,1,1] -> duplicate? yes.
           col0: [1,2,1,4] -> duplicate? (1 and 1) -> yes.

        Then total modifications=2.

        Therefore, the minimum is 2, and we achieve it.

        The catch: the pairing order matters? 
          We paired with bad_cols[1] (index1) first, then bad_cols[0] in the column step? 

        But in our method, we paired in the order of the lists.

        Therefore, we might achieve fewer if we reordered? but the minimum number is max(r,c) anyway? 
        and our method of using the lists in the given order might use more than max(r,c) in the simulation? 

        But note: the total modifications is k + (r-k) + (c-k) = r+c - k = r+c - min(r,c) = max(r,c). 

        So the number of modifications is max(r,c), which is the minimum.

        Therefore, we are safe.

        In the first sample, if we had swapped the order of bad_cols, we would have done 2 modifications? 
        But our method uses the given order of bad_cols (which is the order of increasing index?).

        How do we generate bad_cols? 
          We iterate j from 0 to n-1. 
          So the list bad_cols is in increasing order of j.

        In the first sample: bad_cols = [0,1] (0-indexed) or [0,1,2] for the second sample? 

        In the first sample with n=4, we had bad_cols = [0,1] (0-indexed).

        Then we paired with the first element of bad_cols (0) and then fixed the second (1) in the column step.

        total = 1+1 = 2.

        Therefore, the method works.

    Summary:

        We'll do:

          bad_rows = [i for i in range(n) if is_permutation(matrix[i])]
          bad_cols = [j for j in range(n) if is_permutation( [matrix[i][j] for i in range(n) ]) ]

          r = len(bad_rows)
          c = len(bad_cols)
          k = min(r, c)

          modifications = []
          for i in range(k):
              i_row = bad_rows[i]
              j_col = bad_cols[i]
              a = matrix[i_row][j_col]
              if a != 1:
                  v = 1
              else:
                  v = 2
              modifications.append( (i_row, j_col, v) )

          for i in range(k, r):
              i_row = bad_rows[i]
              j_col = 0   # first column
              a = matrix[i_row][j_col]
              col0 = [ matrix[ii][j_col] for ii in range(n) ]
              S = set(col0)
              if a in S:
                  S.remove(a)   # because a is in the column, and we are going to change it, so remove it
              else:
                  # then we do nothing? 
                  pass
              if S:
                  v = next(iter(S))
              else:
                  v = 1 if a != 1 else 2
              modifications.append( (i_row, j_col, v) )

          for j in range(k, c):
              j_col = bad_cols[j]
              i_row = 0   # first row
              a = matrix[i_row][j_col]
              row0 = matrix[0]   # the first row
              S = set(row0)
              if a in S:
                  S.remove(a)
              else:
                  pass
              if S:
                  v = next(iter(S))
              else:
                  v = 1 if a != 1 else 2
              modifications.append( (0, j_col, v) )

        Then output the number of modifications and then each modification in 1-indexed.

    Note: when we remove a from S, we use remove (which may throw) or discard? 
        We did check: 
            if a in S: then remove
        But we can also use:
            try: 
                S.remove(a)
            except:
                pass

        Or use: 
            if a in S: 
                S.remove(a)

        Because we checked.

    Let's code accordingly.

    We'll write a helper function to check if a list of length n is a permutation of [1, n]:

        def is_permutation(arr):
            if len(arr) != n:  # but it is n
            if sorted(arr) == list(range(1, n+1)):
                return True
            return False

        But that is O(n log n). 

        Alternatively, we can do:
            if len(set(arr)) == n and min(arr) == 1 and max(arr) == n:
                return True
            return False

        But note: the numbers are between 1 and n. Then if distinct and has n elements, then it is a permutation.

        So we can do:
            if len(set(arr)) == n:
                return True
            else:
                return False

    But wait: what if the distinct values are not from 1 to n? 
        The input guarantees that each entry is between 1 and n. Then if distinct and size n, then it must be exactly {1,2,...,n}. 

        So we can use: 
            if len(set(arr)) == n:
                return True
            else:
                return False

    We'll do that.

    Given the constraints (sum of n^2<=10000), then n is at most 100, and the total number of rows and columns is at most 200 per test case? and t is at most 1000, but the sum of n^2 is 10000, then the maximum n is about 100, and the total test cases: the sum of n^2<=10000, so the number of test cases t is at most 10000/ (min(n)^2) -> but n>=3, so the maximum t is 1000, but the sum of n^2 is bounded by 10000, so we are safe.

    Let's code accordingly.

    We'll do in C++.

    Steps in C++:

        int t;
        cin >> t;
        while (t--) {
            int n;
            cin >> n;
            vector<vector<int>> mat(n, vector<int>(n));
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    cin >> mat[i][j];
                }
            }

            vector<int> bad_rows;
            for (int i = 0; i < n; i++) {
                vector<int> row = mat[i];
                set<int> s(row.begin(), row.end());
                if (s.size() == n) {
                    bad_rows.push_back(i);
                }
            }

            vector<int> bad_cols;
            for (int j = 0; j < n; j++) {
                vector<int> col;
                for (int i = 0; i < n; i++) {
                    col.push_back(mat[i][j]);
                }
                set<int> s(col.begin(), col.end());
                if (s.size() == n) {
                    bad_cols.push_back(j);
                }
            }

            int r = bad_rows.size();
            int c = bad_cols.size();
            int k = min(r, c);
            vector<tuple<int, int, int>> mods;

            for (int i = 0; i < k; i++) {
                int i_row = bad_rows[i];
                int j_col = bad_cols[i];
                int a = mat[i_row][j_col];
                int v;
                if (a != 1) {
                    v = 1;
                } else {
                    v = 2;
                }
                mods.push_back(make_tuple(i_row, j_col, v));
            }

            // For remaining bad_rows
            for (int i = k; i < r; i++) {
                int i_row = bad_rows[i];
                int j_col = 0;
                int a = mat[i_row][j_col];
                vector<int> col0;
                for (int ii = 0; ii < n; ii++) {
                    col0.push_back(mat[ii][j_col]);
                }
                set<int> s(col0.begin(), col0.end());
                if (s.find(a) != s.end()) {
                    s.erase(a);
                }
                int v;
                if (!s.empty()) {
                    v = *s.begin();
                } else {
                    if (a != 1) {
                        v = 1;
                    } else {
                        v = 2;
                    }
                }
                mods.push_back(make_tuple(i_row, j_col, v));
            }

            // For remaining bad_cols
            for (int j = k; j < c; j++) {
                int j_col = bad_cols[j];
                int i_row = 0;
                int a = mat[i_row][j_col];
                vector<int> row0 = mat[0];
                set<int> s(row0.begin(), row0.end());
                if (s.find(a) != s.end()) {
                    s.erase(a);
                }
                int v;
                if (!s.empty()) {
                    v = *s.begin();
                } else {
                    if (a != 1) {
                        v = 1;
                    } else {
                        v = 2;
                    }
                }
                mods.push_back(make_tuple(i_row, j_col, v));
            }

            // Output
            cout << mods.size() << endl;
            for (auto &mod : mods) {
                int i = get<0>(mod);
                int j = get<1>(mod);
                int v = get<2>(mod);
                cout << i+1 << " " << j+1 << " " << v << endl;
            }
        }

    Let's test with the first sample.

    We hope to get 2 modifications? 
        But we get 2 modifications: 
            (1,0,1) and (0,1, ?) -> but the sample output for the first test case has 2 modifications: 
                2
                2 1 1   -> (1,0,1) in 0-indexed: row1, col0, value1.
                4 2 3   -> (3,1,3) in 0-indexed: row3, col1, value3.

        We are outputting for the remaining bad_cols: 
            bad_cols has [0,1] -> k=1, then j from 1 to 1 (because c=2, then j=k to c-1: j=k=1, then j<2 -> j=1) 
            then modification: (0,1, v) 
            How do we compute v for (0,1)? 
                a = mat[0][1] = 2.
                row0 = [3,2,1,1] -> set = {1,2,3} -> remove a=2 -> {1,3} -> v = 1 (the first element in the set? but set is unordered, we use *s.begin()? 
                So v=1? 
            Then we output: 
                2
                2 1 1   -> (1,0,1) -> 1-indexed: row1+1=2, col0+1=1 -> "2 1 1"
                1 2 1   -> (0,1,1) -> 1-indexed: row0+1=1, col1+1=2 -> "1 2 1"

        But the sample output has "4 2 3".

        Why is our solution not matching? 

        The sample output has a different cell and value.

        But both are valid? 

        The problem: any solution.

        So we output "1 2 1".

        The sample input has 5 test cases. The judge will accept any valid solution.

    We'll output as above.

    But note: the sample output for the first test case is 2 modifications: 
        "2 1 1"
        "4 2 3"

    We output:
        "2 1 1"
        "1 2 1"

    We can change the value for the second modification: we choose the first element in the set, but the set {1,3} -> we choose 1. 
    But we can choose any element in the set. 

    How about we choose the last element? 
        In C++, set is sorted, and we can choose *s.rbegin()? 

    But the problem does not care. 

    Alternatively, we can choose a value that is not 1? to avoid introducing a 1? 
        But 1 is already in the row, so it's safe.

    We'll leave it as *s.begin().

    We run the second sample test case:

        Input: 
          3
          1 3 1
          2 1 3
          3 2 2

        bad_rows: 
          row0: [1,3,1] -> set.size=2 -> not bad.
          row1: [2,1,3] -> set.size=3 -> bad.
          row2: [3,2,2] -> set.size=2 -> not bad.
          bad_rows = [1]

        bad_cols:
          col0: [1,2,3] -> size=3 -> bad.
          col1: [3,1,2] -> size=3 -> bad.
          col2: [1,3,2] -> size=3 -> bad.
          bad_cols = [0,1,2]

        k = min(1,3)=1.

        modification for (1,0): 
            a = mat[1][0] = 2 -> set to 1? 
            then mod: (1,0,1) -> 0-indexed.

        Then for bad_cols: j from 1 to 2: 
            j=1: 
                i_row=0, j_col=1: a = mat[0][1]=3.
                row0 = [1,3,1] -> set = {1,3} -> remove 3 -> {1} -> v=1.
            j=2:
                i_row=0, j_col=2: a = mat[0][2]=1.
                row0 = [1,3,1] -> set = {1,3} -> remove 1 -> {3} -> v=3.

        Then mods: 
            (1,0,1) -> 1-indexed: "2 1 1"
            (0,1,1) -> "1 2 1"
            (0,2,3) -> "1 3 3"

        Output: 
            3
            2 1 1
            1 2 1
            1 3 3

        Which matches our earlier solution.

    Therefore, we'll code accordingly.

    Note: the sample input says the second test case output is:
        3
        2 1 3
        2 2 3
        3 3 3

    But our solution is different. It is still valid.

    We'll run the third test case: 
        5
        1 1 1 1 1   -> set.size=1 -> not bad.
        ... all ones -> no bad row and no bad column.
        Then modifications=0.

    The fourth and fifth we can check manually? 

    We'll code and submit.

    Note: the constraint says the sum of n^2 across test cases <= 10000.

    We'll use:

        for (int i = 0; i < n; i++) {
            vector<int> row = mat[i];   // O(n)
            set<int> s(row.begin(), row.end()); // O(n log n)
        }

        Total: O(n^2 log n) per test case? 
        The sum of n^2 is 10000, so the total n is at most 10000? 
        But the worst-case test case: n=100, then n^2=10000, and there is only one test case? 
        Then the inner loop for rows: 100 rows, each set from 100 elements: 100 * 100 * log100 ≈ 100*100*7 = 70000 per test case? and one test case -> acceptable.

        And for columns: 100 columns, each column we build a vector of 100 and then a set: 100*(100*log100) = 70000.

        Total 140000 per test case? and the sum of n^2 is 10000, but note: the number of test cases t can be up to 1000, but the condition is the sum of n^2 <= 10000, so the maximum n is 100, and the number of test cases: 
            t: the sum_{test cases} n^2 <= 10000.
            Then the total operations: 
                For rows: for each test case, for each row: n * log n, and there are n rows? so n^2 * log n per test case? 
                Then total over test cases: log n * (sum_{test cases} n^2) <= 7 * 10000 = 70000.

        Similarly for columns: 70000.

        Then total 140000, which is acceptable.

    We'll code accordingly.

    Let's code in C++.