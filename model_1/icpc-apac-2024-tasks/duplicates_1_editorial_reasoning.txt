We are given t test cases. For each test case, an n x n matrix X with entries in [1, n] is provided.
We can change any entry to any integer in [1, n]. We want to achieve two conditions:
1. Every row must contain duplicates (i.e., at least one repeated value in the row).
2. Every column must contain duplicates (i.e., at least one repeated value in the column).

We are to compute the minimum number of modifications and one possible set of modifications.

Observations:

First, note that if the matrix already satisfies both conditions, we output 0 modifications.

But what if it doesn't?

We note that the problem is symmetric for rows and columns. However, we must satisfy both.

Let us consider what it means for a row to not have duplicates: then the row has all distinct elements. Similarly for a column.

In fact, the condition for a row is equivalent to: the row does not form a permutation of [1, n] (because if it does, then all distinct, so no duplicates). Similarly for a column.

But note: even if a row is not a permutation, it might have duplicates. Similarly, a row might have duplicates even if it is not a permutation? Actually, if the row has duplicates, then it is not a permutation. Conversely, if the row is not a permutation, then by the pigeonhole principle (since there are n numbers in [1, n]) it must have duplicates. Therefore, the condition for a row is equivalent to: the row is not a permutation of [1, n]. Similarly for a column.

So we require that no row is a permutation of [1, n] and no column is a permutation of [1, n].

Therefore, the problem reduces to: we want to change as few entries as possible so that no row is a permutation of [1, n] and no column is a permutation of [1, n].

However, note: a row might be a permutation and we break it by changing one element? Actually, changing one element in a permutation row will break the permutation (because then we have two possibilities: either we duplicate an existing number or we introduce a number outside [1, n] but we are allowed to use only [1, n] and if we duplicate then we break the distinctness). Similarly for a column.

But here's the catch: one modification might break both a row and a column? Or might break one row but then create a problem elsewhere? Actually, we are allowed to set the value arbitrarily. So we can set a value that breaks the row condition and the column condition simultaneously? Not necessarily: because if we change an element at (i, j) to a value v, then we break the permutation in row i and in column j.

Therefore, we can think of the problem as: we have a set of rows that are currently permutations (call them bad rows) and a set of columns that are currently permutations (call them bad columns). We want to cover these bad rows and bad columns by as few modifications as possible, where one modification at (i, j) can cover row i (if it is bad) and column j (if it is bad).

However, note: we cannot cover a bad row and a bad column arbitrarily? Actually, we can: because if we change an element at (i, j) that is in a bad row i and a bad column j, then that change will break the permutation in row i and in column j.

But what if the same modification breaks two bad rows? That is not possible: one modification is in one row and one column.

Therefore, the problem becomes: we have a bipartite graph with one set being bad rows and the other set being bad columns. We can put a modification at (i, j) to cover bad row i and bad column j. Then the problem is to cover all bad rows and bad columns with as few modifications as possible. Moreover, note that if we change an entry that is in a bad row and a bad column, we cover both. But we can also change an entry that is only in a bad row? Then we cover only the row. Similarly, an entry only in a bad column? Then we cover only the column.

However, note: if we change an entry that is in a bad row and a bad column, we break both. But what if we change an entry that is in a bad row but not in a bad column? Then we break the row, but the column might not have been bad so we don't need to break it. Similarly, if we change an entry that is in a bad column but not in a bad row, then we break the column.

But wait: what if we change an entry that is in a bad row and also in a column that is not bad? Then we break the row. However, we must be cautious: what if by changing that entry we make the column become a permutation? That is, what if the column was not a permutation (so it already had duplicates) and then we change one entry and now it becomes a permutation? Then we break the row but create a bad column? 

This possibility complicates the matter. Therefore, we must design the modifications in such a way that we do not create new bad columns (or bad rows) when we break a row (or a column). 

But note: when we change an entry, we can set it to an arbitrary value in [1, n]. Therefore, we can choose the value so that we break the row without making the column become a permutation? 

How? Consider a row that is a permutation. We can break it by making two elements in the row equal. However, if we change one element, we can set it to any value. Suppose in the row we have distinct numbers. We can set the changed element to one that already exists in the row. Then the row will have duplicates and hence is broken. Now consider the column: we set the element to v. What do we require? We want the column to not be a permutation. Since the column might have been non-bad (i.e., already had duplicates) then we are safe. But if the column was a permutation (so it was bad) then we break it by the same change? So we are breaking two at once.

But what if the column was not bad? Then we break the row and leave the column non-bad. However, we must avoid turning a non-bad column into a bad one. How?

Suppose the column was non-bad: that means it already had duplicates. Then when we change an element in that column, we might remove one duplicate? Or we might create a new duplicate? Actually, we are replacing one value. Let the original value be a, and we change it to v. 

Case 1: If a was duplicated in the column (appearing at least twice) then after changing to v, we remove one occurrence of a. But if there was at least two other a's, then we still have duplicates. Otherwise, if a appeared exactly twice, then after changing one, a appears only once. Then we have to see: what about v? If v was already present in the column, then we are increasing the frequency of v. If v was present at least once, then after changing we have at least two v's? So the column remains non-bad? Actually, if v was present at least once, then now we have at least two v's (because we added one). So duplicates remain. If v was not present, then we have one occurrence of v and we broke the duplicate for a? But the column might become all distinct? Then we turn it into a permutation? That would be bad.

Therefore, if we change an element in a column that was non-bad (so originally had duplicates) and we set it to a value that was not present in the column, then we might remove one duplicate and not introduce a new duplicate? Then the column might become a permutation? 

So we must avoid setting the new value to a value that is missing in the column? 

But note: the column is non-bad, so it has duplicates. However, that doesn't mean that every value in [1, n] appears? Actually, no: a non-bad column might not contain all numbers? For example, it might have two 1's and two 2's and the rest numbers missing? Then if we change one 1 to a 3 (which is missing) then the column becomes: 1, 2, 2, ... and 3. Now if the column becomes: [1, 2, 2, ..., 3] then it is not a permutation because 3 appears only once and 4,...,n are missing? But wait, we have n elements. If the column originally had duplicates, then the set of numbers does not include all numbers from 1 to n? Then after changing one element to a new number (which is missing), we have one more distinct number. But if we started with k distinct numbers and we break one duplicate and introduce a new distinct number, we have k+1 distinct numbers. But we have n elements. Since the column is non-bad, it had duplicates so k <= n-1? Then after changing, k becomes k+1 which is <= n. But if k+1 = n, then we have a permutation? Then we turned a non-bad column into a bad one.

Therefore, we must be cautious: when changing an element in a non-bad column, we must set the new value to one that is already present in the column? Then we are increasing the frequency of that number, so duplicates remain. 

Similarly, for a bad column: we want to break it. How? We can set the changed element to a value that is already present in the column? Then we create a duplicate? But wait: if the column is a permutation (so bad) then it has one of each number. Then we set the element to a value that already exists? Then that value will appear twice and we break the permutation. And we don't remove any duplicate? Actually, we are replacing one distinct value by one that is already present? Then we have two of one value and one value missing? So the column becomes non-bad.

So the rule: when we change an element at (i, j) to v, we should set v to a value that is already present in the row? Or in the column? Actually, we have two constraints: we want to break the row i (if it is bad) and we want to break the column j (if it is bad) and we don't want to break a non-bad row or non-bad column.

But note: changing an element can affect both the row and the column. Therefore, we can design:

- If the row i is bad, then we break it by setting the new value to a value that already exists in the row? But wait: we are changing one element. How do we know what exists? Actually, we can set v to any value that is already present in the row? However, we are changing one element. Alternatively, we can set it to a value that is already present in the row? Then the row will have a duplicate? But what if the row originally was a permutation? Then every value appears once. If we set the element to a value that is present elsewhere in the row, then that value will appear twice and we break the distinctness.

Similarly, for the column j: if it is bad, then we break it by setting v to a value that already appears in the column? Then the column will have a duplicate.

But what if both the row and the column are bad? Then we want to set v to a value that is already present in the row and also already present in the column? Then we break both? 

However, note: the row and the column share the element at (i, j). The row originally has distinct values, and the column originally has distinct values. The element we are replacing is the value at (i, j). We want to set it to v such that:

- v is present elsewhere in the row? Then the row gets a duplicate.
- v is present elsewhere in the column? Then the column gets a duplicate.

But is there such a v? 

Consider the row: the values are distinct and form a permutation. Similarly, the column. The element we are replacing is x. Then the row has the set {1,2,...,n} and the column also has the set {1,2,...,n}. What values are available for v? We can choose any integer in [1, n]. 

We require that v is not the value that we are replacing? Actually, we can set it to any value. We require that v appears elsewhere in the row. But in the row, all values are distinct. So any value that is not the one we are replacing? Actually, if we set v to a value that is already in the row, then that value must be at some other column j' (because the row has all distinct). Similarly, we require that v appears in the column? Then v must be at some other row i' in the column.

But note: we are free to choose v arbitrarily. We can choose v to be a value that is already in the row and also already in the column? 

What values are in the row? All numbers from 1 to n. Similarly, the column has all numbers from 1 to n. Therefore, any value v in [1, n] is in the row and in the column? So we can pick any value? But wait: we must avoid setting v to the original value at (i, j)? Because if we set v to the same as the original, then we change nothing? But we are modifying, so we can set it to any value. However, if we set it to a different value, then we break the row? Because the row will have two v's: one at (i, j') and now we set (i, j) to v. Similarly, the column will have two v's: at (i, j) and at (i', j).

But what if v is the same as the original value? Then we do nothing. So we don't want that.

Therefore, we can choose any v in [1, n] that is not the original value? Then we break the row and the column? Actually, we break the row because we have two v's: the one that was at (i, j') and the new one at (i, j). Similarly, the column: we have two v's: at (i, j) and at (i', j). 

But what if the original value at (i, j) is the only occurrence of v in the row? Then if we set (i, j) to v, we don't get a duplicate? Actually, we are replacing x by v. If v was originally at (i, j') then after the change, the row has two v's: at (i, j) and (i, j')? So that breaks the distinctness. Similarly for the column: if we set (i, j) to v, and v was originally at (i', j), then we get two v's in the column.

So the key is: we can choose any v that is not the original value? Actually, we can choose any value v that is not the original value? Then:

- In the row: we are replacing x by v. Since the row originally had distinct values, and x is one of them, then if v was already present in the row (which it is, because the row has every number) then after the change, the row has two v's? Actually, no: because we remove x and add v. If v was already present (at some other column) then we have two v's: the existing one and the new one. So we get a duplicate. Similarly, in the column: we remove the original x and add v. Since the column had every number, v was already present (at some other row) so now we have two v's.

Therefore, we can break both with one change by setting the element to any value different from the original? 

But wait: what if we set v to a value that is already present at another position? Then yes. 

However, what about the non-bad rows and non-bad columns? We must not break them. But in this change, we are changing one entry. The row i was bad (permutation) and becomes non-bad. The column j was bad and becomes non-bad. But what about the row that had the existing v? We are increasing the frequency of v in that row? That row might become non-bad? Actually, if that row was non-bad (already had duplicates) then adding an extra duplicate doesn't hurt. If that row was bad (permutation) then we are adding a duplicate? Then we break that row? That is good? But wait, we are breaking row i and column j, but we are also breaking the row that had the existing v? Then we break an extra row? But we didn't intend to? And similarly, we break an extra column? 

But note: the existing v is at (i, j') in the row i (so we are breaking row i by making two v's) and at (i', j) in the column j (so we break column j by making two v's). But the row i' originally was a permutation? Then after we set (i, j) to v, the row i' still has the same set? Actually, no: the row i' has an element at (i', j) which is v. But we did not change that. So the row i' remains a permutation? Then we haven't broken it. Similarly, the column j' remains unchanged? 

But wait: the row i' has an element at (i', j) which is v, and we are setting (i, j) to v. The row i' is not changed. So it remains a permutation? 

Therefore, we are only breaking row i and column j. The other rows and columns are unchanged? 

But what about the column j': we changed an element in row i, column j. The column j' is not affected. 

Therefore, the change only affects row i and column j. 

So if we change an entry that is at the intersection of a bad row and a bad column, we break both. And we don't break any other row or column? 

But what if the row i was bad and the column j was bad, and we set (i, j) to v. Then:

- The row i: we break it because we now have two v's (the one we set and the one that was at (i, j') for some j').
- The column j: we break it because we now have two v's (the one we set and the one that was at (i', j) for some i').

But note: what if the existing v in the row i was at (i, j)? But we are changing (i, j) to v? Then we are replacing the existing v by v? Then no change? So we must not do that. Therefore, we choose v to be a value that is already present in the row i but at a different column j' (j' != j). Similarly, present in the column j at a different row i' (i' != i). 

But since the row i is a permutation, every value appears exactly once. Therefore, the value v that we choose must be one of the values in row i, but not at column j? That is, we can choose any value that is already in the row i (which is the entire set [1, n]) but we must avoid the original value at (i, j)? Actually, we can choose any value v that is in the row i (so v is in [1, n]) and that is not the original value at (i, j)? Then there exists a j' != j such that X[i][j'] = v. Similarly, since the column j is a permutation, v must appear at some row i'' (which might be i? no, because at (i, j) we are changing) so at (i, j) we originally have x, not v? Then there is an i'' != i such that X[i''][j] = v.

Therefore, we can choose any v that is not the original value at (i, j). Then we break the row and the column.

But what if we have a bad row and a bad column that are not at the same entry? Then we can break both with one modification if we pick an entry at their intersection? But if the bad row and bad column do not share an entry? Actually, the intersection of a row and a column is the element at (i, j). So if we have a bad row i and a bad column j, then the element at (i, j) is the only one that is in both. Therefore, we must break at (i, j) to break both. 

But note: we might break a bad row i by changing an entry at (i, j) where j is not in a bad column? Then we break the row. Similarly, we break a bad column j by changing an entry at (i, j) where i is not a bad row? Then we break the column. 

But the problem is: we have a set of bad rows R and a set of bad columns C. We can cover a bad row i and a bad column j by a modification at (i, j). Alternatively, we can cover a bad row i by a modification at (i, j) for any j (even if the column j is not bad) and similarly a bad column j by a modification at (i, j) for any i (even if the row i is not bad). However, if we change an entry at (i, j) that is in a bad row i and a non-bad column j, we must avoid turning the column j into a bad column. Similarly, if we change an entry at (i, j) that is in a bad column j and a non-bad row i, we must avoid turning the row i into a bad row.

But note: if we change an entry in a bad row i at a non-bad column j, we can set the new value to a value that is already present in the row i? Then we break the row. And for the column j: we set the new value to a value that is already present in the column j? Then we avoid making the column j a permutation? Actually, as argued earlier: if we set the new value to a value that is already present in the column j, then we don't create a permutation? Because we are increasing the frequency of that value. The column j was non-bad (so it had duplicates) and after the change, it still has duplicates? Actually, we might remove one value and add another. But if we set it to a value that is already present, then that value becomes one more. So duplicates remain. 

But what if we set it to a value that is not present? Then we might create a permutation? So we must set it to a value that is already present in the column j? 

Similarly, for a change in a bad column j and a non-bad row i: we set the new value to a value that is already present in the column j (to break the column) and also we must set it to a value that is already present in the row i? But wait: the row i is non-bad? We don't want to break it? Actually, we don't want to break a non-bad row? But if we set the new value to a value that is already in the row i, then we might create a duplicate in the row i? That is acceptable? The row i was non-bad (so it already had duplicates) then adding an extra duplicate doesn't break the condition? It remains non-bad? 

But what if the row i was non-bad? Then it had duplicates. If we set an element to a value that is already present in the row, then we are increasing the frequency of that value? Then the row remains non-bad. 

Therefore, we can design:

- For a modification at (i, j):
   - If the row i is bad and the column j is bad, then we set the new value to any value v such that:
        v != original_value
        and v is present in the row i (which it will be, since the row is a permutation) and present in the column j (which it will be, since the column is a permutation) -> so we can choose any v in [1, n] except the original value? But we must avoid the original value? Actually, we can choose any other value.

   - If the row i is bad and the column j is non-bad, then we set the new value to a value that is already present in the row i (to break the row) and we also set it to a value that is already present in the column j (to avoid making the column a permutation). How? We need to choose v that is in the set of values of the row i and also in the set of values of the column j? 

      Since the row i is a permutation, it has all values. Therefore, we can choose any value that is present in the column j? Because the column j is non-bad, it has duplicates, but it might not have all values? But we want v to be present in the column j? Then we break the row? And we don't harm the column? 

      But note: the column j has at least one duplicate? Actually, we don't require that the value we choose is duplicated? We only require that the column j remains non-bad. And by setting the new value to a value that is already in the column j, we are increasing the frequency of that value? Then duplicates remain? 

      However, what if the column j originally had two of a particular value and we set the new value to that? Then we have three? So duplicates remain. 

      Therefore, we can choose any value v that is already present in the column j? Then we break the row? And we don't harm the column? 

      But we must also break the row: we set v to a value that is already in the row i? Actually, the row i has all values? So any v we choose is in the row i? 

      So we can choose any v that is in the column j? 

   - Similarly, if the row i is non-bad and the column j is bad, then we set the new value to any value that is present in the column j (to break the column) and also present in the row i? Then the row i remains non-bad? 

      But note: the row i is non-bad, so it already has duplicates. Then setting an element to a value that is already present in the row i? Then we are increasing the frequency of that value? Then the row remains non-bad? 

      And the column j is broken: because we set the element to a value that is already present in the column j? Then we get two of that value? 

      Therefore, we can choose any value v that is present in the row i? 

      But the column j is a permutation? Then it has all values? So any v we choose is in the column j? 

      So we can choose any v that is present in the row i? 

   - What if both are non-bad? Then we don't need to change? But we are only changing when necessary? 

Therefore, we can break a bad row or a bad column independently? 

But note: we are trying to minimize the number of modifications. We want to cover the set of bad rows and bad columns. Each modification can cover:

   - If we change (i, j) that is in a bad row and a bad column: then we cover one bad row and one bad column.
   - If we change (i, j) that is in a bad row and a non-bad column: then we cover one bad row.
   - If we change (i, j) that is in a non-bad row and a bad column: then we cover one bad column.

So we have:

   - We have a bipartite graph: left part is bad rows, right part is bad columns. 
   - We can cover a bad row by a modification at any column (if we set the value appropriately) and similarly a bad column by a modification at any row? 
   - But we can also cover one bad row and one bad column by a single modification at their intersection.

This is similar to a vertex cover? Actually, it is a set cover: we are covering the bad rows and bad columns. The modifications are at the cells (i, j). Each cell (i, j) can cover:

   - If i is bad and j is bad: then it can cover both i and j.
   - If i is bad and j is non-bad: then it can cover i.
   - If i is non-bad and j is bad: then it can cover j.
   - If both are non-bad: then it covers nothing? 

But note: we are allowed to change any cell arbitrarily? Actually, we are allowed to change any cell, but if we change a cell that is in a non-bad row and non-bad column, then we might break the row? But we don't want to break the row? Actually, we don't need to break it? So we avoid changing such cells? 

Therefore, the problem reduces to: we want to choose a set S of cells such that:

   - Every bad row i has at least one cell in S (at some column j) and every bad column j has at least one cell in S (at some row i).

   - And we want to minimize |S|.

But note: if we choose a cell (i, j) that is in a bad row i and a bad column j, then it covers both. Otherwise, if we choose a cell that is in a bad row and non-bad column, then it only covers the bad row. Similarly for a bad column and non-bad row.

This is equivalent to: we have a bipartite graph where the two parts are the rows and the columns? Actually, we can model:

   - The set of rows and columns form a bipartite graph? But note: we are covering both rows and columns? 

Actually, we have a bipartite graph G = (R ∪ C, E) where R is the set of bad rows, C is the set of bad columns, and we put an edge between a bad row i and a bad column j? Then what? Actually, we can use the following:

   - We can cover all bad rows and bad columns by a set S of cells (each cell (i, j) is an edge between row i and column j) such that: 
        - If the cell (i, j) is in the bipartite graph (i.e., i in R and j in C) then it can cover both i and j.
        - Otherwise, if j is not in C (so non-bad) then the edge (i, j) only covers i? Similarly, if i is not in R, then only covers j?

But note: we are allowed to use any cell (i, j). However, if we use a cell (i, j) that is not in R×C (i.e., either i not in R or j not in C) then it only covers one of them.

So we want to cover the set R (bad rows) and the set C (bad columns). The available covering elements are:

   - For every pair (i, j) where i is in R and j is in C: we have an element that can cover both i and j.
   - For every bad row i: we have for every column j (whether j is bad or not) an element that can cover i? But note: we can also use a cell (i, j) for which j is not in C? Then it covers only i.
   - Similarly, for every bad column j: we have for every row i (whether i is bad or not) an element that can cover j? 

But this is too many. We need to minimize |S|.

How? We can use a matching in the bipartite graph between R and C to cover as many as possible? Specifically, we can cover min(|R|, |C|) with min(|R|, |C|) modifications? Then the remaining bad rows and bad columns must be covered individually? 

Specifically:

   - We can cover k = min(|R|, |C|) pairs (one bad row and one bad column) by k modifications at the intersections (each at a distinct row and column). 
   - Then we have |R| - k bad rows left? Then we cover each by a modification at that row and any column (but we choose a non-bad column? or even a bad column? But note: the bad columns that are already covered we don't need to cover again? And the bad columns that are not covered: we are going to cover them? 

Actually, after covering k pairs, we have:

   - |R| - k bad rows left? 
   - |C| - k bad columns left? 

But note: if we cover k pairs, we have covered k bad rows and k bad columns. Then the remaining bad rows are |R| - k and the remaining bad columns are |C| - k. Then we cover each remaining bad row by a modification at that row and any column (which might be non-bad or even bad? But if we choose a column that is bad and not covered, then we break that column too? Then we get an extra cover? 

However, if we change an entry at (i, j) for a remaining bad row i and a remaining bad column j, then we break both? Then we cover two with one? That is better. 

But we are trying to minimize. Therefore, we can do:

   - Step 1: Cover as many pairs (one bad row and one bad column) as possible with one modification per pair. Let k be the maximum matching? Actually, we can cover min(|R|, |C|) pairs? 

But wait: we don't need a matching? Because we can cover a bad row and a bad column at their intersection? And we can use any intersection? So the maximum number of pairs we can cover by one modification per pair is min(|R|, |C|)? Because we can assign each bad row to a distinct bad column? But we can assign arbitrarily? 

But note: we can cover a bad row i and a bad column j by a modification at (i, j). We can do that for min(|R|, |C|) pairs? Then the remaining:

   - If |R| >= |C|, then we have |R| - |C| bad rows left? Then we cover each by a modification at that row and any column that is not bad? Why not bad? Because if we pick a bad column that is already covered? Then we break that column again? But that column is already broken? Then we don't need to break it again. But we are allowed? However, we are only required to break each bad row and each bad column at least once. 

But if we cover a remaining bad row i by a modification at (i, j) for a column j that is bad? Then we break the row i? But the column j was already broken? Then we break the row and we don't harm the column (it remains broken). 

But note: when we change (i, j) for a bad row i and a bad column j that has already been broken? Then we set the new value to a value that is already in the row i? Then we break the row? And we set it to a value that is already in the column j? Then we don't harm the column? 

So it is safe? 

Therefore, we can cover:

   - min(|R|, |C|) pairs: each at a distinct (i, j) for i in R and j in C.
   - Then for the remaining |R| - min(|R|, |C|) = max(0, |R| - |C|) bad rows: we cover each by a modification at that row and any column (we can choose arbitrarily: even a bad column that we already broke? Or a non-bad column? It doesn't matter? 
   - Similarly, for the remaining |C| - min(|R|, |C|) = max(0, |C| - |R|) bad columns: we cover each by a modification at that column and any row (even a bad row that we already broke? Or a non-bad row?).

But note: we might be able to cover a remaining bad row and a remaining bad column together? But we have min(|R|, |C|) pairs? Then the remaining bad rows and bad columns are not paired? 

Actually, after covering min(|R|, |C|) pairs, we have:

   - If |R| >= |C|, then there are no bad columns left? Only bad rows left? 
   - Similarly, if |C| >= |R|, then there are no bad rows left? 

Therefore, we have:

   - Let r = |R|, c = |C|.
   - Then the minimum number of modifications is: k + (r - k) + (c - k) = r + c - k, where k = min(r, c). But note: k = min(r, c), then r + c - min(r, c) = max(r, c).

But wait: we have k = min(r, c) pairs, then the remaining bad rows are r - k = max(0, r - c) and the remaining bad columns are c - k = max(0, c - r). Then the total modifications = k + (r - k) + (c - k) = r + c - k = max(r, c) + min(r, c) - min(r, c) = max(r, c)? 

Actually: 
   - If r >= c: then k = c, then modifications = c + (r - c) + (c - c) = c + r - c = r = max(r, c).
   - If c >= r: then k = r, then modifications = r + (r - r) + (c - r) = r + c - r = c = max(r, c).

Therefore, the minimum number of modifications is max(|R|, |C|).

But is that always sufficient? 

Example: 
   - R = {1,2}, C = {1,2}. Then we can cover both with two modifications? But max(2,2)=2. Alternatively, we can cover both with one modification? Actually, no: because we can cover one pair (1,1) and then we break row1 and col1. Then we have row2 and col2 left. Then we can cover row2 at (2,1) for example? Then we break row2? And col1 is already broken? Then we don't break col2? Then we need to break col2? Then we do a third modification? 

Wait, that contradicts. 

What went wrong? 

We covered the first pair (1,1) -> modification at (1,1). Then we have row2 and col2 still bad? Then we can cover row2 by a modification at (2,1) (which is in col1, already broken) and col2 by a modification at (1,2) (which is in row1, already broken). Then we use two modifications for the pairs? Then total modifications = 1 + 1 + 1 = 3? 

But no: we can cover two pairs: (1,1) and (2,2) with two modifications. Then we break row1 and col1 by (1,1), and row2 and col2 by (2,2). Then we are done? Then total modifications = 2 = max(2,2). 

Therefore, the key is: we can cover min(r, c) pairs by min(r, c) modifications. Then the remaining bad rows (if any) are r - min(r, c) = max(0, r - c) and we cover each by one modification? Similarly, the remaining bad columns (if any) are c - min(r, c) = max(0, c - r) and we cover each by one modification? Then total = min(r, c) + max(0, r - c) + max(0, c - r) = min(r, c) + max(r, c) - min(r, c) = max(r, c). 

But in the example above: r=2, c=2 -> total = 2.

Another example: r=3, c=2. Then we cover 2 pairs: (r1, c1) and (r2, c2). Then we have one bad row r3 left. Then we cover it by one modification at (r3, any column). Then total = 3 = max(3,2).

But what if we cover the two pairs and then we cover the last row at (r3, c1)? Then we break row r3? And column c1 was already broken? Then we don't break column c1 again? Then we are done? 

Therefore, the plan:

   Step 1: Identify the set of bad rows and bad columns.
        - A row i is bad if it is a permutation of [1, n]? That is, if the set of elements in the row is exactly {1,2,...,n}? But note: the problem says the entries are between 1 and n. So we can check: 
            count_freq = [0]*(n+1)
            for each j: count_freq[X[i][j]] ++
            then if for every k in [1, n] we have count_freq[k] == 1? Then it is a permutation? 

        But note: the condition for a row to have duplicates is the opposite: if it has no duplicates then it is a permutation? Actually, if the row has no duplicates and the numbers are in [1, n], then it must be a permutation. 

        So we can check: 
            if the row has n distinct numbers? Then it is bad.

        Similarly for a column.

   Step 2: Let R = set of bad rows, C = set of bad columns.

   Step 3: The minimum number of modifications is m = max(|R|, |C|).

   Step 4: How to assign the modifications?

        We want to cover the bad rows and bad columns. We can do:

        - We assign the bad rows and bad columns arbitrarily? 

        - First, we cover as many pairs (a bad row and a bad column) as possible? But we don't need to match them arbitrarily? We can choose any set of min(|R|,|C|) pairs? 

        Actually, we can assign arbitrarily? Because we can break a bad row i and a bad column j by modifying (i, j). And we can do that for min(|R|,|C|) distinct pairs? 

        Then, for the remaining bad rows (if any) we break each by modifying an entry in that row and any column? Similarly, for the remaining bad columns (if any) we break each by modifying an entry in that column and any row? 

        But we must choose the value appropriately.

        How to choose the value for a modification at (i, j)?

          - If the row i is bad and the column j is bad: then we choose any value v in [1, n] that is not the original value at (i, j). Then we break both.

          - If the row i is bad and the column j is non-bad: then we choose a value v that is present in the column j? Then we break the row? And we don't harm the column? 

          - If the row i is non-bad and the column j is bad: then we choose a value v that is present in the row i? Then we break the column? And we don't harm the row? 

          - If both are non-bad: then we don't use such a cell? 

        But note: when we break a bad row by a modification at (i, j) and the column j is non-bad, we set the value to one that is present in the column j? Then we break the row? 

        Similarly, when we break a bad column by a modification at (i, j) and the row i is non-bad, we set the value to one that is present in the row i? 

        However, what if we break a bad row at (i, j) and the column j is bad? Then we are in the first case? 

        Therefore, we can do:

          - We want to assign modifications:

              Let k = min(|R|, |C|).

              We choose k pairs: we assign the bad rows and bad columns arbitrarily? We can assign arbitrarily? 

              Then we assign:

                 Let R_list = sorted list of bad rows? 
                 Let C_list = sorted list of bad columns?

                 Then we form k pairs: (R_list[0], C_list[0]), (R_list[1], C_list[1]), ... , (R_list[k-1], C_list[k-1])

                 Then for the remaining bad rows: from R_list[k] to R_list[|R|-1], we assign for each row i a modification at (i, j) for j = an arbitrary column? But we can choose any column? 

                 Similarly, for the remaining bad columns: from C_list[k] to C_list[|C|-1], we assign for each column j a modification at (i, j) for i = an arbitrary row?

          - But note: we must not assign the same cell twice? 

          However, we can choose:

              For the k pairs: each cell (i, j) is distinct? Because we are pairing distinct rows and distinct columns? 

              For the remaining bad rows: we choose a column for each row. We can choose any column? But we must avoid the columns that we already used in the pairs? Why? Because we might break a column that is already broken? But that is acceptable? 

          Actually, we can use the same column multiple times? 

          But we are modifying one cell per modification? 

          However, if we use a column j that we already used in a pair? Then we break that column again? But that column was already broken? Then we don't harm? 

          Therefore, we can choose any column for the remaining bad rows? 

          Similarly, we can choose any row for the remaining bad columns? 

          But we must avoid choosing a cell that we are going to use twice? 

          Since we are assigning one modification per remaining bad row: we can choose any column for that row? And similarly for the remaining bad columns: we choose any row? 

          However, we must not assign the same cell for two modifications? 

          Therefore, we can do:

             Step 1: For the k pairs: we assign distinct cells: (i, j) for each pair (i in R, j in C) and we choose distinct pairs.

             Step 2: For the remaining bad rows: for each such row i, we choose a column j that is not used in the pair for row i? Actually, we can choose any column? But we have n columns. We have k pairs, so k columns are used? But we can reuse a column? 

          However, we can reuse a column? But we are modifying a different row? Then the cell is different? 

          Therefore, we can choose:

             For a remaining bad row i: we choose any column j (even one that we used in a pair) but we choose a cell (i, j) that we haven't modified? 

          Similarly, for a remaining bad column j: we choose any row i (even one that we used in a pair) but a cell (i, j) that we haven't modified? 

          But note: the pairs used distinct rows and distinct columns? Then the remaining bad rows are rows that are not in the first k rows of R? And we can choose any column? 

          However, if we choose a column that we used in a pair, then we are modifying a cell (i, j) that is in row i (which is a new row) and column j (which was used in a pair) -> so the cell is distinct? 

          Similarly, if we choose a row that we used in a pair for a remaining bad column, then the cell (i, j) is distinct? 

          Therefore, we can assign arbitrarily: 

             For the k pairs: we assign (R_list[i], C_list[i]) for i=0 to k-1.

             For the remaining bad rows: we assign (R_list[i], C_list[0]) for i = k to |R|-1? Or we can choose any column? 

          But what if we choose a column that is bad and that we already covered? Then we set the value to a value that is in the column? Then we break the row? 

          Similarly, for the remaining bad columns: we assign (R_list[0], C_list[i]) for i=k to |C|-1? 

          But note: the cell (R_list[0], C_list[0]) was already modified? Then we cannot use it again? 

          Therefore, we must choose a column for the remaining bad rows that is not the same as the row's own columns? Actually, we can choose any column? But we must avoid the cell that we already modified? 

          Actually, we are modifying one cell per modification? We can modify multiple cells in the same column? 

          Therefore, we can do:

             Let modifications = []

             Let R_list = sorted(bad_rows)   # bad_rows: indices of bad rows
             Let C_list = sorted(bad_columns) 

             k = min(len(R_list), len(C_list))

             # Cover k pairs: 
             for i in range(k):
                 row = R_list[i]
                 col = C_list[i]
                 # We are going to change (row, col)
                 # We need to choose a new value v for X[row][col] that breaks the row and the column? 
                 # Since the row is bad and the column is bad: choose any v in [1, n] that is not the original value? 
                 # But we must avoid the original value? 

                 original = X[row][col]
                 # We choose v: 
                 #   We can try to choose v = (original % n) + 1? But it might be the same as original? 
                 #   Or we can choose v = 1 if original != 1, else 2? 

                 # Actually, we can choose any value in [1, n] except original. 
                 # But we must also avoid a value that might cause a problem? However, we argued that any value different from original will break the row and the column? 
                 v = 1
                 if original == 1:
                     v = 2   # but if n==1? but n>=3, so safe? 
                 else:
                     v = 1   # but what if the row already has 1? It does, because it is a permutation. Similarly the column? 

                 # Actually, we can set v to 1? Then it will break the row? Because the row already has 1 at some column? 
                 # Similarly, the column already has 1 at some row? 

                 # Therefore, we can set v to any value except the original. 

                 # However, to be safe: we can pick a value that is present in the row? But the row has all values? So any value is present? Similarly the column? 

                 modifications.append( (row, col, v) )

             # Then, for the remaining bad rows: 
             for i in range(k, len(R_list)):
                 row = R_list[i]
                 # choose a column: we can choose any column? For example, column 0? 
                 col = 0   # but we must choose a column that is non-bad? or bad? It doesn't matter? But we must set the value appropriately.

                 # We set the value to a value that is present in the column? Then we break the row? 

                 # How to choose v? 
                 #   We break the row: we set v to a value that is already in the row? But the row is bad (permutation) so we can set v to any value? But we also want the column to remain non-bad? Or if the column is bad, we break it? 

                 # However, we are only required to break the row? The column might be already broken? 

                 # Actually, if the column col is bad and we haven't broken it yet? Then we break it? But we have already covered the bad columns? 

                 # But note: we are in the remaining bad rows: we haven't covered the column col? It might be bad or non-bad? 

                 # We can choose: 
                 #   If the column col is bad, then we break both? But we are only counting one modification for the row? Then we get an extra break? Then we might have broken a column that we thought we hadn't? 

                 # But we have a set of bad columns C_list. We have already covered the first k columns? Then the column col we choose might be in the remaining bad columns? Or not? 

                 # Actually, we did not cover the entire set of bad columns? We only covered the first k? Then if we choose a column that is in the bad columns that we haven't covered? Then we break it? Then we cover one column for free? 

                 # But then we have to account for that? 

                 # This complicates the count: because we might break a column that we haven't covered? Then we don't need to break it later? 

                 # Therefore, we might reduce the number of modifications? 

                 # But we claimed the minimum is max(|R|, |C|). So we cannot do better? 

                 # Actually, we are breaking a row and also breaking a column (if the column is bad and not covered) with one modification? Then we break two? Then we might reduce the total? 

                 # How? 

                 # We have |R| = r, |C| = c, and we broke k = min(r, c) pairs. Then we have r - k rows left? and c - k columns left? 

                 # But if we break a row and a column that is still bad with one modification, then we break one row and one column? Then the remaining rows become r - k - 1 and columns become c - k - 1? Then we break one row and one column? 

                 # Then the total modifications would be k + 1 + max(r-k-1, c-k-1) = k + 1 + max(r-k-1, c-k-1) = max(r, c) ??? 

                 # Actually, if r>c: then k = c, then we break one row and one column: then we have r - c - 1 rows left? Then we break each row by one modification: so total = c (for pairs) + 1 (for breaking a row and a column) + (r - c - 1) = c + 1 + r - c - 1 = r = max(r, c). 

                 # So it still equals max(r, c). 

                 # Therefore, we can do:

                    # We don't need to worry: we can break a remaining bad row and a remaining bad column together? 

                 # But we have already assigned the k pairs? Then we have the remaining bad rows and bad columns? 

                 # How to cover the remaining bad rows and bad columns? 

                    # We can cover a remaining bad row and a remaining bad column together? 

                 # Actually, we can form a new pair? Then we break one row and one column? Then we do that for min(remaining_rows, remaining_columns) times? 

                 # Then the total modifications = k + min(remaining_rows, remaining_columns) + (remaining_rows - min(remaining_rows, remaining_columns)) + (remaining_columns - min(remaining_rows, remaining_columns)) 
                 # = k + max(remaining_rows, remaining_columns) = k + max(r-k, c-k) = max(r, c). 

                 # Therefore, we can do:

                    # Instead of processing the remaining bad rows and then the remaining bad columns, we can cover as many pairs of the remaining as possible? 

                 # But note: we can cover a pair (a remaining bad row and a remaining bad column) by a modification at (i, j)? 

                 # How? We have the set of remaining bad rows and remaining bad columns? We can form a matching arbitrarily? 

                 # Then we cover min(remaining_rows, remaining_columns) pairs? Then the rest individually? 

                 # But then the total modifications = k + min(remaining_rows, remaining_columns) + (remaining_rows - min(remaining_rows, remaining_columns)) + (remaining_columns - min(remaining_rows, remaining_columns)) 
                 # = k + max(remaining_rows, remaining_columns) = k + max(r-k, c-k) = max(r, c). 

                 # So it is the same. 

                 # Therefore, we can simply do:

                    modifications = max(r, c)

                    and assign arbitrarily: 

                    We list the bad rows: R_list = [r1, r2, ..., r_r]
                    We list the bad columns: C_list = [c1, c2, ..., c_c]

                    Then we assign:

                       for i in range(max(r, c)):
                           if i < r: row_i = R_list[i]
                           else: row_i = R_list[0]   # we don't care? but we are only going to use i in the range of min(i, r-1) for rows? 

                       Actually, we can do:

                          for i in range(max(r, c)):
                              row = R_list[ i % r ]   # but we want to cover each row at least once? 

                    This is messy. 

          Alternative: we can use the following assignment:

             Let k = min(r, c)

             # We cover k pairs: (R_list[i], C_list[i]) for i in range(k)

             # Then, for i in range(k, r): # remaining bad rows
                 modification at (R_list[i], C_list[0])   # we choose the first bad column? But we already covered it? 

             # Then, for j in range(k, c): # remaining bad columns
                 modification at (R_list[0], C_list[j])   # we choose the first bad row? already covered? 

          Then the modifications:

             - The first k: distinct cells.
             - For the remaining bad rows: we use cells (R_list[i], C_list[0]) for i from k to r-1. 
                 Note: C_list[0] is a bad column? Then we break the row? And we break the column? But the column was already broken? Then we break the row? 
             - For the remaining bad columns: we use cells (R_list[0], C_list[j]) for j from k to c-1.
                 Similarly, we break the column? And the row R_list[0] was already broken? 

          But note: we might assign the same cell twice? 

          Example: 
             k=0? Then we have at least one bad row and one bad column? Then we do:
                 for the first bad row: (R_list[0], C_list[0])
                 for the first bad column: (R_list[0], C_list[0]) -> same cell? 

          Then we assign the same cell twice? 

          Therefore, we must avoid:

             For the remaining bad rows: we choose a column that is not used for a pair? But we can choose any column? We are not limited to bad columns? 

          Actually, we can choose any column? 

          So we can do:

             For the remaining bad rows: choose a column that is not bad? Or if we choose a bad column, then we avoid the first column? 

          But we have n columns. We can choose column 0? But note: column 0 might be bad? But we don't care? 

          Actually, we can choose:

             For the remaining bad rows: we choose column 0? But if column 0 is bad? Then we break the row? And we break the column? But we haven't covered column 0? Then we break it? Then we get an extra break? Then we don't need to break it in the remaining bad columns? 

          But then we have to remove column 0 from the bad columns? 

          This complicates. 

        Therefore, to avoid complexity, we can choose:

            For the remaining bad rows: we choose a fixed column, say column 0 (index 0) for every remaining bad row? 

            For the remaining bad columns: we choose a fixed row, say row 0 (index 0) for every remaining bad column? 

        But what if the cell (row_i, 0) for a remaining bad row is already modified? 

        How? 

          - The only modifications so far: 
                the k pairs: (R_list[i], C_list[i]) for i in range(k)
          - Then we are going to assign: 
                (R_list[k], 0), (R_list[k+1], 0), ... 
                (0, C_list[k]), (0, C_list[k+1]), ... 

          - The cell (R_list[i], 0) might be already modified? Only if in the k pairs we modified (R_list[i], 0) for some i in [0, k-1]? But we modified (R_list[i], C_list[i]), so if 0 is in the list of C_list? And if i is in the range [0, k-1] and R_list[i] = R_list[k]? But the rows in R_list are distinct? 

          Therefore, the only conflict is if 0 is one of the bad columns? Then we have a pair (R_list[i], 0) for some i in [0, k-1]? Then when we assign (R_list[k], 0) we are using the same column 0? But a different row? So the cell (R_list[k], 0) is distinct? 

          Similarly, (0, C_list[j]) might conflict with a pair? Only if we had a pair (0, C_list[i]) for i in [0, k-1]? Then the cell (0, C_list[j]) for j>=k is distinct? 

          Therefore, no conflict? 

        However, what if we have a bad row i and we assign (i,0) and then we assign (0, j) for a bad column j? Then these are two distinct cells? 

        Therefore, we can do:

            k = min(r, c)
            modifications = []

            # Cover k pairs: 
            for i in range(k):
                row = R_list[i]
                col = C_list[i]
                # choose v: any value different from the original value at (row, col)
                orig = X[row][col]
                # We choose v = 1 if orig != 1, else 2.
                v = 1
                if orig == 1:
                    v = 2
                modifications.append((row, col, v))

            # Cover the remaining bad rows: 
            for i in range(k, r):
                row = R_list[i]
                col = 0   # column index 0 (if we use 0-indexed, but the problem uses 1-indexed? 
                # But the problem: the matrix is 1-indexed? Actually, the input and output are 1-indexed.

                # We are in 0-indexed in our lists? Actually, we stored R_list and C_list as 0-indexed? 

                # The problem: the matrix is given in 1-indexed? Actually, the input: the first row is row1? 
                # We stored the matrix in 0-indexed? Then row0 is the first row? 

                # Therefore, we choose column0 -> which is the first column? 

                # How to choose v? 
                #   The row is bad: we break it by setting the new value to a value that is already present in the column? 
                #   How to get a value that is present in column0? 
                #   We can look at the column0: 
                #       values = [ X[i][0] for i in range(n) ]
                #   Then we pick the first value that appears? Or we can pick any value that appears? 

                #   Actually, we can pick the value that appears most frequently? Or simply the first value? 

                #   But note: we are allowed to choose any value that is in the column? 

                #   However, we are going to change the value at (row,0). The current value at (row,0) is x. 
                #   We want to set it to a value that is already present in the column? 

                #   We can avoid the current value? But we don't have to? 

                #   Actually, if we set it to the same value? Then we do nothing? So we must change it? 

                #   Therefore, we pick a value that is present in the column and that is not the current value? 

                #   How? 
                #       Let col0_values = [ X[i][0] for i in range(n) ]   # but note: we might have modified some? 
                #   But we haven't modified the column0 yet? 

                #   Actually, we have modified column0 only if in the k pairs we had a pair that modified an element in column0? 

                #   But we have stored the modifications? We are going to output the modifications? 

                #   We are not actually modifying the matrix? 

                #   Therefore, we can use the original matrix? 

                #   But note: we are going to output multiple modifications? They are independent? 

                #   The problem: we output a set of modifications. The modifications are applied to the original matrix? 

                #   Therefore, we can compute the value for the column0 from the original matrix? 

                #   However, if we change multiple times in the same column? Then the value we set in the first modification affects the second? 

                #   But the problem: we output the modifications to be applied to the original matrix? 

                #   Actually, the problem does not require that the modifications are applied sequentially? They are independent? 

                #   Therefore, we can compute the value for each modification independently? 

                #   But note: if we change the same cell twice? We avoid that? 

                #   How to choose v for (row,0): 
                    # We want a value that is present in the column0 (in the original matrix) and that is not the original value at (row,0)? 

                    # But if there is no such value? That is, if the column0 has only one distinct value and that value is the original value? Then we cannot pick a different value? 

                #   However, the column0 is non-bad? Then it has duplicates? Then there is at least one value that appears at least twice? 

                #   And the set of values in the column0 has at least one value that appears twice? Then we can pick that value? 

                #   But note: the value that appears twice might be the same as the original value? Then we can pick it? 

                #   Actually, if we set it to the same value? Then we do nothing? So we must pick a different value? 

                #   Therefore, we need a value that is present in the column0 and different from the original value? 

                #   How to find one? 

                    # We know the column0 is non-bad? Then it has duplicates? Then there are at least two distinct values? Why? 
                         Example: [1,1,1] -> duplicates? Then distinct values = 1? But it has duplicates? 
                    # Actually, non-bad means it has duplicates? So it has at least one duplicate? But the distinct values might be only one? Then we have all the same? 

                #   Then if the original value is that value? Then we cannot pick a different value? 

                #   But the problem: the integers are in [1, n]? Then we can set it to any value? 

                #   However, we must avoid making the column become a permutation? 

                #   So we must set it to a value that is already in the column? 

                #   But if the column is [1,1,1] and the original value is 1, then if we set it to 1 we do nothing? 

                #   Therefore, we must set it to a different value? But the only value present is 1? 

                #   Then we have to set it to 1? Then we do nothing? Then we don't break the row? 

                #   This is a problem. 

            So we must avoid this? 

        How to break the row? 

          We are at (row,0). The row is bad: so in the original row, the values are distinct and include all numbers from 1 to n? 

          How to break the row? We set the value at (row,0) to a value that is already present in the row? 

          But the row has all values? So we can set it to any value? 

          However, we want to avoid harming the column? 

          So we set it to a value that is present in the column? 

          But if the column0 is [1,1,1] and the original value at (row,0) is 1, then we set it to 1: then we do nothing? 

          Then we don't break the row? 

        Therefore, we must set it to a value that is already present in the row and that is also present in the column? 

        But if the column0 has only the value 1? Then we have to set it to 1? Then we do nothing? 

        How can we break the row? 

          We need to create a duplicate in the row? 

          So we set it to a value that appears elsewhere in the row? 

          How to choose that value? 

             Let v = a value that appears at least twice in the row? But the row is a permutation? So no value appears twice? 

          Therefore, we cannot break the row by setting it to a value that is already in the row? 

          Actually, we break the row by making two elements equal? 

          We set the value at (row,0) to a value that is already present at another column in the row? 

          For example, at column j (j !=0), we have a value a. Then we set (row,0) to a? Then we have two a's: at (row,0) and (row,j). 

          Then the row is broken. 

          And for the column0: we set the value to a. 

          Now, if the column0 originally had a? Then we are increasing the frequency of a? Then the column0 remains non-bad? 

          If the column0 did not have a? Then we are introducing a new value? Then the column0 might become a permutation? 

          How to avoid that? 

          We must ensure that the column0 remains non-bad? So we must set the value to one that is already present in the column0? 

          Therefore, we require that a is present in the column0? 

          But the row is a permutation? Then the value a is present in the row? 

          How to choose a? 

            We require that a is in the column0 (so that we don't harm the column) and that a is not the original value at (row,0)? 

            And we require that a is present elsewhere in the row? 

          How to find such an a? 

            Since the row is a permutation, every value from 1 to n appears exactly once. 

            The column0 is non-bad? So it has duplicates? Therefore, the set of values in column0 has size at most n-1? 

            Then there exists a value that is missing in the column0? 

            But we are not concerned with that. 

            We are trying to choose a value a that is present in the column0 and that is present in the row (which it is) and that is not the original value at (row,0)? 

            But note: the column0 has at least two occurrences of some value? 

            However, if the column0 is [1,1,1] then the only value present is 1. So we must choose a=1? 

            But then if the original value at (row,0) is 1, then we cannot choose 1? 

          Therefore, we have a problem. 

        Alternative: 

          Since the column0 is non-bad, it has duplicates. Then there exists at least one value that appears at least twice in the column0? 

          Let a be a value that appears at least twice in the column0. 

          Then we can set the new value to a? 

          But if the original value at (row,0) is a, then we do nothing? 

          How to break the row? 

          We set it to a value that is already in the row? But we want to create a duplicate? 

          We can set it to a value b that is already in the row and that is not a? 

          Then the row will have two b's: one at (row,0) and one at (row, j) for the column j where the row originally had b. 

          But the column0: we set it to b. If b is not in the column0 originally? Then we introduce b? 

          Then the column0 might become distinct? 

          How many distinct values in the column0? 

          Originally, the column0 had duplicates? Let the distinct values be S. 

          We are changing one element: from a to b. 

          Then the new distinct values: 
             If a was appearing k times (k>=2) then after change: a appears k-1 times, and b appears (if b was not present then one time; if b was present then increased by one).

          Then the distinct values: if b was not present: then |S| + 1. 
          And the total distinct values might become n? Then the column0 becomes a permutation? 

          We must avoid that. 

        Therefore, we must set the new value to a value that is already in the column0? 

        Then the distinct set S remains the same? Or if b was already in the column0, then |S| remains. 

        But the frequency of a decreases by one and the frequency of b increases by one. 

        Since a had frequency>=2, then a still has frequency>=1 (so no problem) and b has frequency>=1? 

        But the column0 might become all distinct? Only if originally it had n distinct values? But it is non-bad? Then it had duplicates? So it did not have n distinct values? 

        Therefore, after the change, it still has at most n-1 distinct values? 

        Or if it had n-1 distinct values and one duplicate? Then after change: 
            a: from 2 to 1 -> then distinct values: we remove a? No, a still appears once? 
            and b: if b was already present, then it increases? 

        So distinct values remain n-1? 

        Therefore, it is safe. 

        But if the original value at (row,0) is a, and we set it to b (which is in the column0) and b is not a, then we break the row? And the column0 remains non-bad? 

        Therefore, the algorithm for a modification at (row,0) (when the row is bad and the column0 is non-bad) is:

          Let a = the original value at (row,0)
          We need to choose a value b such that:
             b is in the column0 (in the original matrix) and b != a.
          But does such a b exist? 
             Since the column0 is non-bad, it has at least two distinct values? Not necessarily: it can be [1,1,1] -> then distinct values = {1}. Then if a==1, we cannot choose b!=1? 

          Therefore, if the column0 has only one distinct value, then that value must be a? (because the element at (row,0) is a). Then we are stuck? 

        How to break the row? 

          We can set it to a value that is not in the column0? 

          Then the row will be broken (because we set it to b which is in the row? because the row is a permutation) -> so b is in the row? 

          But then the column0: we set it to b, which is not originally in the column0? Then the distinct values become |S| + 1. 

          And if |S| + 1 = n? then the column0 becomes a permutation? 

          We must avoid that. 

          How to avoid? 

          Since the column0 is non-bad, we know that it has duplicates? So |S| <= n-1? Then |S|+1 <= n? But if |S|+1 = n, then it becomes a permutation? 

          Therefore, we require that the column0 has at most n-2 distinct values? Then after adding one, we have at most n-1? 

          But what if the column0 has exactly n-1 distinct values? Then after adding one, we have n distinct values? Then it becomes a permutation? 

          Therefore, we cannot add a new distinct value if the column0 has n-1 distinct values? 

        Then what? 

        Alternative: 

          We can set the value to a value that is in the row and that is already in the column0? 

          But if the column0 has only one distinct value and it is a, and a is the original value, then we cannot find a b in the column0 and b != a. 

        Then we must break the row without harming the column0? 

          Break the row: we can set it to a value that is already in the row? Then the row will have two of that value? 
          But the column0: we set it to that value, which is not in the column0? Then the column0 might become permutation? 

        How to prevent the column0 from becoming permutation? 

          We can try to choose a value that is not in the column0 and hope that the column0 doesn't become a permutation? 

          But if the column0 has exactly n-1 distinct values, then adding one new distinct value makes it a permutation? 

          Therefore, we must avoid that. 

        But note: the column0 originally had duplicates? And had size n? and distinct values = d, then we require that after change, it does not have distinct values = n? 

          d + (if we add a new value) = d+1. 
          We require d+1 < n? 

          But the problem says n>=3, and the column0 is non-bad, so d <= n-1. 

          If d = n-1, then d+1 = n -> permutation -> bad. 

          Therefore, if the column0 has exactly n-1 distinct values, then we cannot add a new value. 

        Then the only hope is to use a value that is in the column0? 

        But we can't because the column0 has only one distinct value and it is a, and the original value is a. 

        What if we set it to a? Then we do nothing. 

        Therefore, we must have a way to break the row without using the column0? 

        We can choose a different column? 

        But we arbitrarily chose column0. 

        How about we choose a column that has at least two distinct values? 

        Since the column0 might be the only non-bad column with one distinct value? 

        Therefore, we can choose any column? 

        So for a remaining bad row i, we choose a column j such that in the original matrix, the column j has at least two distinct values OR (has one distinct value but the value is not the same as the original value at (i,j))? 

        But if has one distinct value and that value is the same as the original value at (i,j), then we avoid? 

        How to find such a column? 

          For a given bad row i, we can iterate j from 0 to n-1 and look for a column j such that:
             either the column j has at least two distinct values, OR if it has one distinct value then that value is not the same as X[i][j]? 

          But note: if a column has one distinct value, then every element is that value. Therefore, the value at (i,j) is that value. 

          Therefore, we require a column j that has at least two distinct values? 

        Does such a column exist? 

          We know that the matrix has n columns. 
          If every column has only one distinct value, then the entire column is a constant. 

          Then the matrix has at most n distinct values? But it is an n x n matrix? 

          Consider: 
             row i is bad: so it has n distinct values? 
             but if every column is constant, then in row i, the value at column j is the constant of column j. 
             then if the constants are distinct, then the row has distinct values? 
             but if there are n distinct constants, then the row is a permutation? 
             but the matrix might be: 
                 column0: all 1's
                 column1: all 2's
                 ...
                 column_{n-1}: all n's
             then the row i: [1,2,...,n] -> permutation. 

          But then the columns: column0 is [1,1,...,1] -> non-bad? 
          column1 is [2,2,...,2] -> non-bad? 

          So the set of bad columns is empty? 

          Then why are we in the remaining bad rows? 

          This is a bad row and there are no bad columns? 

          Then we only have bad rows? 

          For this bad row, we can choose any column? 

          And we require a column that has at least two distinct values? 

          But in this matrix, every column has only one distinct value? 

          Then we cannot find such a column? 

        Therefore, we are stuck. 

        What to do? 

        Insight: 

          We are not required to preserve the non-badness of the column we modify? We are only required to break the row. 

          But we must not make any good column become bad. 

          In this case, the column we modify is non-bad (because it has only one distinct value, so duplicates) -> and after modification, if we set it to a value that is not the constant, then the column will have two distinct values: the constant and the new value? 

          Example: column0 was [1,1,...,1]. We change one element to 2. Then the column becomes [1,1,...,1,2] -> then it has one 2 and n-1 ones? Then it is not a permutation? Because a permutation requires all values from 1 to n to appear exactly once? Here, values 1 and 2 appear, but 3..n are missing? 

          Therefore, it is not a permutation? 

          So even if we set it to a new value, the column does not become bad. 

          Therefore, we can set it to any value that is in the row (different from the original value) to break the row? 

          And we don't care if the value is in the column or not? 

        Then the algorithm for a modification at (i, j) for a bad row i and any column j is:

          We choose a value v such that:
             v is in the row i (which means any value in [1, n] since the row is a permutation) and v != the original value at (i,j) 
             and such that after the change, the row i will have two v's? 

          But note: there is already one v in the row i at some other column j'? 

          Therefore, we can choose any v that is in the row i (which is every v in [1, n]) and v != X[i][j]? 

          Then we set X[i][j] = v. 

          This breaks the row i. 

          For the column j: 
             - If the column j originally had duplicates, then after change, it might have duplicates or might not? 
                 If we remove one value and add another, the distinct values might change? 
             - But as long as the column j does not become a permutation (which requires distinct values from 1 to n), we are safe. 

          Since the column j is non-bad initially, it has duplicates. After change, if the column j originally had frequency of the old value and the new value, we might remove one occurrence of the old value and add one occurrence of the new value. 

          - If the new value v was already in the column j, then the frequency of v increases by one and the frequency of the old value (call it a) decreases by one. The column j still has duplicates (because v appears at least twice now) and distinct values might be the same or reduced by one if a disappears? But in any case, it is not a permutation? 

          - If the new value v was not in the column j, then the distinct values increases by one. The column j originally had duplicates, so it had at most n-1 distinct values? Then after change, it has at most n distinct values. But if it becomes exactly n distinct values, then it is a permutation? 

          Therefore, we must avoid that. 

        How to avoid? 

          We can choose v to be a value that is already in the column j? 

          But if the column j has only one distinct value (say a), then the only value in the column j is a. 
          - If the original value at (i,j) is a, then we cannot choose v = a? 
          - If we choose v != a, then we introduce a new distinct value. 
             - If the column j originally had one distinct value (a) -> then distinct values become 2, which is <= n-1? only if n>=3 and 2<=n-1 -> n>=3, so 2<=n-1 -> n>=3 holds for n>=3? 
                 Actually, n>=3, then 2<=n-1 for n>=3? 
                 For n=3: 2<=2 -> true.
                 For n=4: 2<=3 -> true.
             - Therefore, the column j will not become a permutation? Because a permutation requires n distinct values, and we only have 2.

          Therefore, we can choose any v in [1, n] except the original value. 

        Conclusion: 

          In all cases, for a bad row i and any column j, we can choose any v in [1, n] except the original value at (i,j). 

        Similarly, for a bad column j and any row i, we can choose any v in [1, n] except the original value at (i,j). 

        And for a cell that is in a bad row and a bad column, we also choose any v in [1, n] except the original value. 

        Therefore, we can simplify:

          For any modification (whether it is for a bad row, bad column, or both), we choose v = 1 if the original value is not 1, else 2.

        Why is this safe? 

          - It breaks the row if the row is bad: because the row will have two 1's (or two 2's) -> one at the changed cell and one at the cell that originally had that value. 
          - It breaks the column if the column is bad: similarly. 
          - For a non-bad row or non-bad column: 
               - We break nothing extra? But we might be doing a change in a non-bad row and non-bad column? We don't do that. 
               - In our assignment, we only change:
                   - a cell in a bad row and bad column (then we break both) -> safe.
                   - a cell in a bad row and any column -> then we break the row, and the column might be non-bad: then after change, we set it to 1 or 2. We only require that the column does not become bad. 
                         The column was non-bad (duplicates) -> after change, it might become permutation? 
                         But as argued, if we change one element, the distinct values might increase by at most 1. And since the column was non-bad (so distinct values < n) then after change distinct values <= n, but if it becomes n, then permutation? 
                         But wait: if the column had n-1 distinct values and we introduce a new distinct value, then distinct values become n -> permutation. 

          Therefore, we must ensure that we don't turn a non-bad column into a bad one. 

        How to ensure? 

          We can choose v = 1 if 1 is already in the column? or 2 if 2 is already in the column? 

          But then we don't introduce a new distinct value. 

          Therefore, we should choose v to be a value that is already in the column if the column is non-bad? 

        But note: if the column is bad, then we are in the first case? 

        Therefore, we can do:

          If the cell is in a bad row and a bad column: 
               v = 1 if 1 != original, else 2.
          If the cell is in a bad row and a non-bad column: 
               we choose v = a value that is in the column and not the original value. 
               How to choose? We can scan the column for a value that is present and not the original value? 
          If the cell is in a non-bad row and a bad column: 
               we choose v = a value that is in the row and not the original value. 

        But wait: the value in the row for a non-bad row? We only require that the row remains non-bad? 

        However, for a non-bad row, we are not using it to break the row, so we set the value to break the column. We can choose any value in [1, n] except the original value? 

        But to keep the row non-bad, we must avoid making it a permutation? 

        Since the row was non-bad, it has duplicates. After change, if we set one element to a new value, the distinct values might increase by at most 1. And if the distinct values become n, then it becomes a permutation? 

        Therefore, to avoid that, we should set it to a value that is already in the row? 

        Therefore, in summary for a modification at (i, j):

          if the row i is bad and the column j is bad:
              v = any value except the original value. (e.g., 1 if original!=1, else 2)

          if the row i is bad and the column j is non-bad:
              // choose v to be a value that is in the column j (from the original matrix) and not the original value.
              // if there is no such value, then choose any value in [1, n] except the original value. 
              //   but note: the column j is non-bad, so it has duplicates -> then the set of values in the column j has size at most n-1, so there is at least one value missing. 
              //   wait, not necessarily: duplicates -> not a permutation, so size < n? 
              //   actually, duplicates means not all distinct, so size < n.
              //   therefore, there exists a value in [1, n] that is not in the column j. 
              //   but we want a value that IS in the column j? 
              //   and we want to avoid the original value? 
              //   But if the column j has size of distinct values = n-1, then there is exactly one value missing. 
              //   then the only value not in the column j is that missing value. 
              //   therefore, there might be no value in the column j that is not the original value? 
              //   for example: the column j = [1,2,2,3] for n=3: distinct values = {1,2,3}? no, it has 3 elements? 
              //   for n=3, the column has 3 elements: [1,2,2] -> distinct = {1,2} (size=2). 
              //   then if the original value is 1, then we can choose 2? 
              //   if the original value is 2, then we can choose 1? 
              //   only if the original value is the only value in the column j that appears once? 
              //   actually, we only require that the value is in the column j and not the original value. 
              //   in [1,2,2]: 
              //         if the original value is 1, then 2 is in the column and !=1 -> use 2.
              //         if the original value is 2, then 1 is in the column and !=2 -> use 1.
              //   so we can always find one? 
          How to find one? 
               Let S = set of values in column j (from the original matrix)
               We need v in S and v != original_value.

               Since the column j is non-bad, it has at least two elements that are equal? 
               Therefore, |S| <= n-1? 
               And the frequency of the original_value might be 1 or more.

               If the original_value is the only occurrence in the column? then there is at least one other value in S (because |S|>=1, and if |S|==1 then that value appears at least twice, so the original_value appears at least twice) -> wait: 
                   If |S| = 1, then the only value is repeated, so the original_value (which is in S) appears at least twice. Then we can choose that value? but then v = the original_value? which we avoid.
               Therefore, we require v != original_value. 
               If |S| = 1, then the only value is the original_value, then there is no v in S and v!=original_value. 

          Therefore, if |S|>=2, we can choose v to be any value in S that is not the original_value.
          If |S| = 1, then we are forced to choose the only value? then we do nothing? 

        So we must have |S|>=2 to be able to choose a value that is in the column and not the original_value? 

        But if |S| = 1, then the entire column is the same value, say a. 
          Then the element at (i,j) is a. 
          We want to break the row i: we can set it to a value not in the column? 
          Then the column will have value a (n-1 times) and one new value b. 
          Then distinct values = 2, which is < n (since n>=3), so not a permutation. 

        Therefore, we can choose any value b in [1, n] that is not a. 
        Then the row i: we set it to b, and since the row i is a permutation, b is elsewhere in the row? so we break the row. 

        Therefore, algorithm for a cell in a bad row and non-bad column:

          Let a = X[i][j] (original value)
          Let S = set of values in column j.

          If there exists a value v in S such that v != a, then choose v.
          Else: (which means S = {a})
               choose any value v in [1, n] such that v != a.  // this will break the row, and the column will not become a permutation.

        Similarly, for a cell in a non-bad row and bad column:

          Let a = X[i][j]
          Let S = set of values in row i.   // note: the row i is non-bad, so duplicates -> |S| < n? Actually, not necessarily: a non-bad row might have distinct values? No: non-bad means has duplicates, so not distinct. Therefore, |S| < n. 
          But wait: non-bad means it has at least one duplicate, so not a permutation -> so |S| < n. 

          If there exists a value v in S such that v != a, then choose v.
          Else: (which means the row i has only the value a? -> but then it would be [a,a,...,a] -> then |S|=1, and we can choose any v!=a) 

          Then choose any v in [1, n] such that v != a. 

          This will break the column? because the column is bad (permutation) and we change one element to a value not in the column? 
             But wait: the column is permutation, so it has all values. Then we set it to v, which might be in the column? 
          Actually, we are not restricted to the row's values for breaking the column? 

          We break the column by creating a duplicate? 
             We set it to a value that is already in the column? 
          Therefore, we should choose v to be a value in the column j? 

        Let me clarify: 

          For a non-bad row and bad column j: 
             We break the column j by setting the value to a value that is already in the column j? 
             How to do that? 
                 Let T = set of values in the column j (original) -> since it is bad, T is the full set [1, n]? 
                 Then we can choose any value v in [1, n] and it will be in the column j. 

                 But we also want to avoid harming the row i? 

                 To avoid harming the row i: we choose v to be in the row i? 

          Therefore, we require v in the row i and in the column j? 

          Since the row i is non-bad: it has at least one duplicate. 
          The column j is permutation: full set. 

          Therefore, the intersection of the row i and the full set is the row i's set? 

          So any value in the row i is in the column j. 

          Then we can choose any value v in the row i and v != the original value. 

          And since the row i has at least two distinct values (because it has a duplicate? actually, it could be [1,1,2] for n=3: then distinct values={1,2} (size=2)), so there is at least one value in the row i that is not the original value? 

          How to find v? 
               Since the row i is non-bad, the set of values in the row i has size at most n-1. 
               And the original value is in the row i. 
               Then if the row i has size>=2, there is another value. 

          But what if the row i has size=1? then it is [a,a,...,a]. Then the only value is a. 
               Then we cannot find v in the row i and v!=a. 

          Then we choose any v in [1, n] such that v != a. 
          Then we set it to v. 
          For the column j: we set it to v, and since the column j is permutation, v is in the column, so we now have two v's? 
               Actually, the column j originally had one of each. Then we change one a to v. Then the column has: 
                   v appears twice (once at the changed cell and once at the cell that had v), and a appears only in the other n-2 cells? 
               so distinct values: still n? 
               but it has duplicates? Then it is not a permutation? -> then we break it. 

          Therefore, we break the column. 

          For the row i: we changed one a to v. Then the row i: 
               originally: [a, a, ..., a] (n times)
               after change: [v, a, a, ..., a] (n-1 times a and one v) -> then distinct values = {a, v} (size=2) and duplicates (a appears n-1 times) -> non-bad. 

          Therefore, it is safe. 

        So in summary, we can do for any modification at (i, j) with:

          if the row i is bad and the column j is bad:
              v = 1 if X[i][j] != 1, else 2.

          if the row i is bad and the column j is non-bad:
              if there is a value in the column j (from the original matrix) that is not X[i][j], then choose such a value (any one).
              else: choose any value in [1, n] except X[i][j].

          if the row i is non-bad and the column j is bad:
              if there is a value in the row i (from the original matrix) that is not X[i][j], then choose such a value.
              else: choose any value in [1, n] except X[i][j].

        Note: the last case "non-bad row and non-bad column" does not happen in our assignment. 

        And for the assignment of the cells:

          Let R = sorted list of bad rows, C = sorted list of bad columns.
          k = min(|R|, |C|)

          modifications = []
          for i in range(k):
              row = R[i], col = C[i]
              // determine v as above for (bad, bad)
              modifications.append( (row, col, v) )

          for i in range(k, len(R)):
              row = R[i]
              col = 0   // or any fixed column index, say 0
              // determine v as above for (bad, non-bad) where non-bad for column0
              modifications.append( (row, col, v) )

          for j in range(k, len(C)):
              row = 0   // any fixed row index, say 0
              col = C[j]
              // determine v as above for (non-bad, bad) -> note: row0 might be bad? 
                   but if k>0, then R[0] might be 0? and we've already might have broken it? 
                   but we are in the first part: we only assign (R[i], C[i]) for i in range(k). 
                   if 0 is in R[0..k-1] then we've broken it. 
                   then row0 is no longer bad? 
                   but if k>0 and 0 is in R, then we've already broken row0? 
                   and if 0 is not in R, then row0 is non-bad. 

              Therefore, to be safe, we can choose a fixed row that we know is non-bad? 
                  for example, the first row that is not in R? 

          But note: if we have a bad column j and we choose a row i that is bad and not covered yet? Then we break the row i and the column j with one modification? 

          But then we would have already covered it in the pairs? 

          Alternatively, we can choose any row i. 

          But to be safe from using the same cell twice, we choose a fixed row for the remaining bad columns, say row0. 

          However, if row0 is bad and we haven't covered it yet (i.e., if there are more bad rows than bad columns, then row0 might be in R[k] and we will cover it in the remaining bad rows) -> then we would also cover it at (row0, C[j]) for the remaining bad columns? 

          Then we would try to change the same cell (row0, C[j]) twice? 

          Example: 
             R = [0, 1, 2] (three bad rows), C = [0, 1] (two bad columns)
             k = min(3,2)=2.
             We cover:
                 (0,0) and (1,1) -> two modifications.
             Then for the remaining bad rows: i=2, we change (2,0)
             Then for the remaining bad columns: none? 

          So no conflict. 

          But if C = [0, 1, 2] and R = [0,1] then for the remaining bad columns: j=2, we change (0,2) -> but (0,0) is already modified? So cell (0,2) is distinct? 

          Therefore, no cell is repeated. 

        Therefore, we can use:

            for the remaining bad rows: use (row, 0) for row in R[k:]
            for the remaining bad columns: use (0, col) for col in C[k:]

        But note: if a cell (R[i],0) for i in [k, r-1] is the same as a cell (0, C[j]) for j in [k, c-1]? 
            This is (R[i],0) = (0, C[j]) only if R[i]=0 and C[j]=0? 
            Then the cell is (0,0). 
            In the first part (pairs) we might have modified (0,0) if both 0 are in the first k? 
            In the remaining, we might then also modify (0,0) again? 

        Example: 
            R = [0,1], C=[0,1], k=2, so no remaining in R or C? 

            R = [0,1,2], C=[0,1,2], k=3: then we do (0,0),(1,1),(2,2) -> then no remaining. 

            R = [0,1,2], C=[0,1]: 
                k=2: (0,0), (1,1)
                then remaining bad rows: [2] -> (2,0)
                then no remaining bad columns.

            R = [0,1], C=[0,1,2]:
                k=2: (0,0), (1,1)
                then remaining bad columns: [2] -> (0,2) 

            Here, we use (0,0) and (0,2): distinct cells. 

        Therefore, the only potential conflict is if we assign (0,0) in the first part and then in the remaining bad rows we assign (0,0) again? 

        But in the first part, for the bad rows in R[0..k-1] and bad columns in C[0..k-1], we use (R[i],C[i]). 
        In the remaining bad rows, we use (R[i],0) for i>=k, and in the remaining bad columns, we use (0, C[j]) for j>=k. 

        The cell (0,0) is used in the first part if 0 is in R[0..k-1] and 0 is in C[0..k-1]. 
        Then in the remaining, we do not use (0,0) for the remaining bad rows (because the remaining bad rows are indices>=k, and 0 is in the first k) -> so we won't use row0 in the remaining bad rows. 
        Similarly, we won't use column0 in the remaining bad columns. 

        Therefore, no conflict. 

        Implementation:

          Steps for a test case:

            n = int(input())
            X = []
            for i in range(n):
                X.append(list(map(int, input().split())))

            # Identify bad rows and bad columns
            bad_rows = []   # list of row indices that are permutations
            for i in range(n):
                row = X[i]
                if sorted(row) == list(range(1, n+1)): 
                    # This is not safe: because the row might not be sorted. 
                    # Instead, we can use set and distinctness and range.
                    if len(set(row)) == n:
                        bad_rows.append(i)

            bad_cols = []
            for j in range(n):
                col = [ X[i][j] for i in range(n) ]
                if len(set(col)) == n:
                    bad_cols.append(j)

            r = len(bad_rows)
            c = len(bad_cols)
            k = min(r, c)
            modifications = []

            # Cover k pairs: 
            for i in range(k):
                row_idx = bad_rows[i]
                col_idx = bad_cols[i]
                a = X[row_idx][col_idx]
                # choose v: 
                if a != 1:
                    v = 1
                else:
                    v = 2
                modifications.append( (row_idx, col_idx, v) )

            # Cover the remaining bad rows: 
            for i in range(k, r):
                row_idx = bad_rows[i]
                col_idx = 0   # we choose column0
                a = X[row_idx][col_idx]
                # Check if column0 is non-bad -> it is not in bad_cols? not necessarily, but we can compute the set from the original matrix.
                col0 = [ X[i][0] for i in range(n) ]
                S = set(col0)
                if a in S:
                    S.discard(a)
                if len(S) > 0:
                    # choose any value in S
                    v = next(iter(S))
                else:
                    # choose any value except a
                    if a != 1:
                        v = 1
                    else:
                        v = 2
                modifications.append( (row_idx, col_idx, v) )

            # Cover the remaining bad columns:
            for j in range(k, c):
                row_idx = 0
                col_idx = bad_cols[j]
                a = X[row_idx][col_idx]
                row0 = X[0]   # the first row
                S = set(row0)
                if a in S:
                    S.discard(a)
                if len(S) > 0:
                    v = next(iter(S))
                else:
                    if a != 1:
                        v = 1
                    else:
                        v = 2
                modifications.append( (row_idx, col_idx, v) )

            # Output: 
            print(str(len(modifications)))
            for (i, j, v) in modifications:
                # Convert to 1-indexed if the matrix is given in 1-indexed? 
                # The problem: the matrix is given with indices 1..n.
                # We stored in 0-indexed.
                # Output: i+1, j+1, v
                print(f"{i+1} {j+1} {v}")

        But note: the sample input uses 1-indexed.

        Let's test with the sample: 
          "3
           1 3 1
           2 1 3
           3 2 2"

          n=3

          Rows:
            row0: [1,3,1] -> set: {1,3} -> not permutation? -> not bad? 
            row1: [2,1,3] -> set: {1,2,3} -> bad? -> bad_rows = [1]  (0-indexed index1)
            row2: [3,2,2] -> set: {2,3} -> not bad.

          Columns:
            col0: [1,2,3] -> bad -> bad_cols=[0]
            col1: [3,1,2] -> bad -> bad_cols=[0,1]
            col2: [1,3,2] -> bad -> bad_cols=[0,1,2]

          But wait: col2: [1,3,2] -> distinct? so bad.

          Therefore, bad_rows = [1] (0-indexed index1) -> so r=1
                 bad_cols = [0,1,2] -> c=3
          k = min(1,3)=1

          Cover one pair: (bad_rows[0]=1, bad_cols[0]=0) -> cell (1,0) -> which is X[1][0]=2 (0-indexed: row1, col0)

          a = 2.
          Then v = 1 (since 2 != 1)

          Then modification: (1,0,1) -> which is row2, column1 in 1-indexed? 

          Then remaining bad_rows: none? 
          Then remaining bad_cols: [1,2] (0-indexed indices: 1 and 2)

          Then for the first remaining bad_cols: j=1 (0-indexed) -> we use (0,1) 
                row0, col1: a = X[0][1] = 3.
                row0 = [1,3,1] -> set = {1,3}
                remove a=3 -> set becomes {1} -> not empty, so we choose v=1.

          Then for the next: j=2 -> (0,2): a = X[0][2]=1.
                row0 = [1,3,1] -> set without 1: {3} -> choose v=3.

          Then total modifications: 
                (1,0,1) -> (2,1,1) in 1-indexed
                (0,1,1) -> (1,2,1)
                (0,2,3) -> (1,3,3)

          Then the output:
                3
                2 1 1
                1 2 1
                1 3 3

          But the sample output for the second test case is:
                3
                2 1 3
                2 2 3
                3 3 3

          Why is our solution different? 

          We are not matching the sample output, but the problem allows any solution. 

          However, let's check if the sample solution is minimal? 

          The sample solution changes 3 cells: 
                (2,1) to 3 -> originally 2
                (2,2) to 3 -> originally 1
                (3,3) to 3 -> originally 2

          After change:

            row0: [1,3,1] -> has duplicates (1)
            row1: [3,3,3] -> has duplicates (3) -> note: changed two cells: (2,1) and (2,2) -> so row1 becomes [3,3,3]
            row2: [3,2,3] -> has duplicates (3)

            col0: [1,3,3] -> has duplicates (3)
            col1: [3,3,2] -> distinct? [2,3] -> but wait: 3,3,2 -> has duplicates (3) -> so duplicates.
            col2: [1,3,3] -> has duplicates (3)

          So it works. 

          Our solution:

            Original matrix:

              0: [1,3,1]
              1: [2,1,3]   -> becomes [1,1,3]  (because changed (1,0) from 2 to 1)
              2: [3,2,2]

            Then after our changes:

              row0: [1,1,3] -> changed: we did (0,1) to 1: then [1,1,3] -> duplicates? 1 appears twice.
              row1: [1,1,3] -> duplicates? 1 appears twice.
              row2: [3,2,2] -> duplicates? 2 appears twice.

              col0: [1,1,3] -> duplicates? 1 appears twice.
              col1: [1,1,2] -> duplicates? 1 appears twice.
              col2: [3,3,2] -> duplicates? 3 appears twice.

          So it works. 

          Therefore, we output our solution. 

        One more: the first sample test case.

          "4
           3 2 1 1
           2 1 3 4
           1 3 3 1
           4 4 4 2"

          The sample output is 2 modifications.

          Let us check:

            bad rows: 
               row0: [3,2,1,1] -> has duplicates (1) -> non-bad.
               row1: [2,1,3,4] -> distinct? {1,2,3,4} -> bad.
               row2: [1,3,3,1] -> duplicates (1 and 3) -> non-bad.
               row3: [4,4,4,2] -> duplicates (4) -> non-bad.

            bad_cols:
               col0: [3,2,1,4] -> distinct -> bad.
               col1: [2,1,3,4] -> distinct -> bad.
               col2: [1,3,3,4] -> duplicates? (3) -> non-bad.
               col3: [1,4,1,2] -> duplicates? (1) -> non-bad.

            Then bad_rows = [1] (0-indexed index1) 
                 bad_cols = [0,1] (0-indexed)

            k = min(1,2)=1.

            Cover one pair: (1,0) -> row1, col0: a = X[1][0]=2.
                v = 1 (since 2!=1)

            Then modification: (1,0,1) -> which is row2, col1 in 1-indexed? -> but 0-indexed: row1, col0.

            Then remaining bad_rows: none.
            Then remaining bad_cols: [1] (0-indexed index1)

            Then we cover: (0,1) for the bad column1? 
                row0, col1: a = X[0][1]=2.
                We need for non-bad row0 and bad column1? 
                   Actually, row0 is non-bad, column1 is bad? 
                So we are in the third case: non-bad row and bad column? 
                Then we choose v: 
                   look at row0: [3,2,1,1] -> set = {1,2,3}
                   remove a=2: set = {1,3} -> choose v=1 or 3? say 1.

            Then modifications: 
                (1,0,1) -> (2,1,1) in 1-indexed.
                (0,1,1) -> (1,2,1) in 1-indexed.

            Then the sample output is:
               2
               2 1 1
               1 2 1

            But the sample expected output is:
               2
               2 1 1   (which is row2, col1 -> 0-indexed: row1, col0) -> matches our first.
               4 2 3   (which is row4, col2 -> 0-indexed: row3, col1) 

            Why did we choose (0,1) and they chose (3,1)? 

            We chose the fixed row0 for the remaining bad column? 
            But the sample chose row3 (0-indexed index3) for the bad column1? 

            Why? 

            The sample output: 
               2
               2 1 1   -> (2,1) in 1-indexed: row2, column1 -> 0-indexed: row1, col0: set to 1.
               4 2 3   -> (4,2) in 1-indexed: row4, column2 -> 0-indexed: row3, col1: set to 3.

            Let's check the sample solution:

                row0: [3,2,1,1] -> unchanged: duplicates.
                row1: [1,1,3,4] -> originally [2,1,3,4] -> then changed (1,0) to 1: becomes [1,1,3,4] -> duplicates (1).
                row2: [1,3,3,1] -> duplicates.
                row3: [4,3,4,2] -> changed (3,1) to 3: then [4,3,4,2] -> duplicates (4).

                col0: [3,1,1,4] -> [3,1,1,4] -> duplicates (1) -> non-bad? 
                col1: [2,1,3,3] -> [2,1,3,3] -> duplicates (3) -> non-bad.
                col2: unchanged: duplicates? 
                col3: unchanged: duplicates.

            So it works.

            Our solution: 
               (1,0): set to 1: 
                   row1: [1,1,3,4] -> duplicates.
                   col0: [3,1,1,4] -> duplicates (1) -> non-bad.
               (0,1): set to 1: 
                   row0: [3,1,1,1] -> duplicates (1) -> non-bad.
                   col1: [1,1,3,4] -> becomes [1,1,3,4]? 
                         But wait: 
                            col1: 
                                row0: now 1 (originally 2)
                                row1: 1
                                row2: 3
                                row3: 4
                         -> then col1 = [1,1,3,4] -> duplicates (1) -> non-bad.

            So our solution also works.

          Therefore, we output our assignment.

        Note: The sample input has 5 test cases. 

        Let's do the third: 
          5
          1 1 1 1 1
          ... all ones.

          Then no row is bad? because every row has duplicates? 
          no col is bad? because every col has duplicates? 

          Then modifications = 0.

        Fourth test case:
          3
          1 1 2
          2 2 1
          2 3 2

          Rows:
            row0: [1,1,2] -> duplicates -> non-bad.
            row1: [2,2,1] -> duplicates -> non-bad.
            row2: [2,3,2] -> duplicates -> non-bad.

          Columns:
            col0: [1,2,2] -> duplicates -> non-bad.
            col1: [1,2,3] -> distinct? -> bad.
            col2: [2,1,2] -> duplicates -> non-bad.

          Then bad_cols = [1] -> one bad column.

          Then k = min(0,1)=0.
          Then remaining bad_cols: [1] -> we cover: (0,1) 
                a = X[0][1] = 1.
                This is non-bad row and bad column: 
                    Look at row0: [1,1,2] -> set = {1,2}; remove a=1 -> {2} -> choose v=2.
                modification: (0,1,2)

          Output: 
              1
              1 2 2

          The sample output is: 
               1
               1 2 2

        Fifth test case:
          3
          1 1 3
          3 2 1
          3 1 3

          Rows:
            row0: [1,1,3] -> duplicates -> non-bad.
            row1: [3,2,1] -> distinct? {1,2,3} -> bad.
            row2: [3,1,3] -> duplicates -> non-bad.

          Columns:
            col0: [1,3,3] -> duplicates -> non-bad.
            col1: [1,2,1] -> duplicates -> non-bad.
            col2: [3,1,3] -> duplicates -> non-bad.

          Then only one bad row: index1 (0-indexed).

          Then k = 0.
          Then we cover: (1,0) for the bad row? 
                a = X[1][0]=3.
                This is bad row and non-bad column? 
                col0: [1,3,3] -> set = {1,3}; remove a=3 -> {1} -> then we choose v=1? 
          Then modification: (1,0,1) -> which is (2,1,1) in 1-indexed.

          Sample output: 
              1
              2 1 1

        Therefore, we output:

          For each test case:
            Read n.
            Read the matrix.

            bad_rows = []
            for i in range(n):
                row = X[i]
                if len(set(row)) == n:   # permutation -> bad
                    bad_rows.append(i)

            bad_cols = []
            for j in range(n):
                col = [X[i][j] for i in range(n)]
                if len(set(col)) == n:
                    bad_cols.append(j)

            r = len(bad_rows)
            c = len(bad_cols)
            k = min(r, c)
            modifs = []

            # Cover k pairs: 
            for i in range(k):
                i_row = bad_rows[i]
                j_col = bad_cols[i]
                a = X[i_row][j_col]
                # choose v: any value except a; use 1 if a!=1, else 2.
                if a != 1:
                    v = 1
                else:
                    v = 2
                modifs.append( (i_row, j_col, v) )

            # Cover the remaining bad rows: 
            for i in range(k, r):
                i_row = bad_rows[i]
                j_col = 0   # fixed column0
                a = X[i_row][j_col]
                # For a bad row and non-bad column: 
                col0_vals = [X[ii][j_col] for ii in range(n)]   # the column0 in the original matrix
                S = set(col0_vals)
                if a in S:
                    S.remove(a)
                if S:
                    v = S.pop()   # any value in S
                else:
                    if a != 1:
                        v = 1
                    else:
                        v = 2
                modifs.append( (i_row, j_col, v) )

            # Cover the remaining bad columns:
            for j in range(k, c):
                i_row = 0   # fixed row0
                j_col = bad_cols[j]
                a = X[i_row][j_col]
                # For a non-bad row and bad column: 
                row0_vals = X[0]   # the row0 in the original matrix
                S = set(row0_vals)
                if a in S:
                    S.remove(a)
                if S:
                    v = S.pop()
                else:
                    if a != 1:
                        v = 1
                    else:
                        v = 2
                modifs.append( (i_row, j_col, v) )

            # Output
            print(len(modifs))
            for (i, j, v) in modifs:
                # Convert to 1-indexed: add 1 to i and j.
                print(f"{i+1} {j+1} {v}")

        Note: The total n^2 across test cases <= 10000, and n<=100, and t<=1000, but the sum of n^2 <=10000, so we are safe.

        Let me test with the sample test case 2 again in code:

          n=3, matrix = 
            [ [1,3,1],
              [2,1,3],
              [3,2,2] ]

          bad_rows = [1]   (because row1: [2,1,3] -> distinct) -> 0-indexed index1
          bad_cols = [0,1,2] -> because 
                col0: [1,2,3] -> distinct -> bad
                col1: [3,1,2] -> distinct -> bad
                col2: [1,3,2] -> distinct -> bad

          k = min(1,3)=1

          Cover one pair: (1,0) -> a = X[1][0]=2 -> v=1
             modifs = [(1,0,1)]

          Then remaining bad_rows: i from k to r-1: i from 1 to 0 -> none? 
          Then remaining bad_cols: j from 1 to 2: 
                j=1: (0,1) -> a = X[0][1]=3
                     row0_vals = [1,3,1] -> set = {1,3}; remove a=3 -> {1} -> v=1
                j=2: (0,2) -> a = X[0][2]=1
                     row0_vals = [1,3,1] -> set={1,3}; remove a=1 -> {3} -> v=3
             modifs = [(1,0,1), (0,1,1), (0,2,3)]

          Then output: 
              3
              2 1 1
              1 2 1
              1 3 3

          This matches our earlier.

        We run the code and hope it passes.

        However, note: the problem constraints: the sum of n^2 across test cases <= 10000, so we can do O(n^2) per test case.

        Let's code accordingly.

        But note: the condition for bad row: 
            if len(set(row)) == n: 
        This is O(n). Similarly for columns.

        Then total work per test case: O(n^2) which is acceptable since the sum of n^2 <= 10000.

        We are done.