We are given t test cases. For each test case, we are given an integer n and a list a of n integers (each between 0 and 60). We wish to find the smallest non-negative integer x such that for each i from 0 to n-1, p(x+i) = a_i.

Note: p(x) = popcount (number of ones) in the binary representation of x.

Observations:
1. The constraints: n up to 500,000, but the total n across test cases is <= 500,000. Also, each a_i is at most 60. However, note that x might be very large (as seen in the sample: 2305843009213693949).

2. The key is to note that the sequence of popcounts for consecutive integers has patterns and constraints. We know that the popcount of consecutive numbers is not arbitrary. In particular, we have:
   - For any x, p(x+1) - p(x) is constrained by the carry chain when adding 1.

3. How does the popcount change when we go from x to x+1?
   Consider the binary representation of x. When we add 1, we flip a sequence of consecutive ones at the end to zeros and then flip a zero to one. For example:
      x = ...01111 -> x+1 = ...10000.
   Therefore, if we let k be the number of trailing ones in x, then:
        p(x+1) = p(x) - k + 1.

   So the difference is: p(x+1) - p(x) = 1 - k.

   Since k>=1, we have p(x+1) - p(x) can be at most 1? Actually, it can be negative: it can be 1 (if k=0, but then k>=1 by the process) or negative: if k=2, then difference is -1; if k=3, then -2, etc.

   Actually, note: if x ends with 0, then k=0? But then we just flip the last 0 to 1: so p(x+1)=p(x)+1 -> difference = +1.
   If x ends with 01, then k=1: we flip the last 1 to 0 and the 0 to 1: so the popcount remains the same -> difference = 0.
   If x ends with 011, then k=2: we flip the two 1's to 0 and the 0 to 1: so popcount decreases by 1 -> difference = -1.

   Therefore, the difference d_i = a_{i+1} - a_i must be in the set {1, 0, -1, -2, -3, ...}. But note that k can be arbitrarily large? However, the popcount of x is at most 60? Actually, the problem says a_i in [0,60]. But note: the x we are considering might have more than 60 bits? However, the condition is that the popcounts we observe are bounded by 60. But note: the consecutive integers might have popcounts that are arbitrary? Actually, the constraint on a_i is only that they are at most 60, but the true popcount of a very large number might be large? However, we are only required to match the given a_i.

   But note: if we have a sequence of a_i's that are all at most 60, then the numbers x+i we are considering must have popcount at most 60. However, the number x might have a large popcount? Actually, no: because if a_i is at most 60, then the popcount of x+i is at most 60. So the numbers x+i are not arbitrary large? Actually, they can be huge, but the popcount is bounded. However, the key is that the consecutive integers are consecutive, so they share a common structure.

4. Constraints on the sequence:
   Let d_i = a_{i+1} - a_i for i=0 to n-2.
   Then, we must have that d_i = 1 - k for some k>=1, but note that k can also be 0? Actually, k is the number of trailing ones? Actually, k is the number of consecutive ones starting from the least significant bit. However, note that k can be 0? Actually, if the last bit is 0, then k=0? But then we only flip the last bit: so we add one and remove nothing? Then the formula: p(x+1)=p(x)+1 -> difference=1. So the difference must be one of:
        +1, 0, -1, -2, -3, ... 

   But note: the difference cannot be arbitrarily negative? Actually, it can be as negative as the entire length of the trailing ones. However, the problem states that the a_i are at most 60, so the popcount of x is at most 60, which implies that the number of trailing ones cannot exceed 60? Actually, no: the entire number might have more than 60 bits? But the popcount is 60, so the number of trailing ones is at most 60. Therefore, the difference must satisfy: d_i = 1 - k_i, where k_i is at least 1 (if there is at least one trailing one) or if the last bit is zero then k_i=0? Actually, we saw that when the last bit is zero, k=0 and we get difference=1.

   Correction: the formula for the difference is always: 
        p(x+1) = p(x) - (k-1)   ??? 

   Actually, let's recompute:
        Let x = A01...1 (with k ones at the end). Then x+1 = A10...0 (with k zeros at the end).
        So the popcount of x: p(x) = p(A) + k.
        The popcount of x+1: p(x+1) = p(A) + 1.
        Therefore, p(x+1) = p(x) - k + 1.

        So d_i = p(x+1) - p(x) = 1 - k.

        Now, k is the number of trailing ones in x. Since the last bit is always one (by the definition of trailing ones), k>=1. Therefore, the difference d_i = 1 - k <= 0? But wait, what if the last bit is zero? Then k=0? Actually, we defined k as the number of consecutive ones at the end. So if the last bit is zero, then k=0. Then the formula: 
          x = A0 -> x+1 = A1, so p(x+1)=p(A)+1, p(x)=p(A) -> difference = 1.

        Therefore, we can write: the difference d_i must be either 1 (if the last bit was 0) or 1 - k (with k>=1) which gives 0, -1, -2, ... and so on.

        In summary, the difference d_i must be at most 1 and at least 1 - (max_possible_trailing_ones). But note that the trailing ones cannot exceed the total popcount of x, which is a_0. However, the trailing ones are contiguous at the end, so they are bounded by the entire number of bits? But we don't know the bit-length. However, note that the next number's popcount must be at least 1 (because we are adding one and then we have one more bit at the position where we broke the chain). But wait: what if x=0? then p(0)=0, then x+1=1 -> p(1)=1 -> difference=1. So the difference can be 1 even if the popcount of x is 0.

        Therefore, the constraints on the differences are:
          d_i must be an integer and d_i <= 1.
          Moreover, since k = 1 - d_i, and k must be nonnegative? Actually, k>=0. So 1 - d_i >= 0  => d_i <= 1? But we already have that. However, k can be 0? Then d_i=1. k>=1? Then d_i<=0.

        But note: k can be 0 only when the last bit is 0? Actually, k is defined as the number of trailing ones, so if the last bit is 0, then k=0. Therefore, we have two cases:
          Case 1: the last bit of x is 0 -> then d_i = 1.
          Case 2: the last bit of x is 1 -> then k>=1 and d_i = 1-k <= 0.

        Therefore, the difference d_i must be either 1 or at most 0? Actually, it can be 1 only if the last bit of x is 0, and negative or zero if the last bit of x is 1.

        However, we can also note: if the last bit of x is 1, then the difference d_i can be 0? That happens when k=1: then d_i=0. Also, if k=2, then d_i=-1, etc.

        Therefore, the sequence of differences must satisfy:
          For each i: d_i <= 1, and if d_i > 0 then d_i must be 1? Actually, d_i cannot be 2? So we have d_i ∈ {1, 0, -1, -2, ... }.

        But note: the condition for the last bit: if d_i=1, then the last bit of x must be 0. If d_i<=0, then the last bit of x must be 1.

        However, we are considering consecutive numbers: the condition applies to the entire sequence. For the j-th consecutive number (x+j), we can define the difference d_j = a_{j+1} - a_j. Then the last bit of x+j must be 0 if d_j=1, and 1 if d_j<=0.

        This gives a necessary condition: 
          For each j from 0 to n-2: 
            if d_j = 1 then the last bit of (x+j) must be 0.
            if d_j <= 0 then the last bit of (x+j) must be 1.

        Moreover, we can also derive the exact value of k (the number of trailing ones) for x+j: 
            k_j = 1 - d_j   [if d_j<=0, then k_j = 1 - d_j (which is at least 1), and if d_j=1, then k_j=0? Actually, in the case d_j=1, we have k_j=0? But that matches: the last bit is 0, so trailing ones=0].

        However, note: the trailing ones k_j is the number of consecutive ones starting from the least significant bit in (x+j). This has implications for the bits of (x+j) and also for the next numbers.

        Actually, the condition for the entire block of trailing ones: 
          In the representation of (x+j): the last k_j bits are ones and the (k_j+1)-th bit (from the right) is 0 (if k_j>0). But note: if k_j=0, then the last bit is 0.

        Therefore, we can reconstruct the least k_j+1 bits of (x+j) from the difference d_j? 

        However, note: the condition on consecutive numbers: 
          The next number x+j+1 is formed by flipping the trailing ones to zeros and then flipping the zero to one. Therefore, the bits of (x+j) and (x+j+1) are related.

        This suggests that we can try to reconstruct x bit by bit? But n can be 500000 and x can be huge (like 2^60) so we cannot iterate over bits arbitrarily.

5. Alternate approach: use known properties of popcount in consecutive numbers.

   We know that the sequence of popcounts for consecutive numbers is well studied. There is a known necessary condition: 
        a_{i} = p(x+i) must satisfy the relation: 
          a_{i+1} = a_i + 1 - 2 * (number of trailing ones in x+i)   ??? 

   But wait, we have: 
        p(x+i+1) = p(x+i) - k + 1, where k is the number of trailing ones in x+i.

   So we have: a_{i+1} = a_i + 1 - k.

   And k is the number of trailing ones in x+i.

   Therefore, k = a_i + 1 - a_{i+1}.

   But k must be a positive integer? Actually, if the last bit is 1 then k>=1, and if the last bit is 0 then k=0. But note: we have already related the last bit to the sign of the difference.

   However, we can write:
        k_i = a_i + 1 - a_{i+1}   [if the last bit of x+i is 1] 
        and if the last bit is 0 then we have a_{i+1} = a_i + 1, so k_i = 0.

   Therefore, we can compute k_i from the sequence? But note: we don't know the last bit of x+i? Actually, we can infer it from the difference: if a_{i+1} = a_i+1 then the last bit must be 0, and then k_i=0. Otherwise, if a_{i+1} <= a_i, then the last bit is 1 and k_i = a_i + 1 - a_{i+1}.

   But note: k_i must be at least 1 when the last bit is 1. Therefore, we require:
        If a_{i+1} <= a_i, then k_i = a_i + 1 - a_{i+1} must be at least 1, which is automatically satisfied because a_{i+1} <= a_i implies a_i+1 - a_{i+1} >= 1.

   However, we also require that k_i is consistent with the bits of x+i.

   How? The value k_i is the number of trailing ones in x+i. This means that the bits of x+i from the least significant bit to the k_i-th bit are ones, and the next bit (if it exists) must be 0. 

   Therefore, we can use this to set constraints on the bits of x+i.

   Moreover, note that x+i and x+i+1 are consecutive. When we add 1, we break the trailing ones and set the next bit to 1. Therefore, the bits of x+i and x+i+1 are determined in the low k_i+1 bits.

   This suggests that we can reconstruct the binary representation of x modulo a certain modulus? Actually, we can reconstruct the bits from the least significant to the most.

   However, the problem: we need the smallest x that matches the entire sequence of n popcounts.

6. How to reconstruct x?

   We note that the constraints on the trailing ones for each position i (from 0 to n-1) might be interdependent. For example, the trailing ones for x+i might extend beyond the bits we have set? Actually, we can consider the bits of x as we go.

   Idea: 
        We are going to consider the bits of x from the least significant bit (LSB) to higher bits. We know that the sequence of numbers x, x+1, ... x+n-1 are consecutive. Therefore, the entire sequence of numbers is determined by x and n.

   How do the trailing ones in x+i relate to the bits of x? 

        Let x have binary representation: ... b_{m} b_{m-1} ... b_0.

        Then the number x+i is x plus i. The trailing ones in x+i depend on the representation of x+i.

        However, we can think of x as a fixed number and then the numbers x, x+1, ... are consecutive. Therefore, the trailing ones in x+i are determined by the carry chain when adding i to x.

        But note: we are going to have constraints from the sequence a_i: for each i, we have:
          p(x+i) = a_i.

        And for each i (from 0 to n-2), we have:
          k_i = (if a_{i+1} <= a_i) then k_i = a_i + 1 - a_{i+1}; and if a_{i+1} = a_i+1 then k_i=0.

        But note: what if the sequence has a jump that is not 1 and not <= a_i? For example, if we see a_{i+1} = a_i+2? Then the condition fails: because the difference must be at most 1? Actually, we argued that the difference must be <=1. Therefore, if we see a_{i+1} - a_i > 1, then we can immediately output -1.

        Similarly, if a_{i+1} - a_i > 1, then it's impossible.

        Also, if a_{i+1} = a_i+1, then we know the last bit of x+i must be 0.
        If a_{i+1} <= a_i, then the last bit of x+i must be 1, and we also know the number of trailing ones k_i = a_i + 1 - a_{i+1}. This k_i must be at least 1.

        However, we also have a constraint from the next numbers: the trailing ones for x+i must be consistent with the bits we set for the lower bits.

        Moreover, note: the trailing ones in x+i must be at least k_i. But also, the next bit (the k_i+1 bit from the right) must be 0? Actually, in the binary representation of x+i, the last k_i bits must be ones and the bit at the k_i-th position (counting from 0) must be 0? Actually, the bit at position k_i (the one that becomes 1 in x+i+1) must be 0 in x+i.

        Therefore, we have constraints on the bits of x+i at positions 0 to k_i.

        But note: the numbers x+i and x+i+1 are consecutive, so the bits of x+i and x+i+1 are known to be:

          x+i: ... 0 1 1 ... 1 (k_i ones) 
          x+i+1: ... 1 0 0 ... 0 (k_i zeros)

        Therefore, the bits from position 0 to k_i-1 of x+i are 1, and the bit at position k_i is 0. Then x+i+1 has the bit at position k_i set to 1 and the bits below set to 0.

        Now, consider the next number: x+i+2: 
          We add 1 to x+i+1: the trailing ones in x+i+1 are 0? Actually, the last bit is 0 (because we have ...10...0, so the last bit is 0). Therefore, the trailing ones in x+i+1 are 0? Actually, the trailing ones are the consecutive ones at the end. Since the last bit is 0, the trailing ones count is 0.

        But wait: the representation of x+i+1: ...? ... 1 0 0 ... 0. The last bit is 0? Actually, no: the last bit is the least significant bit. We set the last k_i bits of x+i to ones? Then when we add 1, we break that and set the next bit to 1. So the representation of x+i+1 has the k_i-th bit set to 1 and the lower k_i bits set to 0. Therefore, the last bit is 0? Only if k_i>=1? Actually, the least significant bit (bit0) is set to 0. So the last bit is 0.

        Therefore, the trailing ones in x+i+1 are 0. So the next difference (if we look at i+1) must be: 
          a_{i+2} - a_{i+1} = ? 
          Since the last bit of x+i+1 is 0, the difference must be 1? 

        Therefore, we must have a_{i+2} = a_{i+1} + 1.

        But wait: what if k_i=0? Then we are in the case of a_{i+1}=a_i+1. Then the last bit of x+i is 0, so x+i+1 = x+i + 1 has the last bit flipped to 1? Actually, no: 
          x+i: ...?0 -> x+i+1: ...?1. So the last bit of x+i+1 is 1. Then the trailing ones in x+i+1? 
          The trailing ones: we look at the last bits: if the last bit is 1, then we look at the next one? But we don't know. However, the condition for the next difference (from i+1 to i+2) is determined by the last bit of x+i+1: 
            If the last bit is 1, then the difference a_{i+2} - a_{i+1} must be <=0? and we compute k_{i+1} = a_{i+1}+1 - a_{i+2}.

        Therefore, we do not necessarily have a_{i+2}=a_{i+1}+1 after a carry. 

        However, note: the carry operation only sets the k_i-th bit to 1 and the lower k_i bits to zeros. Then the next number x+i+1 ends with ...100...0. So the trailing ones count for x+i+1 is 0? Actually, no: the trailing ones are the consecutive ones starting from the least significant bit. The least significant bit is 0? Then there are no trailing ones? So k_{i+1}=0? Then the next difference must be 1? 

        Therefore, we have a strong constraint: 
          After a carry (which happens at x+i, where the last bit was 1 and we had k_i>=1 trailing ones), the next number x+i+1 has the last k_i bits as zeros and the k_i-th bit as 1. Therefore, the last bit (bit0) is 0? Actually, no: 
          Let k_i = 2: 
             x+i: ...011  -> then x+i+1: ...100.
          So the last bit (bit0) of x+i+1 is 0? Then the trailing ones count is 0. So the next difference must be 1? 

        Therefore, we must have a_{i+2} = a_{i+1} + 1.

        This is a necessary condition: 
          If at position i we have a_{i+1} <= a_i (so the last bit of x+i is 1 and k_i = a_i+1 - a_{i+1} >= 1), then at the next step we must have a_{i+2} = a_{i+1} + 1.

        Why? Because the last bit of x+i+1 is 0? Actually, the last bit of x+i+1 is the bit0: and we just set it to 0? Actually, no: we set the entire block of k_i bits to zeros. So the least significant bit is 0. Therefore, the trailing ones count for x+i+1 is 0, so the next difference must be 1.

        Therefore, we have a necessary condition for the sequence: 
          For each i from 0 to n-2:
            if a_{i+1} <= a_i, then we require that i+1 is not the last element and then a_{i+2} must equal a_{i+1} + 1.

        Moreover, if the sequence does not satisfy this, we output -1.

        Example: 
          [3, 3, 4, 1, 2] 
          d0 = 0 -> so k0 = 3+1-3 = 1 -> then we require a_2 = a_1 + 1? a_1=3, then a_2 must be 4 -> which it is. Then for i=1: d1 = 4-3=1 -> so k1=0 -> no constraint. Then i=2: d2 = 1-4 = -3 -> k2=4+1-1=4 -> then we require a_3+1 = a_4? Actually, the next element after a_3 must be a_4 = a_3+1? But we have a_3=1 and a_4=2 -> yes.

        However, note: the constraint applies to the next element: at i=2 (which is the third element) we have a carry, so we require that the next element (if exists, which is i+1=3) must be a_4 = a_3+1? But our sequence: a_3=1, a_4=2 -> yes.

        But wait: the carry at i=2 (which corresponds to x+2) produces x+3. Then the next number is x+4? The constraint is for the next difference: from x+3 to x+4. So we are at i=3? Actually, we are at index i in the sequence: 
          i=0: a0=3, a1=3 -> then k0=1 -> then we require a2 = a1+1? -> 3+1=4 -> matches a2=4.
          i=1: a1=3, a2=4 -> difference=1 -> k1=0 -> no constraint for the next.
          i=2: a2=4, a3=1 -> difference=-3 -> k2=4+1-1=4 -> then we require a4 = a3+1 -> 1+1=2 -> matches a4=2.

        So the sequence passes.

        Now, if we have a sequence that violates: 
          [2, 1, 2] -> 
          i0: a0=2, a1=1 -> difference=-1 -> k0=2+1-1=2 -> then we require a2 = a1+1 -> 1+1=2 -> matches a2=2.

        Another: [60,60] -> 
          n=2: 
          i0: a0=60, a1=60 -> difference=0 -> k0=60+1-60=1 -> but then we require that there is a next element? But n=2, so we are at the last difference? Then we don't need to check the next element? Actually, the constraint is: if we have a carry at i, then we require that the next element (if it exists) must be a_{i+1}+1. Here i0: we require that if i0 is not the last (which it is the last difference? i0 runs from 0 to n-2, so for n=2, i0=0 is the only difference). Then we require that the next element (a2) must be 60+1=61? But we don't have a2. So the constraint only applies when i+2 is in the sequence? 

        Therefore, the constraint is: 
          If at an index i (0<=i<=n-2) we have a_{i+1} <= a_i, then we must have that i+1 <= n-2 (so that a_{i+2} exists) and then a_{i+2} must equal a_{i+1} + 1.

        If i+1 is the last element (i.e., i = n-2) and we have a_{n-1} <= a_{n-2}, then we don't require a next element? But the condition for the trailing ones at x+i (with i=n-2) is valid? However, the carry operation does not affect the next number beyond the sequence? So we don't require a next element. 

        But wait: the condition for the trailing ones at x+i (for i=n-2) does not impose a constraint on the next element because the next element is not in the sequence. 

        Therefore, we only require the constraint when i+1 <= n-2.

        However, note: the carry operation at x+i (i=n-2) produces x+n-1, which is the last number in our sequence. The popcount of x+n-1 is a_{n-1}. But we do not have a next number. So the constraint is only on the existence of the next number for the next difference? Actually, the constraint we derived was: after a carry at x+i, the next number x+i+1 must have a trailing zeros? and then the next difference (from x+i+1 to x+i+2) must be 1? But if we don't have x+i+2, then we don't care. 

        Therefore, the constraint we have is only for the next difference that we are given? 

        So: 
          For i from 0 to n-2:
            if a_{i+1} <= a_i, then we require that i+1 < n-1 (so that there is an element at i+2) and then a_{i+2} = a_{i+1} + 1.

        But wait: what if the sequence ends at i+1? Then we don't have an element at i+2? Then we don't require anything? 

        However, note: the carry operation at x+i (which is the i-th element, i from 0 to n-2) produces x+i+1. The next number x+i+2 is not in the sequence? Then we don't have a constraint on the popcount of x+i+2? So we are safe.

        But the constraint we derived about the trailing ones in x+i+1 is not used? Actually, we don't need to check the next difference if we don't have the next element.

        Therefore, the necessary conditions we have so far are:

          Condition 1: For each i in [0, n-2]:
            (a) a_{i+1} - a_i <= 1.
            (b) If a_{i+1} - a_i > 1, then it's impossible -> output -1.

          Condition 2: For each i in [0, n-2] such that a_{i+1} <= a_i (which is the same as a_{i+1} - a_i <=0) and i < n-2 (so there is an element at i+2), then we require a_{i+2} = a_{i+1} + 1. If not, output -1.

        Also, Condition 3: For each i in [0, n-2] such that a_{i+1} <= a_i, we have k_i = a_i + 1 - a_{i+1} must be at least 1? Actually, we have that because a_{i+1} <= a_i implies k_i = a_i+1 - a_{i+1} >= 1.

        But note: k_i must be an integer and at least 1? It is.

        However, we have one more condition: the trailing ones at x+i must be at least k_i. How do we check that? 

        Actually, we cannot check it without knowing the bits? But we are going to reconstruct x. Alternatively, we can note that the value k_i must not exceed the total number of bits we have? But we don't know the total bits. However, we know that the popcount of x+i is a_i. The trailing ones are k_i, so the rest of the bits must have popcount a_i - k_i. And a_i - k_i = a_i - (a_i+1 - a_{i+1}) = a_{i+1} - 1? But note: a_{i+1} = a_i - k_i + 1 -> so a_i - k_i = a_{i+1} - 1. 

        But we don't know the rest of the bits? 

        Actually, the constraint is: the trailing ones k_i must not exceed the available consecutive ones at the end of x+i? But we don't know x+i. 

        However, we have a more fundamental constraint: the trailing ones k_i must be consistent with the bits that we have already set? 

        Therefore, we must reconstruct the bits of x.

7. How to reconstruct the bits of x?

   We are going to consider the entire sequence and the constraints on the trailing ones. We note that the sequence of numbers is consecutive. Therefore, we can express x+i in terms of x and i. 

   Alternatively, we can use a state machine that tracks the lower bits that have been fixed by the constraints. 

   We note that the constraints from the differences fix the trailing ones for each x+i. Specifically, for each index i, if we have a carry (i.e., a_{i+1} <= a_i), then we know the last k_i+1 bits of x+i: the last k_i bits are ones and the bit at position k_i is 0.

   But note: if k_i=0, then we only know the last bit of x+i is 0.

   How to combine? 

        We can traverse i from 0 to n-1 and maintain the known bits of x. However, note that the constraints might overlap? 

        For example, if we have two consecutive carries: 
          At i=0: k0 = 2 -> so the last 2 bits of x (which is x+0) are ones and the bit at position 2 is 0. 
          Then at i=1: we are looking at x+1. How is x+1 related? 
            x+1 = (x) + 1. 
            Since the last 2 bits of x are 11, then x+1: ... becomes ...? We know that the last 2 bits become 00 and the bit at position 2 becomes 1. 
            So the last 3 bits of x+1: ...100.

        Now, if at i=1 we have a carry? Then the last bit of x+1 is 0? Then we cannot have a carry? Because the last bit must be 1 for a carry? 

        Actually, after a carry, the last bit of x+1 is 0? Then the trailing ones count is 0? So the difference for i=1 must be 1? 

        Therefore, we cannot have two consecutive carries? 

        But wait: after a carry at x, the next number x+1 ends with ...100..0, so the last bit is 0. Then the next difference must be 1? So we cannot have a carry (which requires a_{i+1}<=a_i) at the next step? 

        Therefore, the carries must be isolated by a 1-difference? 

        Actually, the pattern: 
          We have a carry at i: then the next step i+1 must have a difference of 1 (if we have an element at i+2). Then at step i+1, the last bit of x+i+1 is 0? Actually, we just had a carry at x+i, so x+i+1 ends with ...100..0, so the last bit is 0. Then the next difference (from x+i+1 to x+i+2) must be 1? Then the last bit of x+i+1 must be 0 -> which it is, and then the next number x+i+2 = (x+i+1)+1: flip the last bit from 0 to 1 -> so the last bit becomes 1. 

        Then at step i+1: we have a_{i+2} = a_{i+1} + 1.

        Then at step i+2: the last bit of x+i+2 is 1. Then we might have a carry? 

        Therefore, we can have carries at step i and then at step i+2? 

        Example: 
          x: ...011 -> x+1: ...100 -> x+2: ...101 -> then x+3: ...110 -> then if we have a carry at x+2? 
          But at x+2: ...101 -> the last bit is 1, but the next bit is 0? Then trailing ones = 1. So we could have a_{i+2} = a_{i+1} (if the popcount of x+2 equals x+3) or even a drop? 

        However, note: we have a constraint that after a carry we require the next difference to be 1. Then at step i+1 we have a_{i+2} = a_{i+1}+1. Then at step i+2, we have the last bit of x+i+2 is 1 (because x+i+2 = x+i+1+1: we flipped the last bit from 0 to 1). Therefore, we might have a carry at step i+2? 

        But the constraint for a carry at step i+2: we require a_{i+3} <= a_{i+2}. Then we also require that if there is a next element (i+3 < n-1) then a_{i+4} = a_{i+3}+1.

        Therefore, the pattern of carries must be separated by at least one step? And after a carry, there is a forced increase.

        Now, to reconstruct x, we can try to simulate the sequence and set the bits that are forced by the carries.

        We maintain a representation of the known bits of x. But note: x is fixed for the entire sequence. However, the constraints are on x+i for i from 0 to n-1.

        We can express x+i in terms of x and i, but the binary representation is complicated.

        Alternate idea: use a graph or a state that represents the lower bits that are fixed and the value of x modulo a power of two.

        However, note that the constraints only fix a bounded number of bits? Actually, the constraint from a carry at x+i fixes the last k_i+1 bits of x+i. Since k_i can be large, but note that k_i = a_i+1 - a_{i+1}, and a_i and a_{i+1} are at most 60, so k_i <= 61. Therefore, we are only fixing about the last 62 bits.

        But the entire sequence has length up to 500000, so we cannot remember all bits.

        Insight: we can use a segment of bits that is large enough to cover the entire sequence? Actually, the sequence of consecutive numbers might have a carry that propagates? But note: the constraints on the popcounts (each at most 60) imply that the numbers cannot be too large? Actually, no: we can have a number that is very large but has popcount 60. 

        However, we are asked for the smallest x. Therefore, we are going to try to reconstruct x from the LSB upwards.

        Steps:

          We are going to iterate i from 0 to n-1. For each i, we wish to compute the popcount of x+i, but we also have constraints from previous steps and from the given a_i.

          We maintain:
            - The current value of x mod M, for a modulus M that is a power of two. But what should M be? 
            - Or we maintain a set of possible states. However, the state might be the last k bits and the current popcount? 

          Alternatively, we can use the following known approach: 

          We know that the sequence of consecutive numbers is determined by the starting number. The constraints on the popcounts and the carries give us linear equations in bits? 

        However, note the sample solution: 
          The third sample: n=2, [60,60] -> x = 2305843009213693949.

          Let's see: 
            x = 2305843009213693949, which is (2^61 - 2) / 3? Actually, 2^61 is 2305843009213693952, so 2305843009213693949 = 2305843009213693952 - 3 = 2^61 - 3.
            Then:
              x: 2^61 - 3 = (61 ones) in binary? Actually, 2^61 is 1 followed by 61 zeros. Then 2^61 - 3 is 61 bits: 
                  111...11101  (because 2^61 - 1 is all ones, then subtract 2: so the last two bits become 01? Actually, 2^61-3 = (2^61-1) - 2 = ...111111 - 10 = ...111101? 
                How many ones? 
                  61 bits: 59 ones and then 01? 
                Actually: 
                  (2^61-1): 61 ones.
                  subtract 2: 
                     ...11111111
                   -        10
                     ...11111101 -> so popcount = 61 - 1 = 60? 
                Then x+1 = 2^61 - 2: 
                  2^61 - 2 = ...11111110 -> popcount = 60.

          So both x and x+1 have popcount 60.

        How to get the smallest x that has a sequence of popcounts matching a_0, a_1, ... a_{n-1}?

        Known approach: 
          We can solve the problem by iterating the bits from low to high. We maintain a set of candidate values for x that are consistent with the constraints so far. But the total n is 500000, and the number of candidates might be exponential.

        Alternate known solution: 
          There is a known solution for this problem in the competitive programming community. The key is to use a BFS in the state of the last ~60 bits? 

          State: 
            We maintain the last L bits of x, and the current popcount of the entire x? But note: the entire x might be huge. However, we are only interested in the popcount of x+i for i from 0 to n-1. 

          Insight: 
            The constraint from a carry at x+i only fixes the last k_i+1 bits of x+i. And k_i <= 61. Moreover, the effect of adding i to x might be localized to the lower O(log(i)) bits? But i can be up to 500000, which is about 19 bits. Therefore, the entire sequence of consecutive numbers might have changes in the lower 60+19 bits? 

          We can try to simulate the entire sequence by maintaining the last L bits of x, and also the higher bits. But we are only interested in the popcount. The popcount = popcount(lower L bits) + popcount(higher bits). And the higher bits are not affected by the addition until a carry propagates beyond the L bits.

          How to handle carry propagation beyond L? We can maintain the higher bits as a single number (the carry from the lower L bits) and the popcount of the higher bits. But the higher bits might change? 

        Actually, we can use a DP with state (carry, current popcount of the higher bits, the last L bits of x) but L must be at least 60+20? That would be 80 bits, which is 2^80 states -> too many.

        Another known solution: 
          We can use a greedy bit DP that sets the bits from low to high and uses the fact that the constraints only depend on the last few bits and the current popcount.

        However, note: the total n is 500000, but the total across test cases is 500000. Therefore, we need an O(n) solution per test case? Or O(n*C) with C a constant around 60.

        We can try to simulate the entire sequence i=0 to n-1, and for each i, we know the constraint on the last k_i+1 bits of x+i. But then we need to propagate the constraints.

        Insight: 
          We can use a union-find or a data structure for constraints? 

        Alternatively, we can use the following approach by known problems (e.g., from CodeForces):

          Step 1: Check the necessary conditions on the differences and the forced next element after a carry. If fails, output -1.

          Step 2: Now, we assume the necessary conditions are satisfied. How to find the smallest x? 

          We will determine the bits of x from low to high. We maintain the current candidate value for x. But we don't know the high bits.

          We note that the popcount of x+i is given. But we also know the lower bits of x+i from the carry conditions.

          Specifically, for each i, we can express x+i in terms of x and i. And we know the last k_i+1 bits of x+i if there was a carry at a previous step that fixed them? But note: a carry at x+i fixes the last k_i+1 bits of x+i. But we might have not encountered x+i yet? 

          Alternatively, we can try to reconstruct the bits for x+i for each i as we go, and then deduce x.

        How about we reconstruct the entire sequence of bits for the numbers x, x+1, ... x+n-1? But the total length might be O(n) and n=500000 -> 500000 * 500000? That is too high.

        Another idea: 
          We can use a single variable that represents the current value of x mod 2^{L} for L large enough (say L=80). But then we have to account for carries that go beyond L. 

          We maintain:
            x_lo: the last L bits of x (as a binary number, stored as an integer)
            x_hi: the higher bits (which we do not store explicitly, but we store the popcount of the higher bits? and also the fact that the higher bits are all ones? or all zeros? Actually, we don't know.)

          However, the popcount of x+i is the popcount in the higher bits plus the popcount in the lower L bits of x+i. But the lower L bits of x+i = (x_lo + i) mod 2^L, and we also have a carry bit from the lower L bits to the higher bits.

          Let c_i = (x_lo + i) / (2^L) [either 0 or 1]? But L is large enough so that x_lo + i < 2^L? Not necessarily: we might have x_lo + i >= 2^L. Then the higher bits will be x_hi + c_i.

          Then the popcount of x+i = popcount(x_hi + c_i) + popcount( (x_lo+i) mod 2^L ).

          But popcount(x_hi + c_i) is difficult because we don't know x_hi.

        Insight: 
          The smallest x will have the smallest higher bits. And the higher bits will be 0 if there is no carry out of the lower L bits? 

          How to choose L? 
            The maximum k_i is at most 61. And the maximum i is n-1 <= 500000. Therefore, the total number of bits we need to cover is L = 61 + ceil(log2(500000)) ~ 61+19 = 80.

          We set L=80. Then we try to determine the last L bits of x.

          We can iterate over the possible values of x mod 2^L? There are 2^80 possibilities -> too many.

        Alternate solution from known problems: 
          There is a solution that uses the following: 
            We are going to simulate the addition and the constraints. We start at x and then for each i, we know the constraint on x+i. We maintain a set of candidate values for the last L bits of x. But initially, we don't know anything.

          However, the constraints from the carries will fix parts of the last L bits. We can use a BFS that goes bit by bit.

        Given the complexity, we turn to known similar problems: 
          The problem "Binary Blocks" or "Popcount in consecutive integers" has been solved with a method that checks the constraints and then uses a formula for x.

        Formula for x: 

          After a carry at x+i, we know that:
            x+i = A * 2^{k_i+1} + (2^{k_i} - 1)   [because the last k_i bits are ones and the bit at k_i is 0]

          Therefore, 
            x+i = A * 2^{k_i+1} + (2^{k_i} - 1)

          Then the next number:
            x+i+1 = A * 2^{k_i+1} + 2^{k_i}   [popcount: p(A)+1]

          Also, the popcount of x+i is: p(x+i) = p(A) + k_i = a_i.

          Therefore, p(A) = a_i - k_i.

          But also, for the next number, we have: 
            p(x+i+1) = p(A) + 1 = a_i - k_i + 1 = a_i - (a_i+1 - a_{i+1}) + 1 = a_{i+1}? 
          -> a_{i+1} = a_i - k_i + 1, which is the condition we already have.

          So this is consistent.

          Now, what if we have multiple carries? The smallest x might be the one that minimizes A for the earliest carry. 

        How to combine? 

          We can express x in terms of the first carry. But the first carry might not occur at i=0.

          The smallest x might have no carry at i=0? 

          Example: the first sample: 
            x=13: binary: 1101.
            i=0: x=13: 1101 -> p=3.
            i=1: x+1=14: 1110 -> p=3.
            i=2: x+2=15: 1111 -> p=4.
            i=3: x+3=16: 10000 -> p=1.
            i=4: x+4=17: 10001 -> p=2.

          Carry at i=0: 
            a0=3, a1=3 -> difference=0 -> not a carry? Actually, wait: a1<=a0 -> yes, so carry at i=0: k0 = a0+1 - a1 = 3+1-3=1.
            Then x+0 = x = A * 2^{2} + (2^1-1) = 4A + 1.
            Also, p(x)= p(A)+1 = 3 -> so p(A)=2.

          Carry at i=2: 
            a2=4, a3=1 -> difference=-3 -> carry: k2 = 4+1-1=4.
            Then x+2 = B * 2^{5} + (2^4-1) = 32B + 15.
            But also, x+2 = x+2 = (4A+1)+2 = 4A+3.
            So: 4A+3 = 32B + 15  -> 4A = 32B + 12 -> A = 8B+3.

          Then p(A)=2, and A = 8B+3.
          The popcount of A: p(8B+3) = p(B) + p(3) [if no carry] = p(B) + 2, because 3 is '11' in binary. 
          But wait: 8B is B shifted by 3, then plus 3: 
             ... if B has binary representation C, then 8B+3 = C000 + 11 = C011.
          Then popcount = popcount(C)+2.
          So we have popcount(C)+2 = 2 -> popcount(C)=0 -> C=0.
          Then B=0, A=3.
          Then x = 4*3+1 = 13.

          Therefore, we can solve by setting up congruence relations: 
            For each carry at index i, we have:
              x+i = A_i * 2^{k_i+1} + (2^{k_i}-1)

            and also the next element must be: 
              a_{i+1} = a_i - k_i + 1   [which we already used]

            and the next next element (if exists) is forced to be a_{i+1}+1.

          Then we have for the next carry, say at index j>i, we have a similar equation.

          Also, the non-carry indices do not give such equations.

          Then x must satisfy: 
            x+i = A_i * 2^{k_i+1} + (2^{k_i}-1)   [for each carry at i]

          We wish to find the smallest non-negative x that satisfies all these congruences and also yields the popcounts at the non-carry indices.

          But the non-carry indices: 
            At a non-carry index i, we have a_{i+1}=a_i+1, and then we know that the last bit of x+i is 0. Therefore, 
              x+i is even.

          So we have a system of congruence relations and also some parity conditions.

          How to solve? 
            We can collect all the equations from the carries. Each carry at index i gives:
               x = (2^{k_i}-1) - i   mod 2^{k_i+1}

            because: x+i = x+i = A_i * 2^{k_i+1} + (2^{k_i}-1)
            -> x = A_i * 2^{k_i+1} + (2^{k_i}-1) - i.

          Therefore, 
            x ≡ (2^{k_i}-1) - i   (mod 2^{k_i+1})

          Additionally, for a non-carry index i, we have the last bit of x+i is 0, so:
             x+i is even -> x ≡ -i (mod 2)

          But note: a non-carry index i has a_{i+1}=a_i+1. 

          However, the congruence from a carry is usually on a higher modulus.

          Example: first sample: carries at i=0 and i=2.
            i=0: k0=1 -> modulus=2^(1+1)=4.
                 x ≡ (2^1-1) - 0 = 1 (mod 4)
            i=2: k2=4 -> modulus=2^(4+1)=32.
                 x ≡ (2^4-1) - 2 = 15-2=13 (mod 32)

          Then x=13 satisfies both: 13 mod 4 = 1, and 13 mod 32=13.

          The next non-carry indices: 
            i=1: then x+1 must be even -> 13+1=14, even: yes.
            i=3: then x+3 must be even? But i=3: we do have a carry at i=2, and then the next element is non-carry? Actually, after a carry at i=2, we have the next element i=3 is not a carry? 
                   But the next element after a carry is forced to be a non-carry (because the last bit of x+2+1 = x+3 is 0) -> then we have a non-carry at i=3: 
                   a_{4}=a_{3}+1? -> 2=1+1 -> yes. 
                   And the condition: x+3 must be even? 13+3=16, which is even.

          Therefore, the system of congruences is:

            For each carry at index i: 
               x ≡ (2^{k_i} - 1) - i   (mod 2^{k_i+1})

            For each non-carry index i (where a_{i+1}=a_i+1) and also where there is no carry (so we haven't set a congruence that forces the last bit? But the carry congruence might have set the last bit) -> we don't need an extra congruence? 

          But the congruence from a carry already implies the parity condition: 
            For a non-carry index i: we require x+i even.
            For a carry congruence at i: it sets x+i mod 2^{k_i+1}. In particular, it sets the last bit of x+i: 
               x+i = ... (last k_i+1 bits: 0 followed by k_i ones) -> the last bit is 1? 
               But then for a carry, the last bit is 1 -> so x+i is odd. 
               Then for the next index i+1: we have x+i+1 = (x+i)+1, which is even. And we know that at index i+1 we have a non-carry and the last bit must be 0 -> which it is.

          Therefore, the only additional constraints are the carry congruences.

          Then the problem reduces to: 
            Given a system of congruence equations:
               x ≡ c_i (mod m_i)
            for i in some set (the carries), where m_i = 2^{k_i+1} and c_i = (2^{k_i}-1) - i, 
            find the smallest non-negative x that satisfies all.

          But note: the moduli m_i are powers of two. Therefore, the system has a solution if and only if the congruences are pairwise consistent. And then the solution is the least common multiple of the moduli? Actually, the least common multiple of powers of two is the maximum power. But we can combine them: 

            Since the moduli are not necessarily coprime, but they are powers of two, we can merge two congruences:

               x ≡ a (mod 2^p)
               x ≡ b (mod 2^q)

            Without loss of generality, assume p>=q.
            Then the second congruence is weaker: because if x≡a (mod 2^p), then x mod 2^q = a mod 2^q.
            Therefore, we require a mod 2^q = b.

            If this holds, then the first congruence implies the second.

          Therefore, we can merge the congruences by taking the highest modulus and then checking consistency with the lower ones.

          Steps for combining:

            Let M = the maximum modulus among the congruences. Let the congruence for that modulus be x ≡ c (mod M).

            Then for every other congruence with modulus m (a power of two) and constant d, we require:
                c ≡ d (mod m)

            If not, there is no solution.

          But note: there might be multiple congruences with the same modulus? Then they must have the same residue.

          Also, there might be no carry? Then we have no congruence -> x can be any number. But then we have to find the smallest x that satisfies the popcount sequence. 

          However, even without a carry, we have the non-carry conditions? But they only give the last bit at each non-carry index? 

          Actually, without any carry, the entire sequence has no drop in popcount. Then the differences are all 1? 
            a_{i+1} = a_i+1 for all i.
          Then the last bit of every x+i must be 0? -> so every number in the consecutive sequence is even? -> impossible unless the sequence has only one number.

          Actually, let's see: 
            i=0: last bit of x must be 0.
            i=1: last bit of x+1 must be 0? -> x+1 is even -> x is odd. 
            Contradiction.

          Therefore, a sequence of length>=2 cannot have all differences=1.

          In fact, for a sequence of length>=2, there must be at least one carry.

          Also, for a sequence of length 1, there is no difference, so no carry condition. Then we only have to find the smallest x such that p(x)=a0.

          How to do that? 
            We can simply iterate over the numbers with popcount a0 in increasing order? But a0<=60, so we can generate the smallest number with popcount a0: which is (2^{a0}-1). But is that the smallest? 
            However, consider: the smallest non-negative integer with popcount a0 is indeed (2^{a0}-1) if a0>=1, and 0 if a0=0.

          But what if a0=0? then x=0.

          So for a sequence of length 1: 
             x = (2^{a0} - 1) if a0>=1, and 0 if a0=0.

          However, wait: 
             p(0)=0 -> so if a0=0, then x=0.
             a0=1: then x=1? p(1)=1 -> yes, and 1 is the smallest.
             a0=2: then x=3? p(3)=2 -> but 3 is not the smallest: 2 has p(2)=1, 3 has 2, but 1 has 1, then 2 is 10 -> popcount=1, 3=11->popcount=2. But is there a number between 0 and 3 with popcount 2? No.

          However, what if a0=3? 
             The smallest is 7? But 3: 11 -> popcount=2, 4:100->1, 5:101->2, 6:110->2, 7:111->3. 
             So 7 is the smallest.

          Therefore, the smallest number with popcount a0 is (2^{a0}-1) if a0>=1, and 0 if a0=0. But note: a0=0: 2^0-1=0, so we can write: 
              x0 = (1 << a0) - 1   if a0>=1, and 0 if a0=0? Actually, 0 is (1<<0)-1=0.

          So x0 = (1LL<<a0)-1.

          But is that the smallest? 
             For a0=1: (1<<1)-1 = 1 -> correct.
             For a0=2: 3 -> correct.

          However, what if a0=0? then (1<<0)=1, then 1-1=0 -> correct.

          Therefore, for a sequence of length 1, we have x = (1LL<<a0)-1.

          Now, for a sequence with at least one carry, we have a system of congruences. 

          Steps for the general test case:

            Step 1: 
              For i=0 to n-2:
                 if a_{i+1} > a_i+1: then output -1.  [because the difference must be <=1]
                 if a_{i+1} = a_i+1: then we record that at index i, we have a non-carry. (But we don't get a congruence, but we will use the carry congruences that we do get to check the evenness at this index? -> but we don't need an explicit congruence for non-carry)
                 if a_{i+1} <= a_i: then 
                    k_i = a_i+1 - a_{i+1}   (must be at least 1, which it is)
                    and then if i < n-2, we require a_{i+2} = a_{i+1}+1. If not, output -1.

            Step 2: 
              Collect all carries (index i). For each carry i, we get a congruence:
                 m_i = 2^{k_i+1}
                 c_i = (2^{k_i} - 1) - i

            Step 3: 
              If there is no carry and n==1, then use x = (1<<a0)-1.

              If there is no carry and n>=2, then we have a problem: because we must have at least one carry for n>=2? Actually, we argued that a sequence of consecutive numbers of length>=2 must have at least one drop? But wait: it might not have a drop? 
                 Example: [0,1] for n=2: 
                    a0=0, a1=1: difference=1 -> non-carry. 
                 Then we have two non-carries? 
                    At i=0: non-carry -> last bit of x must be 0.
                    At i=1: we don't have a next element? But wait, we only have one difference (i=0). And for the next element? we don't care. 
                 But then for i=0: x must be even.
                 For i=1: we have no constraint? 
                 However, the popcount of x+1 must be 1. The smallest x that is even and such that p(x)=0 and p(x+1)=1: 
                    x=0: p(0)=0, p(1)=1 -> works.

                 So we don't require a carry for n=2? 

              How about [1,2] for n=2: 
                 a0=1, a1=2: difference=1 -> non-carry at i=0.
                 Then x must be even? and p(x)=1, p(x+1)=2.
                 x=2: p(2)=1, p(3)=2 -> works. 

              And [2,3] for n=2: 
                 x= even, p(x)=2, p(x+1)=3.
                 x=4: p(4)=1 -> not 2.
                 x= next: 5: 101 -> p=2, then 110 -> p=2 -> not 3.
                 x=6: 110->2, 111->3 -> works.

              Therefore, we can have sequences of length>=2 without any carry.

              When do we get a carry? When the difference is not 1? Actually, we get a carry when the difference is <= the current value. 

              The necessary conditions we checked in step1 do not force any carry to exist. They only require that if there is a drop (a_{i+1}<=a_i) then the next element must be a_{i+1}+1 (if exists).

              But we can have a test case with no drop? Then no carry.

              How to handle no carry? 

                In this case, we have no congruence from a carry. But we have constraints: at every index i from 0 to n-2, we have a_{i+1}=a_i+1. 

                Then at index i, we have the last bit of x+i must be 0. 
                   -> x+i is even.

                This gives: 
                   x ≡ -i (mod 2)   for every i from 0 to n-2.

                But note: if n>=2, then we have at least two congruences: 
                   i=0: x ≡ 0 (mod 2)  [because -0 mod2=0]
                   i=1: x+1 ≡ 0 (mod2) -> x ≡ 1 (mod2) -> contradiction.

                Therefore, it is impossible to have a sequence of consecutive numbers of length n>=2 such that the popcount increases by 1 at every step.

                Why? 
                   The first number x must be even (from i=0) and the second number x+1 must be even (from i=1) -> but x+1 is odd if x is even.

                Therefore, the condition for a non-carry at i=0 requires x even, and at i=1 requires x+1 even -> which means x must be odd. Contradiction.

                So we must have n==1? 

                Actually, the constraint applies only for i from 0 to n-2. For a sequence of length 2: 
                   i0: from 0 to 0: so only one constraint: x must be even.

                And there is no constraint for i=1? 

                But wait: we have only one difference: i=0. Then we only get one congruence: x ≡ 0 (mod2).

                And then we don't have a constraint for the last number? 

                How about a sequence of length 2: 
                   Condition: 
                     a0 and a1, and a1 = a0+1.
                     and the only constraint is at i=0: the last bit of x must be 0.

                Then we wish to find the smallest even x such that p(x)=a0 and p(x+1)=a0+1.

                This is possible: 
                   a0=0: then x=0: p(0)=0, p(1)=1 -> works.
                   a0=1: then x= even and p(x)=1: the smallest even x with popcount 1: 2 (binary 10) -> p(2)=1, p(3)=2 -> works.
                   a0=2: then x= even and popcount 2: smallest? 6 (110) -> p(6)=2, p(7)=3 -> works? but 5 is 101 (popcount=2) and is odd -> so 6 is the smallest.

                So formula: 
                   We want the smallest even x such that p(x)=a0 and p(x+1)=a0+1.

                How to compute this? 
                   We iterate over the possible even x? But a0<=60, so x might be large.

                Note: x must be even. Then x+1 is odd. 
                   p(x) = a0, p(x+1)=a0+1.

                How does x and x+1 relate? 
                   Since x is even, the last bit is 0. Then x+1: flip the last bit to 1 -> so the popcount increases by 1. 

                Therefore, we only require that p(x)=a0. Then p(x+1)=a0+1 automatically.

                So we simply need the smallest even x with popcount a0.

                How to find the smallest even x with popcount a0? 
                   If a0==0: then x=0.
                   If a0>=1: 
                      The smallest even number with popcount a0: 
                         We cannot use the number (1<<a0)-1 because that is odd (if a0>=1: the last bit is 1). 
                         We want the last bit to be 0. 
                         The number: we want to distribute a0 ones in the bits. The last bit must be 0. Then the number must be at least (1<<a0) (but that has popcount 1). 

                   Consider: 
                      a0=1: then the even numbers with popcount 1: 2, 4, 8, ... -> smallest is 2.
                      a0=2: then even numbers: 6 (110), 10 (1010), 12 (1100), ... -> smallest is 6? But 6 = 110 -> popcount=2, and even.

                   How to form the smallest even number with popcount a0? 
                      We cannot put the ones arbitrarily. To be even, the last bit is 0. Then the ones must be in the higher bits. 
                      The smallest such number: 
                         We set the lowest a0-1 bits to ones and then the next bit to 1 and the last bit to 0? 
                         But note: we want the smallest. 
                         Actually, we can use: 
                            x = (1<< (a0)) | ...? 

                   Example: a0=2: 
                         We want two ones. The number: 110 (binary) = 6, or 1010 (binary)=10 -> 6 is smaller.

                   How about: 
                         Start with the number that has a0-1 ones at the lowest bits and then put a 1 at the a0-th bit? 
                         But then we get: 1<<(a0) has one one, then we need a0-1 ones: we put them in the low bits? 
                         But then the number is: 
                            (1<<a0) | ((1<<(a0-1))-1)   [if we put the a0-1 ones in the low a0-1 bits] 
                         But note: the low a0-1 bits are ones, then the bit at position a0-1 is 1 and the bit at position a0 is 1, and the last bit (bit0) is 1? -> not even.

                   Alternatively, we can put the ones in a block: 
                      The number: ( (1<<a0) - 1 ) << 1   -> then it is even, and popcount = a0.
                         But is that the smallest? 
                         For a0=1: (1<<1) - 1 = 1, then <<1 -> 2 -> works.
                         For a0=2: 3<<1 = 6 -> works.
                         For a0=3: 7<<1=14 -> is 14 the smallest? 
                                14: 1110 -> popcount=3, even.
                                Next candidate: 11 in binary: 1011? -> not even. 13: 1101 -> odd. 10: 1010 -> popcount=2 -> not 3. 12: 1100 -> popcount=2. 14 is the smallest.

                   Therefore, the smallest even number with popcount a0 is ( (1<<a0) - 1 ) << 1 = (2^{a0+1} - 2).

                But note: if a0=0, then (2^1-2)=0 -> works.

                Therefore, for a sequence of length n>=2 with no carry (which means the entire sequence has increasing popcount by 1 at every step), we require:
                   x = (1<< (a0+1) - 2.

                However, wait: the sequence has more than one element. We require not only p(x)=a0 and p(x+1)=a0+1, but also p(x+2)=a0+2, etc.

                But we argued that for n>=2 it is impossible to have a sequence of consecutive numbers of length n such that the popcount increases by 1 at every step? 

                Why? 
                   We have a0, a1 = a0+1, a2 = a0+2, ... 
                   Then at index i: we require x+i to be even? -> because the difference is 1 (non-carry) so the last bit of x+i must be 0.

                   Then x must be even, x+1 must be even -> impossible.

                Therefore, if the sequence has length n>=2 and has no carry, then it must be that the entire sequence has the property that the popcount increases by 1 at every step? But we just proved that is impossible for n>=2.

                However, note: our sample [0,1] for n=2 works: 
                   x=0: even, then x+1=1: odd -> and the last bit of x+1 is 1, which is not 0. 

                What's the catch? 

                  The condition for a non-carry at index i: 
                    We only require that the last bit of x+i is 0 if the difference is 1? Actually, no: 

                  The condition for a non-carry is: 
                    if a_{i+1} = a_i+1, then the last bit of x+i must be 0.

                  In the sample [0,1]:
                    i=0: a0=0, a1=1 -> difference=1 -> non-carry -> so we require the last bit of x+0 = x to be 0 -> x is even.

                  We do not have a constraint for the last bit of x+1? 

                Therefore, for a sequence of length n, we only have constraints for the last bit of x+i for i in [0, n-2] (because the difference a_i to a_{i+1} is defined for i in [0, n-2]).

                In the sample [0,1] (n=2): 
                   Only constraint: at i=0: x must be even.

                And we are not requiring anything for i=1.

                Then x=0 works.

                How about [1,2] for n=2:
                   Constraint: at i=0: x must be even.
                   Then we find the smallest even x with p(x)=1 -> x=2.

                Then the sequence: 
                   x=2: p(2)=1, p(3)=2 -> works.

                How about a sequence of length 3: [0,1,2]?
                   Constraints: 
                     i=0: x must be even.
                     i=1: a2 = a1+1 -> so we require the last bit of x+1 to be 0.

                   Then we have:
                     x even -> last bit 0.
                     x+1: last bit 1 -> but we require it to be 0? -> contradiction.

                Therefore, for a sequence of length 3 with no carry, it is impossible.

                In general, the constraints are:
                   For i=0: x ≡ 0 (mod2)
                   For i=1: x+1 ≡ 0 (mod2)  => x ≡ 1 (mod2)   -> contradiction.

                So we only have one constraint for n=2, but for n>=3 we have at least two constraints: i=0 and i=1, which conflict.

                Therefore, a sequence of length n>=3 cannot have no carry? 

                But wait: what if there is a carry somewhere? 

                In our system, if there is no carry in the entire sequence, then we have the constraints:
                   For i=0 to n-2: x+i is even.

                This is possible only if n-1<=1? i.e., n<=2.

                So for n>=3 and no carry, it is impossible.

                Therefore, we can summarize:

                  Step 1: Check the immediate necessary conditions (differences and the forced next element after a carry). If fails, output -1.

                  Step 2: 
                     If n==1: 
                         x = (1<<a0)-1.

                     If n>=2 and there is no carry in the entire sequence (i.e., we never have a drop: a_{i+1}<=a_i for any i in [0, n-2]? Actually, we might have a drop and then the next element is not there? But if we have a drop, we have a carry -> so if there is no carry, then there is no drop) -> then we require that the entire sequence has a_{i+1}=a_i+1 for every i in [0, n-2]. 

                         - If n==2: then we output the smallest even x with popcount a0: which is (1<<(a0+1))-2. But note: we also require that p(x+1)=a0+1, which is automatically satisfied if p(x)=a0 and x is even? 
                         - If n>=3: then we require at least two constraints: 
                               x is even, and x+1 is even -> impossible, so output -1.

                  Step 3: If there is at least one carry (for any i in [0, n-2]), then 
                     Collect the congruences: 
                         For each carry at i: 
                            k_i = a_i+1 - a_{i+1}
                            m_i = 2^{k_i+1}
                            c_i = (2^{k_i}-1) - i

                     Then we wish to find the smallest non-negative x that satisfies:
                         x ≡ c_i (mod m_i) for every carry i.

                     How to do that? 
                         Since the moduli are powers of two, we can take the maximum modulus M = max_i (m_i). Then the solution, if it exists, is unique modulo M? 

                         But note: there might be multiple congruences. We require that for every carry i: 
                             c_i mod gcd(m_i, m_j) = c_j mod gcd(m_i, m_j)   for every j? 

                         However, since both m_i and m_j are powers of two, the gcd is 2^{min(k_i+1, k_j+1)}. And we require that c_i ≡ c_j (mod 2^{min(k_i+1, k_j+1)}).

                     Algorithm: 
                         Let M = 1, and X = 0.   (initial modulus and residue)
                         For each congruence (c_i, m_i) in increasing order of m_i (or any order) [but note: we want to use the strongest congruence?] 
                            We can also do in decreasing order of m_i.

                         Alternatively: 
                            Let M = 1, X = 0.
                            For each congruence (c, m) in the set: 
                                We require that X ≡ c (mod gcd(M, m)). 
                                If not, there is no solution.
                                Then we update to a solution for the system { X0 ≡ X (mod M), X0 ≡ c (mod m) }.

                         But since M and m are powers of two, we can do:

                            Let L = max(M, m). But we can let L = lcm(M, m) = max(M, m) if one is a multiple of the other? 

                         However, we can simply take the congruence with the largest modulus as the master, and then check all others against it.

                     Steps: 
                         Find the congruence with the largest modulus (i.e., the largest m_i). Let that modulus be M, and the residue be C. 
                         For every other congruence (c_i, m_i): 
                             If C mod m_i != c_i, then there is no solution.

                         Then the solution is the smallest non-negative x such that x ≡ C (mod M) and x >= some lower bound? 

                         But is that all? 
                             We also have to ensure that the popcount of x+i = a_i for all i? 
                         However, we have already ensured the necessary conditions and the congruences from the carries. 
                         But is it sufficient? 

                         We must also ensure that the popcount of x+i equals a_i. The congruences only ensure the trailing ones and the positions of the carries. The popcount in the higher bits is not fixed? 

                         How to ensure the popcount? 
                             For a carry at i, we have:
                                 x+i = A * 2^{k_i+1} + (2^{k_i}-1)
                                 and we require p(x+i)=a_i = p(A) + k_i.
                                 => p(A) = a_i - k_i.

                             But A is x_hi (the higher bits) and we don't have a direct constraint on A other than that it is nonnegative. 

                         Therefore, we must choose the smallest x that is at least ...? and that has the property that for every carry at i, the higher bits A_i = (x+i - (2^{k_i}-1)) / (2^{k_i+1}) has popcount = a_i - k_i.

                         But note: the smallest x might not be the one with A=0? 

                         Example: the first sample: 
                            Carries: i=0: k0=1, then x = 1 (mod4), and also A = (x+0 - (2^1-1)) / 4 = (x-1)/4, and we require p(A)= a0 - k0 = 3-1=2.
                            The smallest x that is 1 mod4 and for which p((x-1)/4)=2: 
                                x=1: (1-1)/4=0 -> p(0)=0 -> not 2.
                                x=5: (5-1)/4=1 -> p(1)=1 -> not 2.
                                x=9: (9-1)/4=2 -> p(2)=1 -> not 2.
                                x=13: (13-1)/4=3 -> p(3)=2 -> works.

                         Therefore, we must find the smallest x that is ≡ C (mod M) and such that for every carry i, the value 
                                 A_i = (x+i - (2^{k_i}-1)) / (2^{k_i+1}) 
                         has popcount = a_i - k_i.

                         But a_i - k_i = a_{i+1} - 1, and we know a_{i+1} is given, so it's a fixed number.

                         Also, note: the same x must satisfy for every carry i.

                         How to do that? 
                             Since the moduli M might be very large (like 2^62), and x might be astronomical, we cannot iterate.

                         Insight: 
                             The value A_i is the higher bits of x+i. As x increases by M, A_i increases by M / (2^{k_i+1})? 
                             But we require that A_i has a fixed popcount, say b_i = a_i - k_i.

                             The smallest non-negative A_i with popcount b_i is (1<<b_i)-1.

                             Therefore, the smallest x that works for carry i is: 
                                 x = A_i * (2^{k_i+1}) + (2^{k_i}-1) - i, with A_i = (1<<b_i)-1.

                             Then we wish to find the smallest x that is ≡ C (mod M) and that is at least as large as the maximum over the minimal x for each carry.

                         But note: the congruences might already force a candidate residue. Then we can try: 
                                 x0 = C, then C + k*M for k=0,1,2,...

                         But M might be large (like 2^60) and the minimal A_i might be about 2^{b_i} which is 2^60, so x0 might be of the order of 2^{60} * 2^{61} which is 2^121 -> too big.

                         Alternatively, we can minimize x over the carries independently and then take the maximum of these minima, and then find the smallest x that is at least that maximum and satisfies the congruence mod M.

                         However, it is not independent: the same x must work for all carries.

                         Therefore, we must find the smallest solution to the congruence that is at least as large as the minimal x required by any carry.

                         Let L = max_i { (1<<b_i)-1) * (2^{k_i+1}) + (2^{k_i}-1) - i }.

                         Then we wish to find the smallest x>=L that satisfies x≡C (mod M).

                         This can be done by: 
                             x = C + M * ceil((L - C) / M)

                         But careful: 
                             If C>=L, then x=C.
                             Else, x = C + M * ceil((L-C)/M) = C + M * floor((L-C-1)/M) + M? 

                         Actually, we can compute: 
                             x = C + M * max(0, ( (L - C + M - 1) / M )   [integer division]

                         However, note: the minimal solution is: 
                             x = C + M * k, where k is the smallest integer such that C+M*k>=L.

                         So k = ceil( (L - C) / M ) if L>C, and k=0 if C>=L.

                         But note: (L-C) might be negative, then k=0.

                         Therefore, 
                             x = C + M * max(0, ceil((L-C)/M))

                         But (L-C) might be negative -> then x=C.

                         However, we want the smallest non-negative solution.

          But is this x guaranteed to satisfy the popcount at every non-carry index? 
             We have ensured the necessary conditions and the conditions at the carries. For the non-carry indices, we have not done anything. 
             However, we have the necessary conditions that after a carry the next element is forced to have popcount a_{i+1}+1, and we also have the congruence for the next element's evenness? 

          Actually, the conditions at the non-carry indices are only the evenness of x+i at the time, and that is ensured by the carry constraints? 

          In summary, the solution for a test case with at least one carry is:

            Step 1: Check the differences: for every i, a_{i+1} is either a_i+1 or <=a_i (and then the next element if exists must be a_i+1).

            Step 2: Collect all carries (i where a_{i+1}<=a_i). For each such i, set:
                     k_i = a_i+1 - a_{i+1}
                     m_i = 2^(k_i+1)
                     c_i = (2^k_i - 1) - i

            Step 3: If there is no carry and n>=3, output -1. 
                     If there is no carry and n==1, output (1<<a0)-1.
                     If there is no carry and n==2, output (1<<(a0+1))-2.

            Step 4: For the carry case: 
                     (a) Find the congruence with the largest modulus. Let M = that modulus, and C = the residue for that congruence.
                     (b) Check every other carry congruence: if C mod m_i != c_i, then output -1.
                     (c) For each carry i: 
                             b_i = a_i - k_i   [must be nonnegative? and we know it is because a_i>=k_i? Actually, from the definition: k_i = a_i+1 - a_{i+1}, and a_{i+1}<=a_i, so k_i>=1, and then b_i = a_i - k_i = a_{i+1}-1, and a_{i+1}>=0, so b_i>=-1. But a_{i+1}>=1? because if a_{i+1}=0, then b_i=-1 -> popcount cannot be negative. 

                         Actually, if a_{i+1}=0, then k_i = a_i+1 -0 = a_i+1, and then b_i = a_i - (a_i+1) = -1 -> not possible.

                         Therefore, we must check: for a carry at i, we require a_{i+1}>=1, so that b_i = a_{i+1}-1>=0.

                         And also, a_i - k_i = a_{i+1}-1, which is nonnegative -> so a_{i+1}>=1.

                     (d) For each carry i, let 
                             L_i = ( (1<<b_i) - 1 ) * (1<< (k_i+1)) + ( (1<<k_i) - 1 ) - i
                         Then L = max_i L_i.

                     (e) Let x0 = the smallest number >= L that is ≡ C (mod M). 
                         This is: 
                            if C >= L: 
                                x = C
                            else:
                                k = ceil((L-C)/M)   = floor((L-C-1)/M) + 1   [if (L-C) is not divisible by M, then ceil((L-C)/M) = (L-C + M - 1) // M]
                                x = C + k * M

            Step 5: We must also verify that for every non-carry index i (which we haven't used in the congruences) the last bit of x+i is 0? 
                     But we haven't done that. How to verify? 
                     The congruence from a carry might have fixed the last bits. In particular, we already have that for every carry i, we know the last k_i+1 bits of x+i, and they include that the last bit is 1. 
                     And for a non-carry index i, we require that the last bit is 0.

                     But how do we know the last bit of x+i for an index i that is not covered by a carry? 
                         We don't. 

                     However, note: 
                         We have the necessary conditions on the entire sequence. Specifically, the difference conditions and the next element after a carry. 
                         But we have not enforced the evenness of x+i at non-carry indices.

            How to enforce? 
                For a non-carry index i (which means a_{i+1}=a_i+1), we require that the last bit of x+i is 0. 
                But we have the entire x, so we can compute (x+i) & 1. 
                However, we are constructing x as the solution to the congruence. 

            But note: 
                In our system of congruences from the carries, we have already fixed the value of x mod (a modulus that is at least 2). 
                For a non-carry index i, we require: 
                     (x+i) is even.

                But this is a linear constraint: x+i ≡ 0 (mod 2)  -> x ≡ -i (mod 2).

                And we have a congruence from a carry that sets x mod (2^p) for p>=1, which includes the parity. 

                Therefore, the parity of x is fixed by the carry congruences. 

                And we must check that for every non-carry index i, the congruence we have satisfies x ≡ -i (mod 2).

                But wait: the congruence we have for x is modulo M (a power of two, at least 2). So we know x mod 2.

                Therefore, we can check: 
                   For every non-carry index i: 
                         if (x+i) is even? -> but we don't have x, but we know x mod 2. 
                         We know x mod 2 = C mod 2 (since M is even, at least 2). 
                         Then we can compute: (C+i) mod 2 must be 0.

                But note: 
                   x ≡ C (mod M) and M>=2, so x mod 2 = C mod 2.

                Therefore, we require: (C+i) mod 2 = 0.

                If this fails for any non-carry index i, then we output -1? 

                Or is there a larger solution? 

                But the next solution is x+M, and M is even? -> so x and x+M have the same parity. 
                   Then (x+M+i) mod 2 = (x+i) mod 2? 
                   But we require (x+i) mod2=0. And if (C+i) mod2 !=0, then (x+i) mod2 !=0. 

                Therefore, we must check before step (d) that for every non-carry index i: 
                         (C+i) is even.

                But note: a non-carry index i might appear in the middle. 

            Therefore, we add:

                Step 4.5: 
                   For every non-carry index i (i.e., where a_{i+1}=a_i+1) in the entire range [0, n-2]:
                         if (C+i) % 2 != 0, then output -1.

            But note: if there is a carry at index i, then we already know that the last bit of x+i is 1, so (x+i) is odd, and then (C+i) mod2 = (x+i) mod2 = 1, and we are not requiring it to be 0? 
                   We only require non-carry indices to be even.

            Therefore, we only check the non-carry indices.

          Finally, we also haven't verified the popcount for non-carry indices? 
                We only know the last bit is 0, and then p(x+i+1)=p(x+i)+1. 
                But we haven't checked the actual popcounts.

          However, we have ensured the conditions at the carries, and for the non-carry indices we have the last bit 0, and then the next number has popcount increased by 1. But the entire popcount might not be a_i? 

          For a non-carry index i, we have a_{i}=p(x+i) and a_{i+1}=p(x+i+1)=a_i+1. 
          How can we be sure that the popcount of x+i is a_i? 

          We have not constrained the higher bits for the non-carry indices. 

          But note: 
             The popcount of x+i = popcount of the higher bits (which is the same as in the carry constraints) plus the popcount of the lower bits that we have fixed? 

          Actually, the entire x is fixed by the congruence and the minimal condition from the carries. 

          And we have also constrained the popcount at the carry indices. 

          But the non-carry indices fall between carries? 

          How about we simply compute the popcount of x+i for i in the entire sequence? 
             But x might be huge (like 2^60), and n up to 500000, so we cannot compute the popcount of 500000 huge numbers.

          Therefore, we must trust the necessary conditions and the minimal representation. 

          However, note: 
             In the non-carry index i, we have the last bit of x+i is 0 (by the constraint we checked: the evenness) and then x+i+1 is x+i+1, which flips the last bit to 1 and might cause a carry? But we have no constraint on the higher bits. 

          How do we know that the popcount increases by exactly 1? 

             The only change is the last bit: from 0 to 1. Therefore, the popcount increases by 1. 
             So p(x+i+1) = p(x+i)+1.

          Therefore, if we know p(x+i)=a_i, then p(x+i+1)=a_i+1, which is a_{i+1}. 

          And the starting value: 
             The first number: x. We have the constraint at the first carry that fixes the popcount of the higher bits and the lower bits. 

          But what if the sequence has a non-carry at the beginning? 
             Then we don't have a carry at i=0, so we haven't fixed the popcount of x. 

          However, we have the condition for the entire sequence: 
             The first element: a0 = p(x). 

          But in the non-carry case for n>=2, we only have the evenness of x. 

          In the carry case, we have a carry that might cover i=0? 

          Therefore, to ensure the popcount at every index, we have only constrained the popcount at the carry indices. 

          But the non-carry indices are then forced: 
             a0 = p(x) is not constrained by any carry? 
             Then we must also ensure that p(x)=a0.

          How to ensure that? 
             We have the same issue as in the carry: we need to set the higher bits to have the right popcount.

          But in our minimal solution, we only set the higher bits to the minimal value that satisfies the popcount at the carry indices. We did not consider the non-carry indices.

          Therefore, we must also ensure that for every index i that is not covered by a carry constraint, the popcount of x+i is a_i.

          However, for a non-carry index i, we have:
              p(x+i+1) = p(x+i)+1.

          And if we know the popcount at one of the carries, we can propagate? 

          But the sequence might start with a non-carry and then have a carry later. 

          Example: [3,4,1,2] from the first sample? 
              The first sample: 
                  5
                  3,3,4,1,2
              We have carries at i=0 and i=2.

          How about an index i=1: non-carry. 
             We require p(x+1)=3? 
             But we have not constrained it.

          But we have the entire x, so we can compute the popcount of the lower bits and then we know the higher bits? 

          Actually, we fixed x by the congruence mod M. And then we fixed the higher bits A for the carries to be the minimal ones. But the popcount of x+1 might not be 3? 

          However, in the first sample, we computed x=13 and it works.

          How did it work? 
             We had a carry at i=0: 
                  x = 13: 
                  x+0 = 13: ...1101 -> 
                     We break the last 1? -> but k0=1: we require the last 1 bit to be ones and then the next bit 0? 
                     The last bit is 1 -> one trailing one? -> so the representation: ...0 1? 
                     But 13 in binary: 1101 -> the last bit is 1, and the next bit is 0? -> no, the next bit is 0? Actually: 
                        13: 8+4+1 -> 1101 -> the last bit is 1, the next is 0 (from the right: bit0=1, bit1=0, bit2=1, bit3=1). 
                     So the trailing ones count is 1 -> matches k0=1.

                     Then the higher bits: (13 - (2^1-1)) / 4 = (13-1)/4 = 12/4=3 -> which is 11 in binary -> popcount=2, and 2 = a0 - k0 = 3-1=2 -> works.

             Then x+1=14: 1110 -> popcount=3 -> matches a1=3.

          How did we get a1=3? 
             We didn't impose it explicitly, but it was forced by the carry at i=0 and the next condition? 

          In fact: 
             From the carry at i=0: 
                  x+1 = (A * 4) + 3? -> no: 
                  x+0 = 4A+1, then x+1 = 4A+2? 
                  But 4A+2: 
                     A=3: 4*3+2=14 -> popcount=3.

          And the next number: x+2=15: 1111 -> popcount=4 -> a2=4.

          Then a carry at i=2: 
                  k2 = a2+1 - a3 = 4+1-1=4.
                  Then x+2 = 15 = B * 32 + 15? -> then B=0, but 15<32 -> then 15 = 0*32+15 -> then popcount of B=0, and a2 - k2 = 4-4=0 -> works.

          Therefore, the popcount at the non-carry indices is forced by the representation and the carry constraints.

          But is that always true? 

          Consider a non-carry index i: 
             We have a_{i} = p(x+i) and a_{i+1}=a_i+1.
             And we know the last bit of x+i is 0. Then x+i is even, and x+i+1 = x+i+1, which is the next integer. 
             Then the popcount of x+i+1 = p(x+i) + 1 = a_i+1 = a_{i+1}. 

          Therefore, if the first element is fixed to a0 by a carry (or if the sequence starts with a non-carry, then we haven't fixed the first element by a carry, but we have fixed it by the evenness and then the next carry will fix it? or the entire sequence has no carry?).

          But note: the first element might be covered by a carry? 

          If the first element is not covered by a carry, then we have no constraint on the popcount of the first element. 

          How can we ensure it? 

          In the case with no carry at i=0, we are not in the carry branch. 
             - If n==1, we fix x to the smallest number with popcount a0.
             - If n==2, we fix x to the smallest even number with popcount a0.

          But in the case with a carry at i=0, we fix the higher bits to have popcount a0 - k0.

          What if there is a non-carry at the beginning and then a carry later? 
             Example: [3,4,2] (which might be invalid because after a carry we require the next element to be the carry's a_{i+1}+1, but here after the drop at i=1: a2=2, and then we require a3= a2+1=3, but we don't have a3).

          The sample: [3,4,2] for n=3: 
             i0: a0=3, a1=4 -> difference=1 -> non-carry.
             i1: a1=4, a2=2 -> difference=-2 -> carry: k1=4+1-2=3.
                 and then since i1=1 < n-1? (n-1=2, so i1=1, and next index i2=2 is the last) -> so we don't require a next element? 
                 But the necessary condition only requires the next element if i1+1<=n-1 -> i1+1=2<=n-1? n-1=2 -> so we require a3 = a2+1, but we don't have a3 -> invalid.

          Therefore, the necessary condition fails.

          So we never have a non-carry followed by a carry at the last difference? 

          In summary, the only open issue is the first element in a sequence that has a carry not at the beginning. 

          How about: [0,1,1] for n=3? 
             i0: a0=0, a1=1 -> difference=1 -> non-carry.
             i1: a1=1, a2=1 -> difference=0 -> carry: k1=1+1-1=1.
                 and then we require that if there was a next element, it would be 2, but there is none -> valid.

             Then we have a carry at i=1. 
                 Congruence: 
                    k1=1, m1=2^(1+1)=4, c1 = (2^1-1)-1 = 1-1=0.

                 Then we have x ≡ 0 (mod 4).

                 Then the minimal x for the carry at i=1: 
                    b1 = a1 - k1 = 1-1=0.
                    L1 = ( (1<<0)-1 ) * 4 + (2^1-1) - 1 = (0)*4 + (1) - 1 = 0.

                 Then x=0.

                 Then check: 
                    i0: x+0=0: p=0 -> matches a0=0.
                    i1: x+1=1: p=1 -> matches a1=1.
                    i2: x+2=2: p=1 -> matches a2=1.

                 But wait: at i1: we have a carry: 
                    x+1=1: binary 01 -> trailing ones count: last bit is 1, and the next bit is 0? -> k1=1 -> matches.
                 Then the next number: x+2: 10 -> popcount=1 -> matches.

                 However, the next element after a carry: we don't have one, so it's fine.

          Therefore, we must allow a carry at the last difference.

          But note: the necessary condition: 
             For a carry at i (which is the last difference, i=n-2), we do not require a next element. 

          And we do not require a next element's popcount.

          Therefore, our method works.

          But in the example [0,1,1], we had x=0. 

          However, let's check the non-carry index i0: 
             We require that x+0 is even? -> 0 is even -> works.

          And the non-carry condition for the evenness at i0: we require x+0 even -> 0 even -> works.

          But what if we had [1,2,2]? 
             a0=1, a1=2, a2=2.
             i0: difference=1 -> non-carry: require x even.
             i1: difference=0 -> carry: k1= a1+1 - a2 = 2+1-2=1.
                 congruence: x+1 ≡ 0 (mod4)  [c1 = (2^1-1)-1 = 0] -> x ≡ -1 (mod4) -> x ≡ 3 (mod4).
                 But from non-carry at i0: x even -> 3 mod4 is odd -> contradiction.

          Therefore, in step 4.5: we must check non-carry indices even if there is a carry later. 
             For i0: non-carry: we require x+0 even -> x even.
             But we have a carry at i1: which gives x≡3 (mod4) -> which is odd -> then we would detect the contradiction in step 4.5: 
                 For non-carry index i0: (C+i0) mod2 = (3+0) mod2 = 1, but we require 0 -> so we output -1.

          Therefore, the method is complete.

          Steps for a test case:

            n = ... 
            a = [a0, a1, ... a_{n-1}]

            // Step 1: Check the differences and the forced increase after a carry.
            for i in range(n-1):
                if a[i+1] > a[i] + 1:
                    return -1   (for this test case)

                if a[i+1] <= a[i]:
                    k = a[i] + 1 - a[i+1]
                    // k must be at least 1 (automatically because a[i+1]<=a[i])
                    if k < 1:  // not necessary, but if we do, then it's an error? 
                         return -1

                    if i+1 < n-1:  // there is an element at i+2
                         if a[i+2] != a[i+1] + 1:
                             return -1

            // Step 2: Check if there is at least one carry and the length to decide the branch.
            carries = []
            for i in range(n-1):
                if a[i+1] <= a[i]:
                    carries.append(i)

            if len(carries)==0:
                if n==1:
                    x = (1 << a[0]) - 1
                elif n==2:
                    x = (1 << (a[0]+1)) - 2
                else:  // n>=3
                    // as argued, it's impossible
                    x = -1
                // output x
            else:
                // collect congruences from carries
                congruences = []  // list of (modulus, residue)
                for i in carries:
                    k = a[i] + 1 - a[i+1]
                    // Check: a[i+1] must be >=1 (so that b = a[i+1]-1 is nonnegative)
                    if a[i+1] < 1:
                         return -1   // because b would be negative
                    modulus = 1 << (k+1)   // 2^(k+1)
                    residue = ((1 << k) - 1) - i   // (2^k - 1) - i
                    // reduce residue modulo modulus? 
                    residue = residue % modulus
                    if residue < 0:
                         residue += modulus
                    congruences.append( (modulus, residue) )

                // Now find the congruence with the largest modulus.
                // sort by modulus in descending order
                congruences.sort(key=lambda x: x[0], reverse=True)
                M, C = congruences[0]   // largest modulus and its residue

                // Check all other congruences
                for (m, c) in congruences[1:]:
                    if C % m != c:
                         return -1

                // Check non-carry indices for evenness: 
                //   For every i in [0, n-2] such that a[i+1] == a[i]+1, we require (C+i) % 2 == 0.
                for i in range(n-1):
                    if a[i+1] == a[i] + 1:
                         if (C+i) % 2 != 0:
                             return -1

                // For each carry, compute the minimal x for that carry and take the maximum L.
                L = 0
                for i in carries:
                    k = a[i] + 1 - a[i+1]
                    b = a[i] - k   // = a[i+1]-1
                    // minimal A = (1<<b)-1, but if b==0, then A=0.
                    A_val = (1 << b) - 1
                    if b==0:  // then A_val = 0
                        A_val = 0
                    // The representation: x+i = A_val * (2^(k+1)) + (2^k-1)
                    // so x = A_val * (2^(k+1)) + (2^k-1) - i
                    candidate = (A_val << (k+1)) + ((1<<k) - 1) - i
                    if candidate > L:
                         L = candidate

                // Now find the smallest x >= L such that x ≡ C (mod M)
                if C >= L:
                    x = C
                else:
                    // k0 = ceil((L-C)/M)
                    k0 = (L - C + M - 1) // M   # integer division, and note: if (L-C) is divisible by M, then (L-C+M-1)//M = (L-C)//M, because (L-C) is divisible by M, so (L-C+M-1) = M*t + (M-1) -> //M = t + (M-1)//M = t? no, integer division is floor. 
                    // Actually: 
                    //   k0 = ceil((L-C)/M) = (L-C + M - 1) // M
                    x = C + k0 * M

                // output x

          Let's test with the provided examples:

          Example 1: [3,3,4,1,2]  -> n=5
             carries: i0: 3,3 -> k0=3+1-3=1 -> modulus=4, residue=(2^1-1)-0=1-0=1.
                     i2: 4,1 -> k2=4+1-1=4 -> modulus=32, residue=(2^4-1)-2=15-2=13.

             Then we take the largest modulus: 32, residue=13.
             Check the other congruence: 13 mod 4 = 1 -> matches.

             Check non-carry indices: 
                i1: a1=3, a2=4 -> difference=1 -> non-carry: require (13+1) mod2=14 mod2=0 -> OK.
                i3: a3=1, a4=2 -> difference=1 -> non-carry: (13+3) mod2=16 mod2=0 -> OK.

             Then L: 
                i0: b0 = a0 - k0 = 3-1=2 -> A_val = (1<<2)-1=3, 
                     candidate = 3 * 4 + (2^1-1) - 0 = 12+1=13? 
                     But wait: 3 * 4 = 12, plus (2^1-1)=1 -> 13, then minus 0 -> 13.
                i2: b2 = a2 - k2 = 4-4=0 -> A_val= (1<<0)-1=0, 
                     candidate = 0 * 32 + (2^4-1) - 2 = 15 - 2 = 13.
                So L=13.

             Then x = 13 (since 13>=13 and 13 mod32=13) -> x=13.

          Example 2: [2,1,2] -> n=3
             carries: i0: 2,1 -> k0=2+1-1=2 -> modulus=8, residue=(2^2-1)-0=3.
                     i1: 1,2 -> not a carry? 
             But wait: a1=1, a2=2: difference=1 -> non-carry.

             Then only carry at i0.

             Check: 
                i0: carry: then i0+1=1<=n-1 (n-1=2) -> so we require a[2]=a[1]+1 -> a2=1+1=2 -> matches.

             Then congruences: only one: (m=8, c=3).

             Check non-carry indices: 
                i1: non-carry: a1=1, a2=2 -> difference=1: non-carry -> require (3+1) mod2=0 -> 4 mod2=0 -> OK.

             Then L: 
                i0: b0 = a0 - k0 = 2-2=0 -> A_val=0, 
                     candidate = 0*8 + (2^2-1) - 0 = 3.

             Then x: the smallest x>=3 and x≡3 (mod8) -> x=3.

          Example 3: [60,60] -> n=2
             carries: i0: a0=60, a1=60: k0=60+1-60=1 -> modulus=4, residue=(2^1-1)-0=1.
             non-carry indices: none? 
                Actually, n=2: only index i0: carry.

             Then L: 
                i0: b0=60-1=59, 
                     A_val = (1<<59)-1, 
                     candidate = ((1<<59)-1) * 4 + (2^1-1) - 0 = ( (1<<59)-1 )*4 + 1.

             We compute: 
                 (1<<59) is 2^59.
                 candidate = (2^59-1)*4+1 = 4*2^59 - 4 +1 = 2^61 - 3.

             Then x = the smallest number >= candidate that is ≡1 (mod4). 
                candidate = 2^61-3.
                2^61-3 mod4 = (0 - 3) mod4 = 1 mod4?  -> because 2^61 mod4=0, and -3 mod4=1? 
                So candidate is 1 mod4 -> x = candidate = 2^61-3.

             But the sample output is 2305843009213693949 = 2^61 - 3.

          Example 4: [8,0] -> n=2
             Step1: 
                 i0: a0=8, a1=0 -> difference = -8 -> which is <=8? yes.
                 then since i0=0 and n-1=1, we require that if there is an element at i0+2? no -> so we don't require a next element.

             Then carries: i0: k0=8+1-0=9 -> modulus=2^10=1024, residue=(2^9-1)-0=511.

             Then check: 
                non-carry indices: none.

             Then L: 
                b0=8-9=-1 -> we return -1 in the carry loop because a[i+1]=0<1.

          But note: we already check at the start of the carry loop: 
                if a[i+1] < 1: then return -1.

          So we return -1.

          Therefore, output -1.

          However, the sample output is -1.

          Therefore, the solution.

          Note: We must be cautious of the bit lengths: 
             k_i up to 60 -> then modulus = 2^(k_i+1) might be 2^61, which is around 2e18, which fits in a long long.

          But the minimal candidate L: 
             For a carry, we compute: 
                 candidate = ( (1<<b_i) - 1 ) * (1 << (k_i+1)) + ( (1<<k_i)-1 ) - i.

             Here, b_i = a_i - k_i, and a_i<=60, k_i>=1, so b_i<=59.

             Then (1<<b_i) is at most 2^59, which is around 5e17, then multiplied by (1<< (k_i+1)) which is at most 2^61 -> total 2^(59+61)=2^120, which is too big to compute.

          We must avoid computing this number.

          Alternative: 
             We can note that the minimal candidate for a carry at i is at least (1<< (k_i+1)) * ( (1<<b_i)-1 ) which is about 2^(b_i) * 2^(k_i+1) = 2^(a_i+1) (since b_i+k_i+1 = a_i+1).

          But a_i<=60, so 2^(a_i+1) is at most 2^61, which is representable in a long long.

          Why: 
             candidate = A * (2^{k_i+1}) + (2^{k_i}-1) - i 
                        = ( (1<<b_i)-1 ) * (1<< (k_i+1)) + (1<<k_i) - 1 - i.

          And ( (1<<b_i)-1 ) is at most (1<<b_i) = 2^{b_i}, and then multiplied by 2^{k_i+1} = 2^{b_i + k_i + 1} = 2^{ (a_i - k_i) + k_i + 1 } = 2^{a_i+1}.

          Therefore, candidate <= 2^{a_i+1} (approximately) and a_i<=60, so 2^61 is about 2e18, which is within 64-bit integers.

          But note: 
             ( (1<<b_i)-1 ) * (1<< (k_i+1)) might be (2^b_i - 1) * 2^{k_i+1} < 2^{b_i} * 2^{k_i+1} = 2^{a_i+1} (because b_i = a_i - k_i).

          So we can compute candidate as an integer if we use 64-bit integers? 
             2^61 is about 2.3e18, which is less than 1e19, so we can use unsigned long long or __int128 if necessary? 

          But the problem: 
             The sample [60,60]: candidate = (2^59-1)*4 + 1 = 2^61 - 4 + 1 = 2^61 - 3, which is about 2.3e18.

          And the next test: 
             [60,60,60] -> then we have two carries: 
                 i0: k0=1, b0=59 -> candidate0 = (2^59-1)*4 + 1 = 2^61-3.
                 i1: a1=60, a2=60: k1=1, b1=59 -> candidate1 = (2^59-1)*4 + (2^1-1) - 1 = (2^59-1)*4 + 1 - 1 = (2^59-1)*4 = 2^61-4.

                 Then L = max(2^61-3, 2^61-4) = 2^61-3.

             Then x = the smallest number >= 2^61-3 that is ≡ residue (mod modulus). The modulus in this case would be the maximum modulus: 
                 for i0: modulus=4, residue0 = (2^1-1)-0 = 1.
                 for i1: modulus=4, residue1 = (2^1-1)-1 = 0.
                 They are not the same: 1 and 0 mod4 -> not consistent? 

             So we would output -1.

          But is [60,60,60] possible? 
             We need x, x+1, x+2 with popcount 60.
             x = 2^61 - 3: 61-bit number: 111..11101 (popcount=60) 
             x+1 = 2^61-2: 111..11110 (popcount=60)
             x+2 = 2^61-1: 111..11111 (popcount=61) -> not 60.

          Therefore, it is impossible.

          So our method works.

          However, we must use 64-bit integers and be cautious of shift amounts: 
             We are shifting by b_i and k_i, which are at most 60, so 1<<60 is about 1e18, and 1<<61 is 2e18, which fits in an unsigned long long (which can hold 1.8e19).

          But for b_i=60: (1<<60) is 2^60, which is about 1e18, and then we multiply by (1<< (k_i+1)): which is at least 2^(1+1)=4, so 4e18 -> which is beyond 2^63-1 (about 9e18) for signed 64-bit? 
          But 2^60 * 2^61 = 2^121, which is huge.

          But note: we argued that the candidate is at most 2^{a_i+1}? 
             But a_i<=60, so 2^61 is about 2e18, which fits in an unsigned 64-bit integer? 
                2^61 is 2305843009213693952, which is less than 1e19.

          But wait: 
             candidate = ( (1<<b_i)-1 ) * (1<< (k_i+1)) + ... 
             But (1<< (k_i+1)) is 2^{k_i+1}, and (1<<b_i) is 2^{b_i}, and b_i + k_i = a_i, so 2^{b_i} * 2^{k_i+1} = 2^{a_i+1} which is 2^(a_i+1) <= 2^61.

          However, note: 
             ( (1<<b_i)-1 ) is 2^{b_i} - 1, and then multiplied by 2^{k_i+1} is (2^{b_i}-1) * 2^{k_i+1} = 2^{b_i+k_i+1} - 2^{k_i+1} = 2^{a_i+1} - 2^{k_i+1}.

          Then we add (2^{k_i}-1) and subtract i.

          Therefore, the candidate is bounded by 2^{a_i+1} (which is 2^61) and a_i<=60, so we can compute it.

          But note: we do (1<<b_i) and (1<< (k_i+1)): the shifts are by up to 60, so 1<<60 is 2^60 which is about 1e18, and we do a multiplication: (2^60) * (2^61) would be 2^121, which is too big.

          How to avoid that? 
             We note: 
                candidate = ( (1<<b_i) - 1 ) * (1<< (k_i+1)) + (1<<k_i) - 1 - i
                         = (1<< (b_i + k_i + 1)) - (1<< (k_i+1)) + (1<<k_i) - 1 - i
                         = (1<< (a_i+1)) - (1<< (k_i+1)) + (1<<k_i) - 1 - i

          Now, we can compute: 
                term1 = 1LL << (a_i+1)   [if a_i+1<=60? then a_i+1<=61, so 2^61 is about 2.3e18, which fits in an unsigned long long? 
                term2 = 1LL << (k_i+1)
                term3 = 1LL << k_i

          Then candidate = term1 - term2 + term3 - 1 - i.

          And we can do that without huge exponents.

          Therefore, we can compute candidate as:

             candidate = (1ULL << (a_i+1)) - (1ULL << (k_i+1)) + (1ULL << k_i) - 1 - i;

          Example: a_i=3, k_i=1: 
                term1 = 1<<4 = 16
                term2 = 1<<2 = 4
                term3 = 1<<1 = 2
                candidate = 16 - 4 + 2 - 1 - i = 13 - i. 
                For i=0: 13.

          Example: a_i=60, k_i=1: 
                candidate = (1<<61) - (1<<2) + (1<<1) - 1 - i
                         = (2305843009213693952) - 4 + 2 - 1 - i
                         = 2305843009213693949 - i.

          So for i=0: 2305843009213693949.

          This matches the sample.

          Therefore, we can compute candidate without overflow for a_i<=60.

          We use unsigned long long for shifts.

          Code summary for one test case:

            t = number of test cases (<=1000, total n<=500000)

            for each test case:
                n = int(input())
                a = list of n integers

                // Step 1: check differences
                valid = True
                for i in range(n-1):
                    if a[i+1] > a[i]+1:
                        valid = False; break
                    if a[i+1] <= a[i]:
                        k = a[i] + 1 - a[i+1]
                        if k < 1: 
                            valid = False; break
                        if i+1 < n-1:
                            if a[i+2] != a[i+1]+1:
                                valid = False; break

                if not valid:
                    print(-1)
                    continue

                // Step 2: find carries and branch
                carries = []
                for i in range(n-1):
                    if a[i+1] <= a[i]:
                        carries.append(i)

                if len(carries)==0:
                    if n==1:
                        x = (1 << a[0]) - 1
                        print(x)
                    elif n==2:
                        x = (1 << (a[0]+1)) - 2
                        print(x)
                    else:
                        print(-1)
                else:
                    congruences = []
                    for i in carries:
                        k = a[i] + 1 - a[i+1]
                        if a[i+1] < 1: 
                            valid = False
                            break
                        modulus = 1 << (k+1)   # 2^(k+1)
                        residue = ((1 << k) - 1) - i
                        residue %= modulus
                        if residue < 0:
                            residue += modulus
                        congruences.append( (modulus, residue) )

                    if not valid:
                        print(-1)
                        continue

                    // Find the congruence with the largest modulus
                    congruences.sort(key=lambda x: x[0], reverse=True)
                    M, C = congruences[0]

                    // Check consistency of other congruences
                    for i in range(1, len(congruences)):
                        m, c_req = congruences[i]
                        if C % m != c_req:
                            valid = False
                            break

                    if not valid:
                        print(-1)
                        continue

                    // Check non-carry indices: 
                    for i in range(n-1):
                        if a[i+1] == a[i] + 1:   // non-carry
                            if (C + i) % 2 != 0:
                                valid = False
                                break

                    if not valid:
                        print(-1)
                        continue

                    // Compute L = max_i (minimal candidate for carry i)
                    L = 0
                    for i in carries:
                        k_val = a[i] + 1 - a[i+1]
                        a_i_val = a[i]
                        // candidate = (1<<(a_i_val+1)) - (1<< (k_val+1)) + (1<<k_val) - 1 - i
                        // Use unsigned long long arithmetic.
                        term1 = (1 << (a_i_val+1))   if (a_i_val+1) < 64 else (1 << 63) * 2  // but a_i_val<=60, so a_i_val+1<=61 -> safe for 64-bit if we use unsigned?
                        // However, 1<<61 is about 2.3e18, which fits in unsigned long long.
                        term2 = (1 << (k_val+1))
                        term3 = (1 << k_val)
                        candidate = term1 - term2 + term3 - 1 - i
                        if candidate > L:
                            L = candidate

                    // Now compute x = the smallest number >= L that is C mod M.
                    if C >= L:
                        x = C
                    else:
                        k0 = (L - C + M - 1) // M
                        x = C + k0 * M

                    print(x)

          Note: We must use 64-bit integers. In Python, integers are arbitrary precision, but we must be cautious of the shifts.

          However, the problem: the total n<=500000, but the shifts are by at most 61, so the numbers are at most 2^61, which is around 2.3e18, and Python integers can handle that.

          Let's run the provided examples in the sample.

          But note: the sample [60,60]: 
                carries: [0] -> k=1, modulus=4, residue= (2^1-1)-0 = 1.
                Then L: 
                    a0=60, k_val=1 -> 
                    term1 = 1<<61 = 2305843009213693952
                    term2 = 1<<2 = 4
                    term3 = 1<<1 = 2
                    candidate = 2305843009213693952 - 4 + 2 - 1 - 0 = 2305843009213693949
                Then x = 2305843009213693949 (because C=1 < L, then k0 = ceil((2305843009213693949-1)/4) = ceil( (2305843009213693948)/4 ) = 576460752303423487, then x = 1 + 4 * 576460752303423487 = 1 + 2305843009213693948 = 2305843009213693949.

          Therefore, we output 2305843009213693949.

          The sample [8,0]: 
                carries: [0] -> k0=8+1-0=9, then we check: a[i+1]=0<1 -> we set valid=False.

          So we output -1.

          We have one more sample: [2,1,2] -> we did by hand and got 3.

          Therefore, we output the sample answers.

          However, note: the modulus M might be very large? 
             In [60,60]: M=4, so no problem.

          But in a carry with k_i=60, modulus=2^61, which is about 2.3e18, and then we do k0 = (L-C + M-1) // M: 
             L and C are about 2^61, so we are dividing two numbers around 2^61, which is an integer.

          We can do this in Python.

          Implementation in Python: we must be cautious that the total n across test cases is 500000, and the number of carries is at most the number of test cases times ...? but the total n is 500000, so the number of carries is at most 500000. And we are doing a loop over the carries. 

          Therefore, the algorithm is O(n) per test case? but the total n is 500000, so it is acceptable.

          Let's code accordingly.

          But note: we have an additional loop over non-carry indices: that loop is O(n). And the sort of congruences: the number of carries is at most n, so worst-case 500000, and we sort: O(n log n). But the total n is 500000, and the total across test cases is 500000, so worst-case one test case with n=500000, then the sort is O(500000 log 500000) which is about 500000*20 = 10e6, which is acceptable.

          Therefore, we output the solution.

          However, we must be cautious: the sample input t up to 1000, but the sum of n is 500000, so the worst-case might be 1000 test cases, each with n=500, then the total carries is at most 500*1000 = 500000, and the sort per test case would be O(500 log500) which is 500*9=4500, and 1000 test cases: 4.5e6, which is acceptable.

          So we implement as described.

          Note: The shifts: we do 1 << (a_i+1) for a_i in [0,60] -> a_i+1 in [1,61]. 
             We can do: 1 << (a_i+1) is safe for a_i+1<=61.

          Let's code.

          But note: in the computation of candidate, we did:
                candidate = (1 << (a_i+1)) - (1 << (k_i+1)) + (1 << k_i) - 1 - i

          This expression: we do the shifts and then subtract. We must do the shifts with sufficient bit-length.

          We'll do everything in integers.

          We'll write:

            candidate = (1 << (a_i+1)) - (1 << (k_i+1)) + (1 << k_i) - 1 - i

          This is the formula.

          Let's test: a_i=3, k_i=1: 
                = (1<<4) - (1<<2) + (1<<1) - 1 - i
                = 16 - 4 + 2 - 1 - i = 13 - i.

          For i=0: 13.

          Therefore, correct.

          We output the solution.

          IMPORTANT: The sample [60,60] gives a candidate = 2305843009213693949, which is 2^61-3.

          We'll now run the provided sample test cases.

          Sample 1: [3,3,4,1,2] -> x=13
          Sample 2: [2,1,2] -> x=3
          Sample 3: [60,60] -> x=2305843009213693949
          Sample 4: [8,0] -> -1

          We hope it passes.

          Let me do [60,60] by hand: 
              a0=60, a1=60: 
                  x = 2305843009213693949
                  p(x) = p(2^61-3) = 61 - 2 = 59? -> no, we computed earlier: 
                    2^61-3 = (2^61-1) - 2 = ...11111101 (binary, 61 bits: 59 ones and 2 zeros? -> no, 59 ones? 
                    Actually: 
                      2^61-1: 61 ones.
                      subtract 2: 
                         ...11111111
                         -        10
                         = ...11111101 -> so we turned two ones to zeros? 
                         But actually, we turned the last two bits: from 11 to 01? 
                         So the popcount: 61 - 2 + 0 = 59? 

                  But we need popcount=60.

                  Why the discrepancy? 

          Let me compute: 
            2^61-3 in binary: 
                We know 2^61 is 1 followed by 61 zeros.
                2^61-1 is 61 ones.
                2^61-2 is 61 ones minus 1: 111..1110 -> popcount=60.
                2^61-3 = 2^61-2-1 = 111..1110 - 1 = 111..1101 -> popcount=60? 
                    The last two bits: 01, and the rest are ones? 
                    Then the number of ones: 59? 

          Actually: 
                positions: from 0 to 60.
                bit0: 1
                bit1: 0
                bits2 to 60: 1's -> that's 59 ones? 

          But wait: 59+1 = 60? -> bit0 is 1, and bits2..60: that's 59 bits? -> total 60 ones.

          Yes: 59 (from bits2 to 60) and 1 from bit0: total 60.

          So p(2^61-3)=60.

          Then x+1 = 2^61-2: 
                binary: ...1110 -> 
                   bit0:0, bit1:1, bits2..60:1 -> then popcount= (59 from bits2..60) + 1 (from bit1) = 60.

          Therefore, it works.

          We are done.

          Code accordingly.

          Note: The sample [2,1,2] with x=3: 
                p(3)=2, p(4)=1, p(5)=2? 
                But we need: 
                    a0=2, a1=1, a2=2.

                p(3)=2: yes.
                p(4)=1: yes.
                p(5)=2: yes.

          Therefore, it works.

          We output the solution.

          However, note: the problem says the total n across test cases does not exceed 500000, so our O(n) per test case is acceptable.

          Let's hope.

          We write the code accordingly.

          Note: We must be cautious to use integers and not to do shifts beyond 63 in C++? In Python, it's fine.

          We are using Python.

          Code for the problem:

            t = int(input().strip())
            for _ in range(t):
                n = int(input().strip())
                a = list(map(int, input().split()))

                # Step 1: Check the differences and the condition after a carry.
                valid = True
                for i in range(n-1):
                    if a[i+1] > a[i] + 1:
                        valid = False
                        break
                    if a[i+1] <= a[i]:
                        k = a[i] + 1 - a[i+1]
                        if k < 1:
                            valid = False
                            break
                        if i+1 < n-1:
                            if a[i+2] != a[i+1] + 1:
                                valid = False
                                break

                if not valid:
                    print(-1)
                    continue

                # Step 2: Identify carries and branch.
                carries = []
                for i in range(n-1):
                    if a[i+1] <= a[i]:
                        carries.append(i)

                if not carries:
                    if n == 1:
                        # Note: if a0==0, then (1<<0)-1 = 0.
                        x = (1 << a[0]) - 1
                        print(x)
                    elif n == 2:
                        # x = (1<< (a0+1)) - 2
                        x = (1 << (a[0]+1)) - 2
                        print(x)
                    else:
                        # n>=3: no carry -> impossible
                        print(-1)
                else:
                    congruences = []  # list of (modulus, residue)
                    for i in carries:
                        k = a[i] + 1 - a[i+1]
                        # Check: a[i+1] must be at least 1.
                        if a[i+1] < 1:
                            valid = False
                            break
                        modulus = 1 << (k+1)   # 2^(k+1)
                        residue = ( (1 << k) - 1 ) - i
                        residue %= modulus
                        if residue < 0:
                            residue += modulus
                        congruences.append( (modulus, residue) )

                    if not valid:
                        print(-1)
                        continue

                    # If we have congruences, find the one with the largest modulus.
                    if congruences:
                        congruences.sort(key=lambda x: x[0], reverse=True)
                        M, C = congruences[0]
                        # Check other congruences
                        for i in range(1, len(congruences)):
                            m, c_req = congruences[i]
                            if C % m != c_req:
                                valid = False
                                break
                    else:
                        # This should not happen because carries is nonempty
                        M, C = 1, 0

                    if not valid:
                        print(-1)
                        continue

                    # Check non-carry indices: for every i such that a[i+1]==a[i]+1, we require (C+i) % 2 == 0.
                    for i in range(n-1):
                        if a[i+1] == a[i] + 1:
                            if (C + i) % 2 != 0:
                                valid = False
                                break

                    if not valid:
                        print(-1)
                        continue

                    # Compute L = max_i (minimal x for carry i)
                    L = 0
                    for i in carries:
                        k_val = a[i] + 1 - a[i+1]
                        a_i_val = a[i]
                        # candidate = (1<<(a_i_val+1)) - (1<<(k_val+1)) + (1<<k_val) - 1 - i
                        # We have to do the shifts with big integers.
                        # a_i_val in [0,60] -> a_i_val+1 in [1,61]
                        term1 = (1 << (a_i_val+1)) if (a_i_val+1) < 200 else 0
                        # But a_i_val<=60, so we can do:
                        term1 = 1 << (a_i_val+1)
                        term2 = 1 << (k_val+1)
                        term3 = 1 << k_val
                        candidate = term1 - term2 + term3 - 1 - i
                        if candidate > L:
                            L = candidate

                    # Now compute the smallest x >= L and x ≡ C (mod M)
                    if C >= L:
                        x = C
                    else:
                        # k0 = ceil((L-C)/M)
                        # If (L-C) is divisible by M, then k0 = (L-C)//M, else (L-C)//M + 1? 
                        # But: ceil(a) = (a + M - 1) // M  when we are doing nonnegative integers?
                        k0 = (L - C + M - 1) // M
                        x = C + k0 * M

                    print(x)

          Let me test with a small example: 
                [0,1,1] (n=3) -> 
                  Step1: 
                    i0: a0=0, a1=1: 1>0+1? 1>1? no, then 1<=0? no -> skip.
                    i1: a1=1, a2=1: 1<=1 -> k=1+1-1=1, and i1+1=2 (which is n-1? n=3 -> n-1=2, so i1+1=2 is not < n-1? actually, i1+1=2 and n-1=2, so we require i1+1<=n-1? 
                          condition: if i1+1 < n-1 -> false, so we skip the check for a[i1+2].
                  So valid.

                  Car