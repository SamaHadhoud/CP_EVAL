**Observe** that we can go from cell $(r, c)$ to cell $(r \pm 1, c)$ only if the parity of $R[r]$ and the target cell (i.e. $R[r \pm 1]$) are the same because there is only one element changing, i.e. $R[r]$ to $R[r \pm 1]$. Similar things also happened with the column. We can go from cell $(r, c)$ to cell $(r, c \pm 1)$ only if the parity of $C[c]$ and the target cell (i.e. $C[c \pm 1]$) are the same.

Therefore, for each query $\langle r_a, c_a, r_b, c_b \rangle$, we only need to check whether the parity of $R[r]$ are the same for all $r = \min(r_a, r_b)..\max(r_a, r_b)$, and whether the parity of $C[c]$ are the same for all $c = \min(c_a, c_b)..\max(c_a, c_b)$.  
Do a precomputation first (in $\mathcal{O}(N)$) before processing any query so that we can decide whether $R[i..j]$ or $C[i..j]$ have the same parity in $\mathcal{O}(1)$ for all pair of $i$ and $j$. You can use a union-find data structure to do this, although it is overkill; there is another much simpler ad-hoc method to find the groups involving only one iteration. The time complexity for this solution is $\mathcal{O}(N + Q)$.