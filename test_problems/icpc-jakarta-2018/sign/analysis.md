We can convert each of the constraints $A_i B_i C_i$ into the following: there are at most $D_i = \frac{B_i - A_i + 1 - C_i}{2}$ $-1$s in the range $[A_i, B_i]$. We can imagine $D_i$ as the “hit points” (HP) of the $i^{th}$ constraint. Whenever we put a $-1$ in $[A_i, B_i]$, we decrement the HP of the $i^{th}$ constraint by one.

We can also subtract $D_i$ with the number of $-1$s already prefilled in the range $[A_i, B_i]$, thus we can ignore the prefilled conditions for the rest of the discussion. If one of $D_i$ is less than 0, then it is impossible to fill the sequence.

Since we want to find the lexicographically smallest sequence, we want to fill the sequence greedily from the first position. As long as we can fill a position with $-1$, we will do so. We cannot fill a position with $-1$ if doing so causes one of the constraint to have a negative HP. However, an $\mathcal{O}(NM)$ solution by checking each constraint for each position is too slow for this problem.

We can maintain a data structure to keep track of the constraint with the least HP. At the start of our loop at position $x$, we can insert those constraints $i$ with $A_i = x$ to our data structure. Also, at the end of our loop at position $x$, we can remove those constraints $i$ with $B_i = x$. We check whether it is possible to put a $-1$ in the position $x$ by checking the least value in our data structure. If and only if it is larger than 0, then can put a $-1$ in the position $x$. If we decide to put a $-1$ in the position $x$, we need to subtract all values in our data structure by one. We can implement this by actually inserting $D_i + C$ (instead of $D_i$) to our data structure, where $C$ is the number of $-1$s we have put so far. This is to make sure that all the constraints HP in the data structure are “calibrated” using the same benchmark.

To support our needs, we can either use a balanced binary search tree or a minimum heap with lazy deletion. This algorithm runs in $\mathcal{O}(N \log N)$.