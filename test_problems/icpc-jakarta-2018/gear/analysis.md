Let gear 1 be the root of our tree. The first observation to solve this problem is that we can simplify the problem such that all the gears connected to the gear given in the type 3 operation rotate in the same direction. However, for each 3 $x$ $\alpha$ operation, we must negate the value of $\alpha$ if the distance (number of edges) between gear 1 and gear $x$ is odd. Moreover, after all the operations, we must negate the value of $\delta_x$ for all gear $x$ that has an odd distance to gear 1.

The main idea to solve this problem is for each operation 3 $x$ $\alpha$, we find the highest ancestor of gear $x$ that is not taken out and still connected to gear $x$. We can do this efficiently using a binary search, and, for each gear $g$, we store the number of taken out gears that is an ancestor of $g$. Let’s say the highest ancestor of gear $x$ that is still connected to gear $x$ is gear $y$. We then increment $\delta_z$ by $\alpha$, for all gear $z$ in the subtree of gear $y$.

This is not necessarily true, since there might be a gear $u$ in the subtree which is not connected to gear $y$, and we don’t want to update the value of $\delta_u$. Let gear $v$ be the lowest ancestor of gear $u$ which is taken out (not on the board). Since gear $u$ is not connected to gear $y$, gear $v$ must be in the path between gear $u$ and gear $y$. The idea is to note the value of $\delta_u$ when it was about to be taken out. Let this value be $\delta'_v$. When we place gear $v$ back to the board, we can correct the value of $\delta_w$ for all gear $w$ in the subtree of gear $v$ by incrementing $\delta'_v - \delta_u$. The exact details of the increment values when there are two gears taken out, where one gear is the ancestor of the other, is left out in this discussion.

After all the operations are done, we can simply return all the taken out gears to the board to make sure that the $\delta$ value correctness takes place, without changing the output. In other words, we can assume that there are additional pseudo-operations that return all the gears back.

The number of gears connected to gear $x$ can be computed using the same idea. For each of the taken out gear (say, gear $g$), we compute the number of gears in the subtree of gear $g$ that is still connected to gear $g$. Let this value be $\mu_g$.

The number of gears connected to gear $x$ can be retrieved by $subtree(y) - \sum \mu_z$, for all gear $z$ in the subtree of $y$, and $subtree(y)$ is the number of gears in the subtree of gear $y$. The details of updating the value of $\mu$ when gears are taken out or placed back are also left out in this discussion.

All the data structure needs (incrementing all numbers in a subtree for $\delta$, finding the highest ancestor that is still connected to the current node, and finding a sum of numbers in a subtree for $\mu$) requires either a range-update point-query or a point-update range-query data structure. We can use Fenwick Tree for all of them. The solution runs in $O(N \log^2 N)$.